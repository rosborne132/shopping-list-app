module.exports = /******/ (function(modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/ var installedModules = {} // The require function
    /******/
    /******/ /******/ function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/ if (installedModules[moduleId]) {
            /******/ return installedModules[moduleId].exports
            /******/
        } // Create a new module (and put it into the cache)
        /******/ /******/ var module = (installedModules[moduleId] = {
            /******/ i: moduleId,
            /******/ l: false,
            /******/ exports: {}
            /******/
        }) // Execute the module function
        /******/
        /******/ /******/ var threw = true
        /******/ try {
            /******/ modules[moduleId].call(
                module.exports,
                module,
                module.exports,
                __webpack_require__
            )
            /******/ threw = false
            /******/
        } finally {
            /******/ if (threw) delete installedModules[moduleId]
            /******/
        } // Flag the module as loaded
        /******/
        /******/ /******/ module.l = true // Return the exports of the module
        /******/
        /******/ /******/ return module.exports
        /******/
    } // expose the modules object (__webpack_modules__)
    /******/
    /******/
    /******/ /******/ __webpack_require__.m = modules // expose the module cache
    /******/
    /******/ /******/ __webpack_require__.c = installedModules // define getter function for harmony exports
    /******/
    /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
        /******/ if (!__webpack_require__.o(exports, name)) {
            /******/ Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            })
            /******/
        }
        /******/
    } // define __esModule on exports
    /******/
    /******/ /******/ __webpack_require__.r = function(exports) {
        /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            })
            /******/
        }
        /******/ Object.defineProperty(exports, '__esModule', { value: true })
        /******/
    } // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
    /******/
    /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
        value,
        mode
    ) {
        /******/ if (mode & 1) value = __webpack_require__(value)
        /******/ if (mode & 8) return value
        /******/ if (
            mode & 4 &&
            typeof value === 'object' &&
            value &&
            value.__esModule
        )
            return value
        /******/ var ns = Object.create(null)
        /******/ __webpack_require__.r(ns)
        /******/ Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        })
        /******/ if (mode & 2 && typeof value != 'string')
            for (var key in value)
                __webpack_require__.d(
                    ns,
                    key,
                    function(key) {
                        return value[key]
                    }.bind(null, key)
                )
        /******/ return ns
        /******/
    } // getDefaultExport function for compatibility with non-harmony modules
    /******/
    /******/ /******/ __webpack_require__.n = function(module) {
        /******/ var getter =
            module && module.__esModule
                ? /******/ function getDefault() {
                      return module['default']
                  }
                : /******/ function getModuleExports() {
                      return module
                  }
        /******/ __webpack_require__.d(getter, 'a', getter)
        /******/ return getter
        /******/
    } // Object.prototype.hasOwnProperty.call
    /******/
    /******/ /******/ __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property)
    } // __webpack_public_path__
    /******/
    /******/ /******/ __webpack_require__.p = '' // Load entry module and return exports
    /******/
    /******/
    /******/ /******/ return __webpack_require__(
        (__webpack_require__.s = 'Itc5')
    )
    /******/
})(
    /************************************************************************/
    /******/ {
        /***/ '+00W': /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('RF0s').default
            module.exports.default = module.exports

            /***/
        },

        /***/ '+6XX': /***/ function(module, exports, __webpack_require__) {
            var assocIndexOf = __webpack_require__('y1pI')

            /**
             * Checks if a list cache value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf ListCache
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1
            }

            module.exports = listCacheHas

            /***/
        },

        /***/ '+K+b': /***/ function(module, exports, __webpack_require__) {
            var Uint8Array = __webpack_require__('JHRd')

            /**
             * Creates a clone of `arrayBuffer`.
             *
             * @private
             * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
             * @returns {ArrayBuffer} Returns the cloned array buffer.
             */
            function cloneArrayBuffer(arrayBuffer) {
                var result = new arrayBuffer.constructor(arrayBuffer.byteLength)
                new Uint8Array(result).set(new Uint8Array(arrayBuffer))
                return result
            }

            module.exports = cloneArrayBuffer

            /***/
        },

        /***/ '+Qka': /***/ function(module, exports, __webpack_require__) {
            var Stack = __webpack_require__('fmRc'),
                assignMergeValue = __webpack_require__('t2Dn'),
                baseFor = __webpack_require__('cq/+'),
                baseMergeDeep = __webpack_require__('T1AV'),
                isObject = __webpack_require__('GoyQ'),
                keysIn = __webpack_require__('mTTR'),
                safeGet = __webpack_require__('itsj')

            /**
             * The base implementation of `_.merge` without support for multiple sources.
             *
             * @private
             * @param {Object} object The destination object.
             * @param {Object} source The source object.
             * @param {number} srcIndex The index of `source`.
             * @param {Function} [customizer] The function to customize merged values.
             * @param {Object} [stack] Tracks traversed source values and their merged
             *  counterparts.
             */
            function baseMerge(object, source, srcIndex, customizer, stack) {
                if (object === source) {
                    return
                }
                baseFor(
                    source,
                    function(srcValue, key) {
                        stack || (stack = new Stack())
                        if (isObject(srcValue)) {
                            baseMergeDeep(
                                object,
                                source,
                                key,
                                srcIndex,
                                baseMerge,
                                customizer,
                                stack
                            )
                        } else {
                            var newValue = customizer
                                ? customizer(
                                      safeGet(object, key),
                                      srcValue,
                                      key + '',
                                      object,
                                      source,
                                      stack
                                  )
                                : undefined

                            if (newValue === undefined) {
                                newValue = srcValue
                            }
                            assignMergeValue(object, key, newValue)
                        }
                    },
                    keysIn
                )
            }

            module.exports = baseMerge

            /***/
        },

        /***/ '+c4W': /***/ function(module, exports, __webpack_require__) {
            var baseProperty = __webpack_require__('711d'),
                basePropertyDeep = __webpack_require__('4/ic'),
                isKey = __webpack_require__('9ggG'),
                toKey = __webpack_require__('9Nap')

            /**
             * Creates a function that returns the value at `path` of a given object.
             *
             * @static
             * @memberOf _
             * @since 2.4.0
             * @category Util
             * @param {Array|string} path The path of the property to get.
             * @returns {Function} Returns the new accessor function.
             * @example
             *
             * var objects = [
             *   { 'a': { 'b': 2 } },
             *   { 'a': { 'b': 1 } }
             * ];
             *
             * _.map(objects, _.property('a.b'));
             * // => [2, 1]
             *
             * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
             * // => [1, 2]
             */
            function property(path) {
                return isKey(path)
                    ? baseProperty(toKey(path))
                    : basePropertyDeep(path)
            }

            module.exports = property

            /***/
        },

        /***/ '+du+': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const handlers_1 = tslib_1.__importDefault(
                __webpack_require__('PC/d')
            )
            const oidc_client_1 = tslib_1.__importDefault(
                __webpack_require__('O3E8')
            )
            const cookie_store_1 = tslib_1.__importDefault(
                __webpack_require__('qQzh')
            )
            const settings_1 = tslib_1.__importDefault(
                __webpack_require__('Mu3n')
            )
            function createInstance(settings) {
                if (!settings.session) {
                    throw new Error('The session configuration is required')
                }
                const clientProvider = oidc_client_1.default(settings)
                const sessionSettings = new settings_1.default(settings.session)
                const store = new cookie_store_1.default(sessionSettings)
                return {
                    handleLogin: handlers_1.default.LoginHandler(
                        settings,
                        clientProvider
                    ),
                    handleLogout: handlers_1.default.LogoutHandler(
                        settings,
                        sessionSettings
                    ),
                    handleCallback: handlers_1.default.CallbackHandler(
                        settings,
                        clientProvider,
                        store
                    ),
                    handleProfile: handlers_1.default.ProfileHandler(store),
                    getSession: handlers_1.default.SessionHandler(store),
                    requireAuthentication: handlers_1.default.RequireAuthentication(
                        store
                    )
                }
            }
            exports.default = createInstance
            //# sourceMappingURL=instance.node.js.map

            /***/
        },

        /***/ '+iFO': /***/ function(module, exports, __webpack_require__) {
            var baseCreate = __webpack_require__('dTAl'),
                getPrototype = __webpack_require__('LcsW'),
                isPrototype = __webpack_require__('6sVZ')

            /**
             * Initializes an object clone.
             *
             * @private
             * @param {Object} object The object to clone.
             * @returns {Object} Returns the initialized clone.
             */
            function initCloneObject(object) {
                return typeof object.constructor == 'function' &&
                    !isPrototype(object)
                    ? baseCreate(getPrototype(object))
                    : {}
            }

            module.exports = initCloneObject

            /***/
        },

        /***/ '//Cd': /***/ function(module, exports, __webpack_require__) {
            const { strict: assert } = __webpack_require__('Qs3B')
            const { inspect } = __webpack_require__('jK02')
            const { EOL } = __webpack_require__('jle/')

            const { keyObjectSupported } = __webpack_require__('pDDt')
            const { createPublicKey } = __webpack_require__('1ALl')
            const { keyObjectToJWK } = __webpack_require__('gXwc')
            const {
                THUMBPRINT_MATERIAL,
                PUBLIC_MEMBERS,
                PRIVATE_MEMBERS,
                JWK_MEMBERS,
                KEYOBJECT,
                USES_MAPPING,
                OPS,
                USES
            } = __webpack_require__('ehsS')
            const isObject = __webpack_require__('kF1/')
            const thumbprint = __webpack_require__('uk5n')
            const errors = __webpack_require__('yt7c')

            const privateApi = Symbol('privateApi')
            const { JWK } = __webpack_require__('N+nT')

            class Key {
                constructor(
                    keyObject,
                    {
                        alg,
                        use,
                        kid,
                        key_ops: ops,
                        x5c,
                        x5t,
                        'x5t#S256': x5t256
                    } = {}
                ) {
                    if (use !== undefined) {
                        if (typeof use !== 'string' || !USES.has(use)) {
                            throw new TypeError(
                                '`use` must be either "sig" or "enc" string when provided'
                            )
                        }
                    }

                    if (alg !== undefined) {
                        if (typeof alg !== 'string' || !alg) {
                            throw new TypeError(
                                '`alg` must be a non-empty string when provided'
                            )
                        }
                    }

                    if (kid !== undefined) {
                        if (typeof kid !== 'string' || !kid) {
                            throw new TypeError(
                                '`kid` must be a non-empty string when provided'
                            )
                        }
                    }

                    if (ops !== undefined) {
                        if (
                            !Array.isArray(ops) ||
                            !ops.length ||
                            ops.some(o => typeof o !== 'string')
                        ) {
                            throw new TypeError(
                                '`key_ops` must be a non-empty array of strings when provided'
                            )
                        }
                        ops = Array.from(new Set(ops)).filter(x => OPS.has(x))
                    }

                    if (ops && use) {
                        if (
                            (use === 'enc' &&
                                ops.some(x => USES_MAPPING.sig.has(x))) ||
                            (use === 'sig' &&
                                ops.some(x => USES_MAPPING.enc.has(x)))
                        ) {
                            throw new errors.JWKInvalid(
                                'inconsistent JWK "use" and "key_ops"'
                            )
                        }
                    }

                    if (keyObjectSupported && x5c !== undefined) {
                        if (
                            !Array.isArray(x5c) ||
                            !x5c.length ||
                            x5c.some(c => typeof c !== 'string')
                        ) {
                            throw new TypeError(
                                '`x5c` must be an array of one or more PKIX certificates when provided'
                            )
                        }

                        x5c.forEach((cert, i) => {
                            let publicKey
                            try {
                                publicKey = createPublicKey({
                                    key: `-----BEGIN CERTIFICATE-----${EOL}${cert
                                        .match(/.{1,64}/g)
                                        .join(
                                            EOL
                                        )}${EOL}-----END CERTIFICATE-----`,
                                    format: 'pem'
                                })
                            } catch (err) {
                                throw new errors.JWKInvalid(
                                    `\`x5c\` member at index ${i} is not a valid base64-encoded DER PKIX certificate`
                                )
                            }
                            if (i === 0) {
                                try {
                                    assert.deepEqual(
                                        publicKey.export({
                                            type: 'spki',
                                            format: 'der'
                                        }),
                                        (keyObject.type === 'public'
                                            ? keyObject
                                            : createPublicKey(keyObject)
                                        ).export({
                                            type: 'spki',
                                            format: 'der'
                                        })
                                    )
                                } catch (err) {
                                    throw new errors.JWKInvalid(
                                        'The key in the first `x5c` certificate MUST match the public key represented by the JWK'
                                    )
                                }
                            }
                        })
                    }

                    Object.defineProperties(this, {
                        [KEYOBJECT]: {
                            value: isObject(keyObject) ? undefined : keyObject
                        },
                        keyObject: {
                            get() {
                                if (!keyObjectSupported) {
                                    throw new errors.JOSENotSupported(
                                        'KeyObject class is not supported in your Node.js runtime version'
                                    )
                                }

                                return this[KEYOBJECT]
                            }
                        },
                        type: { value: keyObject.type },
                        private: { value: keyObject.type === 'private' },
                        public: { value: keyObject.type === 'public' },
                        secret: { value: keyObject.type === 'secret' },
                        alg: { value: alg, enumerable: alg !== undefined },
                        use: { value: use, enumerable: use !== undefined },
                        x5c: {
                            enumerable: x5c !== undefined,
                            ...(x5c
                                ? {
                                      get() {
                                          return [...x5c]
                                      }
                                  }
                                : { value: undefined })
                        },
                        key_ops: {
                            enumerable: ops !== undefined,
                            ...(ops
                                ? {
                                      get() {
                                          return [...ops]
                                      }
                                  }
                                : { value: undefined })
                        },
                        kid: {
                            enumerable: true,
                            ...(kid
                                ? { value: kid }
                                : {
                                      get() {
                                          Object.defineProperty(this, 'kid', {
                                              value: this.thumbprint,
                                              configurable: false
                                          })
                                          return this.kid
                                      },
                                      configurable: true
                                  })
                        },
                        ...(x5c
                            ? {
                                  x5t: {
                                      enumerable: true,
                                      ...(x5t
                                          ? { value: x5t }
                                          : {
                                                get() {
                                                    Object.defineProperty(
                                                        this,
                                                        'x5t',
                                                        {
                                                            value: thumbprint.x5t(
                                                                this.x5c[0]
                                                            ),
                                                            configurable: false
                                                        }
                                                    )
                                                    return this.x5t
                                                },
                                                configurable: true
                                            })
                                  }
                              }
                            : undefined),
                        ...(x5c
                            ? {
                                  'x5t#S256': {
                                      enumerable: true,
                                      ...(x5t256
                                          ? { value: x5t256 }
                                          : {
                                                get() {
                                                    Object.defineProperty(
                                                        this,
                                                        'x5t#S256',
                                                        {
                                                            value: thumbprint[
                                                                'x5t#S256'
                                                            ](this.x5c[0]),
                                                            configurable: false
                                                        }
                                                    )
                                                    return this['x5t#S256']
                                                },
                                                configurable: true
                                            })
                                  }
                              }
                            : undefined),
                        thumbprint: {
                            get() {
                                Object.defineProperty(this, 'thumbprint', {
                                    value: thumbprint.kid(
                                        this[THUMBPRINT_MATERIAL]()
                                    ),
                                    configurable: false
                                })
                                return this.thumbprint
                            },
                            configurable: true
                        }
                    })
                }

                toPEM(priv = false, encoding = {}) {
                    if (this.secret) {
                        throw new TypeError(
                            'symmetric keys cannot be exported as PEM'
                        )
                    }

                    if (priv && this.public === true) {
                        throw new TypeError(
                            'public key cannot be exported as private'
                        )
                    }

                    const {
                        type = priv ? 'pkcs8' : 'spki',
                        cipher,
                        passphrase
                    } = encoding

                    let keyObject = this[KEYOBJECT]

                    if (!priv) {
                        if (this.private) {
                            keyObject = createPublicKey(keyObject)
                        }
                        if (cipher || passphrase) {
                            throw new TypeError(
                                'cipher and passphrase can only be applied when exporting private keys'
                            )
                        }
                    }

                    if (priv) {
                        return keyObject.export({
                            format: 'pem',
                            type,
                            cipher,
                            passphrase
                        })
                    }

                    return keyObject.export({ format: 'pem', type })
                }

                toJWK(priv = false) {
                    if (priv && this.public === true) {
                        throw new TypeError(
                            'public key cannot be exported as private'
                        )
                    }

                    const components = [
                        ...this.constructor[
                            priv ? PRIVATE_MEMBERS : PUBLIC_MEMBERS
                        ]
                    ].map(k => [k, this[k]])

                    const result = {}

                    Object.keys(components).forEach(key => {
                        const [k, v] = components[key]

                        result[k] = v
                    })

                    result.kty = this.kty
                    result.kid = this.kid

                    if (this.alg) {
                        result.alg = this.alg
                    }

                    if (this.key_ops && this.key_ops.length) {
                        result.key_ops = this.key_ops
                    }

                    if (this.use) {
                        result.use = this.use
                    }

                    if (this.x5c) {
                        result.x5c = this.x5c
                    }

                    if (this.x5t) {
                        result.x5t = this.x5t
                    }

                    if (this['x5t#S256']) {
                        result['x5t#S256'] = this['x5t#S256']
                    }

                    return result
                }

                [JWK_MEMBERS]() {
                    const props =
                        this[KEYOBJECT].type === 'private'
                            ? this.constructor[PRIVATE_MEMBERS]
                            : this.constructor[PUBLIC_MEMBERS]
                    Object.defineProperties(
                        this,
                        [...props].reduce((acc, component) => {
                            acc[component] = {
                                get() {
                                    const jwk = keyObjectToJWK(this[KEYOBJECT])
                                    Object.defineProperties(
                                        this,
                                        Object.entries(jwk)
                                            .filter(([key]) => props.has(key))
                                            .reduce((acc, [key, value]) => {
                                                acc[key] = {
                                                    value,
                                                    enumerable: this.constructor[
                                                        PUBLIC_MEMBERS
                                                    ].has(key),
                                                    configurable: false
                                                }
                                                return acc
                                            }, {})
                                    )

                                    return this[component]
                                },
                                enumerable: this.constructor[
                                    PUBLIC_MEMBERS
                                ].has(component),
                                configurable: true
                            }
                            return acc
                        }, {})
                    )
                }

                /* c8 ignore next 8 */
                [inspect.custom]() {
                    return `${this.constructor.name} ${inspect(
                        this.toJWK(false),
                        {
                            depth: Infinity,
                            colors: process.stdout.isTTY,
                            compact: false,
                            sorted: true
                        }
                    )}`
                }

                /* c8 ignore next 3 */
                [THUMBPRINT_MATERIAL]() {
                    throw new Error(
                        `"[THUMBPRINT_MATERIAL]()" is not implemented on ${this.constructor.name}`
                    )
                }

                algorithms(operation, /* the rest is private API */ int, opts) {
                    const {
                        use = this.use,
                        alg = this.alg,
                        key_ops: ops = this.key_ops
                    } = int === privateApi ? opts : {}
                    if (alg) {
                        return new Set(
                            this.algorithms(operation, privateApi, {
                                alg: null,
                                use,
                                key_ops: ops
                            }).has(alg)
                                ? [alg]
                                : undefined
                        )
                    }

                    if (typeof operation === 'symbol') {
                        try {
                            return this[operation]()
                        } catch (err) {
                            return new Set()
                        }
                    }

                    if (operation && ops && !ops.includes(operation)) {
                        return new Set()
                    }

                    switch (operation) {
                        case 'decrypt':
                        case 'deriveKey':
                        case 'encrypt':
                        case 'sign':
                        case 'unwrapKey':
                        case 'verify':
                        case 'wrapKey':
                            return new Set(
                                Object.entries(JWK[this.kty][operation])
                                    .map(([alg, fn]) =>
                                        fn(this) ? alg : undefined
                                    )
                                    .filter(Boolean)
                            )
                        case undefined:
                            return new Set([
                                ...this.algorithms('sign'),
                                ...this.algorithms('verify'),
                                ...this.algorithms('decrypt'),
                                ...this.algorithms('encrypt'),
                                ...this.algorithms('unwrapKey'),
                                ...this.algorithms('wrapKey'),
                                ...this.algorithms('deriveKey')
                            ])
                        default:
                            throw new TypeError('invalid key operation')
                    }
                }

                /* c8 ignore next 3 */
                static async generate() {
                    throw new Error(
                        `"static async generate()" is not implemented on ${this.name}`
                    )
                }

                /* c8 ignore next 3 */
                static generateSync() {
                    throw new Error(
                        `"static generateSync()" is not implemented on ${this.name}`
                    )
                }

                /* c8 ignore next 3 */
                static get [PUBLIC_MEMBERS]() {
                    throw new Error(
                        `"static get [PUBLIC_MEMBERS]()" is not implemented on ${this.name}`
                    )
                }

                /* c8 ignore next 3 */
                static get [PRIVATE_MEMBERS]() {
                    throw new Error(
                        `"static get [PRIVATE_MEMBERS]()" is not implemented on ${this.name}`
                    )
                }
            }

            module.exports = Key

            /***/
        },

        /***/ '/0p4': /***/ function(module, exports) {
            module.exports = require('events')

            /***/
        },

        /***/ '/9aa': /***/ function(module, exports, __webpack_require__) {
            var baseGetTag = __webpack_require__('NykK'),
                isObjectLike = __webpack_require__('ExA7')

            /** `Object#toString` result references. */
            var symbolTag = '[object Symbol]'

            /**
             * Checks if `value` is classified as a `Symbol` primitive or object.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
             * @example
             *
             * _.isSymbol(Symbol.iterator);
             * // => true
             *
             * _.isSymbol('abc');
             * // => false
             */
            function isSymbol(value) {
                return (
                    typeof value == 'symbol' ||
                    (isObjectLike(value) && baseGetTag(value) == symbolTag)
                )
            }

            module.exports = isSymbol

            /***/
        },

        /***/ '/JKO': /***/ function(module, exports, __webpack_require__) {
            const merge = __webpack_require__('QkVN')
            const omitBy = __webpack_require__('3WX/')
            const jose = __webpack_require__('xZSz')

            const { assertIssuerConfiguration } = __webpack_require__('N+si')
            const { random } = __webpack_require__('iAgo')
            const now = __webpack_require__('PbSP')
            const request = __webpack_require__('UwMm')
            const instance = __webpack_require__('0pkK')

            const formUrlEncode = value =>
                encodeURIComponent(value).replace(/%20/g, '+')

            async function clientAssertion(endpoint, payload) {
                let alg = this[`${endpoint}_endpoint_auth_signing_alg`]
                if (!alg) {
                    assertIssuerConfiguration(
                        this.issuer,
                        `${endpoint}_endpoint_auth_signing_alg_values_supported`
                    )
                }

                if (
                    this[`${endpoint}_endpoint_auth_method`] ===
                    'client_secret_jwt'
                ) {
                    const key = await this.joseSecret()

                    if (!alg) {
                        const supported = this.issuer[
                            `${endpoint}_endpoint_auth_signing_alg_values_supported`
                        ]
                        alg =
                            Array.isArray(supported) &&
                            supported.find(signAlg =>
                                key.algorithms('sign').has(signAlg)
                            )
                    }

                    return jose.JWS.sign(payload, key, { alg, typ: 'JWT' })
                }

                const keystore = instance(this).get('keystore')

                if (!keystore) {
                    throw new TypeError(
                        'no client jwks provided for signing a client assertion with'
                    )
                }

                if (!alg) {
                    const algs = new Set()

                    keystore.all().forEach(key => {
                        key.algorithms('sign').forEach(
                            Set.prototype.add.bind(algs)
                        )
                    })

                    const supported = this.issuer[
                        `${endpoint}_endpoint_auth_signing_alg_values_supported`
                    ]
                    alg =
                        Array.isArray(supported) &&
                        supported.find(signAlg => algs.has(signAlg))
                }

                const key = keystore.get({ alg, use: 'sig' })
                if (!key) {
                    throw new TypeError(
                        `no key found in client jwks to sign a client assertion with using alg ${alg}`
                    )
                }
                return jose.JWS.sign(payload, key, {
                    alg,
                    typ: 'JWT',
                    kid: key.kid
                })
            }

            async function authFor(endpoint, { clientAssertionPayload } = {}) {
                const authMethod = this[`${endpoint}_endpoint_auth_method`]
                switch (authMethod) {
                    case 'self_signed_tls_client_auth':
                    case 'tls_client_auth':
                    case 'none':
                        return { body: { client_id: this.client_id } }
                    case 'client_secret_post':
                        if (!this.client_secret) {
                            throw new TypeError(
                                'client_secret_post client authentication method requires a client_secret'
                            )
                        }
                        return {
                            body: {
                                client_id: this.client_id,
                                client_secret: this.client_secret
                            }
                        }
                    case 'private_key_jwt':
                    case 'client_secret_jwt': {
                        const timestamp = now()
                        const assertion = await clientAssertion.call(
                            this,
                            endpoint,
                            {
                                iat: timestamp,
                                exp: timestamp + 60,
                                jti: random(),
                                iss: this.client_id,
                                sub: this.client_id,
                                aud: this.issuer[`${endpoint}_endpoint`], // TODO: in v4.x pass the issuer instead (for now clientAssertionPayload can be used for that)
                                ...clientAssertionPayload
                            }
                        )

                        return {
                            body: {
                                client_id: this.client_id,
                                client_assertion: assertion,
                                client_assertion_type:
                                    'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'
                            }
                        }
                    }
                    default: {
                        // client_secret_basic
                        // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the
                        // related appendix. (also https://github.com/panva/node-openid-client/pull/91)
                        // > The client identifier is encoded using the
                        // > "application/x-www-form-urlencoded" encoding algorithm per
                        // > Appendix B, and the encoded value is used as the username; the client
                        // > password is encoded using the same algorithm and used as the
                        // > password.
                        if (!this.client_secret) {
                            throw new TypeError(
                                'client_secret_basic client authentication method requires a client_secret'
                            )
                        }
                        const encoded = `${formUrlEncode(
                            this.client_id
                        )}:${formUrlEncode(this.client_secret)}`
                        const value = Buffer.from(encoded).toString('base64')
                        return { headers: { Authorization: `Basic ${value}` } }
                    }
                }
            }

            function resolveResponseType() {
                const { length, 0: value } = this.response_types

                if (length === 1) {
                    return value
                }

                return undefined
            }

            function resolveRedirectUri() {
                const { length, 0: value } = this.redirect_uris || []

                if (length === 1) {
                    return value
                }

                return undefined
            }

            async function authenticatedPost(
                endpoint,
                opts,
                { clientAssertionPayload, endpointAuthMethod = endpoint } = {}
            ) {
                const auth = await authFor.call(this, endpointAuthMethod, {
                    clientAssertionPayload
                })
                const requestOpts = merge(opts, auth, { form: true })

                const mTLS =
                    this[`${endpointAuthMethod}_endpoint_auth_method`].includes(
                        'tls_client_auth'
                    ) ||
                    (endpoint === 'token' &&
                        this.tls_client_certificate_bound_access_tokens)

                let targetUrl
                if (mTLS && this.issuer.mtls_endpoint_aliases) {
                    targetUrl = this.issuer.mtls_endpoint_aliases[
                        `${endpoint}_endpoint`
                    ]
                }

                targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`]

                if ('body' in requestOpts) {
                    requestOpts.body = omitBy(
                        requestOpts.body,
                        arg => arg === undefined
                    )
                }

                return request.call(
                    this,
                    {
                        ...requestOpts,
                        method: 'POST',
                        url: targetUrl
                    },
                    { mTLS }
                )
            }

            module.exports = {
                resolveResponseType,
                resolveRedirectUri,
                authFor,
                authenticatedPost
            }

            /***/
        },

        /***/ '/SMw': /***/ function(module, exports) {
            function webpackEmptyContext(req) {
                var e = new Error("Cannot find module '" + req + "'")
                e.code = 'MODULE_NOT_FOUND'
                throw e
            }
            webpackEmptyContext.keys = function() {
                return []
            }
            webpackEmptyContext.resolve = webpackEmptyContext
            module.exports = webpackEmptyContext
            webpackEmptyContext.id = '/SMw'

            /***/
        },

        /***/ '/co4': /***/ function(module, exports, __webpack_require__) {
            /* eslint-disable no-underscore-dangle */

            const url = __webpack_require__('bzos')
            const { format } = __webpack_require__('jK02')

            const cloneDeep = __webpack_require__('BkRI')

            const { RPError, OPError } = __webpack_require__('L71r')
            const { BaseClient } = __webpack_require__('HrFp')
            const { random, codeChallenge } = __webpack_require__('iAgo')
            const pick = __webpack_require__('LZmR')
            const {
                resolveResponseType,
                resolveRedirectUri
            } = __webpack_require__('/JKO')

            function verified(err, user, info = {}) {
                if (err) {
                    this.error(err)
                } else if (!user) {
                    this.fail(info)
                } else {
                    this.success(user, info)
                }
            }

            /**
             * @name constructor
             * @api public
             */
            function OpenIDConnectStrategy(
                {
                    client,
                    params = {},
                    passReqToCallback = false,
                    sessionKey,
                    usePKCE = false
                } = {},
                verify
            ) {
                if (!(client instanceof BaseClient)) {
                    throw new TypeError(
                        'client must be an instance of openid-client Client'
                    )
                }

                if (typeof verify !== 'function') {
                    throw new TypeError('verify callback must be a function')
                }

                if (!client.issuer || !client.issuer.issuer) {
                    throw new TypeError(
                        'client must have an issuer with an identifier'
                    )
                }

                this._client = client
                this._issuer = client.issuer
                this._verify = verify
                this._passReqToCallback = passReqToCallback
                this._usePKCE = usePKCE
                this._key =
                    sessionKey ||
                    `oidc:${url.parse(this._issuer.issuer).hostname}`
                this._params = cloneDeep(params)

                if (this._usePKCE === true) {
                    const supportedMethods = this._issuer
                        .code_challenge_methods_supported
                    if (!Array.isArray(supportedMethods)) {
                        throw new TypeError(
                            'code_challenge_methods_supported is not properly set on issuer'
                        )
                    }
                    if (supportedMethods.includes('S256')) {
                        this._usePKCE = 'S256'
                    } else if (supportedMethods.includes('plain')) {
                        this._usePKCE = 'plain'
                    } else {
                        throw new TypeError(
                            'neither supported code_challenge_method is supported by the issuer'
                        )
                    }
                } else if (
                    typeof this._usePKCE === 'string' &&
                    !['plain', 'S256'].includes(this._usePKCE)
                ) {
                    throw new TypeError(
                        `${this._usePKCE} is not valid/implemented PKCE code_challenge_method`
                    )
                }

                this.name = url.parse(client.issuer.issuer).hostname

                if (!this._params.response_type)
                    this._params.response_type = resolveResponseType.call(
                        client
                    )
                if (!this._params.redirect_uri)
                    this._params.redirect_uri = resolveRedirectUri.call(client)
                if (!this._params.scope) this._params.scope = 'openid'
            }

            OpenIDConnectStrategy.prototype.authenticate = function authenticate(
                req,
                options
            ) {
                ;(async () => {
                    const client = this._client
                    if (!req.session) {
                        throw new TypeError(
                            'authentication requires session support'
                        )
                    }
                    const reqParams = client.callbackParams(req)
                    const sessionKey = this._key

                    /* start authentication request */
                    if (Object.keys(reqParams).length === 0) {
                        // provide options object with extra authentication parameters
                        const params = {
                            state: random(),
                            ...this._params,
                            ...options
                        }

                        if (
                            !params.nonce &&
                            params.response_type.includes('id_token')
                        ) {
                            params.nonce = random()
                        }

                        req.session[sessionKey] = pick(
                            params,
                            'nonce',
                            'state',
                            'max_age',
                            'response_type'
                        )

                        if (this._usePKCE) {
                            const verifier = random()
                            req.session[sessionKey].code_verifier = verifier

                            switch (
                                this._usePKCE // eslint-disable-line default-case
                            ) {
                                case 'S256':
                                    params.code_challenge = codeChallenge(
                                        verifier
                                    )
                                    params.code_challenge_method = 'S256'
                                    break
                                case 'plain':
                                    params.code_challenge = verifier
                                    break
                            }
                        }

                        this.redirect(client.authorizationUrl(params))
                        return
                    }
                    /* end authentication request */

                    /* start authentication response */

                    const session = req.session[sessionKey]
                    if (Object.keys(session || {}).length === 0) {
                        throw new Error(
                            format(
                                'did not find expected authorization request details in session, req.session["%s"] is %j',
                                sessionKey,
                                session
                            )
                        )
                    }

                    const {
                        state,
                        nonce,
                        max_age: maxAge,
                        code_verifier: codeVerifier,
                        response_type: responseType
                    } = session

                    try {
                        delete req.session[sessionKey]
                    } catch (err) {}

                    const opts = {
                        redirect_uri: this._params.redirect_uri,
                        ...options
                    }

                    const checks = {
                        state,
                        nonce,
                        max_age: maxAge,
                        code_verifier: codeVerifier,
                        response_type: responseType
                    }

                    const tokenset = await client.callback(
                        opts.redirect_uri,
                        reqParams,
                        checks
                    )

                    const passReq = this._passReqToCallback
                    const loadUserinfo =
                        this._verify.length > (passReq ? 3 : 2) &&
                        client.issuer.userinfo_endpoint

                    const args = [tokenset, verified.bind(this)]

                    if (loadUserinfo) {
                        if (!tokenset.access_token) {
                            throw new RPError({
                                message:
                                    'expected access_token to be returned when asking for userinfo in verify callback',
                                tokenset
                            })
                        }
                        const userinfo = await client.userinfo(tokenset)
                        args.splice(1, 0, userinfo)
                    }

                    if (passReq) {
                        args.unshift(req)
                    }

                    this._verify(...args)
                    /* end authentication response */
                })().catch(error => {
                    if (
                        (error instanceof OPError &&
                            error.error !== 'server_error' &&
                            !error.error.startsWith('invalid')) ||
                        error instanceof RPError
                    ) {
                        this.fail(error)
                    } else {
                        this.error(error)
                    }
                })
            }

            module.exports = OpenIDConnectStrategy

            /***/
        },

        /***/ '/hDD': /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * depd
             * Copyright(c) 2014-2015 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module dependencies.
             * @private
             */

            var EventEmitter = __webpack_require__('/0p4').EventEmitter

            /**
             * Module exports.
             * @public
             */

            lazyProperty(
                module.exports,
                'callSiteToString',
                function callSiteToString() {
                    var limit = Error.stackTraceLimit
                    var obj = {}
                    var prep = Error.prepareStackTrace

                    function prepareObjectStackTrace(obj, stack) {
                        return stack
                    }

                    Error.prepareStackTrace = prepareObjectStackTrace
                    Error.stackTraceLimit = 2

                    // capture the stack
                    Error.captureStackTrace(obj)

                    // slice the stack
                    var stack = obj.stack.slice()

                    Error.prepareStackTrace = prep
                    Error.stackTraceLimit = limit

                    return stack[0].toString
                        ? toString
                        : __webpack_require__('HpLx')
                }
            )

            lazyProperty(
                module.exports,
                'eventListenerCount',
                function eventListenerCount() {
                    return (
                        EventEmitter.listenerCount ||
                        __webpack_require__('8vrp')
                    )
                }
            )

            /**
             * Define a lazy property.
             */

            function lazyProperty(obj, prop, getter) {
                function get() {
                    var val = getter()

                    Object.defineProperty(obj, prop, {
                        configurable: true,
                        enumerable: true,
                        value: val
                    })

                    return val
                }

                Object.defineProperty(obj, prop, {
                    configurable: true,
                    enumerable: true,
                    get: get
                })
            }

            /**
             * Call toString() on the obj
             */

            function toString(obj) {
                return obj.toString()
            }

            /***/
        },

        /***/ '/hdj': /***/ function(module, exports, __webpack_require__) {
            const { deflateRawSync } = __webpack_require__('FMKJ')

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const generateIV = __webpack_require__('X3uD')
            const base64url = __webpack_require__('Xab3')
            const getKey = __webpack_require__('oGTz')
            const isObject = __webpack_require__('kF1/')
            const { createSecretKey } = __webpack_require__('1ALl')
            const deepClone = __webpack_require__('O9d4')
            const importKey = __webpack_require__('GhER')
            const { JWEInvalid } = __webpack_require__('yt7c')
            const {
                check,
                keyManagementEncrypt,
                encrypt
            } = __webpack_require__('FUB/')

            const serializers = __webpack_require__('ARPQ')
            const generateCEK = __webpack_require__('RGIU')
            const validateHeaders = __webpack_require__('OHZa')

            const PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT')

            class Encrypt {
                // TODO: in v2.x swap unprotectedHeader and aad
                constructor(
                    cleartext,
                    protectedHeader,
                    unprotectedHeader,
                    aad
                ) {
                    if (
                        !Buffer.isBuffer(cleartext) &&
                        typeof cleartext !== 'string'
                    ) {
                        throw new TypeError(
                            'cleartext argument must be a Buffer or a string'
                        )
                    }
                    cleartext = Buffer.from(cleartext)

                    if (
                        aad !== undefined &&
                        !Buffer.isBuffer(aad) &&
                        typeof aad !== 'string'
                    ) {
                        throw new TypeError(
                            'aad argument must be a Buffer or a string when provided'
                        )
                    }
                    aad = aad ? Buffer.from(aad) : undefined

                    if (
                        protectedHeader !== undefined &&
                        !isObject(protectedHeader)
                    ) {
                        throw new TypeError(
                            'protectedHeader argument must be a plain object when provided'
                        )
                    }

                    if (
                        unprotectedHeader !== undefined &&
                        !isObject(unprotectedHeader)
                    ) {
                        throw new TypeError(
                            'unprotectedHeader argument must be a plain object when provided'
                        )
                    }

                    this._recipients = []
                    this._cleartext = cleartext
                    this._aad = aad
                    this._unprotected = unprotectedHeader
                        ? deepClone(unprotectedHeader)
                        : undefined
                    this._protected = protectedHeader
                        ? deepClone(protectedHeader)
                        : undefined
                }

                /*
                 * @public
                 */
                recipient(key, header) {
                    key = getKey(key)

                    if (header !== undefined && !isObject(header)) {
                        throw new TypeError(
                            'header argument must be a plain object when provided'
                        )
                    }

                    this._recipients.push({
                        key,
                        header: header ? deepClone(header) : undefined
                    })

                    return this
                }

                /*
                 * @private
                 */
                [PROCESS_RECIPIENT](recipient) {
                    const unprotectedHeader = this._unprotected
                    const protectedHeader = this._protected
                    const { length: recipientCount } = this._recipients

                    const jweHeader = {
                        ...protectedHeader,
                        ...unprotectedHeader,
                        ...recipient.header
                    }
                    const { key } = recipient

                    const enc = jweHeader.enc
                    let alg = jweHeader.alg

                    if (key.use === 'sig') {
                        throw new TypeError(
                            'a key with "use":"sig" is not usable for encryption'
                        )
                    }

                    if (alg === 'dir') {
                        check(key, 'encrypt', enc)
                    } else if (alg) {
                        check(key, 'keyManagementEncrypt', alg)
                    } else {
                        alg =
                            key.alg ||
                            [...key.algorithms('wrapKey')][0] ||
                            [...key.algorithms('deriveKey')][0]

                        if (alg === 'ECDH-ES' && recipientCount !== 1) {
                            alg = [...key.algorithms('deriveKey')][1]
                        }

                        if (!alg) {
                            throw new JWEInvalid(
                                'could not resolve a usable "alg" for a recipient'
                            )
                        }

                        if (recipientCount === 1) {
                            if (protectedHeader) {
                                protectedHeader.alg = alg
                            } else {
                                this._protected = { alg }
                            }
                        } else {
                            if (recipient.header) {
                                recipient.header.alg = alg
                            } else {
                                recipient.header = { alg }
                            }
                        }
                    }

                    let wrapped
                    let generatedHeader

                    if (key.kty === 'oct' && alg === 'dir') {
                        this._cek = importKey(key[KEYOBJECT], {
                            use: 'enc',
                            alg: enc
                        })
                    } else {
                        check(this._cek, 'encrypt', enc)
                        ;({
                            wrapped,
                            header: generatedHeader
                        } = keyManagementEncrypt(
                            alg,
                            key,
                            this._cek[KEYOBJECT].export(),
                            { enc, alg }
                        ))
                        if (alg === 'ECDH-ES') {
                            this._cek = importKey(createSecretKey(wrapped), {
                                use: 'enc',
                                alg: enc
                            })
                        }
                    }

                    if (alg === 'dir' || alg === 'ECDH-ES') {
                        recipient.encrypted_key = ''
                    } else {
                        recipient.encrypted_key = base64url.encodeBuffer(
                            wrapped
                        )
                    }

                    if (generatedHeader) {
                        recipient.generatedHeader = generatedHeader
                    }
                }

                /*
                 * @public
                 */
                encrypt(serialization) {
                    const serializer = serializers[serialization]
                    if (!serializer) {
                        throw new TypeError(
                            'serialization must be one of "compact", "flattened", "general"'
                        )
                    }

                    if (!this._recipients.length) {
                        throw new JWEInvalid('missing recipients')
                    }

                    serializer.validate(
                        this._protected,
                        this._unprotected,
                        this._aad,
                        this._recipients
                    )

                    let enc = validateHeaders(
                        this._protected,
                        this._unprotected,
                        this._recipients,
                        false,
                        this._protected ? this._protected.crit : undefined
                    )
                    if (!enc) {
                        enc = 'A128CBC-HS256'
                        if (this._protected) {
                            this._protected.enc = enc
                        } else {
                            this._protected = { enc }
                        }
                    }
                    const final = {}
                    this._cek = generateCEK(enc)

                    for (const recipient of this._recipients) {
                        this[PROCESS_RECIPIENT](recipient)
                    }

                    const iv = generateIV(enc)
                    final.iv = base64url.encodeBuffer(iv)

                    if (
                        this._recipients.length === 1 &&
                        this._recipients[0].generatedHeader
                    ) {
                        const [{ generatedHeader }] = this._recipients
                        delete this._recipients[0].generatedHeader
                        this._protected = {
                            ...this._protected,
                            ...generatedHeader
                        }
                    }

                    if (this._protected) {
                        final.protected = base64url.JSON.encode(this._protected)
                    }
                    final.unprotected = this._unprotected

                    let aad
                    if (this._aad) {
                        final.aad = base64url.encode(this._aad)
                        aad = Buffer.concat([
                            Buffer.from(final.protected || ''),
                            Buffer.from('.'),
                            Buffer.from(final.aad)
                        ])
                    } else {
                        aad = Buffer.from(final.protected || '')
                    }

                    let cleartext = this._cleartext
                    if (this._protected && 'zip' in this._protected) {
                        cleartext = deflateRawSync(cleartext)
                    }

                    const { ciphertext, tag } = encrypt(
                        enc,
                        this._cek,
                        cleartext,
                        { iv, aad }
                    )
                    final.tag = base64url.encodeBuffer(tag)
                    final.ciphertext = base64url.encodeBuffer(ciphertext)

                    return serializer(final, this._recipients)
                }
            }

            module.exports = Encrypt

            /***/
        },

        /***/ '/sST': /***/ function(module, exports, __webpack_require__) {
            const {
                sign: signOneShot,
                verify: verifyOneShot,
                createSign,
                createVerify,
                getCurves
            } = __webpack_require__('PJMN')

            const { derToJose, joseToDer } = __webpack_require__('f0Nx')
            const { KEYOBJECT } = __webpack_require__('ehsS')
            const resolveNodeAlg = __webpack_require__('uGJc')
            const { asInput } = __webpack_require__('1ALl')
            const { dsaEncodingSupported } = __webpack_require__('pDDt')
            const { name: secp256k1 } = __webpack_require__('F/JS')

            let sign, verify

            if (dsaEncodingSupported) {
                sign = (
                    jwaAlg,
                    nodeAlg,
                    { [KEYOBJECT]: keyObject },
                    payload
                ) => {
                    if (typeof payload === 'string') {
                        payload = Buffer.from(payload)
                    }
                    return signOneShot(nodeAlg, payload, {
                        key: asInput(keyObject, false),
                        dsaEncoding: 'ieee-p1363'
                    })
                }
                verify = (
                    jwaAlg,
                    nodeAlg,
                    { [KEYOBJECT]: keyObject },
                    payload,
                    signature
                ) => {
                    try {
                        return verifyOneShot(
                            nodeAlg,
                            payload,
                            {
                                key: asInput(keyObject, true),
                                dsaEncoding: 'ieee-p1363'
                            },
                            signature
                        )
                    } catch (err) {
                        return false
                    }
                }
            } else {
                sign = (
                    jwaAlg,
                    nodeAlg,
                    { [KEYOBJECT]: keyObject },
                    payload
                ) => {
                    return derToJose(
                        createSign(nodeAlg)
                            .update(payload)
                            .sign(asInput(keyObject, false)),
                        jwaAlg
                    )
                }
                verify = (
                    jwaAlg,
                    nodeAlg,
                    { [KEYOBJECT]: keyObject },
                    payload,
                    signature
                ) => {
                    try {
                        return createVerify(nodeAlg)
                            .update(payload)
                            .verify(
                                asInput(keyObject, true),
                                joseToDer(signature, jwaAlg)
                            )
                    } catch (err) {
                        return false
                    }
                }
            }

            const crvToAlg = crv => {
                switch (crv) {
                    case 'P-256':
                        return 'ES256'
                    case secp256k1:
                        return 'ES256K'
                    case 'P-384':
                        return 'ES384'
                    case 'P-521':
                        return 'ES512'
                }
            }

            module.exports = (JWA, JWK) => {
                const algs = []

                if (getCurves().includes('prime256v1')) {
                    algs.push('ES256')
                }

                if (getCurves().includes('secp256k1')) {
                    algs.push('ES256K')
                }

                if (getCurves().includes('secp384r1')) {
                    algs.push('ES384')
                }

                if (getCurves().includes('secp521r1')) {
                    algs.push('ES512')
                }

                algs.forEach(jwaAlg => {
                    const nodeAlg = resolveNodeAlg(jwaAlg)
                    JWA.sign.set(jwaAlg, sign.bind(undefined, jwaAlg, nodeAlg))
                    JWA.verify.set(
                        jwaAlg,
                        verify.bind(undefined, jwaAlg, nodeAlg)
                    )
                    JWK.EC.sign[jwaAlg] = key =>
                        key.private && JWK.EC.verify[jwaAlg](key)
                    JWK.EC.verify[jwaAlg] = key =>
                        (key.use === 'sig' || key.use === undefined) &&
                        crvToAlg(key.crv) === jwaAlg
                })
            }

            /***/
        },

        /***/ '01QI': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var Buffer = __webpack_require__('xZGU').Buffer

            // Export Node.js internal encodings.

            module.exports = {
                // Encodings
                utf8: { type: '_internal', bomAware: true },
                cesu8: { type: '_internal', bomAware: true },
                unicode11utf8: 'utf8',

                ucs2: { type: '_internal', bomAware: true },
                utf16le: 'ucs2',

                binary: { type: '_internal' },
                base64: { type: '_internal' },
                hex: { type: '_internal' },

                // Codec.
                _internal: InternalCodec
            }

            //------------------------------------------------------------------------------

            function InternalCodec(codecOptions, iconv) {
                this.enc = codecOptions.encodingName
                this.bomAware = codecOptions.bomAware

                if (this.enc === 'base64') this.encoder = InternalEncoderBase64
                else if (this.enc === 'cesu8') {
                    this.enc = 'utf8' // Use utf8 for decoding.
                    this.encoder = InternalEncoderCesu8

                    // Add decoder for versions of Node not supporting CESU-8
                    if (
                        Buffer.from('eda0bdedb2a9', 'hex').toString() !== ''
                    ) {
                        this.decoder = InternalDecoderCesu8
                        this.defaultCharUnicode = iconv.defaultCharUnicode
                    }
                }
            }

            InternalCodec.prototype.encoder = InternalEncoder
            InternalCodec.prototype.decoder = InternalDecoder

            //------------------------------------------------------------------------------

            // We use node.js internal decoder. Its signature is the same as ours.
            var StringDecoder = __webpack_require__('tlh6').StringDecoder

            if (!StringDecoder.prototype.end)
                // Node v0.8 doesn't have this method.
                StringDecoder.prototype.end = function() {}

            function InternalDecoder(options, codec) {
                StringDecoder.call(this, codec.enc)
            }

            InternalDecoder.prototype = StringDecoder.prototype

            //------------------------------------------------------------------------------
            // Encoder is mostly trivial

            function InternalEncoder(options, codec) {
                this.enc = codec.enc
            }

            InternalEncoder.prototype.write = function(str) {
                return Buffer.from(str, this.enc)
            }

            InternalEncoder.prototype.end = function() {}

            //------------------------------------------------------------------------------
            // Except base64 encoder, which must keep its state.

            function InternalEncoderBase64(options, codec) {
                this.prevStr = ''
            }

            InternalEncoderBase64.prototype.write = function(str) {
                str = this.prevStr + str
                var completeQuads = str.length - (str.length % 4)
                this.prevStr = str.slice(completeQuads)
                str = str.slice(0, completeQuads)

                return Buffer.from(str, 'base64')
            }

            InternalEncoderBase64.prototype.end = function() {
                return Buffer.from(this.prevStr, 'base64')
            }

            //------------------------------------------------------------------------------
            // CESU-8 encoder is also special.

            function InternalEncoderCesu8(options, codec) {}

            InternalEncoderCesu8.prototype.write = function(str) {
                var buf = Buffer.alloc(str.length * 3),
                    bufIdx = 0
                for (var i = 0; i < str.length; i++) {
                    var charCode = str.charCodeAt(i)
                    // Naive implementation, but it works because CESU-8 is especially easy
                    // to convert from UTF-16 (which all JS strings are encoded in).
                    if (charCode < 0x80) buf[bufIdx++] = charCode
                    else if (charCode < 0x800) {
                        buf[bufIdx++] = 0xc0 + (charCode >>> 6)
                        buf[bufIdx++] = 0x80 + (charCode & 0x3f)
                    } else {
                        // charCode will always be < 0x10000 in javascript.
                        buf[bufIdx++] = 0xe0 + (charCode >>> 12)
                        buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f)
                        buf[bufIdx++] = 0x80 + (charCode & 0x3f)
                    }
                }
                return buf.slice(0, bufIdx)
            }

            InternalEncoderCesu8.prototype.end = function() {}

            //------------------------------------------------------------------------------
            // CESU-8 decoder is not implemented in Node v4.0+

            function InternalDecoderCesu8(options, codec) {
                this.acc = 0
                this.contBytes = 0
                this.accBytes = 0
                this.defaultCharUnicode = codec.defaultCharUnicode
            }

            InternalDecoderCesu8.prototype.write = function(buf) {
                var acc = this.acc,
                    contBytes = this.contBytes,
                    accBytes = this.accBytes,
                    res = ''
                for (var i = 0; i < buf.length; i++) {
                    var curByte = buf[i]
                    if ((curByte & 0xc0) !== 0x80) {
                        // Leading byte
                        if (contBytes > 0) {
                            // Previous code is invalid
                            res += this.defaultCharUnicode
                            contBytes = 0
                        }

                        if (curByte < 0x80) {
                            // Single-byte code
                            res += String.fromCharCode(curByte)
                        } else if (curByte < 0xe0) {
                            // Two-byte code
                            acc = curByte & 0x1f
                            contBytes = 1
                            accBytes = 1
                        } else if (curByte < 0xf0) {
                            // Three-byte code
                            acc = curByte & 0x0f
                            contBytes = 2
                            accBytes = 1
                        } else {
                            // Four or more are not supported for CESU-8.
                            res += this.defaultCharUnicode
                        }
                    } else {
                        // Continuation byte
                        if (contBytes > 0) {
                            // We're waiting for it.
                            acc = (acc << 6) | (curByte & 0x3f)
                            contBytes--
                            accBytes++
                            if (contBytes === 0) {
                                // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                                if (accBytes === 2 && acc < 0x80 && acc > 0)
                                    res += this.defaultCharUnicode
                                else if (accBytes === 3 && acc < 0x800)
                                    res += this.defaultCharUnicode
                                // Actually add character.
                                else res += String.fromCharCode(acc)
                            }
                        } else {
                            // Unexpected continuation byte
                            res += this.defaultCharUnicode
                        }
                    }
                }
                this.acc = acc
                this.contBytes = contBytes
                this.accBytes = accBytes
                return res
            }

            InternalDecoderCesu8.prototype.end = function() {
                var res = 0
                if (this.contBytes > 0) res += this.defaultCharUnicode
                return res
            }

            /***/
        },

        /***/ '03A+': /***/ function(module, exports, __webpack_require__) {
            var baseIsArguments = __webpack_require__('JTzB'),
                isObjectLike = __webpack_require__('ExA7')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /** Built-in value references. */
            var propertyIsEnumerable = objectProto.propertyIsEnumerable

            /**
             * Checks if `value` is likely an `arguments` object.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an `arguments` object,
             *  else `false`.
             * @example
             *
             * _.isArguments(function() { return arguments; }());
             * // => true
             *
             * _.isArguments([1, 2, 3]);
             * // => false
             */
            var isArguments = baseIsArguments(
                (function() {
                    return arguments
                })()
            )
                ? baseIsArguments
                : function(value) {
                      return (
                          isObjectLike(value) &&
                          hasOwnProperty.call(value, 'callee') &&
                          !propertyIsEnumerable.call(value, 'callee')
                      )
                  }

            module.exports = isArguments

            /***/
        },

        /***/ '0Aai': /***/ function(module, exports) {
            const REGISTRY = new Map()

            module.exports = REGISTRY

            /***/
        },

        /***/ '0Cz8': /***/ function(module, exports, __webpack_require__) {
            var ListCache = __webpack_require__('Xi7e'),
                Map = __webpack_require__('ebwN'),
                MapCache = __webpack_require__('e4Nc')

            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200

            /**
             * Sets the stack `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf Stack
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the stack cache instance.
             */
            function stackSet(key, value) {
                var data = this.__data__
                if (data instanceof ListCache) {
                    var pairs = data.__data__
                    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                        pairs.push([key, value])
                        this.size = ++data.size
                        return this
                    }
                    data = this.__data__ = new MapCache(pairs)
                }
                data.set(key, value)
                this.size = data.size
                return this
            }

            module.exports = stackSet

            /***/
        },

        /***/ '0pkK': /***/ function(module, exports) {
            const privateProps = new WeakMap()

            module.exports = ctx => {
                if (!privateProps.has(ctx)) {
                    privateProps.set(ctx, new Map([['metadata', new Map()]]))
                }
                return privateProps.get(ctx)
            }

            /***/
        },

        /***/ '0ycA': /***/ function(module, exports) {
            /**
             * This method returns a new empty array.
             *
             * @static
             * @memberOf _
             * @since 4.13.0
             * @category Util
             * @returns {Array} Returns the new empty array.
             * @example
             *
             * var arrays = _.times(2, _.stubArray);
             *
             * console.log(arrays);
             * // => [[], []]
             *
             * console.log(arrays[0] === arrays[1]);
             * // => false
             */
            function stubArray() {
                return []
            }

            module.exports = stubArray

            /***/
        },

        /***/ '1+5i': /***/ function(module, exports, __webpack_require__) {
            var baseIsSet = __webpack_require__('w/wX'),
                baseUnary = __webpack_require__('sEf8'),
                nodeUtil = __webpack_require__('mdPL')

            /* Node.js helper references. */
            var nodeIsSet = nodeUtil && nodeUtil.isSet

            /**
             * Checks if `value` is classified as a `Set` object.
             *
             * @static
             * @memberOf _
             * @since 4.3.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a set, else `false`.
             * @example
             *
             * _.isSet(new Set);
             * // => true
             *
             * _.isSet(new WeakSet);
             * // => false
             */
            var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet

            module.exports = isSet

            /***/
        },

        /***/ '10GS': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const fs = __webpack_require__('mw/K')
            const util = __webpack_require__('jK02')
            const is = __webpack_require__('6mOv')
            const isFormData = __webpack_require__('faWz')

            module.exports = async options => {
                const { body } = options

                if (options.headers['content-length']) {
                    return Number(options.headers['content-length'])
                }

                if (!body && !options.stream) {
                    return 0
                }

                if (is.string(body)) {
                    return Buffer.byteLength(body)
                }

                if (isFormData(body)) {
                    return util.promisify(body.getLength.bind(body))()
                }

                if (body instanceof fs.ReadStream) {
                    const { size } = await util.promisify(fs.stat)(body.path)
                    return size
                }

                return null
            }

            /***/
        },

        /***/ '1ALl': /***/ function(module, exports, __webpack_require__) {
            const { keyObjectSupported } = __webpack_require__('pDDt')

            let createPublicKey
            let createPrivateKey
            let createSecretKey
            let KeyObject
            let asInput

            if (keyObjectSupported) {
                ;({
                    createPublicKey,
                    createPrivateKey,
                    createSecretKey,
                    KeyObject
                } = __webpack_require__('PJMN'))
                asInput = input => input
            } else {
                const { EOL } = __webpack_require__('jle/')

                const errors = __webpack_require__('yt7c')
                const isObject = __webpack_require__('kF1/')
                const asn1 = __webpack_require__('u88T')
                const toInput = Symbol('toInput')

                const namedCurve = Symbol('namedCurve')

                asInput = (keyObject, needsPublic) => {
                    if (keyObject instanceof KeyObject) {
                        return keyObject[toInput](needsPublic)
                    }

                    return createSecretKey(keyObject)[toInput](needsPublic)
                }

                const pemToDer = pem =>
                    Buffer.from(
                        pem.replace(
                            /(?:-----(?:BEGIN|END)(?: (?:RSA|EC))? (?:PRIVATE|PUBLIC) KEY-----|\s)/g,
                            ''
                        ),
                        'base64'
                    )
                const derToPem = (der, label) =>
                    `-----BEGIN ${label}-----${EOL}${der
                        .toString('base64')
                        .match(/.{1,64}/g)
                        .join(EOL)}${EOL}-----END ${label}-----`
                const unsupported = label => {
                    switch (label) {
                        case '1.3.101.110':
                            label = 'X25519'
                            break
                        case '1.3.101.111':
                            label = 'X448'
                            break
                        case '1.3.101.112':
                            label = 'Ed25519'
                            break
                        case '1.3.101.113':
                            label = 'Ed448'
                            break
                        default:
                            label = `OID ${label}`
                    }

                    throw new errors.JOSENotSupported(
                        `${label} is not supported in your Node.js runtime version`
                    )
                }

                KeyObject = class KeyObject {
                    export({ cipher, passphrase, type, format } = {}) {
                        if (this._type === 'secret') {
                            return this._buffer
                        }

                        if (this._type === 'public') {
                            if (this.asymmetricKeyType === 'rsa') {
                                switch (type) {
                                    case 'pkcs1':
                                        if (format === 'pem') {
                                            return this._pem
                                        }

                                        return pemToDer(this._pem)
                                    case 'spki': {
                                        const PublicKeyInfo = asn1.get(
                                            'PublicKeyInfo'
                                        )
                                        const pem = PublicKeyInfo.encode(
                                            {
                                                algorithm: {
                                                    algorithm: '1.2.840.113549.1.1.1'.split(
                                                        '.'
                                                    ),
                                                    parameters: Buffer.from(
                                                        'BQA=',
                                                        'base64'
                                                    )
                                                },
                                                publicKey: {
                                                    unused: 0,
                                                    data: pemToDer(this._pem)
                                                }
                                            },
                                            'pem',
                                            { label: 'PUBLIC KEY' }
                                        )

                                        return format === 'pem'
                                            ? pem
                                            : pemToDer(pem)
                                    }
                                    default:
                                        throw new TypeError(
                                            `The value ${type} is invalid for option "type"`
                                        )
                                }
                            }

                            if (this.asymmetricKeyType === 'ec') {
                                if (type !== 'spki') {
                                    throw new TypeError(
                                        `The value ${type} is invalid for option "type"`
                                    )
                                }

                                if (format === 'pem') {
                                    return this._pem
                                }

                                return pemToDer(this._pem)
                            }
                        }

                        if (this._type === 'private') {
                            if (
                                passphrase !== undefined ||
                                cipher !== undefined
                            ) {
                                throw new errors.JOSENotSupported(
                                    'encrypted private keys are not supported in your Node.js runtime version'
                                )
                            }

                            if (type === 'pkcs8') {
                                if (this._pkcs8) {
                                    if (
                                        format === 'der' &&
                                        typeof this._pkcs8 === 'string'
                                    ) {
                                        return pemToDer(this._pkcs8)
                                    }

                                    if (
                                        format === 'pem' &&
                                        Buffer.isBuffer(this._pkcs8)
                                    ) {
                                        return derToPem(
                                            this._pkcs8,
                                            'PRIVATE KEY'
                                        )
                                    }

                                    return this._pkcs8
                                }

                                if (this.asymmetricKeyType === 'rsa') {
                                    const parsed = this._asn1
                                    const RSAPrivateKey = asn1.get(
                                        'RSAPrivateKey'
                                    )
                                    const privateKey = RSAPrivateKey.encode(
                                        parsed
                                    )
                                    const PrivateKeyInfo = asn1.get(
                                        'PrivateKeyInfo'
                                    )
                                    const pkcs8 = PrivateKeyInfo.encode({
                                        version: 0,
                                        privateKey,
                                        algorithm: {
                                            algorithm: '1.2.840.113549.1.1.1'.split(
                                                '.'
                                            ),
                                            parameters: Buffer.from(
                                                'BQA=',
                                                'base64'
                                            )
                                        }
                                    })

                                    this._pkcs8 = pkcs8

                                    return this.export({ type, format })
                                }

                                if (this.asymmetricKeyType === 'ec') {
                                    const parsed = this._asn1
                                    const ECPrivateKey = asn1.get(
                                        'ECPrivateKey'
                                    )
                                    const privateKey = ECPrivateKey.encode({
                                        version: parsed.version,
                                        privateKey: parsed.privateKey,
                                        publicKey: parsed.publicKey
                                    })
                                    const PrivateKeyInfo = asn1.get(
                                        'PrivateKeyInfo'
                                    )
                                    const OID = asn1.get('OID')
                                    const pkcs8 = PrivateKeyInfo.encode({
                                        version: 0,
                                        privateKey,
                                        algorithm: {
                                            algorithm: '1.2.840.10045.2.1'.split(
                                                '.'
                                            ),
                                            parameters: OID.encode(
                                                this._asn1.parameters.value
                                            )
                                        }
                                    })

                                    this._pkcs8 = pkcs8

                                    return this.export({ type, format })
                                }
                            }

                            if (
                                this.asymmetricKeyType === 'rsa' &&
                                type === 'pkcs1'
                            ) {
                                if (format === 'pem') {
                                    return this._pem
                                }

                                return pemToDer(this._pem)
                            } else if (
                                this.asymmetricKeyType === 'ec' &&
                                type === 'sec1'
                            ) {
                                if (format === 'pem') {
                                    return this._pem
                                }

                                return pemToDer(this._pem)
                            } else {
                                throw new TypeError(
                                    `The value ${type} is invalid for option "type"`
                                )
                            }
                        }
                    }

                    get type() {
                        return this._type
                    }

                    get asymmetricKeyType() {
                        return this._asymmetricKeyType
                    }

                    get symmetricKeySize() {
                        return this._symmetricKeySize
                    }

                    [toInput](needsPublic) {
                        switch (this._type) {
                            case 'secret':
                                return this._buffer
                            case 'public':
                                return this._pem
                            default:
                                if (needsPublic) {
                                    if (!('_pub' in this)) {
                                        this._pub = createPublicKey(this)
                                    }

                                    return this._pub[toInput](false)
                                }

                                return this._pem
                        }
                    }
                }

                createSecretKey = buffer => {
                    if (!Buffer.isBuffer(buffer) || !buffer.length) {
                        throw new TypeError(
                            'input must be a non-empty Buffer instance'
                        )
                    }

                    const keyObject = new KeyObject()
                    keyObject._buffer = Buffer.from(buffer)
                    keyObject._symmetricKeySize = buffer.length
                    keyObject._type = 'secret'

                    return keyObject
                }

                createPublicKey = input => {
                    if (input instanceof KeyObject) {
                        if (input.type !== 'private') {
                            throw new TypeError(
                                `Invalid key object type ${input.type}, expected private.`
                            )
                        }

                        switch (input.asymmetricKeyType) {
                            case 'ec': {
                                const PublicKeyInfo = asn1.get('PublicKeyInfo')
                                const OID = asn1.get('OID')
                                const key = PublicKeyInfo.encode({
                                    algorithm: {
                                        algorithm: '1.2.840.10045.2.1'.split(
                                            '.'
                                        ),
                                        parameters: OID.encode(
                                            input._asn1.parameters.value
                                        )
                                    },
                                    publicKey: input._asn1.publicKey
                                })

                                return createPublicKey({
                                    key,
                                    format: 'der',
                                    type: 'spki'
                                })
                            }
                            case 'rsa': {
                                const RSAPublicKey = asn1.get('RSAPublicKey')
                                const key = RSAPublicKey.encode(input._asn1)
                                return createPublicKey({
                                    key,
                                    format: 'der',
                                    type: 'pkcs1'
                                })
                            }
                        }
                    }

                    if (typeof input === 'string' || Buffer.isBuffer(input)) {
                        input = { key: input, format: 'pem' }
                    }

                    if (!isObject(input)) {
                        throw new TypeError(
                            'input must be a string, Buffer or an object'
                        )
                    }

                    const { format, passphrase } = input
                    let { key, type } = input

                    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {
                        throw new TypeError('key must be a string or Buffer')
                    }

                    if (format !== 'pem' && format !== 'der') {
                        throw new TypeError(
                            'format must be one of "pem" or "der"'
                        )
                    }

                    let label
                    if (format === 'pem') {
                        key = key.toString()
                        switch (key.split(/\r?\n/g)[0].toString()) {
                            case '-----BEGIN PUBLIC KEY-----':
                                type = 'spki'
                                label = 'PUBLIC KEY'
                                break
                            case '-----BEGIN RSA PUBLIC KEY-----':
                                type = 'pkcs1'
                                label = 'RSA PUBLIC KEY'
                                break
                            case '-----BEGIN CERTIFICATE-----':
                                throw new errors.JOSENotSupported(
                                    'X.509 certificates are not supported in your Node.js runtime version'
                                )
                            case '-----BEGIN PRIVATE KEY-----':
                            case '-----BEGIN EC PRIVATE KEY-----':
                            case '-----BEGIN RSA PRIVATE KEY-----':
                                return createPublicKey(createPrivateKey(key))
                            default:
                                throw new TypeError(
                                    'unknown/unsupported PEM type'
                                )
                        }
                    }

                    switch (type) {
                        case 'spki': {
                            const PublicKeyInfo = asn1.get('PublicKeyInfo')
                            const parsed = PublicKeyInfo.decode(key, format, {
                                label
                            })

                            let type, keyObject
                            const oid = parsed.algorithm.algorithm.join('.')
                            switch (oid) {
                                case '1.2.840.10045.2.1': {
                                    keyObject = new KeyObject()
                                    keyObject._asn1 = parsed
                                    keyObject._asymmetricKeyType = 'ec'
                                    keyObject._type = 'public'
                                    keyObject._pem = PublicKeyInfo.encode(
                                        parsed,
                                        'pem',
                                        { label: 'PUBLIC KEY' }
                                    )

                                    break
                                }
                                case '1.2.840.113549.1.1.1': {
                                    type = 'pkcs1'
                                    keyObject = createPublicKey({
                                        type,
                                        key: parsed.publicKey.data,
                                        format: 'der'
                                    })
                                    break
                                }
                                default:
                                    unsupported(oid)
                            }

                            return keyObject
                        }
                        case 'pkcs1': {
                            const RSAPublicKey = asn1.get('RSAPublicKey')
                            const parsed = RSAPublicKey.decode(key, format, {
                                label
                            })

                            // special case when private pkcs1 PEM / DER is used with createPublicKey
                            if (parsed.n === 0n) {
                                return createPublicKey(
                                    createPrivateKey({
                                        key,
                                        format,
                                        type,
                                        passphrase
                                    })
                                )
                            }

                            const keyObject = new KeyObject()
                            keyObject._asn1 = parsed
                            keyObject._asymmetricKeyType = 'rsa'
                            keyObject._type = 'public'
                            keyObject._pem = RSAPublicKey.encode(
                                parsed,
                                'pem',
                                { label: 'RSA PUBLIC KEY' }
                            )

                            return keyObject
                        }
                        case 'pkcs8':
                        case 'sec1':
                            return createPublicKey(
                                createPrivateKey({
                                    format,
                                    key,
                                    type,
                                    passphrase
                                })
                            )
                        default:
                            throw new TypeError(
                                `The value ${type} is invalid for option "type"`
                            )
                    }
                }

                createPrivateKey = (input, hints) => {
                    if (typeof input === 'string' || Buffer.isBuffer(input)) {
                        input = { key: input, format: 'pem' }
                    }

                    if (!isObject(input)) {
                        throw new TypeError(
                            'input must be a string, Buffer or an object'
                        )
                    }

                    const { format, passphrase } = input
                    let { key, type } = input

                    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {
                        throw new TypeError('key must be a string or Buffer')
                    }

                    if (passphrase !== undefined) {
                        throw new errors.JOSENotSupported(
                            'encrypted private keys are not supported in your Node.js runtime version'
                        )
                    }

                    if (format !== 'pem' && format !== 'der') {
                        throw new TypeError(
                            'format must be one of "pem" or "der"'
                        )
                    }

                    let label
                    if (format === 'pem') {
                        key = key.toString()
                        switch (key.split(/\r?\n/g)[0].toString()) {
                            case '-----BEGIN PRIVATE KEY-----':
                                type = 'pkcs8'
                                label = 'PRIVATE KEY'
                                break
                            case '-----BEGIN EC PRIVATE KEY-----':
                                type = 'sec1'
                                label = 'EC PRIVATE KEY'
                                break
                            case '-----BEGIN RSA PRIVATE KEY-----':
                                type = 'pkcs1'
                                label = 'RSA PRIVATE KEY'
                                break
                            default:
                                throw new TypeError(
                                    'unknown/unsupported PEM type'
                                )
                        }
                    }

                    switch (type) {
                        case 'pkcs8': {
                            const PrivateKeyInfo = asn1.get('PrivateKeyInfo')
                            const parsed = PrivateKeyInfo.decode(key, format, {
                                label
                            })

                            let type, keyObject
                            const oid = parsed.algorithm.algorithm.join('.')
                            switch (oid) {
                                case '1.2.840.10045.2.1': {
                                    const OID = asn1.get('OID')
                                    type = 'sec1'
                                    keyObject = createPrivateKey(
                                        {
                                            type,
                                            key: parsed.privateKey,
                                            format: 'der'
                                        },
                                        {
                                            [namedCurve]: OID.decode(
                                                parsed.algorithm.parameters
                                            )
                                        }
                                    )
                                    break
                                }
                                case '1.2.840.113549.1.1.1': {
                                    type = 'pkcs1'
                                    keyObject = createPrivateKey({
                                        type,
                                        key: parsed.privateKey,
                                        format: 'der'
                                    })
                                    break
                                }
                                default:
                                    unsupported(oid)
                            }

                            keyObject._pkcs8 = key
                            return keyObject
                        }
                        case 'pkcs1': {
                            const RSAPrivateKey = asn1.get('RSAPrivateKey')
                            const parsed = RSAPrivateKey.decode(key, format, {
                                label
                            })

                            const keyObject = new KeyObject()
                            keyObject._asn1 = parsed
                            keyObject._asymmetricKeyType = 'rsa'
                            keyObject._type = 'private'
                            keyObject._pem = RSAPrivateKey.encode(
                                parsed,
                                'pem',
                                { label: 'RSA PRIVATE KEY' }
                            )

                            return keyObject
                        }
                        case 'sec1': {
                            const ECPrivateKey = asn1.get('ECPrivateKey')
                            let parsed = ECPrivateKey.decode(key, format, {
                                label
                            })

                            if (
                                !('parameters' in parsed) &&
                                !hints[namedCurve]
                            ) {
                                throw new Error('invalid sec1')
                            } else if (!('parameters' in parsed)) {
                                parsed = {
                                    ...parsed,
                                    parameters: {
                                        type: 'namedCurve',
                                        value: hints[namedCurve]
                                    }
                                }
                            }

                            const keyObject = new KeyObject()
                            keyObject._asn1 = parsed
                            keyObject._asymmetricKeyType = 'ec'
                            keyObject._type = 'private'
                            keyObject._pem = ECPrivateKey.encode(
                                parsed,
                                'pem',
                                { label: 'EC PRIVATE KEY' }
                            )

                            return keyObject
                        }
                        default:
                            throw new TypeError(
                                `The value ${type} is invalid for option "type"`
                            )
                    }
                }
            }

            module.exports = {
                createPublicKey,
                createPrivateKey,
                createSecretKey,
                KeyObject,
                asInput
            }

            /***/
        },

        /***/ '1Gj5': /***/ function(module, exports) {
            // Helper
            function reverse(map) {
                const res = {}

                Object.keys(map).forEach(function(key) {
                    // Convert key to integer if it is stringified
                    if ((key | 0) == key) {
                        key = key | 0
                    } // eslint-disable-line eqeqeq

                    const value = map[key]
                    res[value] = key
                })

                return res
            }

            exports.tagClass = {
                0: 'universal',
                1: 'application',
                2: 'context',
                3: 'private'
            }
            exports.tagClassByName = reverse(exports.tagClass)

            exports.tag = {
                0x00: 'end',
                0x01: 'bool',
                0x02: 'int',
                0x03: 'bitstr',
                0x04: 'octstr',
                0x05: 'null_',
                0x06: 'objid',
                0x07: 'objDesc',
                0x08: 'external',
                0x09: 'real',
                0x0a: 'enum',
                0x0b: 'embed',
                0x0c: 'utf8str',
                0x0d: 'relativeOid',
                0x10: 'seq',
                0x11: 'set',
                0x12: 'numstr',
                0x13: 'printstr',
                0x14: 't61str',
                0x15: 'videostr',
                0x16: 'ia5str',
                0x17: 'utctime',
                0x18: 'gentime',
                0x19: 'graphstr',
                0x1a: 'iso646str',
                0x1b: 'genstr',
                0x1c: 'unistr',
                0x1d: 'charstr',
                0x1e: 'bmpstr'
            }
            exports.tagByName = reverse(exports.tag)

            /***/
        },

        /***/ '1WHo': /***/ function(module, exports, __webpack_require__) {
            const { inherits } = __webpack_require__('jK02')

            function Reporter(options) {
                this._reporterState = {
                    obj: null,
                    path: [],
                    options: options || {},
                    errors: []
                }
            }

            Reporter.prototype.isError = function isError(obj) {
                return obj instanceof ReporterError
            }

            Reporter.prototype.save = function save() {
                const state = this._reporterState

                return { obj: state.obj, pathLen: state.path.length }
            }

            Reporter.prototype.restore = function restore(data) {
                const state = this._reporterState

                state.obj = data.obj
                state.path = state.path.slice(0, data.pathLen)
            }

            Reporter.prototype.enterKey = function enterKey(key) {
                return this._reporterState.path.push(key)
            }

            Reporter.prototype.exitKey = function exitKey(index) {
                const state = this._reporterState

                state.path = state.path.slice(0, index - 1)
            }

            Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
                const state = this._reporterState

                this.exitKey(index)
                if (state.obj !== null) {
                    state.obj[key] = value
                }
            }

            Reporter.prototype.path = function path() {
                return this._reporterState.path.join('/')
            }

            Reporter.prototype.enterObject = function enterObject() {
                const state = this._reporterState

                const prev = state.obj
                state.obj = {}
                return prev
            }

            Reporter.prototype.leaveObject = function leaveObject(prev) {
                const state = this._reporterState

                const now = state.obj
                state.obj = prev
                return now
            }

            Reporter.prototype.error = function error(msg) {
                let err
                const state = this._reporterState

                const inherited = msg instanceof ReporterError
                if (inherited) {
                    err = msg
                } else {
                    err = new ReporterError(
                        state.path
                            .map(function(elem) {
                                return `[${JSON.stringify(elem)}]`
                            })
                            .join(''),
                        msg.message || msg,
                        msg.stack
                    )
                }

                if (!state.options.partial) {
                    throw err
                }

                if (!inherited) {
                    state.errors.push(err)
                }

                return err
            }

            Reporter.prototype.wrapResult = function wrapResult(result) {
                const state = this._reporterState
                if (!state.options.partial) {
                    return result
                }

                return {
                    result: this.isError(result) ? null : result,
                    errors: state.errors
                }
            }

            function ReporterError(path, msg) {
                this.path = path
                this.rethrow(msg)
            }
            inherits(ReporterError, Error)

            ReporterError.prototype.rethrow = function rethrow(msg) {
                this.message = `${msg} at: ${this.path || '(shallow)'}`
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, ReporterError)
                }

                if (!this.stack) {
                    try {
                        // IE only adds stack when thrown
                        throw new Error(this.message)
                    } catch (e) {
                        this.stack = e.stack
                    }
                }
                return this
            }

            exports.Reporter = Reporter

            /***/
        },

        /***/ '1gXH': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const base64url_1 = tslib_1.__importDefault(
                __webpack_require__('+00W')
            )
            const crypto_1 = __webpack_require__('PJMN')
            const version_1 = tslib_1.__importDefault(
                __webpack_require__('Nndd')
            )
            const cookies_1 = __webpack_require__('gKi1')
            function telemetry() {
                const bytes = Buffer.from(
                    JSON.stringify({
                        name: 'nextjs-auth0',
                        version: version_1.default
                    })
                )
                return bytes
                    .toString('base64')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=+$/, '')
            }
            function loginHandler(settings, clientProvider) {
                return (req, res, options = {}) =>
                    tslib_1.__awaiter(this, void 0, void 0, function*() {
                        if (!res) {
                            throw new Error('Response is not available')
                        }
                        // Generate the state
                        const state = base64url_1.default(
                            crypto_1.randomBytes(48)
                        )
                        // Create the authorization url.
                        const client = yield clientProvider()
                        const authParams = (options && options.authParams) || {}
                        const authorizationUrl = client.authorizationUrl(
                            Object.assign(
                                {
                                    redirect_uri: settings.redirectUri,
                                    scope: settings.scope,
                                    response_type: 'code',
                                    audience: settings.audience,
                                    state,
                                    auth0Client: telemetry()
                                },
                                authParams
                            )
                        )
                        // Set the necessary cookies
                        cookies_1.setCookies(req, res, [
                            {
                                name: 'a0:state',
                                value: state,
                                maxAge: 60 * 60
                            }
                        ])
                        // Redirect to the authorize endpoint.
                        res.writeHead(302, {
                            Location: authorizationUrl
                        })
                        res.end()
                    })
            }
            exports.default = loginHandler
            //# sourceMappingURL=login.js.map

            /***/
        },

        /***/ '1hJj': /***/ function(module, exports, __webpack_require__) {
            var MapCache = __webpack_require__('e4Nc'),
                setCacheAdd = __webpack_require__('ftKO'),
                setCacheHas = __webpack_require__('3A9y')

            /**
             *
             * Creates an array cache object to store unique values.
             *
             * @private
             * @constructor
             * @param {Array} [values] The values to cache.
             */
            function SetCache(values) {
                var index = -1,
                    length = values == null ? 0 : values.length

                this.__data__ = new MapCache()
                while (++index < length) {
                    this.add(values[index])
                }
            }

            // Add methods to `SetCache`.
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd
            SetCache.prototype.has = setCacheHas

            module.exports = SetCache

            /***/
        },

        /***/ '1jOq': /***/ function(module, exports) {
            // Returns a wrapper function that returns a wrapped callback
            // The wrapper function should do some stuff, and return a
            // presumably different callback function.
            // This makes sure that own properties are retained, so that
            // decorations and such are not lost along the way.
            module.exports = wrappy
            function wrappy(fn, cb) {
                if (fn && cb) return wrappy(fn)(cb)

                if (typeof fn !== 'function')
                    throw new TypeError('need wrapper function')

                Object.keys(fn).forEach(function(k) {
                    wrapper[k] = fn[k]
                })

                return wrapper

                function wrapper() {
                    var args = new Array(arguments.length)
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i]
                    }
                    var ret = fn.apply(this, args)
                    var cb = args[args.length - 1]
                    if (typeof ret === 'function' && ret !== cb) {
                        Object.keys(cb).forEach(function(k) {
                            ret[k] = cb[k]
                        })
                    }
                    return ret
                }
            }

            /***/
        },

        /***/ '21rS': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const PassThrough = __webpack_require__('msIP').PassThrough
            const mimicResponse = __webpack_require__('qsvm')

            const cloneResponse = response => {
                if (!(response && response.pipe)) {
                    throw new TypeError(
                        'Parameter `response` must be a response stream.'
                    )
                }

                const clone = new PassThrough()
                mimicResponse(response, clone)

                return response.pipe(clone)
            }

            module.exports = cloneResponse

            /***/
        },

        /***/ '2GTP': /***/ function(module, exports, __webpack_require__) {
            // optional / simple context binding
            var aFunction = __webpack_require__('eaoh')
            module.exports = function(fn, that, length) {
                aFunction(fn)
                if (that === undefined) return fn
                switch (length) {
                    case 1:
                        return function(a) {
                            return fn.call(that, a)
                        }
                    case 2:
                        return function(a, b) {
                            return fn.call(that, a, b)
                        }
                    case 3:
                        return function(a, b, c) {
                            return fn.call(that, a, b, c)
                        }
                }
                return function(/* ...args */) {
                    return fn.apply(that, arguments)
                }
            }

            /***/
        },

        /***/ '2IvE': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const net = __webpack_require__('Qs2e')

            class TimeoutError extends Error {
                constructor(threshold, event) {
                    super(`Timeout awaiting '${event}' for ${threshold}ms`)
                    this.name = 'TimeoutError'
                    this.code = 'ETIMEDOUT'
                    this.event = event
                }
            }

            const reentry = Symbol('reentry')

            const noop = () => {}

            module.exports = (request, delays, options) => {
                /* istanbul ignore next: this makes sure timed-out isn't called twice */
                if (request[reentry]) {
                    return
                }

                request[reentry] = true

                let stopNewTimeouts = false

                const addTimeout = (delay, callback, ...args) => {
                    // An error had been thrown before. Going further would result in uncaught errors.
                    // See https://github.com/sindresorhus/got/issues/631#issuecomment-435675051
                    if (stopNewTimeouts) {
                        return noop
                    }

                    // Event loop order is timers, poll, immediates.
                    // The timed event may emit during the current tick poll phase, so
                    // defer calling the handler until the poll phase completes.
                    let immediate
                    const timeout = setTimeout(() => {
                        immediate = setImmediate(callback, delay, ...args)
                        /* istanbul ignore next: added in node v9.7.0 */
                        if (immediate.unref) {
                            immediate.unref()
                        }
                    }, delay)

                    /* istanbul ignore next: in order to support electron renderer */
                    if (timeout.unref) {
                        timeout.unref()
                    }

                    const cancel = () => {
                        clearTimeout(timeout)
                        clearImmediate(immediate)
                    }

                    cancelers.push(cancel)

                    return cancel
                }

                const { host, hostname } = options
                const timeoutHandler = (delay, event) => {
                    request.emit('error', new TimeoutError(delay, event))
                    request.once('error', () => {}) // Ignore the `socket hung up` error made by request.abort()

                    request.abort()
                }

                const cancelers = []
                const cancelTimeouts = () => {
                    stopNewTimeouts = true
                    cancelers.forEach(cancelTimeout => cancelTimeout())
                }

                request.once('error', cancelTimeouts)
                request.once('response', response => {
                    response.once('end', cancelTimeouts)
                })

                if (delays.request !== undefined) {
                    addTimeout(delays.request, timeoutHandler, 'request')
                }

                if (delays.socket !== undefined) {
                    const socketTimeoutHandler = () => {
                        timeoutHandler(delays.socket, 'socket')
                    }

                    request.setTimeout(delays.socket, socketTimeoutHandler)

                    // `request.setTimeout(0)` causes a memory leak.
                    // We can just remove the listener and forget about the timer - it's unreffed.
                    // See https://github.com/sindresorhus/got/issues/690
                    cancelers.push(() =>
                        request.removeListener('timeout', socketTimeoutHandler)
                    )
                }

                if (
                    delays.lookup !== undefined &&
                    !request.socketPath &&
                    !net.isIP(hostname || host)
                ) {
                    request.once('socket', socket => {
                        /* istanbul ignore next: hard to test */
                        if (socket.connecting) {
                            const cancelTimeout = addTimeout(
                                delays.lookup,
                                timeoutHandler,
                                'lookup'
                            )
                            socket.once('lookup', cancelTimeout)
                        }
                    })
                }

                if (delays.connect !== undefined) {
                    request.once('socket', socket => {
                        /* istanbul ignore next: hard to test */
                        if (socket.connecting) {
                            const timeConnect = () =>
                                addTimeout(
                                    delays.connect,
                                    timeoutHandler,
                                    'connect'
                                )

                            if (
                                request.socketPath ||
                                net.isIP(hostname || host)
                            ) {
                                socket.once('connect', timeConnect())
                            } else {
                                socket.once('lookup', error => {
                                    if (error === null) {
                                        socket.once('connect', timeConnect())
                                    }
                                })
                            }
                        }
                    })
                }

                if (
                    delays.secureConnect !== undefined &&
                    options.protocol === 'https:'
                ) {
                    request.once('socket', socket => {
                        /* istanbul ignore next: hard to test */
                        if (socket.connecting) {
                            socket.once('connect', () => {
                                const cancelTimeout = addTimeout(
                                    delays.secureConnect,
                                    timeoutHandler,
                                    'secureConnect'
                                )
                                socket.once('secureConnect', cancelTimeout)
                            })
                        }
                    })
                }

                if (delays.send !== undefined) {
                    request.once('socket', socket => {
                        const timeRequest = () =>
                            addTimeout(delays.send, timeoutHandler, 'send')
                        /* istanbul ignore next: hard to test */
                        if (socket.connecting) {
                            socket.once('connect', () => {
                                request.once('upload-complete', timeRequest())
                            })
                        } else {
                            request.once('upload-complete', timeRequest())
                        }
                    })
                }

                if (delays.response !== undefined) {
                    request.once('upload-complete', () => {
                        const cancelTimeout = addTimeout(
                            delays.response,
                            timeoutHandler,
                            'response'
                        )
                        request.once('response', cancelTimeout)
                    })
                }
            }

            module.exports.TimeoutError = TimeoutError

            /***/
        },

        /***/ '2KX+': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            function profileHandler(sessionStore) {
                return (req, res) =>
                    tslib_1.__awaiter(this, void 0, void 0, function*() {
                        if (!req) {
                            throw new Error('Request is not available')
                        }
                        if (!res) {
                            throw new Error('Response is not available')
                        }
                        const session = yield sessionStore.read(req)
                        if (!session || !session.user) {
                            res.status(401).json({
                                error: 'not_authenticated',
                                description:
                                    'The user does not have an active session or is not authenticated'
                            })
                            return
                        }
                        res.json(session.user)
                    })
            }
            exports.default = profileHandler
            //# sourceMappingURL=profile.js.map

            /***/
        },

        /***/ '2NqA': /***/ function(
            module,
            __webpack_exports__,
            __webpack_require__
        ) {
            'use strict'
            /* harmony import */ var _auth0_nextjs_auth0__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                'qwdb'
            )
            /* harmony import */ var _auth0_nextjs_auth0__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
                _auth0_nextjs_auth0__WEBPACK_IMPORTED_MODULE_0__
            )

            /* harmony default export */ __webpack_exports__['a'] = Object(
                _auth0_nextjs_auth0__WEBPACK_IMPORTED_MODULE_0__['initAuth0']
            )({
                clientId: 'pd7pNi0CFbkPtmuZof0tg7HNcb2uoY53',
                clientSecret:
                    'bTsCl2WWhXY7bLlEVs3kQL9a_4vzs3MHcV3EIILcC-5rnyPNHtz1yTpLManmIOBo',
                scope: 'openid profile',
                domain: 'osborne-dev.auth0.com',
                redirectUri:
                    'https://www.shopping-list-app.com/api/auth/callback',
                postLogoutRedirectUri: 'https://www.shopping-list-app.com/',
                session: {
                    cookieSecret:
                        'viloxyf_z2GW6K4CT-KQD_MoLEA2wqv5jWuq4Jd0P7ymgG5GJGMpvMneXZzhK3sL',
                    cookieLifetime: 7200
                }
            })

            /***/
        },

        /***/ '2faE': /***/ function(module, exports, __webpack_require__) {
            var anObject = __webpack_require__('5K7Z')
            var IE8_DOM_DEFINE = __webpack_require__('eUtF')
            var toPrimitive = __webpack_require__('G8Mo')
            var dP = Object.defineProperty

            exports.f = __webpack_require__('jmDH')
                ? Object.defineProperty
                : function defineProperty(O, P, Attributes) {
                      anObject(O)
                      P = toPrimitive(P, true)
                      anObject(Attributes)
                      if (IE8_DOM_DEFINE)
                          try {
                              return dP(O, P, Attributes)
                          } catch (e) {
                              /* empty */
                          }
                      if ('get' in Attributes || 'set' in Attributes)
                          throw TypeError('Accessors not supported!')
                      if ('value' in Attributes) O[P] = Attributes.value
                      return O
                  }

            /***/
        },

        /***/ '2gN3': /***/ function(module, exports, __webpack_require__) {
            var root = __webpack_require__('Kz5y')

            /** Used to detect overreaching core-js shims. */
            var coreJsData = root['__core-js_shared__']

            module.exports = coreJsData

            /***/
        },

        /***/ '33Iv': /***/ function(module, exports, __webpack_require__) {
            const { inflateRawSync } = __webpack_require__('FMKJ')

            const base64url = __webpack_require__('Xab3')
            const getKey = __webpack_require__('oGTz')
            const { KeyStore } = __webpack_require__('WPgm')
            const errors = __webpack_require__('yt7c')
            const {
                check,
                decrypt,
                keyManagementDecrypt
            } = __webpack_require__('FUB/')
            const JWK = __webpack_require__('lA9T')

            const { createSecretKey } = __webpack_require__('1ALl')
            const generateCEK = __webpack_require__('RGIU')
            const validateHeaders = __webpack_require__('OHZa')
            const { detect: resolveSerialization } = __webpack_require__('ARPQ')

            const SINGLE_RECIPIENT = new Set(['compact', 'flattened'])

            const combineHeader = (
                prot = {},
                unprotected = {},
                header = {}
            ) => {
                if (typeof prot === 'string') {
                    prot = base64url.JSON.decode(prot)
                }

                const p2s = prot.p2s || unprotected.p2s || header.p2s
                const apu = prot.apu || unprotected.apu || header.apu
                const apv = prot.apv || unprotected.apv || header.apv
                const iv = prot.iv || unprotected.iv || header.iv
                const tag = prot.tag || unprotected.tag || header.tag

                return {
                    ...prot,
                    ...unprotected,
                    ...header,
                    ...(typeof p2s === 'string'
                        ? { p2s: base64url.decodeToBuffer(p2s) }
                        : undefined),
                    ...(typeof apu === 'string'
                        ? { apu: base64url.decodeToBuffer(apu) }
                        : undefined),
                    ...(typeof apv === 'string'
                        ? { apv: base64url.decodeToBuffer(apv) }
                        : undefined),
                    ...(typeof iv === 'string'
                        ? { iv: base64url.decodeToBuffer(iv) }
                        : undefined),
                    ...(typeof tag === 'string'
                        ? { tag: base64url.decodeToBuffer(tag) }
                        : undefined)
                }
            }

            /*
             * @public
             */
            const jweDecrypt = (
                skipValidateHeaders,
                serialization,
                jwe,
                key,
                { crit = [], complete = false, algorithms } = {}
            ) => {
                key = getKey(key, true)

                if (
                    algorithms !== undefined &&
                    (!Array.isArray(algorithms) ||
                        algorithms.some(s => typeof s !== 'string' || !s))
                ) {
                    throw new TypeError(
                        '"algorithms" option must be an array of non-empty strings'
                    )
                } else if (algorithms) {
                    algorithms = new Set(algorithms)
                }

                if (
                    !Array.isArray(crit) ||
                    crit.some(s => typeof s !== 'string' || !s)
                ) {
                    throw new TypeError(
                        '"crit" option must be an array of non-empty strings'
                    )
                }

                if (!serialization) {
                    serialization = resolveSerialization(jwe)
                }

                let alg,
                    ciphertext,
                    enc,
                    encryptedKey,
                    iv,
                    opts,
                    prot,
                    tag,
                    unprotected,
                    cek,
                    aad,
                    header

                // treat general format with one recipient as flattened
                // skips iteration and avoids multi errors in this case
                if (
                    serialization === 'general' &&
                    jwe.recipients.length === 1
                ) {
                    serialization = 'flattened'
                    const { recipients, ...root } = jwe
                    jwe = { ...root, ...recipients[0] }
                }

                if (SINGLE_RECIPIENT.has(serialization)) {
                    if (serialization === 'compact') {
                        // compact serialization format
                        ;[prot, encryptedKey, iv, ciphertext, tag] = jwe.split(
                            '.'
                        )
                    } else {
                        // flattened serialization format
                        ;({
                            protected: prot,
                            encrypted_key: encryptedKey,
                            iv,
                            ciphertext,
                            tag,
                            unprotected,
                            aad,
                            header
                        } = jwe)
                    }

                    if (!skipValidateHeaders) {
                        validateHeaders(
                            prot,
                            unprotected,
                            [{ header }],
                            true,
                            crit
                        )
                    }

                    opts = combineHeader(prot, unprotected, header)
                    ;({ alg, enc } = opts)

                    if (
                        algorithms &&
                        !algorithms.has(alg === 'dir' ? enc : alg)
                    ) {
                        throw new errors.JOSEAlgNotWhitelisted(
                            'alg not whitelisted'
                        )
                    }

                    if (key instanceof KeyStore) {
                        const keystore = key
                        let keys
                        if (opts.alg === 'dir') {
                            keys = keystore.all({
                                kid: opts.kid,
                                alg: opts.enc,
                                key_ops: ['decrypt']
                            })
                        } else {
                            keys = keystore.all({
                                kid: opts.kid,
                                alg: opts.alg,
                                key_ops: ['unwrapKey']
                            })
                        }
                        switch (keys.length) {
                            case 0:
                                throw new errors.JWKSNoMatchingKey()
                            case 1:
                                // treat the call as if a Key instance was passed in
                                // skips iteration and avoids multi errors in this case
                                key = keys[0]
                                break
                            default: {
                                const errs = []
                                for (const key of keys) {
                                    try {
                                        return jweDecrypt(
                                            true,
                                            serialization,
                                            jwe,
                                            key,
                                            {
                                                crit,
                                                complete,
                                                algorithms: algorithms
                                                    ? [...algorithms]
                                                    : undefined
                                            }
                                        )
                                    } catch (err) {
                                        errs.push(err)
                                        continue
                                    }
                                }

                                const multi = new errors.JOSEMultiError(errs)
                                if (
                                    [...multi].some(
                                        e =>
                                            e instanceof
                                            errors.JWEDecryptionFailed
                                    )
                                ) {
                                    throw new errors.JWEDecryptionFailed()
                                }
                                throw multi
                            }
                        }
                    }

                    check(
                        key,
                        ...(alg === 'dir'
                            ? ['decrypt', enc]
                            : ['keyManagementDecrypt', alg])
                    )

                    try {
                        if (alg === 'dir') {
                            cek = JWK.asKey(key, { alg: enc, use: 'enc' })
                        } else if (alg === 'ECDH-ES') {
                            const unwrapped = keyManagementDecrypt(
                                alg,
                                key,
                                undefined,
                                opts
                            )
                            cek = JWK.asKey(createSecretKey(unwrapped), {
                                alg: enc,
                                use: 'enc'
                            })
                        } else {
                            const unwrapped = keyManagementDecrypt(
                                alg,
                                key,
                                base64url.decodeToBuffer(encryptedKey),
                                opts
                            )
                            cek = JWK.asKey(createSecretKey(unwrapped), {
                                alg: enc,
                                use: 'enc'
                            })
                        }
                    } catch (err) {
                        // To mitigate the attacks described in RFC 3218, the
                        // recipient MUST NOT distinguish between format, padding, and length
                        // errors of encrypted keys.  It is strongly recommended, in the event
                        // of receiving an improperly formatted key, that the recipient
                        // substitute a randomly generated CEK and proceed to the next step, to
                        // mitigate timing attacks.
                        cek = generateCEK(enc)
                    }

                    let adata
                    if (aad) {
                        adata = Buffer.concat([
                            Buffer.from(prot || ''),
                            Buffer.from('.'),
                            Buffer.from(aad)
                        ])
                    } else {
                        adata = Buffer.from(prot || '')
                    }

                    try {
                        iv = base64url.decodeToBuffer(iv)
                    } catch (err) {}
                    try {
                        tag = base64url.decodeToBuffer(tag)
                    } catch (err) {}

                    let cleartext = decrypt(
                        enc,
                        cek,
                        base64url.decodeToBuffer(ciphertext),
                        { iv, tag, aad: adata }
                    )

                    if (opts.zip) {
                        cleartext = inflateRawSync(cleartext)
                    }

                    if (complete) {
                        const result = { cleartext, key, cek }
                        if (aad) result.aad = aad
                        if (header) result.header = header
                        if (unprotected) result.unprotected = unprotected
                        if (prot) result.protected = base64url.JSON.decode(prot)
                        return result
                    }

                    return cleartext
                }

                validateHeaders(
                    jwe.protected,
                    jwe.unprotected,
                    jwe.recipients.map(({ header }) => ({ header })),
                    true,
                    crit
                )

                // general serialization format
                const { recipients, ...root } = jwe
                const errs = []
                for (const recipient of recipients) {
                    try {
                        return jweDecrypt(
                            true,
                            'flattened',
                            { ...root, ...recipient },
                            key,
                            {
                                crit,
                                complete,
                                algorithms: algorithms
                                    ? [...algorithms]
                                    : undefined
                            }
                        )
                    } catch (err) {
                        errs.push(err)
                        continue
                    }
                }

                const multi = new errors.JOSEMultiError(errs)
                if (
                    [...multi].some(
                        e => e instanceof errors.JWEDecryptionFailed
                    )
                ) {
                    throw new errors.JWEDecryptionFailed()
                } else if (
                    [...multi].every(e => e instanceof errors.JWKSNoMatchingKey)
                ) {
                    throw new errors.JWKSNoMatchingKey()
                }
                throw multi
            }

            module.exports = jweDecrypt.bind(undefined, false, undefined)

            /***/
        },

        /***/ '3A9y': /***/ function(module, exports) {
            /**
             * Checks if `value` is in the array cache.
             *
             * @private
             * @name has
             * @memberOf SetCache
             * @param {*} value The value to search for.
             * @returns {number} Returns `true` if `value` is found, else `false`.
             */
            function setCacheHas(value) {
                return this.__data__.has(value)
            }

            module.exports = setCacheHas

            /***/
        },

        /***/ '3Fdi': /***/ function(module, exports) {
            /** Used for built-in method references. */
            var funcProto = Function.prototype

            /** Used to resolve the decompiled source of functions. */
            var funcToString = funcProto.toString

            /**
             * Converts `func` to its source code.
             *
             * @private
             * @param {Function} func The function to convert.
             * @returns {string} Returns the source code.
             */
            function toSource(func) {
                if (func != null) {
                    try {
                        return funcToString.call(func)
                    } catch (e) {}
                    try {
                        return func + ''
                    } catch (e) {}
                }
                return ''
            }

            module.exports = toSource

            /***/
        },

        /***/ '3HlQ': /***/ function(module, exports, __webpack_require__) {
            const {
                generateKeyPairSync,
                generateKeyPair: async
            } = __webpack_require__('PJMN')
            const { promisify } = __webpack_require__('jK02')

            const {
                THUMBPRINT_MATERIAL,
                JWK_MEMBERS,
                PUBLIC_MEMBERS,
                PRIVATE_MEMBERS,
                KEY_MANAGEMENT_DECRYPT,
                KEY_MANAGEMENT_ENCRYPT
            } = __webpack_require__('ehsS')
            const { EC_CURVES } = __webpack_require__('N+nT')
            const { keyObjectSupported } = __webpack_require__('pDDt')
            const { createPublicKey, createPrivateKey } = __webpack_require__(
                '1ALl'
            )

            const errors = __webpack_require__('yt7c')
            const { name: secp256k1 } = __webpack_require__('F/JS')

            const Key = __webpack_require__('//Cd')

            const generateKeyPair = promisify(async)

            const EC_PUBLIC = new Set(['crv', 'x', 'y'])
            Object.freeze(EC_PUBLIC)
            const EC_PRIVATE = new Set([...EC_PUBLIC, 'd'])
            Object.freeze(EC_PRIVATE)

            // Elliptic Curve Key Type
            class ECKey extends Key {
                constructor(...args) {
                    super(...args)
                    this[JWK_MEMBERS]()
                    Object.defineProperty(this, 'kty', {
                        value: 'EC',
                        enumerable: true
                    })
                    if (!this.crv) {
                        throw new errors.JOSENotSupported(
                            'unsupported EC key curve'
                        )
                    }
                }

                static get [PUBLIC_MEMBERS]() {
                    return EC_PUBLIC
                }

                static get [PRIVATE_MEMBERS]() {
                    return EC_PRIVATE
                }

                // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special
                // JSON.stringify handling in V8
                [THUMBPRINT_MATERIAL]() {
                    return { crv: this.crv, kty: 'EC', x: this.x, y: this.y }
                }

                [KEY_MANAGEMENT_ENCRYPT]() {
                    return this.algorithms('deriveKey')
                }

                [KEY_MANAGEMENT_DECRYPT]() {
                    if (this.public) {
                        return new Set()
                    }
                    return this.algorithms('deriveKey')
                }

                static async generate(crv = 'P-256', privat = true) {
                    if (!EC_CURVES.has(crv)) {
                        throw new errors.JOSENotSupported(
                            `unsupported EC key curve: ${crv}`
                        )
                    }

                    if (crv === secp256k1 && crv !== 'secp256k1') {
                        crv = 'secp256k1'
                    }

                    let privateKey, publicKey

                    if (keyObjectSupported) {
                        ;({
                            privateKey,
                            publicKey
                        } = await generateKeyPair('ec', { namedCurve: crv }))
                        return privat ? privateKey : publicKey
                    }

                    ;({ privateKey, publicKey } = await generateKeyPair('ec', {
                        namedCurve: crv,
                        publicKeyEncoding: { type: 'spki', format: 'pem' },
                        privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
                    }))

                    if (privat) {
                        return createPrivateKey(privateKey)
                    } else {
                        return createPublicKey(publicKey)
                    }
                }

                static generateSync(crv = 'P-256', privat = true) {
                    if (!EC_CURVES.has(crv)) {
                        throw new errors.JOSENotSupported(
                            `unsupported EC key curve: ${crv}`
                        )
                    }

                    if (crv === secp256k1 && crv !== 'secp256k1') {
                        crv = 'secp256k1'
                    }

                    let privateKey, publicKey

                    if (keyObjectSupported) {
                        ;({ privateKey, publicKey } = generateKeyPairSync(
                            'ec',
                            { namedCurve: crv }
                        ))
                        return privat ? privateKey : publicKey
                    }

                    ;({ privateKey, publicKey } = generateKeyPairSync('ec', {
                        namedCurve: crv,
                        publicKeyEncoding: { type: 'spki', format: 'pem' },
                        privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
                    }))

                    if (privat) {
                        return createPrivateKey(privateKey)
                    } else {
                        return createPublicKey(publicKey)
                    }
                }
            }

            module.exports = ECKey

            /***/
        },

        /***/ '3L66': /***/ function(module, exports, __webpack_require__) {
            var isArrayLike = __webpack_require__('MMmD'),
                isObjectLike = __webpack_require__('ExA7')

            /**
             * This method is like `_.isArrayLike` except that it also checks if `value`
             * is an object.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an array-like object,
             *  else `false`.
             * @example
             *
             * _.isArrayLikeObject([1, 2, 3]);
             * // => true
             *
             * _.isArrayLikeObject(document.body.children);
             * // => true
             *
             * _.isArrayLikeObject('abc');
             * // => false
             *
             * _.isArrayLikeObject(_.noop);
             * // => false
             */
            function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value)
            }

            module.exports = isArrayLikeObject

            /***/
        },

        /***/ '3OWR': /***/ function(module, exports, __webpack_require__) {
            var assignValue = __webpack_require__('MrPd'),
                copyObject = __webpack_require__('juv8'),
                createAssigner = __webpack_require__('LsHQ'),
                isArrayLike = __webpack_require__('MMmD'),
                isPrototype = __webpack_require__('6sVZ'),
                keys = __webpack_require__('7GkX')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Assigns own enumerable string keyed properties of source objects to the
             * destination object. Source objects are applied from left to right.
             * Subsequent sources overwrite property assignments of previous sources.
             *
             * **Note:** This method mutates `object` and is loosely based on
             * [`Object.assign`](https://mdn.io/Object/assign).
             *
             * @static
             * @memberOf _
             * @since 0.10.0
             * @category Object
             * @param {Object} object The destination object.
             * @param {...Object} [sources] The source objects.
             * @returns {Object} Returns `object`.
             * @see _.assignIn
             * @example
             *
             * function Foo() {
             *   this.a = 1;
             * }
             *
             * function Bar() {
             *   this.c = 3;
             * }
             *
             * Foo.prototype.b = 2;
             * Bar.prototype.d = 4;
             *
             * _.assign({ 'a': 0 }, new Foo, new Bar);
             * // => { 'a': 1, 'c': 3 }
             */
            var assign = createAssigner(function(object, source) {
                if (isPrototype(source) || isArrayLike(source)) {
                    copyObject(source, keys(source), object)
                    return
                }
                for (var key in source) {
                    if (hasOwnProperty.call(source, key)) {
                        assignValue(object, key, source[key])
                    }
                }
            })

            module.exports = assign

            /***/
        },

        /***/ '3SI8': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /* eslint no-proto: 0 */
            module.exports =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array
                    ? setProtoOf
                    : mixinProperties)

            function setProtoOf(obj, proto) {
                obj.__proto__ = proto
                return obj
            }

            function mixinProperties(obj, proto) {
                for (var prop in proto) {
                    if (!obj.hasOwnProperty(prop)) {
                        obj[prop] = proto[prop]
                    }
                }
                return obj
            }

            /***/
        },

        /***/ '3WX/': /***/ function(module, exports, __webpack_require__) {
            var baseIteratee = __webpack_require__('ut/Y'),
                negate = __webpack_require__('oKwy'),
                pickBy = __webpack_require__('d8FT')

            /**
             * The opposite of `_.pickBy`; this method creates an object composed of
             * the own and inherited enumerable string keyed properties of `object` that
             * `predicate` doesn't return truthy for. The predicate is invoked with two
             * arguments: (value, key).
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Object
             * @param {Object} object The source object.
             * @param {Function} [predicate=_.identity] The function invoked per property.
             * @returns {Object} Returns the new object.
             * @example
             *
             * var object = { 'a': 1, 'b': '2', 'c': 3 };
             *
             * _.omitBy(object, _.isNumber);
             * // => { 'b': '2' }
             */
            function omitBy(object, predicate) {
                return pickBy(object, negate(baseIteratee(predicate)))
            }

            module.exports = omitBy

            /***/
        },

        /***/ '3Zki': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(input) {
                if (!input) {
                    return ''
                }

                let escaped = ''

                for (let i = 0; i < input.length; ++i) {
                    const charCode = input.charCodeAt(i)

                    if (internals.isSafe(charCode)) {
                        escaped += input[i]
                    } else {
                        escaped += internals.escapeHtmlChar(charCode)
                    }
                }

                return escaped
            }

            internals.escapeHtmlChar = function(charCode) {
                const namedEscape = internals.namedHtml[charCode]
                if (typeof namedEscape !== 'undefined') {
                    return namedEscape
                }

                if (charCode >= 256) {
                    return '&#' + charCode + ';'
                }

                const hexValue = charCode.toString(16).padStart(2, '0')
                return `&#x${hexValue};`
            }

            internals.isSafe = function(charCode) {
                return typeof internals.safeCharCodes[charCode] !== 'undefined'
            }

            internals.namedHtml = {
                '38': '&amp;',
                '60': '&lt;',
                '62': '&gt;',
                '34': '&quot;',
                '160': '&nbsp;',
                '162': '&cent;',
                '163': '&pound;',
                '164': '&curren;',
                '169': '&copy;',
                '174': '&reg;'
            }

            internals.safeCharCodes = (function() {
                const safe = {}

                for (let i = 32; i < 123; ++i) {
                    if (
                        i >= 97 || // a-z
                        (i >= 65 && i <= 90) || // A-Z
                        (i >= 48 && i <= 57) || // 0-9
                        i === 32 || // space
                        i === 46 || // .
                        i === 44 || // ,
                        i === 45 || // -
                        i === 58 || // :
                        i === 95
                    ) {
                        // _

                        safe[i] = null
                    }
                }

                return safe
            })()

            /***/
        },

        /***/ '4/ic': /***/ function(module, exports, __webpack_require__) {
            var baseGet = __webpack_require__('ZWtO')

            /**
             * A specialized version of `baseProperty` which supports deep paths.
             *
             * @private
             * @param {Array|string} path The path of the property to get.
             * @returns {Function} Returns the new accessor function.
             */
            function basePropertyDeep(path) {
                return function(object) {
                    return baseGet(object, path)
                }
            }

            module.exports = basePropertyDeep

            /***/
        },

        /***/ '44Ds': /***/ function(module, exports, __webpack_require__) {
            var MapCache = __webpack_require__('e4Nc')

            /** Error message constants. */
            var FUNC_ERROR_TEXT = 'Expected a function'

            /**
             * Creates a function that memoizes the result of `func`. If `resolver` is
             * provided, it determines the cache key for storing the result based on the
             * arguments provided to the memoized function. By default, the first argument
             * provided to the memoized function is used as the map cache key. The `func`
             * is invoked with the `this` binding of the memoized function.
             *
             * **Note:** The cache is exposed as the `cache` property on the memoized
             * function. Its creation may be customized by replacing the `_.memoize.Cache`
             * constructor with one whose instances implement the
             * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
             * method interface of `clear`, `delete`, `get`, `has`, and `set`.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Function
             * @param {Function} func The function to have its output memoized.
             * @param {Function} [resolver] The function to resolve the cache key.
             * @returns {Function} Returns the new memoized function.
             * @example
             *
             * var object = { 'a': 1, 'b': 2 };
             * var other = { 'c': 3, 'd': 4 };
             *
             * var values = _.memoize(_.values);
             * values(object);
             * // => [1, 2]
             *
             * values(other);
             * // => [3, 4]
             *
             * object.a = 2;
             * values(object);
             * // => [1, 2]
             *
             * // Modify the result cache.
             * values.cache.set(object, ['a', 'b']);
             * values(object);
             * // => ['a', 'b']
             *
             * // Replace `_.memoize.Cache`.
             * _.memoize.Cache = WeakMap;
             */
            function memoize(func, resolver) {
                if (
                    typeof func != 'function' ||
                    (resolver != null && typeof resolver != 'function')
                ) {
                    throw new TypeError(FUNC_ERROR_TEXT)
                }
                var memoized = function() {
                    var args = arguments,
                        key = resolver ? resolver.apply(this, args) : args[0],
                        cache = memoized.cache

                    if (cache.has(key)) {
                        return cache.get(key)
                    }
                    var result = func.apply(this, args)
                    memoized.cache = cache.set(key, result) || cache
                    return result
                }
                memoized.cache = new (memoize.Cache || MapCache)()
                return memoized
            }

            // Expose `MapCache`.
            memoize.Cache = MapCache

            module.exports = memoize

            /***/
        },

        /***/ '4DFU': /***/ function(module, exports, __webpack_require__) {
            var baseMerge = __webpack_require__('+Qka'),
                isObject = __webpack_require__('GoyQ')

            /**
             * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
             * objects into destination objects that are passed thru.
             *
             * @private
             * @param {*} objValue The destination value.
             * @param {*} srcValue The source value.
             * @param {string} key The key of the property to merge.
             * @param {Object} object The parent object of `objValue`.
             * @param {Object} source The parent object of `srcValue`.
             * @param {Object} [stack] Tracks traversed source values and their merged
             *  counterparts.
             * @returns {*} Returns the value to assign.
             */
            function customDefaultsMerge(
                objValue,
                srcValue,
                key,
                object,
                source,
                stack
            ) {
                if (isObject(objValue) && isObject(srcValue)) {
                    // Recursively merge objects and arrays (susceptible to call stack limits).
                    stack.set(srcValue, objValue)
                    baseMerge(
                        objValue,
                        srcValue,
                        undefined,
                        customDefaultsMerge,
                        stack
                    )
                    stack['delete'](srcValue)
                }
                return objValue
            }

            module.exports = customDefaultsMerge

            /***/
        },

        /***/ '4UWp': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const EventEmitter = __webpack_require__('/0p4')
            const getStream = __webpack_require__('NFjz')
            const is = __webpack_require__('6mOv')
            const PCancelable = __webpack_require__('Qxd3')
            const requestAsEventEmitter = __webpack_require__('y/nk')
            const { HTTPError, ParseError, ReadError } = __webpack_require__(
                '9Fi5'
            )
            const { options: mergeOptions } = __webpack_require__('AW8e')
            const { reNormalize } = __webpack_require__('whhB')

            const asPromise = options => {
                const proxy = new EventEmitter()

                const promise = new PCancelable((resolve, reject, onCancel) => {
                    const emitter = requestAsEventEmitter(options)

                    onCancel(emitter.abort)

                    emitter.on('response', async response => {
                        proxy.emit('response', response)

                        const stream = is.null(options.encoding)
                            ? getStream.buffer(response)
                            : getStream(response, options)

                        let data
                        try {
                            data = await stream
                        } catch (error) {
                            reject(new ReadError(error, options))
                            return
                        }

                        const limitStatusCode = options.followRedirect
                            ? 299
                            : 399

                        response.body = data

                        try {
                            for (const [index, hook] of Object.entries(
                                options.hooks.afterResponse
                            )) {
                                // eslint-disable-next-line no-await-in-loop
                                response = await hook(
                                    response,
                                    updatedOptions => {
                                        updatedOptions = reNormalize(
                                            mergeOptions(options, {
                                                ...updatedOptions,
                                                retry: 0,
                                                throwHttpErrors: false
                                            })
                                        )

                                        // Remove any further hooks for that request, because we we'll call them anyway.
                                        // The loop continues. We don't want duplicates (asPromise recursion).
                                        updatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(
                                            0,
                                            index
                                        )

                                        return asPromise(updatedOptions)
                                    }
                                )
                            }
                        } catch (error) {
                            reject(error)
                            return
                        }

                        const { statusCode } = response

                        if (options.json && response.body) {
                            try {
                                response.body = JSON.parse(response.body)
                            } catch (error) {
                                if (statusCode >= 200 && statusCode < 300) {
                                    const parseError = new ParseError(
                                        error,
                                        statusCode,
                                        options,
                                        data
                                    )
                                    Object.defineProperty(
                                        parseError,
                                        'response',
                                        { value: response }
                                    )
                                    reject(parseError)
                                    return
                                }
                            }
                        }

                        if (
                            statusCode !== 304 &&
                            (statusCode < 200 || statusCode > limitStatusCode)
                        ) {
                            const error = new HTTPError(response, options)
                            Object.defineProperty(error, 'response', {
                                value: response
                            })
                            if (emitter.retry(error) === false) {
                                if (options.throwHttpErrors) {
                                    reject(error)
                                    return
                                }

                                resolve(response)
                            }

                            return
                        }

                        resolve(response)
                    })

                    emitter.once('error', reject)
                    ;[
                        'request',
                        'redirect',
                        'uploadProgress',
                        'downloadProgress'
                    ].forEach(event =>
                        emitter.on(event, (...args) =>
                            proxy.emit(event, ...args)
                        )
                    )
                })

                promise.on = (name, fn) => {
                    proxy.on(name, fn)
                    return promise
                }

                return promise
            }

            module.exports = asPromise

            /***/
        },

        /***/ '4kuk': /***/ function(module, exports, __webpack_require__) {
            var hashClear = __webpack_require__('SfRM'),
                hashDelete = __webpack_require__('Hvzi'),
                hashGet = __webpack_require__('u8Dt'),
                hashHas = __webpack_require__('ekgI'),
                hashSet = __webpack_require__('JSQU')

            /**
             * Creates a hash object.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function Hash(entries) {
                var index = -1,
                    length = entries == null ? 0 : entries.length

                this.clear()
                while (++index < length) {
                    var entry = entries[index]
                    this.set(entry[0], entry[1])
                }
            }

            // Add methods to `Hash`.
            Hash.prototype.clear = hashClear
            Hash.prototype['delete'] = hashDelete
            Hash.prototype.get = hashGet
            Hash.prototype.has = hashHas
            Hash.prototype.set = hashSet

            module.exports = Hash

            /***/
        },

        /***/ '4sDh': /***/ function(module, exports, __webpack_require__) {
            var castPath = __webpack_require__('4uTw'),
                isArguments = __webpack_require__('03A+'),
                isArray = __webpack_require__('Z0cm'),
                isIndex = __webpack_require__('wJg7'),
                isLength = __webpack_require__('shjB'),
                toKey = __webpack_require__('9Nap')

            /**
             * Checks if `path` exists on `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Array|string} path The path to check.
             * @param {Function} hasFunc The function to check properties.
             * @returns {boolean} Returns `true` if `path` exists, else `false`.
             */
            function hasPath(object, path, hasFunc) {
                path = castPath(path, object)

                var index = -1,
                    length = path.length,
                    result = false

                while (++index < length) {
                    var key = toKey(path[index])
                    if (!(result = object != null && hasFunc(object, key))) {
                        break
                    }
                    object = object[key]
                }
                if (result || ++index != length) {
                    return result
                }
                length = object == null ? 0 : object.length
                return (
                    !!length &&
                    isLength(length) &&
                    isIndex(key, length) &&
                    (isArray(object) || isArguments(object))
                )
            }

            module.exports = hasPath

            /***/
        },

        /***/ '4uTw': /***/ function(module, exports, __webpack_require__) {
            var isArray = __webpack_require__('Z0cm'),
                isKey = __webpack_require__('9ggG'),
                stringToPath = __webpack_require__('GNiM'),
                toString = __webpack_require__('dt0z')

            /**
             * Casts `value` to a path array if it's not one.
             *
             * @private
             * @param {*} value The value to inspect.
             * @param {Object} [object] The object to query keys on.
             * @returns {Array} Returns the cast property path array.
             */
            function castPath(value, object) {
                if (isArray(value)) {
                    return value
                }
                return isKey(value, object)
                    ? [value]
                    : stringToPath(toString(value))
            }

            module.exports = castPath

            /***/
        },

        /***/ '5K7Z': /***/ function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__('93I4')
            module.exports = function(it) {
                if (!isObject(it)) throw TypeError(it + ' is not an object!')
                return it
            }

            /***/
        },

        /***/ '5T2Y': /***/ function(module, exports) {
            // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
            var global = (module.exports =
                typeof window != 'undefined' && window.Math == Math
                    ? window
                    : typeof self != 'undefined' && self.Math == Math
                    ? self
                    : // eslint-disable-next-line no-new-func
                      Function('return this')())
            if (typeof __g == 'number') __g = global // eslint-disable-line no-undef

            /***/
        },

        /***/ '5Tg0': /***/ function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */ ;(function(module) {
                var root = __webpack_require__('Kz5y')

                /** Detect free variable `exports`. */
                var freeExports =
                    true && exports && !exports.nodeType && exports

                /** Detect free variable `module`. */
                var freeModule =
                    freeExports &&
                    typeof module == 'object' &&
                    module &&
                    !module.nodeType &&
                    module

                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports =
                    freeModule && freeModule.exports === freeExports

                /** Built-in value references. */
                var Buffer = moduleExports ? root.Buffer : undefined,
                    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined

                /**
                 * Creates a clone of  `buffer`.
                 *
                 * @private
                 * @param {Buffer} buffer The buffer to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Buffer} Returns the cloned buffer.
                 */
                function cloneBuffer(buffer, isDeep) {
                    if (isDeep) {
                        return buffer.slice()
                    }
                    var length = buffer.length,
                        result = allocUnsafe
                            ? allocUnsafe(length)
                            : new buffer.constructor(length)

                    buffer.copy(result)
                    return result
                }

                module.exports = cloneBuffer

                /* WEBPACK VAR INJECTION */
            }.call(this, __webpack_require__('YuTi')(module)))

            /***/
        },

        /***/ '5WRQ': /***/ function(module) {
            module.exports = JSON.parse(
                '[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]'
            )

            /***/
        },

        /***/ '5ZhA': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Assert = __webpack_require__('GlC0')
            const Clone = __webpack_require__('qnp3')
            const Utils = __webpack_require__('O0PD')

            const internals = {}

            module.exports = internals.merge = function(
                target,
                source,
                options
            ) {
                Assert(
                    target && typeof target === 'object',
                    'Invalid target value: must be an object'
                )
                Assert(
                    source === null ||
                        source === undefined ||
                        typeof source === 'object',
                    'Invalid source value: must be null, undefined, or an object'
                )

                if (!source) {
                    return target
                }

                options = Object.assign(
                    { nullOverride: true, mergeArrays: true },
                    options
                )

                if (Array.isArray(source)) {
                    Assert(
                        Array.isArray(target),
                        'Cannot merge array onto an object'
                    )
                    if (!options.mergeArrays) {
                        target.length = 0 // Must not change target assignment
                    }

                    for (let i = 0; i < source.length; ++i) {
                        target.push(
                            Clone(source[i], { symbols: options.symbols })
                        )
                    }

                    return target
                }

                const keys = Utils.keys(source, options)
                for (let i = 0; i < keys.length; ++i) {
                    const key = keys[i]
                    if (
                        key === '__proto__' ||
                        !Object.prototype.propertyIsEnumerable.call(source, key)
                    ) {
                        continue
                    }

                    const value = source[key]
                    if (value && typeof value === 'object') {
                        if (
                            !target[key] ||
                            typeof target[key] !== 'object' ||
                            Array.isArray(target[key]) !==
                                Array.isArray(value) ||
                            value instanceof Date ||
                            (Buffer && Buffer.isBuffer(value)) || // $lab:coverage:ignore$
                            value instanceof RegExp
                        ) {
                            target[key] = Clone(value, {
                                symbols: options.symbols
                            })
                        } else {
                            internals.merge(target[key], value, options)
                        }
                    } else {
                        if (value !== null && value !== undefined) {
                            // Explicit to preserve empty strings

                            target[key] = value
                        } else if (options.nullOverride) {
                            target[key] = value
                        }
                    }
                }

                return target
            }

            /***/
        },

        /***/ '5fWB': /***/ function(module, exports, __webpack_require__) {
            const { createSign, createVerify } = __webpack_require__('PJMN')

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const resolveNodeAlg = __webpack_require__('uGJc')
            const { asInput } = __webpack_require__('1ALl')

            const sign = (nodeAlg, { [KEYOBJECT]: keyObject }, payload) => {
                return createSign(nodeAlg)
                    .update(payload)
                    .sign(asInput(keyObject, false))
            }

            const verify = (
                nodeAlg,
                { [KEYOBJECT]: keyObject },
                payload,
                signature
            ) => {
                return createVerify(nodeAlg)
                    .update(payload)
                    .verify(asInput(keyObject, true), signature)
            }

            const LENGTHS = {
                RS256: 0,
                RS384: 624,
                RS512: 752
            }

            module.exports = (JWA, JWK) => {
                ;['RS256', 'RS384', 'RS512'].forEach(jwaAlg => {
                    const nodeAlg = resolveNodeAlg(jwaAlg)
                    JWA.sign.set(jwaAlg, sign.bind(undefined, nodeAlg))
                    JWA.verify.set(jwaAlg, verify.bind(undefined, nodeAlg))
                    JWK.RSA.sign[jwaAlg] = key =>
                        key.private && JWK.RSA.verify[jwaAlg](key)
                    JWK.RSA.verify[jwaAlg] = key =>
                        (key.use === 'sig' || key.use === undefined) &&
                        key.length >= LENGTHS[jwaAlg]
                })
            }

            /***/
        },

        /***/ '5kZ8': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {
                suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
            }

            exports.parse = function(text, reviver, options) {
                // Normalize arguments

                if (!options) {
                    if (reviver && typeof reviver === 'object') {
                        options = reviver
                        reviver = undefined
                    } else {
                        options = {}
                    }
                }

                // Parse normally, allowing exceptions

                const obj = JSON.parse(text, reviver)

                // options.protoAction: 'error' (default) / 'remove' / 'ignore'

                if (options.protoAction === 'ignore') {
                    return obj
                }

                // Ignore null and non-objects

                if (!obj || typeof obj !== 'object') {
                    return obj
                }

                // Check original string for potential exploit

                if (!text.match(internals.suspectRx)) {
                    return obj
                }

                // Scan result for proto keys

                exports.scan(obj, options)

                return obj
            }

            exports.scan = function(obj, options) {
                options = options || {}

                let next = [obj]

                while (next.length) {
                    const nodes = next
                    next = []

                    for (const node of nodes) {
                        if (
                            Object.prototype.hasOwnProperty.call(
                                node,
                                '__proto__'
                            )
                        ) {
                            // Avoid calling node.hasOwnProperty directly
                            if (options.protoAction !== 'remove') {
                                throw new SyntaxError(
                                    'Object contains forbidden prototype property'
                                )
                            }

                            delete node.__proto__
                        }

                        for (const key in node) {
                            const value = node[key]
                            if (value && typeof value === 'object') {
                                next.push(node[key])
                            }
                        }
                    }
                }
            }

            exports.safeParse = function(text, reviver) {
                try {
                    return exports.parse(text, reviver)
                } catch (ignoreError) {
                    return null
                }
            }

            /***/
        },

        /***/ '5sMl': /***/ function(module, exports, __webpack_require__) {
            const crypto = __webpack_require__('PJMN')

            const [major, minor] = process.version
                .substr(1)
                .split('.')
                .map(x => parseInt(x, 10))
            const xofOutputLength = major > 12 || (major === 12 && minor >= 8)
            const shake256 =
                xofOutputLength && crypto.getHashes().includes('shake256')

            module.exports = shake256

            /***/
        },

        /***/ '5sNo': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const cookies_1 = __webpack_require__('gKi1')
            function callbackHandler(settings, clientProvider, sessionStore) {
                return (req, res, options) =>
                    tslib_1.__awaiter(this, void 0, void 0, function*() {
                        if (!res) {
                            throw new Error('Response is not available')
                        }
                        if (!req) {
                            throw new Error('Request is not available')
                        }
                        // Parse the cookies.
                        const cookies = cookies_1.parseCookies(req)
                        // Require that we have a state.
                        const state = cookies['a0:state']
                        if (!state) {
                            throw new Error(
                                'Invalid request, an initial state could not be found'
                            )
                        }
                        // Execute the code exchange
                        const client = yield clientProvider()
                        const params = client.callbackParams(req)
                        const tokenSet = yield client.callback(
                            settings.redirectUri,
                            params,
                            {
                                state
                            }
                        )
                        // Get the claims without any OIDC specific claim.
                        const claims = tokenSet.claims()
                        if (claims.aud) {
                            delete claims.aud
                        }
                        if (claims.exp) {
                            delete claims.exp
                        }
                        if (claims.iat) {
                            delete claims.iat
                        }
                        if (claims.iss) {
                            delete claims.iss
                        }
                        // Create the session.
                        const session = {
                            user: Object.assign({}, claims),
                            idToken: tokenSet.id_token,
                            accessToken: tokenSet.access_token,
                            refreshToken: tokenSet.refresh_token,
                            createdAt: Date.now()
                        }
                        // Create the session.
                        yield sessionStore.save(req, res, session)
                        // Redirect to the homepage.
                        const redirectTo =
                            (options && options.redirectTo) || '/'
                        res.writeHead(302, {
                            Location: redirectTo
                        })
                        res.end()
                    })
            }
            exports.default = callbackHandler
            //# sourceMappingURL=callback.js.map

            /***/
        },

        /***/ '6I+L': /***/ function(module, exports, __webpack_require__) {
            const isObject = __webpack_require__('kF1/')
            const secs = __webpack_require__('o156')
            const epoch = __webpack_require__('F4x3')
            const getKey = __webpack_require__('oGTz')
            const JWS = __webpack_require__('sR+5')

            const isString = __webpack_require__('mRrf').isString.bind(
                undefined,
                TypeError
            )

            const validateOptions = options => {
                if (typeof options.iat !== 'boolean') {
                    throw new TypeError('options.iat must be a boolean')
                }

                if (typeof options.kid !== 'boolean') {
                    throw new TypeError('options.kid must be a boolean')
                }

                isString(options.subject, 'options.subject')
                isString(options.issuer, 'options.issuer')

                if (
                    options.audience !== undefined &&
                    (typeof options.audience !== 'string' ||
                        !options.audience) &&
                        (!Array.isArray(options.audience) ||
                            options.audience.length === 0 ||
                            options.audience.some(
                                a => !a || typeof a !== 'string'
                            ))
                ) {
                    throw new TypeError(
                        'options.audience must be a string or an array of strings'
                    )
                }

                if (!isObject(options.header)) {
                    throw new TypeError('options.header must be an object')
                }

                isString(options.algorithm, 'options.algorithm')
                isString(options.expiresIn, 'options.expiresIn')
                isString(options.notBefore, 'options.notBefore')
                isString(options.jti, 'options.jti')
                isString(options.nonce, 'options.nonce')

                if (
                    options.now !== undefined &&
                    (!(options.now instanceof Date) || !options.now.getTime())
                ) {
                    throw new TypeError(
                        'options.now must be a valid Date object'
                    )
                }
            }

            module.exports = (payload, key, options = {}) => {
                if (!isObject(options)) {
                    throw new TypeError('options must be an object')
                }

                const {
                    algorithm,
                    audience,
                    expiresIn,
                    header = {},
                    iat = true,
                    issuer,
                    jti,
                    kid = true,
                    nonce,
                    notBefore,
                    subject,
                    now
                } = options

                validateOptions({
                    algorithm,
                    audience,
                    expiresIn,
                    header,
                    iat,
                    issuer,
                    jti,
                    kid,
                    nonce,
                    notBefore,
                    now,
                    subject
                })

                if (!isObject(payload)) {
                    throw new TypeError('payload must be an object')
                }

                let unix
                if (expiresIn || notBefore || iat) {
                    unix = epoch(now || new Date())
                }

                payload = {
                    ...payload,
                    sub: subject || payload.sub,
                    aud: audience || payload.aud,
                    iss: issuer || payload.iss,
                    jti: jti || payload.jti,
                    iat: iat ? unix : payload.iat,
                    nonce: nonce || payload.nonce,
                    exp: expiresIn ? unix + secs(expiresIn) : payload.exp,
                    nbf: notBefore ? unix + secs(notBefore) : payload.nbf
                }

                key = getKey(key)

                let includeKid

                if (typeof options.kid === 'boolean') {
                    includeKid = kid
                } else {
                    includeKid = !key.secret
                }

                return JWS.sign(JSON.stringify(payload), key, {
                    ...header,
                    alg: algorithm || header.alg,
                    kid: includeKid ? key.kid : header.kid
                })
            }

            /***/
        },

        /***/ '6U0C': /***/ function(
            module,
            __webpack_exports__,
            __webpack_require__
        ) {
            'use strict'
            __webpack_require__.r(__webpack_exports__)
            /* harmony import */ var _lib_auth0__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                '2NqA'
            )

            const login = async (req, res) => {
                try {
                    await _lib_auth0__WEBPACK_IMPORTED_MODULE_0__[
                        /* default */ 'a'
                    ].handleLogin(req, res)
                } catch (error) {
                    res.status(error.status || 500).end(error.message)
                }
            }

            /* harmony default export */ __webpack_exports__['default'] = login

            /***/
        },

        /***/ '6gLP': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            function createDummyBrowserInstance() {
                return {
                    isBrowser: true,
                    handleLogin: () => {
                        throw new Error(
                            'The handleLogin method can only be used from the server side'
                        )
                    },
                    handleLogout: () => {
                        throw new Error(
                            'The handleLogout method can only be used from the server side'
                        )
                    },
                    handleCallback: () => {
                        throw new Error(
                            'The handleCallback method can only be used from the server side'
                        )
                    },
                    handleProfile: () => {
                        throw new Error(
                            'The handleProfile method can only be used from the server side'
                        )
                    },
                    getSession: () => {
                        throw new Error(
                            'The getSession method can only be used from the server side'
                        )
                    },
                    requireAuthentication: () => () => {
                        throw new Error(
                            'The requireAuthentication method can only be used from the server side'
                        )
                    }
                }
            }
            exports.default = createDummyBrowserInstance
            //# sourceMappingURL=instance.browser.js.map

            /***/
        },

        /***/ '6mOv': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /// <reference lib="es2016"/>
            /// <reference lib="es2017.sharedmemory"/>
            /// <reference lib="esnext.asynciterable"/>
            /// <reference lib="dom"/>
            Object.defineProperty(exports, '__esModule', { value: true })
            // TODO: Use the `URL` global when targeting Node.js 10
            // tslint:disable-next-line
            const URLGlobal =
                typeof URL === 'undefined'
                    ? __webpack_require__('bzos').URL
                    : URL
            const toString = Object.prototype.toString
            const isOfType = type => value => typeof value === type
            const isBuffer = input =>
                !is.nullOrUndefined(input) &&
                !is.nullOrUndefined(input.constructor) &&
                is.function_(input.constructor.isBuffer) &&
                input.constructor.isBuffer(input)
            const getObjectType = value => {
                const objectName = toString.call(value).slice(8, -1)
                if (objectName) {
                    return objectName
                }
                return null
            }
            const isObjectOfType = type => value =>
                getObjectType(value) === type
            function is(value) {
                switch (value) {
                    case null:
                        return 'null' /* null */
                    case true:
                    case false:
                        return 'boolean' /* boolean */
                    default:
                }
                switch (typeof value) {
                    case 'undefined':
                        return 'undefined' /* undefined */
                    case 'string':
                        return 'string' /* string */
                    case 'number':
                        return 'number' /* number */
                    case 'symbol':
                        return 'symbol' /* symbol */
                    default:
                }
                if (is.function_(value)) {
                    return 'Function' /* Function */
                }
                if (is.observable(value)) {
                    return 'Observable' /* Observable */
                }
                if (Array.isArray(value)) {
                    return 'Array' /* Array */
                }
                if (isBuffer(value)) {
                    return 'Buffer' /* Buffer */
                }
                const tagType = getObjectType(value)
                if (tagType) {
                    return tagType
                }
                if (
                    value instanceof String ||
                    value instanceof Boolean ||
                    value instanceof Number
                ) {
                    throw new TypeError(
                        "Please don't use object wrappers for primitive types"
                    )
                }
                return 'Object' /* Object */
            }
            ;(function(is) {
                // tslint:disable-next-line:strict-type-predicates
                const isObject = value => typeof value === 'object'
                // tslint:disable:variable-name
                is.undefined = isOfType('undefined')
                is.string = isOfType('string')
                is.number = isOfType('number')
                is.function_ = isOfType('function')
                // tslint:disable-next-line:strict-type-predicates
                is.null_ = value => value === null
                is.class_ = value =>
                    is.function_(value) && value.toString().startsWith('class ')
                is.boolean = value => value === true || value === false
                is.symbol = isOfType('symbol')
                // tslint:enable:variable-name
                is.numericString = value =>
                    is.string(value) &&
                    value.length > 0 &&
                    !Number.isNaN(Number(value))
                is.array = Array.isArray
                is.buffer = isBuffer
                is.nullOrUndefined = value =>
                    is.null_(value) || is.undefined(value)
                is.object = value =>
                    !is.nullOrUndefined(value) &&
                    (is.function_(value) || isObject(value))
                is.iterable = value =>
                    !is.nullOrUndefined(value) &&
                    is.function_(value[Symbol.iterator])
                is.asyncIterable = value =>
                    !is.nullOrUndefined(value) &&
                    is.function_(value[Symbol.asyncIterator])
                is.generator = value =>
                    is.iterable(value) &&
                    is.function_(value.next) &&
                    is.function_(value.throw)
                is.nativePromise = value =>
                    isObjectOfType('Promise' /* Promise */)(value)
                const hasPromiseAPI = value =>
                    !is.null_(value) &&
                    isObject(value) &&
                    is.function_(value.then) &&
                    is.function_(value.catch)
                is.promise = value =>
                    is.nativePromise(value) || hasPromiseAPI(value)
                is.generatorFunction = isObjectOfType(
                    'GeneratorFunction' /* GeneratorFunction */
                )
                is.asyncFunction = isObjectOfType(
                    'AsyncFunction' /* AsyncFunction */
                )
                is.boundFunction = value =>
                    is.function_(value) && !value.hasOwnProperty('prototype')
                is.regExp = isObjectOfType('RegExp' /* RegExp */)
                is.date = isObjectOfType('Date' /* Date */)
                is.error = isObjectOfType('Error' /* Error */)
                is.map = value => isObjectOfType('Map' /* Map */)(value)
                is.set = value => isObjectOfType('Set' /* Set */)(value)
                is.weakMap = value =>
                    isObjectOfType('WeakMap' /* WeakMap */)(value)
                is.weakSet = value =>
                    isObjectOfType('WeakSet' /* WeakSet */)(value)
                is.int8Array = isObjectOfType('Int8Array' /* Int8Array */)
                is.uint8Array = isObjectOfType('Uint8Array' /* Uint8Array */)
                is.uint8ClampedArray = isObjectOfType(
                    'Uint8ClampedArray' /* Uint8ClampedArray */
                )
                is.int16Array = isObjectOfType('Int16Array' /* Int16Array */)
                is.uint16Array = isObjectOfType('Uint16Array' /* Uint16Array */)
                is.int32Array = isObjectOfType('Int32Array' /* Int32Array */)
                is.uint32Array = isObjectOfType('Uint32Array' /* Uint32Array */)
                is.float32Array = isObjectOfType(
                    'Float32Array' /* Float32Array */
                )
                is.float64Array = isObjectOfType(
                    'Float64Array' /* Float64Array */
                )
                is.arrayBuffer = isObjectOfType('ArrayBuffer' /* ArrayBuffer */)
                is.sharedArrayBuffer = isObjectOfType(
                    'SharedArrayBuffer' /* SharedArrayBuffer */
                )
                is.dataView = isObjectOfType('DataView' /* DataView */)
                is.directInstanceOf = (instance, klass) =>
                    Object.getPrototypeOf(instance) === klass.prototype
                is.urlInstance = value => isObjectOfType('URL' /* URL */)(value)
                is.urlString = value => {
                    if (!is.string(value)) {
                        return false
                    }
                    try {
                        new URLGlobal(value) // tslint:disable-line no-unused-expression
                        return true
                    } catch (_a) {
                        return false
                    }
                }
                is.truthy = value => Boolean(value)
                is.falsy = value => !value
                is.nan = value => Number.isNaN(value)
                const primitiveTypes = new Set([
                    'undefined',
                    'string',
                    'number',
                    'boolean',
                    'symbol'
                ])
                is.primitive = value =>
                    is.null_(value) || primitiveTypes.has(typeof value)
                is.integer = value => Number.isInteger(value)
                is.safeInteger = value => Number.isSafeInteger(value)
                is.plainObject = value => {
                    // From: https://github.com/sindresorhus/is-plain-obj/blob/master/index.js
                    let prototype
                    return (
                        getObjectType(value) === 'Object' /* Object */ &&
                        ((prototype = Object.getPrototypeOf(value)),
                        prototype === null || // tslint:disable-line:ban-comma-operator
                            prototype === Object.getPrototypeOf({}))
                    )
                }
                const typedArrayTypes = new Set([
                    'Int8Array' /* Int8Array */,
                    'Uint8Array' /* Uint8Array */,
                    'Uint8ClampedArray' /* Uint8ClampedArray */,
                    'Int16Array' /* Int16Array */,
                    'Uint16Array' /* Uint16Array */,
                    'Int32Array' /* Int32Array */,
                    'Uint32Array' /* Uint32Array */,
                    'Float32Array' /* Float32Array */,
                    'Float64Array' /* Float64Array */
                ])
                is.typedArray = value => {
                    const objectType = getObjectType(value)
                    if (objectType === null) {
                        return false
                    }
                    return typedArrayTypes.has(objectType)
                }
                const isValidLength = value =>
                    is.safeInteger(value) && value > -1
                is.arrayLike = value =>
                    !is.nullOrUndefined(value) &&
                    !is.function_(value) &&
                    isValidLength(value.length)
                is.inRange = (value, range) => {
                    if (is.number(range)) {
                        return (
                            value >= Math.min(0, range) &&
                            value <= Math.max(range, 0)
                        )
                    }
                    if (is.array(range) && range.length === 2) {
                        return (
                            value >= Math.min(...range) &&
                            value <= Math.max(...range)
                        )
                    }
                    throw new TypeError(
                        `Invalid range: ${JSON.stringify(range)}`
                    )
                }
                const NODE_TYPE_ELEMENT = 1
                const DOM_PROPERTIES_TO_CHECK = [
                    'innerHTML',
                    'ownerDocument',
                    'style',
                    'attributes',
                    'nodeValue'
                ]
                is.domElement = value =>
                    is.object(value) &&
                    value.nodeType === NODE_TYPE_ELEMENT &&
                    is.string(value.nodeName) &&
                    !is.plainObject(value) &&
                    DOM_PROPERTIES_TO_CHECK.every(property => property in value)
                is.observable = value => {
                    if (!value) {
                        return false
                    }
                    if (
                        value[Symbol.observable] &&
                        value === value[Symbol.observable]()
                    ) {
                        return true
                    }
                    if (
                        value['@@observable'] &&
                        value === value['@@observable']()
                    ) {
                        return true
                    }
                    return false
                }
                is.nodeStream = value =>
                    !is.nullOrUndefined(value) &&
                    isObject(value) &&
                    is.function_(value.pipe) &&
                    !is.observable(value)
                is.infinite = value => value === Infinity || value === -Infinity
                const isAbsoluteMod2 = rem => value =>
                    is.integer(value) && Math.abs(value % 2) === rem
                is.even = isAbsoluteMod2(0)
                is.odd = isAbsoluteMod2(1)
                const isWhiteSpaceString = value =>
                    is.string(value) && /\S/.test(value) === false
                is.emptyArray = value => is.array(value) && value.length === 0
                is.nonEmptyArray = value => is.array(value) && value.length > 0
                is.emptyString = value => is.string(value) && value.length === 0
                is.nonEmptyString = value =>
                    is.string(value) && value.length > 0
                is.emptyStringOrWhitespace = value =>
                    is.emptyString(value) || isWhiteSpaceString(value)
                is.emptyObject = value =>
                    is.object(value) &&
                    !is.map(value) &&
                    !is.set(value) &&
                    Object.keys(value).length === 0
                is.nonEmptyObject = value =>
                    is.object(value) &&
                    !is.map(value) &&
                    !is.set(value) &&
                    Object.keys(value).length > 0
                is.emptySet = value => is.set(value) && value.size === 0
                is.nonEmptySet = value => is.set(value) && value.size > 0
                is.emptyMap = value => is.map(value) && value.size === 0
                is.nonEmptyMap = value => is.map(value) && value.size > 0
                const predicateOnArray = (method, predicate, values) => {
                    if (is.function_(predicate) === false) {
                        throw new TypeError(
                            `Invalid predicate: ${JSON.stringify(predicate)}`
                        )
                    }
                    if (values.length === 0) {
                        throw new TypeError('Invalid number of values')
                    }
                    return method.call(values, predicate)
                }
                // tslint:disable variable-name
                is.any = (predicate, ...values) =>
                    predicateOnArray(Array.prototype.some, predicate, values)
                is.all = (predicate, ...values) =>
                    predicateOnArray(Array.prototype.every, predicate, values)
                // tslint:enable variable-name
            })(is || (is = {}))
            // Some few keywords are reserved, but we'll populate them for Node.js users
            // See https://github.com/Microsoft/TypeScript/issues/2536
            Object.defineProperties(is, {
                class: {
                    value: is.class_
                },
                function: {
                    value: is.function_
                },
                null: {
                    value: is.null_
                }
            })
            exports.default = is
            // For CommonJS default export support
            module.exports = is
            module.exports.default = is
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ '6sVZ': /***/ function(module, exports) {
            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /**
             * Checks if `value` is likely a prototype object.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
             */
            function isPrototype(value) {
                var Ctor = value && value.constructor,
                    proto =
                        (typeof Ctor == 'function' && Ctor.prototype) ||
                        objectProto

                return value === proto
            }

            module.exports = isPrototype

            /***/
        },

        /***/ '711d': /***/ function(module, exports) {
            /**
             * The base implementation of `_.property` without support for deep paths.
             *
             * @private
             * @param {string} key The key of the property to get.
             * @returns {Function} Returns the new accessor function.
             */
            function baseProperty(key) {
                return function(object) {
                    return object == null ? undefined : object[key]
                }
            }

            module.exports = baseProperty

            /***/
        },

        /***/ '77Zs': /***/ function(module, exports, __webpack_require__) {
            var ListCache = __webpack_require__('Xi7e')

            /**
             * Removes all key-value entries from the stack.
             *
             * @private
             * @name clear
             * @memberOf Stack
             */
            function stackClear() {
                this.__data__ = new ListCache()
                this.size = 0
            }

            module.exports = stackClear

            /***/
        },

        /***/ '781u': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Assert = __webpack_require__('GlC0')
            const DeepEqual = __webpack_require__('Cl1u')
            const EscapeRegex = __webpack_require__('zosA')
            const Utils = __webpack_require__('O0PD')

            const internals = {}

            module.exports = function(ref, values, options = {}) {
                // options: { deep, once, only, part, symbols }

                /*
        string -> string(s)
        array -> item(s)
        object -> key(s)
        object -> object (key:value)
    */

                if (typeof values !== 'object') {
                    values = [values]
                }

                Assert(
                    !Array.isArray(values) || values.length,
                    'Values array cannot be empty'
                )

                // String

                if (typeof ref === 'string') {
                    return internals.string(ref, values, options)
                }

                // Array

                if (Array.isArray(ref)) {
                    return internals.array(ref, values, options)
                }

                // Object

                Assert(
                    typeof ref === 'object',
                    'Reference must be string or an object'
                )
                return internals.object(ref, values, options)
            }

            internals.array = function(ref, values, options) {
                if (!Array.isArray(values)) {
                    values = [values]
                }

                if (!ref.length) {
                    return false
                }

                if (
                    options.only &&
                    options.once &&
                    ref.length !== values.length
                ) {
                    return false
                }

                let compare

                // Map values

                const map = new Map()
                for (const value of values) {
                    if (!options.deep || !value || typeof value !== 'object') {
                        const existing = map.get(value)
                        if (existing) {
                            ++existing.allowed
                        } else {
                            map.set(value, { allowed: 1, hits: 0 })
                        }
                    } else {
                        compare = compare || internals.compare(options)

                        let found = false
                        for (const [key, existing] of map.entries()) {
                            if (compare(key, value)) {
                                ++existing.allowed
                                found = true
                                break
                            }
                        }

                        if (!found) {
                            map.set(value, { allowed: 1, hits: 0 })
                        }
                    }
                }

                // Lookup values

                let hits = 0
                for (const item of ref) {
                    let match
                    if (!options.deep || !item || typeof item !== 'object') {
                        match = map.get(item)
                    } else {
                        for (const [key, existing] of map.entries()) {
                            if (compare(key, item)) {
                                match = existing
                                break
                            }
                        }
                    }

                    if (match) {
                        ++match.hits
                        ++hits

                        if (options.once && match.hits > match.allowed) {
                            return false
                        }
                    }
                }

                // Validate results

                if (options.only && hits !== ref.length) {
                    return false
                }

                for (const match of map.values()) {
                    if (match.hits === match.allowed) {
                        continue
                    }

                    if (match.hits < match.allowed && !options.part) {
                        return false
                    }
                }

                return !!hits
            }

            internals.object = function(ref, values, options) {
                Assert(
                    options.once === undefined,
                    'Cannot use option once with object'
                )

                const keys = Utils.keys(ref, options)
                if (!keys.length) {
                    return false
                }

                // Keys list

                if (Array.isArray(values)) {
                    return internals.array(keys, values, options)
                }

                // Key value pairs

                const symbols = Object.getOwnPropertySymbols(
                    values
                ).filter(sym => values.propertyIsEnumerable(sym))
                const targets = [...Object.keys(values), ...symbols]

                const compare = internals.compare(options)
                const set = new Set(targets)

                for (const key of keys) {
                    if (!set.has(key)) {
                        if (options.only) {
                            return false
                        }

                        continue
                    }

                    if (!compare(values[key], ref[key])) {
                        return false
                    }

                    set.delete(key)
                }

                if (set.size) {
                    return options.part ? set.size < targets.length : false
                }

                return true
            }

            internals.string = function(ref, values, options) {
                // Empty string

                if (ref === '') {
                    return (
                        (values.length === 1 && values[0] === '') || // '' contains ''
                        (!options.once && !values.some(v => v !== ''))
                    ) // '' contains multiple '' if !once
                }

                // Map values

                const map = new Map()
                const patterns = []

                for (const value of values) {
                    Assert(
                        typeof value === 'string',
                        'Cannot compare string reference to non-string value'
                    )

                    if (value) {
                        const existing = map.get(value)
                        if (existing) {
                            ++existing.allowed
                        } else {
                            map.set(value, { allowed: 1, hits: 0 })
                            patterns.push(EscapeRegex(value))
                        }
                    } else if (options.once || options.only) {
                        return false
                    }
                }

                if (!patterns.length) {
                    // Non-empty string contains unlimited empty string
                    return true
                }

                // Match patterns

                const regex = new RegExp(`(${patterns.join('|')})`, 'g')
                const leftovers = ref.replace(regex, ($0, $1) => {
                    ++map.get($1).hits
                    return '' // Remove from string
                })

                // Validate results

                if (options.only && leftovers) {
                    return false
                }

                let any = false
                for (const match of map.values()) {
                    if (match.hits) {
                        any = true
                    }

                    if (match.hits === match.allowed) {
                        continue
                    }

                    if (match.hits < match.allowed && !options.part) {
                        return false
                    }

                    // match.hits > match.allowed

                    if (options.once) {
                        return false
                    }
                }

                return !!any
            }

            internals.compare = function(options) {
                if (!options.deep) {
                    return internals.shallow
                }

                const hasOnly = options.only !== undefined
                const hasPart = options.part !== undefined

                const flags = {
                    prototype: hasOnly
                        ? options.only
                        : hasPart
                        ? !options.part
                        : false,
                    part: hasOnly
                        ? !options.only
                        : hasPart
                        ? options.part
                        : false
                }

                return (a, b) => DeepEqual(a, b, flags)
            }

            internals.shallow = function(a, b) {
                return a === b
            }

            /***/
        },

        /***/ '7GkX': /***/ function(module, exports, __webpack_require__) {
            var arrayLikeKeys = __webpack_require__('b80T'),
                baseKeys = __webpack_require__('A90E'),
                isArrayLike = __webpack_require__('MMmD')

            /**
             * Creates an array of the own enumerable property names of `object`.
             *
             * **Note:** Non-object values are coerced to objects. See the
             * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
             * for more details.
             *
             * @static
             * @since 0.1.0
             * @memberOf _
             * @category Object
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             * @example
             *
             * function Foo() {
             *   this.a = 1;
             *   this.b = 2;
             * }
             *
             * Foo.prototype.c = 3;
             *
             * _.keys(new Foo);
             * // => ['a', 'b'] (iteration order is not guaranteed)
             *
             * _.keys('hi');
             * // => ['0', '1']
             */
            function keys(object) {
                return isArrayLike(object)
                    ? arrayLikeKeys(object)
                    : baseKeys(object)
            }

            module.exports = keys

            /***/
        },

        /***/ '7Ix3': /***/ function(module, exports) {
            /**
             * This function is like
             * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
             * except that it includes inherited enumerable properties.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             */
            function nativeKeysIn(object) {
                var result = []
                if (object != null) {
                    for (var key in Object(object)) {
                        result.push(key)
                    }
                }
                return result
            }

            module.exports = nativeKeysIn

            /***/
        },

        /***/ '7WL4': /***/ function(module, exports) {
            module.exports = require('https')

            /***/
        },

        /***/ '7fqy': /***/ function(module, exports) {
            /**
             * Converts `map` to its key-value pairs.
             *
             * @private
             * @param {Object} map The map to convert.
             * @returns {Array} Returns the key-value pairs.
             */
            function mapToArray(map) {
                var index = -1,
                    result = Array(map.size)

                map.forEach(function(value, key) {
                    result[++index] = [key, value]
                })
                return result
            }

            module.exports = mapToArray

            /***/
        },

        /***/ '7o4N': /***/ function(module, exports, __webpack_require__) {
            const base64url = __webpack_require__('Xab3')
            const errors = __webpack_require__('yt7c')

            module.exports = (token, { complete = false } = {}) => {
                if (typeof token !== 'string' || !token) {
                    throw new TypeError('JWT must be a string')
                }

                const {
                    0: header,
                    1: payload,
                    2: signature,
                    length
                } = token.split('.')

                if (length === 5) {
                    throw new TypeError('JWTs must be decrypted first')
                }

                if (length !== 3) {
                    throw new errors.JWTMalformed(
                        'JWTs must have three components'
                    )
                }

                try {
                    const result = {
                        header: base64url.JSON.decode(header),
                        payload: base64url.JSON.decode(payload),
                        signature
                    }

                    return complete ? result : result.payload
                } catch (err) {
                    throw new errors.JWTMalformed('JWT is malformed')
                }
            }

            /***/
        },

        /***/ '88Gu': /***/ function(module, exports) {
            /** Used to detect hot functions by number of calls within a span of milliseconds. */
            var HOT_COUNT = 800,
                HOT_SPAN = 16

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeNow = Date.now

            /**
             * Creates a function that'll short out and invoke `identity` instead
             * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
             * milliseconds.
             *
             * @private
             * @param {Function} func The function to restrict.
             * @returns {Function} Returns the new shortable function.
             */
            function shortOut(func) {
                var count = 0,
                    lastCalled = 0

                return function() {
                    var stamp = nativeNow(),
                        remaining = HOT_SPAN - (stamp - lastCalled)

                    lastCalled = stamp
                    if (remaining > 0) {
                        if (++count >= HOT_COUNT) {
                            return arguments[0]
                        }
                    } else {
                        count = 0
                    }
                    return func.apply(undefined, arguments)
                }
            }

            module.exports = shortOut

            /***/
        },

        /***/ '8kg+': /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * bytes
             * Copyright(c) 2012-2014 TJ Holowaychuk
             * Copyright(c) 2015 Jed Watson
             * MIT Licensed
             */

            /**
             * Module exports.
             * @public
             */

            module.exports = bytes
            module.exports.format = format
            module.exports.parse = parse

            /**
             * Module variables.
             * @private
             */

            var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g

            var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/

            var map = {
                b: 1,
                kb: 1 << 10,
                mb: 1 << 20,
                gb: 1 << 30,
                tb: Math.pow(1024, 4),
                pb: Math.pow(1024, 5)
            }

            var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i

            /**
             * Convert the given value in bytes into a string or parse to string to an integer in bytes.
             *
             * @param {string|number} value
             * @param {{
             *  case: [string],
             *  decimalPlaces: [number]
             *  fixedDecimals: [boolean]
             *  thousandsSeparator: [string]
             *  unitSeparator: [string]
             *  }} [options] bytes options.
             *
             * @returns {string|number|null}
             */

            function bytes(value, options) {
                if (typeof value === 'string') {
                    return parse(value)
                }

                if (typeof value === 'number') {
                    return format(value, options)
                }

                return null
            }

            /**
             * Format the given value in bytes into a string.
             *
             * If the value is negative, it is kept as such. If it is a float,
             * it is rounded.
             *
             * @param {number} value
             * @param {object} [options]
             * @param {number} [options.decimalPlaces=2]
             * @param {number} [options.fixedDecimals=false]
             * @param {string} [options.thousandsSeparator=]
             * @param {string} [options.unit=]
             * @param {string} [options.unitSeparator=]
             *
             * @returns {string|null}
             * @public
             */

            function format(value, options) {
                if (!Number.isFinite(value)) {
                    return null
                }

                var mag = Math.abs(value)
                var thousandsSeparator =
                    (options && options.thousandsSeparator) || ''
                var unitSeparator = (options && options.unitSeparator) || ''
                var decimalPlaces =
                    options && options.decimalPlaces !== undefined
                        ? options.decimalPlaces
                        : 2
                var fixedDecimals = Boolean(options && options.fixedDecimals)
                var unit = (options && options.unit) || ''

                if (!unit || !map[unit.toLowerCase()]) {
                    if (mag >= map.pb) {
                        unit = 'PB'
                    } else if (mag >= map.tb) {
                        unit = 'TB'
                    } else if (mag >= map.gb) {
                        unit = 'GB'
                    } else if (mag >= map.mb) {
                        unit = 'MB'
                    } else if (mag >= map.kb) {
                        unit = 'KB'
                    } else {
                        unit = 'B'
                    }
                }

                var val = value / map[unit.toLowerCase()]
                var str = val.toFixed(decimalPlaces)

                if (!fixedDecimals) {
                    str = str.replace(formatDecimalsRegExp, '$1')
                }

                if (thousandsSeparator) {
                    str = str.replace(formatThousandsRegExp, thousandsSeparator)
                }

                return str + unitSeparator + unit
            }

            /**
             * Parse the string value into an integer in bytes.
             *
             * If no unit is given, it is assumed the value is in bytes.
             *
             * @param {number|string} val
             *
             * @returns {number|null}
             * @public
             */

            function parse(val) {
                if (typeof val === 'number' && !isNaN(val)) {
                    return val
                }

                if (typeof val !== 'string') {
                    return null
                }

                // Test if the string passed is valid
                var results = parseRegExp.exec(val)
                var floatValue
                var unit = 'b'

                if (!results) {
                    // Nothing could be extracted from the given string
                    floatValue = parseInt(val, 10)
                    unit = 'b'
                } else {
                    // Retrieve the value and the unit
                    floatValue = parseFloat(results[1])
                    unit = results[4].toLowerCase()
                }

                return Math.floor(map[unit] * floatValue)
            }

            /***/
        },

        /***/ '8vrp': /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * depd
             * Copyright(c) 2015 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module exports.
             * @public
             */

            module.exports = eventListenerCount

            /**
             * Get the count of listeners on an event emitter of a specific type.
             */

            function eventListenerCount(emitter, type) {
                return emitter.listeners(type).length
            }

            /***/
        },

        /***/ '8xkj': /***/ function(module, exports) {
            module.exports = require('querystring')

            /***/
        },

        /***/ '93I4': /***/ function(module, exports) {
            module.exports = function(it) {
                return typeof it === 'object'
                    ? it !== null
                    : typeof it === 'function'
            }

            /***/
        },

        /***/ '9AeD': /***/ function(module, exports, __webpack_require__) {
            const Encrypt = __webpack_require__('/hdj')
            const decrypt = __webpack_require__('33Iv')

            // TODO: in v2.x swap unprotectedHeader and aad
            const single = (
                serialization,
                cleartext,
                key,
                protectedHeader,
                unprotectedHeader,
                aad
            ) => {
                return new Encrypt(
                    cleartext,
                    protectedHeader,
                    unprotectedHeader,
                    aad
                )
                    .recipient(key)
                    .encrypt(serialization)
            }

            module.exports.Encrypt = Encrypt
            module.exports.encrypt = single.bind(undefined, 'compact')
            module.exports.encrypt.flattened = single.bind(
                undefined,
                'flattened'
            )
            module.exports.encrypt.general = single.bind(undefined, 'general')

            module.exports.decrypt = decrypt

            /***/
        },

        /***/ '9Fi5': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const urlLib = __webpack_require__('bzos')
            const http = __webpack_require__('KEll')
            const PCancelable = __webpack_require__('Qxd3')
            const is = __webpack_require__('6mOv')

            class GotError extends Error {
                constructor(message, error, options) {
                    super(message)
                    Error.captureStackTrace(this, this.constructor)
                    this.name = 'GotError'

                    if (!is.undefined(error.code)) {
                        this.code = error.code
                    }

                    Object.assign(this, {
                        host: options.host,
                        hostname: options.hostname,
                        method: options.method,
                        path: options.path,
                        socketPath: options.socketPath,
                        protocol: options.protocol,
                        url: options.href,
                        gotOptions: options
                    })
                }
            }

            module.exports.GotError = GotError

            module.exports.CacheError = class extends GotError {
                constructor(error, options) {
                    super(error.message, error, options)
                    this.name = 'CacheError'
                }
            }

            module.exports.RequestError = class extends GotError {
                constructor(error, options) {
                    super(error.message, error, options)
                    this.name = 'RequestError'
                }
            }

            module.exports.ReadError = class extends GotError {
                constructor(error, options) {
                    super(error.message, error, options)
                    this.name = 'ReadError'
                }
            }

            module.exports.ParseError = class extends GotError {
                constructor(error, statusCode, options, data) {
                    super(
                        `${error.message} in "${urlLib.format(
                            options
                        )}": \n${data.slice(0, 77)}...`,
                        error,
                        options
                    )
                    this.name = 'ParseError'
                    this.statusCode = statusCode
                    this.statusMessage = http.STATUS_CODES[this.statusCode]
                }
            }

            module.exports.HTTPError = class extends GotError {
                constructor(response, options) {
                    const { statusCode } = response
                    let { statusMessage } = response

                    if (statusMessage) {
                        statusMessage = statusMessage
                            .replace(/\r?\n/g, ' ')
                            .trim()
                    } else {
                        statusMessage = http.STATUS_CODES[statusCode]
                    }

                    super(
                        `Response code ${statusCode} (${statusMessage})`,
                        {},
                        options
                    )
                    this.name = 'HTTPError'
                    this.statusCode = statusCode
                    this.statusMessage = statusMessage
                    this.headers = response.headers
                    this.body = response.body
                }
            }

            module.exports.MaxRedirectsError = class extends GotError {
                constructor(statusCode, redirectUrls, options) {
                    super('Redirected 10 times. Aborting.', {}, options)
                    this.name = 'MaxRedirectsError'
                    this.statusCode = statusCode
                    this.statusMessage = http.STATUS_CODES[this.statusCode]
                    this.redirectUrls = redirectUrls
                }
            }

            module.exports.UnsupportedProtocolError = class extends GotError {
                constructor(options) {
                    super(
                        `Unsupported protocol "${options.protocol}"`,
                        {},
                        options
                    )
                    this.name = 'UnsupportedProtocolError'
                }
            }

            module.exports.TimeoutError = class extends GotError {
                constructor(error, options) {
                    super(error.message, { code: 'ETIMEDOUT' }, options)
                    this.name = 'TimeoutError'
                    this.event = error.event
                }
            }

            module.exports.CancelError = PCancelable.CancelError

            /***/
        },

        /***/ '9Nap': /***/ function(module, exports, __webpack_require__) {
            var isSymbol = __webpack_require__('/9aa')

            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0

            /**
             * Converts `value` to a string key if it's not a string or symbol.
             *
             * @private
             * @param {*} value The value to inspect.
             * @returns {string|symbol} Returns the key.
             */
            function toKey(value) {
                if (typeof value == 'string' || isSymbol(value)) {
                    return value
                }
                var result = value + ''
                return result == '0' && 1 / value == -INFINITY ? '-0' : result
            }

            module.exports = toKey

            /***/
        },

        /***/ '9RKe': /***/ function(module, exports, __webpack_require__) {
            /*!
             * depd
             * Copyright(c) 2014-2017 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module dependencies.
             */

            var callSiteToString = __webpack_require__('/hDD').callSiteToString
            var eventListenerCount = __webpack_require__('/hDD')
                .eventListenerCount
            var relative = __webpack_require__('oyvS').relative

            /**
             * Module exports.
             */

            module.exports = depd

            /**
             * Get the path to base files on.
             */

            var basePath = process.cwd()

            /**
             * Determine if namespace is contained in the string.
             */

            function containsNamespace(str, namespace) {
                var vals = str.split(/[ ,]+/)
                var ns = String(namespace).toLowerCase()

                for (var i = 0; i < vals.length; i++) {
                    var val = vals[i]

                    // namespace contained
                    if (val && (val === '*' || val.toLowerCase() === ns)) {
                        return true
                    }
                }

                return false
            }

            /**
             * Convert a data descriptor to accessor descriptor.
             */

            function convertDataDescriptorToAccessor(obj, prop, message) {
                var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
                var value = descriptor.value

                descriptor.get = function getter() {
                    return value
                }

                if (descriptor.writable) {
                    descriptor.set = function setter(val) {
                        return (value = val)
                    }
                }

                delete descriptor.value
                delete descriptor.writable

                Object.defineProperty(obj, prop, descriptor)

                return descriptor
            }

            /**
             * Create arguments string to keep arity.
             */

            function createArgumentsString(arity) {
                var str = ''

                for (var i = 0; i < arity; i++) {
                    str += ', arg' + i
                }

                return str.substr(2)
            }

            /**
             * Create stack string from stack.
             */

            function createStackString(stack) {
                var str = this.name + ': ' + this.namespace

                if (this.message) {
                    str += ' deprecated ' + this.message
                }

                for (var i = 0; i < stack.length; i++) {
                    str += '\n    at ' + callSiteToString(stack[i])
                }

                return str
            }

            /**
             * Create deprecate for namespace in caller.
             */

            function depd(namespace) {
                if (!namespace) {
                    throw new TypeError('argument namespace is required')
                }

                var stack = getStack()
                var site = callSiteLocation(stack[1])
                var file = site[0]

                function deprecate(message) {
                    // call to self as log
                    log.call(deprecate, message)
                }

                deprecate._file = file
                deprecate._ignored = isignored(namespace)
                deprecate._namespace = namespace
                deprecate._traced = istraced(namespace)
                deprecate._warned = Object.create(null)

                deprecate.function = wrapfunction
                deprecate.property = wrapproperty

                return deprecate
            }

            /**
             * Determine if namespace is ignored.
             */

            function isignored(namespace) {
                /* istanbul ignore next: tested in a child processs */
                if (process.noDeprecation) {
                    // --no-deprecation support
                    return true
                }

                var str = process.env.NO_DEPRECATION || ''

                // namespace ignored
                return containsNamespace(str, namespace)
            }

            /**
             * Determine if namespace is traced.
             */

            function istraced(namespace) {
                /* istanbul ignore next: tested in a child processs */
                if (process.traceDeprecation) {
                    // --trace-deprecation support
                    return true
                }

                var str = process.env.TRACE_DEPRECATION || ''

                // namespace traced
                return containsNamespace(str, namespace)
            }

            /**
             * Display deprecation message.
             */

            function log(message, site) {
                var haslisteners =
                    eventListenerCount(process, 'deprecation') !== 0

                // abort early if no destination
                if (!haslisteners && this._ignored) {
                    return
                }

                var caller
                var callFile
                var callSite
                var depSite
                var i = 0
                var seen = false
                var stack = getStack()
                var file = this._file

                if (site) {
                    // provided site
                    depSite = site
                    callSite = callSiteLocation(stack[1])
                    callSite.name = depSite.name
                    file = callSite[0]
                } else {
                    // get call site
                    i = 2
                    depSite = callSiteLocation(stack[i])
                    callSite = depSite
                }

                // get caller of deprecated thing in relation to file
                for (; i < stack.length; i++) {
                    caller = callSiteLocation(stack[i])
                    callFile = caller[0]

                    if (callFile === file) {
                        seen = true
                    } else if (callFile === this._file) {
                        file = this._file
                    } else if (seen) {
                        break
                    }
                }

                var key = caller
                    ? depSite.join(':') + '__' + caller.join(':')
                    : undefined

                if (key !== undefined && key in this._warned) {
                    // already warned
                    return
                }

                this._warned[key] = true

                // generate automatic message from call site
                var msg = message
                if (!msg) {
                    msg =
                        callSite === depSite || !callSite.name
                            ? defaultMessage(depSite)
                            : defaultMessage(callSite)
                }

                // emit deprecation if listeners exist
                if (haslisteners) {
                    var err = DeprecationError(
                        this._namespace,
                        msg,
                        stack.slice(i)
                    )
                    process.emit('deprecation', err)
                    return
                }

                // format and write message
                var format = process.stderr.isTTY ? formatColor : formatPlain
                var output = format.call(this, msg, caller, stack.slice(i))
                process.stderr.write(output + '\n', 'utf8')
            }

            /**
             * Get call site location as array.
             */

            function callSiteLocation(callSite) {
                var file = callSite.getFileName() || '<anonymous>'
                var line = callSite.getLineNumber()
                var colm = callSite.getColumnNumber()

                if (callSite.isEval()) {
                    file = callSite.getEvalOrigin() + ', ' + file
                }

                var site = [file, line, colm]

                site.callSite = callSite
                site.name = callSite.getFunctionName()

                return site
            }

            /**
             * Generate a default message from the site.
             */

            function defaultMessage(site) {
                var callSite = site.callSite
                var funcName = site.name

                // make useful anonymous name
                if (!funcName) {
                    funcName = '<anonymous@' + formatLocation(site) + '>'
                }

                var context = callSite.getThis()
                var typeName = context && callSite.getTypeName()

                // ignore useless type name
                if (typeName === 'Object') {
                    typeName = undefined
                }

                // make useful type name
                if (typeName === 'Function') {
                    typeName = context.name || typeName
                }

                return typeName && callSite.getMethodName()
                    ? typeName + '.' + funcName
                    : funcName
            }

            /**
             * Format deprecation message without color.
             */

            function formatPlain(msg, caller, stack) {
                var timestamp = new Date().toUTCString()

                var formatted =
                    timestamp + ' ' + this._namespace + ' deprecated ' + msg

                // add stack trace
                if (this._traced) {
                    for (var i = 0; i < stack.length; i++) {
                        formatted += '\n    at ' + callSiteToString(stack[i])
                    }

                    return formatted
                }

                if (caller) {
                    formatted += ' at ' + formatLocation(caller)
                }

                return formatted
            }

            /**
             * Format deprecation message with color.
             */

            function formatColor(msg, caller, stack) {
                var formatted =
                    '\x1b[36;1m' +
                    this._namespace +
                    '\x1b[22;39m' + // bold cyan
                    ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
                    ' \x1b[0m' +
                    msg +
                    '\x1b[39m' // reset

                // add stack trace
                if (this._traced) {
                    for (var i = 0; i < stack.length; i++) {
                        formatted +=
                            '\n    \x1b[36mat ' +
                            callSiteToString(stack[i]) +
                            '\x1b[39m' // cyan
                    }

                    return formatted
                }

                if (caller) {
                    formatted +=
                        ' \x1b[36m' + formatLocation(caller) + '\x1b[39m' // cyan
                }

                return formatted
            }

            /**
             * Format call site location.
             */

            function formatLocation(callSite) {
                return (
                    relative(basePath, callSite[0]) +
                    ':' +
                    callSite[1] +
                    ':' +
                    callSite[2]
                )
            }

            /**
             * Get the stack as array of call sites.
             */

            function getStack() {
                var limit = Error.stackTraceLimit
                var obj = {}
                var prep = Error.prepareStackTrace

                Error.prepareStackTrace = prepareObjectStackTrace
                Error.stackTraceLimit = Math.max(10, limit)

                // capture the stack
                Error.captureStackTrace(obj)

                // slice this function off the top
                var stack = obj.stack.slice(1)

                Error.prepareStackTrace = prep
                Error.stackTraceLimit = limit

                return stack
            }

            /**
             * Capture call site stack from v8.
             */

            function prepareObjectStackTrace(obj, stack) {
                return stack
            }

            /**
             * Return a wrapped function in a deprecation message.
             */

            function wrapfunction(fn, message) {
                if (typeof fn !== 'function') {
                    throw new TypeError('argument fn must be a function')
                }

                var args = createArgumentsString(fn.length)
                var deprecate = this // eslint-disable-line no-unused-vars
                var stack = getStack()
                var site = callSiteLocation(stack[1])

                site.name = fn.name

                // eslint-disable-next-line no-eval
                var deprecatedfn = eval(
                    '(function (' +
                        args +
                        ') {\n' +
                        '"use strict"\n' +
                        'log.call(deprecate, message, site)\n' +
                        'return fn.apply(this, arguments)\n' +
                        '})'
                )

                return deprecatedfn
            }

            /**
             * Wrap property in a deprecation message.
             */

            function wrapproperty(obj, prop, message) {
                if (
                    !obj ||
                    (typeof obj !== 'object' && typeof obj !== 'function')
                ) {
                    throw new TypeError('argument obj must be object')
                }

                var descriptor = Object.getOwnPropertyDescriptor(obj, prop)

                if (!descriptor) {
                    throw new TypeError('must call property on owner object')
                }

                if (!descriptor.configurable) {
                    throw new TypeError('property must be configurable')
                }

                var deprecate = this
                var stack = getStack()
                var site = callSiteLocation(stack[1])

                // set site name
                site.name = prop

                // convert data descriptor
                if ('value' in descriptor) {
                    descriptor = convertDataDescriptorToAccessor(
                        obj,
                        prop,
                        message
                    )
                }

                var get = descriptor.get
                var set = descriptor.set

                // wrap getter
                if (typeof get === 'function') {
                    descriptor.get = function getter() {
                        log.call(deprecate, message, site)
                        return get.apply(this, arguments)
                    }
                }

                // wrap setter
                if (typeof set === 'function') {
                    descriptor.set = function setter() {
                        log.call(deprecate, message, site)
                        return set.apply(this, arguments)
                    }
                }

                Object.defineProperty(obj, prop, descriptor)
            }

            /**
             * Create DeprecationError for deprecation
             */

            function DeprecationError(namespace, message, stack) {
                var error = new Error()
                var stackString

                Object.defineProperty(error, 'constructor', {
                    value: DeprecationError
                })

                Object.defineProperty(error, 'message', {
                    configurable: true,
                    enumerable: false,
                    value: message,
                    writable: true
                })

                Object.defineProperty(error, 'name', {
                    enumerable: false,
                    configurable: true,
                    value: 'DeprecationError',
                    writable: true
                })

                Object.defineProperty(error, 'namespace', {
                    configurable: true,
                    enumerable: false,
                    value: namespace,
                    writable: true
                })

                Object.defineProperty(error, 'stack', {
                    configurable: true,
                    enumerable: false,
                    get: function() {
                        if (stackString !== undefined) {
                            return stackString
                        }

                        // prepare stack trace
                        return (stackString = createStackString.call(
                            this,
                            stack
                        ))
                    },
                    set: function setter(val) {
                        stackString = val
                    }
                })

                return error
            }

            /***/
        },

        /***/ '9YuQ': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            function requireAuthentication(sessionStore) {
                return apiRoute => (req, res) =>
                    tslib_1.__awaiter(this, void 0, void 0, function*() {
                        if (!req) {
                            throw new Error('Request is not available')
                        }
                        if (!res) {
                            throw new Error('Response is not available')
                        }
                        const session = yield sessionStore.read(req)
                        if (!session || !session.user) {
                            res.status(401).json({
                                error: 'not_authenticated',
                                description:
                                    'The user does not have an active session or is not authenticated'
                            })
                            return
                        }
                        yield apiRoute(req, res)
                    })
            }
            exports.default = requireAuthentication
            //# sourceMappingURL=require-authentication.js.map

            /***/
        },

        /***/ '9ggG': /***/ function(module, exports, __webpack_require__) {
            var isArray = __webpack_require__('Z0cm'),
                isSymbol = __webpack_require__('/9aa')

            /** Used to match property names within property paths. */
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                reIsPlainProp = /^\w*$/

            /**
             * Checks if `value` is a property name and not a property path.
             *
             * @private
             * @param {*} value The value to check.
             * @param {Object} [object] The object to query keys on.
             * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
             */
            function isKey(value, object) {
                if (isArray(value)) {
                    return false
                }
                var type = typeof value
                if (
                    type == 'number' ||
                    type == 'symbol' ||
                    type == 'boolean' ||
                    value == null ||
                    isSymbol(value)
                ) {
                    return true
                }
                return (
                    reIsPlainProp.test(value) ||
                    !reIsDeepProp.test(value) ||
                    (object != null && value in Object(object))
                )
            }

            module.exports = isKey

            /***/
        },

        /***/ '9l6Z': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const url = __webpack_require__('bzos')
            const prependHttp = __webpack_require__('Tqu4')

            module.exports = (input, options) => {
                if (typeof input !== 'string') {
                    throw new TypeError(
                        `Expected \`url\` to be of type \`string\`, got \`${typeof input}\` instead.`
                    )
                }

                const finalUrl = prependHttp(
                    input,
                    Object.assign({ https: true }, options)
                )
                return url.parse(finalUrl)
            }

            /***/
        },

        /***/ '9ny7': /***/ function(module, exports, __webpack_require__) {
            const { define } = __webpack_require__('jUDV')
            const base = __webpack_require__('VZIC')
            const constants = __webpack_require__('h+i2')
            const decoders = __webpack_require__('zspo')
            const encoders = __webpack_require__('E8LI')

            module.exports = {
                base,
                constants,
                decoders,
                define,
                encoders
            }

            /***/
        },

        /***/ '9rVn': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const os = __webpack_require__('jle/')

            const extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/
            const pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/
            const homeDir =
                typeof os.homedir === 'undefined' ? '' : os.homedir()

            module.exports = (stack, options) => {
                options = Object.assign({ pretty: false }, options)

                return stack
                    .replace(/\\/g, '/')
                    .split('\n')
                    .filter(line => {
                        const pathMatches = line.match(extractPathRegex)
                        if (pathMatches === null || !pathMatches[1]) {
                            return true
                        }

                        const match = pathMatches[1]

                        // Electron
                        if (
                            match.includes(
                                '.app/Contents/Resources/electron.asar'
                            ) ||
                            match.includes(
                                '.app/Contents/Resources/default_app.asar'
                            )
                        ) {
                            return false
                        }

                        return !pathRegex.test(match)
                    })
                    .filter(line => line.trim() !== '')
                    .map(line => {
                        if (options.pretty) {
                            return line.replace(extractPathRegex, (m, p1) =>
                                m.replace(p1, p1.replace(homeDir, '~'))
                            )
                        }

                        return line
                    })
                    .join('\n')
            }

            /***/
        },

        /***/ A90E: /***/ function(module, exports, __webpack_require__) {
            var isPrototype = __webpack_require__('6sVZ'),
                nativeKeys = __webpack_require__('V6Ve')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             */
            function baseKeys(object) {
                if (!isPrototype(object)) {
                    return nativeKeys(object)
                }
                var result = []
                for (var key in Object(object)) {
                    if (
                        hasOwnProperty.call(object, key) &&
                        key != 'constructor'
                    ) {
                        result.push(key)
                    }
                }
                return result
            }

            module.exports = baseKeys

            /***/
        },

        /***/ A93I: /***/ function(module, exports, __webpack_require__) {
            /* eslint-disable max-classes-per-file */

            const { inspect, deprecate } = __webpack_require__('jK02')
            const url = __webpack_require__('bzos')

            const jose = __webpack_require__('xZSz')
            const pAny = __webpack_require__('lN8I')
            const LRU = __webpack_require__('HyWp')
            const objectHash = __webpack_require__('RIp3')

            const { RPError } = __webpack_require__('L71r')
            const getClient = __webpack_require__('HrFp')
            const registry = __webpack_require__('0Aai')
            const processResponse = __webpack_require__('WeJA')
            const webfingerNormalize = __webpack_require__('HpSD')
            const instance = __webpack_require__('0pkK')
            const request = __webpack_require__('UwMm')
            const { assertIssuerConfiguration } = __webpack_require__('N+si')
            const {
                ISSUER_DEFAULTS,
                OIDC_DISCOVERY,
                OAUTH2_DISCOVERY,
                WEBFINGER,
                REL,
                AAD_MULTITENANT_DISCOVERY
            } = __webpack_require__('TJm8')

            const AAD_MULTITENANT = Symbol('AAD_MULTITENANT')

            class Issuer {
                /**
                 * @name constructor
                 * @api public
                 */
                constructor(meta = {}) {
                    const aadIssValidation = meta[AAD_MULTITENANT]
                    delete meta[AAD_MULTITENANT]

                    ;['introspection', 'revocation'].forEach(endpoint => {
                        // if intro/revocation endpoint auth specific meta is missing use the token ones if they
                        // are defined
                        if (
                            meta[`${endpoint}_endpoint`] &&
                            meta[
                                `${endpoint}_endpoint_auth_methods_supported`
                            ] === undefined &&
                            meta[
                                `${endpoint}_endpoint_auth_signing_alg_values_supported`
                            ] === undefined
                        ) {
                            if (meta.token_endpoint_auth_methods_supported) {
                                meta[
                                    `${endpoint}_endpoint_auth_methods_supported`
                                ] = meta.token_endpoint_auth_methods_supported
                            }
                            if (
                                meta.token_endpoint_auth_signing_alg_values_supported
                            ) {
                                meta[
                                    `${endpoint}_endpoint_auth_signing_alg_values_supported`
                                ] =
                                    meta.token_endpoint_auth_signing_alg_values_supported
                            }
                        }
                    })

                    Object.entries(meta).forEach(([key, value]) => {
                        instance(this)
                            .get('metadata')
                            .set(key, value)
                        if (!this[key]) {
                            Object.defineProperty(this, key, {
                                get() {
                                    return instance(this)
                                        .get('metadata')
                                        .get(key)
                                },
                                enumerable: true
                            })
                        }
                    })

                    instance(this).set('cache', new LRU({ max: 100 }))

                    registry.set(this.issuer, this)

                    Object.defineProperty(this, 'Client', {
                        value: getClient(this, aadIssValidation)
                    })

                    Object.defineProperty(this, 'FAPIClient', {
                        value: class FAPIClient extends this.Client {}
                    })
                }

                /**
                 * @name keystore
                 * @api public
                 */
                async keystore(reload = false) {
                    assertIssuerConfiguration(this, 'jwks_uri')

                    const keystore = instance(this).get('keystore')
                    const cache = instance(this).get('cache')

                    if (reload || !keystore) {
                        cache.reset()
                        const response = await request.call(this, {
                            method: 'GET',
                            json: true,
                            url: this.jwks_uri
                        })
                        const jwks = processResponse(response)

                        const joseKeyStore = jose.JWKS.asKeyStore(jwks, {
                            ignoreErrors: true
                        })
                        cache.set('throttle', true, 60 * 1000)
                        instance(this).set('keystore', joseKeyStore)
                        return joseKeyStore
                    }

                    return keystore
                }

                /**
                 * @name queryKeyStore
                 * @api private
                 */
                async queryKeyStore(
                    { kid, kty, alg, use, key_ops: ops },
                    { allowMulti = false } = {}
                ) {
                    const cache = instance(this).get('cache')

                    const def = {
                        kid,
                        kty,
                        alg,
                        use,
                        key_ops: ops
                    }

                    const defHash = objectHash(def, {
                        algorithm: 'sha256',
                        ignoreUnknown: true,
                        unorderedArrays: true,
                        unorderedSets: true
                    })

                    // refresh keystore on every unknown key but also only upto once every minute
                    const freshJwksUri =
                        cache.get(defHash) || cache.get('throttle')

                    const keystore = await this.keystore(!freshJwksUri)
                    const keys = keystore.all(def)

                    if (keys.length === 0) {
                        throw new RPError({
                            printf: [
                                "no valid key found in issuer's jwks_uri for key parameters %j",
                                def
                            ],
                            jwks: keystore
                        })
                    }

                    if (!allowMulti && keys.length > 1 && !kid) {
                        throw new RPError({
                            printf: [
                                "multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case",
                                def
                            ],
                            jwks: keystore
                        })
                    }

                    cache.set(defHash, true)

                    return new jose.JWKS.KeyStore(keys)
                }

                /**
                 * @name metadata
                 * @api public
                 */
                get metadata() {
                    const copy = {}
                    instance(this)
                        .get('metadata')
                        .forEach((value, key) => {
                            copy[key] = value
                        })
                    return copy
                }

                /**
                 * @name webfinger
                 * @api public
                 */
                static async webfinger(input) {
                    const resource = webfingerNormalize(input)
                    const { host } = url.parse(resource)
                    const webfingerUrl = `https://${host}${WEBFINGER}`

                    const response = await request.call(this, {
                        method: 'GET',
                        url: webfingerUrl,
                        json: true,
                        query: { resource, rel: REL },
                        followRedirect: true
                    })
                    const body = processResponse(response)

                    const location =
                        Array.isArray(body.links) &&
                        body.links.find(
                            link =>
                                typeof link === 'object' &&
                                link.rel === REL &&
                                link.href
                        )

                    if (!location) {
                        throw new RPError({
                            message: 'no issuer found in webfinger response',
                            body
                        })
                    }

                    if (
                        typeof location.href !== 'string' ||
                        !location.href.startsWith('https://')
                    ) {
                        throw new RPError({
                            printf: [
                                'invalid issuer location %s',
                                location.href
                            ],
                            body
                        })
                    }

                    const expectedIssuer = location.href
                    if (registry.has(expectedIssuer)) {
                        return registry.get(expectedIssuer)
                    }

                    const issuer = await this.discover(expectedIssuer)

                    if (issuer.issuer !== expectedIssuer) {
                        registry.delete(issuer.issuer)
                        throw new RPError(
                            'discovered issuer mismatch, expected %s, got: %s',
                            expectedIssuer,
                            issuer.issuer
                        )
                    }
                    return issuer
                }

                /**
                 * @name discover
                 * @api public
                 */
                static async discover(uri) {
                    const parsed = url.parse(uri)

                    if (parsed.pathname.includes('/.well-known/')) {
                        const response = await request.call(this, {
                            method: 'GET',
                            json: true,
                            url: uri
                        })
                        const body = processResponse(response)
                        return new Issuer({
                            ...ISSUER_DEFAULTS,
                            ...body,
                            [AAD_MULTITENANT]: AAD_MULTITENANT_DISCOVERY.has(
                                uri
                            )
                        })
                    }

                    const uris = []
                    if (parsed.pathname === '/') {
                        uris.push(`${OAUTH2_DISCOVERY}`)
                    } else {
                        uris.push(`${OAUTH2_DISCOVERY}${parsed.pathname}`)
                    }
                    if (parsed.pathname.endsWith('/')) {
                        uris.push(
                            `${parsed.pathname}${OIDC_DISCOVERY.substring(1)}`
                        )
                    } else {
                        uris.push(`${parsed.pathname}${OIDC_DISCOVERY}`)
                    }

                    return pAny(
                        uris.map(async pathname => {
                            const wellKnownUri = url.format({
                                ...parsed,
                                pathname
                            })
                            const response = await request.call(this, {
                                method: 'GET',
                                json: true,
                                url: wellKnownUri
                            })
                            const body = processResponse(response)
                            return new Issuer({
                                ...ISSUER_DEFAULTS,
                                ...body,
                                [AAD_MULTITENANT]: AAD_MULTITENANT_DISCOVERY.has(
                                    wellKnownUri
                                )
                            })
                        })
                    )
                }

                /* istanbul ignore next */
                [inspect.custom]() {
                    return `${this.constructor.name} ${inspect(this.metadata, {
                        depth: Infinity,
                        colors: process.stdout.isTTY,
                        compact: false,
                        sorted: true
                    })}`
                }
            }

            /**
             * @name key
             * @api private
             */
            Issuer.prototype.key = deprecate(async function key(
                { kid, kty, alg, use, key_ops: ops },
                allowMulti = false
            ) {
                const cache = instance(this).get('cache')

                const def = {
                    kid,
                    kty,
                    alg,
                    use,
                    key_ops: ops
                }

                const defHash = objectHash(def, {
                    algorithm: 'sha256',
                    ignoreUnknown: true,
                    unorderedArrays: true,
                    unorderedSets: true
                })

                // refresh keystore on every unknown key but also only upto once every minute
                const freshJwksUri = cache.get(defHash) || cache.get('throttle')

                const keystore = await this.keystore(!freshJwksUri)
                const keys = keystore.all(def)

                if (keys.length === 0) {
                    throw new RPError({
                        printf: [
                            "no valid key found in issuer's jwks_uri for key parameters %j",
                            def
                        ],
                        jwks: keystore
                    })
                }
                if (!allowMulti) {
                    if (keys.length !== 1) {
                        throw new RPError({
                            printf: [
                                "multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case",
                                def
                            ],
                            jwks: keystore
                        })
                    }
                    cache.set(defHash, true)
                }
                return keys[0]
            },
            'issuer.key is not only a private API, it is also deprecated')

            module.exports = Issuer

            /***/
        },

        /***/ AP2z: /***/ function(module, exports, __webpack_require__) {
            var Symbol = __webpack_require__('nmnc')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var nativeObjectToString = objectProto.toString

            /** Built-in value references. */
            var symToStringTag = Symbol ? Symbol.toStringTag : undefined

            /**
             * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
             *
             * @private
             * @param {*} value The value to query.
             * @returns {string} Returns the raw `toStringTag`.
             */
            function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag),
                    tag = value[symToStringTag]

                try {
                    value[symToStringTag] = undefined
                    var unmasked = true
                } catch (e) {}

                var result = nativeObjectToString.call(value)
                if (unmasked) {
                    if (isOwn) {
                        value[symToStringTag] = tag
                    } else {
                        delete value[symToStringTag]
                    }
                }
                return result
            }

            module.exports = getRawTag

            /***/
        },

        /***/ ARPQ: /***/ function(module, exports, __webpack_require__) {
            const isObject = __webpack_require__('kF1/')
            let validateCrit = __webpack_require__('urXW')

            const { JWEInvalid } = __webpack_require__('yt7c')

            validateCrit = validateCrit.bind(undefined, JWEInvalid)

            const compactSerializer = (final, [recipient]) => {
                return `${final.protected}.${recipient.encrypted_key}.${final.iv}.${final.ciphertext}.${final.tag}`
            }
            compactSerializer.validate = (
                protectedHeader,
                unprotectedHeader,
                aad,
                { 0: { header }, length }
            ) => {
                if (length !== 1 || aad || unprotectedHeader || header) {
                    throw new JWEInvalid(
                        "JWE Compact Serialization doesn't support multiple recipients, JWE unprotected headers or AAD"
                    )
                }
                validateCrit(
                    protectedHeader,
                    unprotectedHeader,
                    protectedHeader ? protectedHeader.crit : undefined
                )
            }

            const flattenedSerializer = (final, [recipient]) => {
                const { header, encrypted_key: encryptedKey } = recipient

                return {
                    ...(final.protected
                        ? { protected: final.protected }
                        : undefined),
                    ...(final.unprotected
                        ? { unprotected: final.unprotected }
                        : undefined),
                    ...(header ? { header } : undefined),
                    ...(encryptedKey
                        ? { encrypted_key: encryptedKey }
                        : undefined),
                    ...(final.aad ? { aad: final.aad } : undefined),
                    iv: final.iv,
                    ciphertext: final.ciphertext,
                    tag: final.tag
                }
            }
            flattenedSerializer.validate = (
                protectedHeader,
                unprotectedHeader,
                aad,
                { 0: { header }, length }
            ) => {
                if (length !== 1) {
                    throw new JWEInvalid(
                        "Flattened JWE JSON Serialization doesn't support multiple recipients"
                    )
                }
                validateCrit(
                    protectedHeader,
                    { ...unprotectedHeader, ...header },
                    protectedHeader ? protectedHeader.crit : undefined
                )
            }

            const generalSerializer = (final, recipients) => {
                const result = {
                    ...(final.protected
                        ? { protected: final.protected }
                        : undefined),
                    ...(final.unprotected
                        ? { unprotected: final.unprotected }
                        : undefined),
                    recipients: recipients
                        .map(
                            ({
                                header,
                                encrypted_key: encryptedKey,
                                generatedHeader
                            }) => {
                                if (
                                    !header &&
                                    !encryptedKey &&
                                    !generatedHeader
                                ) {
                                    return false
                                }

                                return {
                                    ...(header || generatedHeader
                                        ? {
                                              header: {
                                                  ...header,
                                                  ...generatedHeader
                                              }
                                          }
                                        : undefined),
                                    ...(encryptedKey
                                        ? { encrypted_key: encryptedKey }
                                        : undefined)
                                }
                            }
                        )
                        .filter(Boolean),
                    ...(final.aad ? { aad: final.aad } : undefined),
                    iv: final.iv,
                    ciphertext: final.ciphertext,
                    tag: final.tag
                }

                if (!result.recipients.length) {
                    delete result.recipients
                }

                return result
            }
            generalSerializer.validate = (
                protectedHeader,
                unprotectedHeader,
                aad,
                recipients
            ) => {
                recipients.forEach(({ header }) => {
                    validateCrit(
                        protectedHeader,
                        { ...header, ...unprotectedHeader },
                        protectedHeader ? protectedHeader.crit : undefined
                    )
                })
            }

            const isJSON = input => {
                return (
                    isObject(input) &&
                    typeof input.ciphertext === 'string' &&
                    typeof input.iv === 'string' &&
                    typeof input.tag === 'string' &&
                    (input.unprotected === undefined ||
                        isObject(input.unprotected)) &&
                    (input.protected === undefined ||
                        typeof input.protected === 'string') &&
                    (input.aad === undefined || typeof input.aad === 'string')
                )
            }

            const isSingleRecipient = input => {
                return (
                    (input.encrypted_key === undefined ||
                        typeof input.encrypted_key === 'string') &&
                    (input.header === undefined || isObject(input.header))
                )
            }

            const isValidRecipient = recipient => {
                return (
                    isObject(recipient) &&
                    typeof recipient.encrypted_key === 'string' &&
                    (recipient.header === undefined ||
                        isObject(recipient.header))
                )
            }

            const isMultiRecipient = input => {
                if (
                    Array.isArray(input.recipients) &&
                    input.recipients.every(isValidRecipient)
                ) {
                    return true
                }

                return false
            }

            const detect = input => {
                if (
                    typeof input === 'string' &&
                    input.split('.').length === 5
                ) {
                    return 'compact'
                }

                if (isJSON(input)) {
                    if (isMultiRecipient(input)) {
                        return 'general'
                    }

                    if (isSingleRecipient(input)) {
                        return 'flattened'
                    }
                }

                throw new JWEInvalid('JWE malformed or invalid serialization')
            }

            module.exports = {
                compact: compactSerializer,
                flattened: flattenedSerializer,
                general: generalSerializer,
                detect
            }

            /***/
        },

        /***/ AW8e: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { URL } = __webpack_require__('bzos')
            const is = __webpack_require__('6mOv')
            const knownHookEvents = __webpack_require__('JlL/')

            const merge = (target, ...sources) => {
                for (const source of sources) {
                    for (const [key, sourceValue] of Object.entries(source)) {
                        if (is.undefined(sourceValue)) {
                            continue
                        }

                        const targetValue = target[key]
                        if (
                            is.urlInstance(targetValue) &&
                            (is.urlInstance(sourceValue) ||
                                is.string(sourceValue))
                        ) {
                            target[key] = new URL(sourceValue, targetValue)
                        } else if (is.plainObject(sourceValue)) {
                            if (is.plainObject(targetValue)) {
                                target[key] = merge(
                                    {},
                                    targetValue,
                                    sourceValue
                                )
                            } else {
                                target[key] = merge({}, sourceValue)
                            }
                        } else if (is.array(sourceValue)) {
                            target[key] = merge([], sourceValue)
                        } else {
                            target[key] = sourceValue
                        }
                    }
                }

                return target
            }

            const mergeOptions = (...sources) => {
                sources = sources.map(source => source || {})
                const merged = merge({}, ...sources)

                const hooks = {}
                for (const hook of knownHookEvents) {
                    hooks[hook] = []
                }

                for (const source of sources) {
                    if (source.hooks) {
                        for (const hook of knownHookEvents) {
                            hooks[hook] = hooks[hook].concat(source.hooks[hook])
                        }
                    }
                }

                merged.hooks = hooks

                return merged
            }

            const mergeInstances = (instances, methods) => {
                const handlers = instances.map(
                    instance => instance.defaults.handler
                )
                const size = instances.length - 1

                return {
                    methods,
                    options: mergeOptions(
                        ...instances.map(instance => instance.defaults.options)
                    ),
                    handler: (options, next) => {
                        let iteration = -1
                        const iterate = options =>
                            handlers[++iteration](
                                options,
                                iteration === size ? next : iterate
                            )

                        return iterate(options)
                    }
                }
            }

            module.exports = merge
            module.exports.options = mergeOptions
            module.exports.instances = mergeInstances

            /***/
        },

        /***/ AWHq: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const constants_1 = __webpack_require__('w7wo')
            const path_1 = __webpack_require__('oyvS')
            const require_1 = __webpack_require__('vv4h')
            function interopDefault(mod) {
                return mod.default || mod
            }
            exports.interopDefault = interopDefault
            async function loadComponents(
                distDir,
                buildId,
                pathname,
                serverless
            ) {
                if (serverless) {
                    const Component = await require_1.requirePage(
                        pathname,
                        distDir,
                        serverless
                    )
                    return {
                        Component,
                        pageConfig: Component.config || {},
                        unstable_getStaticProps:
                            Component.unstable_getStaticProps,
                        unstable_getStaticParams:
                            Component.unstable_getStaticParams
                    }
                }
                const documentPath = path_1.join(
                    distDir,
                    constants_1.SERVER_DIRECTORY,
                    constants_1.CLIENT_STATIC_FILES_PATH,
                    buildId,
                    'pages',
                    '_document'
                )
                const appPath = path_1.join(
                    distDir,
                    constants_1.SERVER_DIRECTORY,
                    constants_1.CLIENT_STATIC_FILES_PATH,
                    buildId,
                    'pages',
                    '_app'
                )
                const DocumentMod = __webpack_require__('PJv+')(documentPath)
                const { middleware: DocumentMiddleware } = DocumentMod
                const ComponentMod = require_1.requirePage(
                    pathname,
                    distDir,
                    serverless
                )
                const [
                    buildManifest,
                    reactLoadableManifest,
                    Component,
                    Document,
                    App
                ] = await Promise.all([
                    __webpack_require__('PJv+')(
                        path_1.join(distDir, constants_1.BUILD_MANIFEST)
                    ),
                    __webpack_require__('PJv+')(
                        path_1.join(
                            distDir,
                            constants_1.REACT_LOADABLE_MANIFEST
                        )
                    ),
                    interopDefault(ComponentMod),
                    interopDefault(DocumentMod),
                    interopDefault(__webpack_require__('PJv+')(appPath))
                ])
                return {
                    App,
                    Document,
                    Component,
                    buildManifest,
                    DocumentMiddleware,
                    reactLoadableManifest,
                    pageConfig: ComponentMod.config || {},
                    unstable_getStaticProps:
                        ComponentMod.unstable_getStaticProps,
                    unstable_getStaticParams:
                        ComponentMod.unstable_getStaticParams
                }
            }
            exports.loadComponents = loadComponents

            /***/
        },

        /***/ AfMj: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const pkg = __webpack_require__('tCGZ')
            const create = __webpack_require__('canG')

            const defaults = {
                options: {
                    retry: {
                        retries: 2,
                        methods: [
                            'GET',
                            'PUT',
                            'HEAD',
                            'DELETE',
                            'OPTIONS',
                            'TRACE'
                        ],
                        statusCodes: [408, 413, 429, 500, 502, 503, 504],
                        errorCodes: [
                            'ETIMEDOUT',
                            'ECONNRESET',
                            'EADDRINUSE',
                            'ECONNREFUSED',
                            'EPIPE',
                            'ENOTFOUND',
                            'ENETUNREACH',
                            'EAI_AGAIN'
                        ]
                    },
                    headers: {
                        'user-agent': `${pkg.name}/${pkg.version} (https://github.com/sindresorhus/got)`
                    },
                    hooks: {
                        beforeRequest: [],
                        beforeRedirect: [],
                        beforeRetry: [],
                        afterResponse: []
                    },
                    decompress: true,
                    throwHttpErrors: true,
                    followRedirect: true,
                    stream: false,
                    form: false,
                    json: false,
                    cache: false,
                    useElectronNet: false
                },
                mutableDefaults: false
            }

            const got = create(defaults)

            module.exports = got

            /***/
        },

        /***/ AlvL: /***/ function(module, exports) {
            const curves = new Set(['Ed25519'])

            if (!('electron' in process.versions)) {
                curves.add('Ed448')
                curves.add('X25519')
                curves.add('X448')
            }

            module.exports = curves

            /***/
        },

        /***/ 'B+OT': /***/ function(module, exports) {
            var hasOwnProperty = {}.hasOwnProperty
            module.exports = function(it, key) {
                return hasOwnProperty.call(it, key)
            }

            /***/
        },

        /***/ B8du: /***/ function(module, exports) {
            /**
             * This method returns `false`.
             *
             * @static
             * @memberOf _
             * @since 4.13.0
             * @category Util
             * @returns {boolean} Returns `false`.
             * @example
             *
             * _.times(2, _.stubFalse);
             * // => [false, false]
             */
            function stubFalse() {
                return false
            }

            module.exports = stubFalse

            /***/
        },

        /***/ BBt9: /***/ function(module, exports, __webpack_require__) {
            const { randomBytes } = __webpack_require__('PJMN')

            const { createSecretKey } = __webpack_require__('1ALl')
            const base64url = __webpack_require__('Xab3')
            const {
                THUMBPRINT_MATERIAL,
                PUBLIC_MEMBERS,
                PRIVATE_MEMBERS,
                KEY_MANAGEMENT_DECRYPT,
                KEY_MANAGEMENT_ENCRYPT,
                KEYOBJECT
            } = __webpack_require__('ehsS')

            const Key = __webpack_require__('//Cd')

            const OCT_PUBLIC = new Set()
            Object.freeze(OCT_PUBLIC)
            const OCT_PRIVATE = new Set(['k'])
            Object.freeze(OCT_PRIVATE)

            // Octet sequence Key Type
            class OctKey extends Key {
                constructor(...args) {
                    super(...args)
                    Object.defineProperties(this, {
                        kty: {
                            value: 'oct',
                            enumerable: true
                        },
                        length: {
                            value: this[KEYOBJECT]
                                ? this[KEYOBJECT].symmetricKeySize * 8
                                : undefined
                        },
                        k: {
                            enumerable: false,
                            get() {
                                if (this[KEYOBJECT]) {
                                    Object.defineProperty(this, 'k', {
                                        value: base64url.encodeBuffer(
                                            this[KEYOBJECT].export()
                                        ),
                                        configurable: false
                                    })
                                } else {
                                    Object.defineProperty(this, 'k', {
                                        value: undefined,
                                        configurable: false
                                    })
                                }

                                return this.k
                            },
                            configurable: true
                        }
                    })
                }

                static get [PUBLIC_MEMBERS]() {
                    return OCT_PUBLIC
                }

                static get [PRIVATE_MEMBERS]() {
                    return OCT_PRIVATE
                }

                // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special
                // JSON.stringify handling in V8
                [THUMBPRINT_MATERIAL]() {
                    if (!this[KEYOBJECT]) {
                        throw new TypeError(
                            'reference "oct" keys without "k" cannot have their thumbprint calculated'
                        )
                    }
                    return { k: this.k, kty: 'oct' }
                }

                [KEY_MANAGEMENT_ENCRYPT]() {
                    return new Set([
                        ...this.algorithms('wrapKey'),
                        ...this.algorithms('deriveKey')
                    ])
                }

                [KEY_MANAGEMENT_DECRYPT]() {
                    return this[KEY_MANAGEMENT_ENCRYPT]()
                }

                algorithms(...args) {
                    if (!this[KEYOBJECT]) {
                        return new Set()
                    }

                    return Key.prototype.algorithms.call(this, ...args)
                }

                static async generate(...args) {
                    return this.generateSync(...args)
                }

                static generateSync(len = 256, privat = true) {
                    if (!privat) {
                        throw new TypeError(
                            '"oct" keys cannot be generated as public'
                        )
                    }
                    if (!Number.isSafeInteger(len) || !len || len % 8 !== 0) {
                        throw new TypeError('invalid bit length')
                    }

                    return createSecretKey(randomBytes(len / 8))
                }
            }

            module.exports = OctKey

            /***/
        },

        /***/ BJV5: /***/ function(module, exports, __webpack_require__) {
            const {
                createCipheriv,
                createDecipheriv,
                getCiphers
            } = __webpack_require__('PJMN')

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const { JWEInvalid, JWEDecryptionFailed } = __webpack_require__(
                'yt7c'
            )
            const { asInput } = __webpack_require__('1ALl')

            const checkInput = function(size, iv, tag) {
                if (iv.length !== 12) {
                    throw new JWEInvalid('invalid iv')
                }
                if (arguments.length === 3) {
                    if (tag.length !== 16) {
                        throw new JWEInvalid('invalid tag')
                    }
                }
            }

            const encrypt = (
                size,
                { [KEYOBJECT]: keyObject },
                cleartext,
                { iv, aad = Buffer.alloc(0) }
            ) => {
                const key = asInput(keyObject, false)
                checkInput(size, iv)

                const cipher = createCipheriv(`aes-${size}-gcm`, key, iv, {
                    authTagLength: 16
                })
                cipher.setAAD(aad)

                const ciphertext = Buffer.concat([
                    cipher.update(cleartext),
                    cipher.final()
                ])
                const tag = cipher.getAuthTag()

                return { ciphertext, tag }
            }

            const decrypt = (
                size,
                { [KEYOBJECT]: keyObject },
                ciphertext,
                { iv, tag = Buffer.alloc(0), aad = Buffer.alloc(0) }
            ) => {
                const key = asInput(keyObject, false)
                checkInput(size, iv, tag)

                try {
                    const cipher = createDecipheriv(
                        `aes-${size}-gcm`,
                        key,
                        iv,
                        { authTagLength: 16 }
                    )
                    cipher.setAuthTag(tag)
                    cipher.setAAD(aad)

                    return Buffer.concat([
                        cipher.update(ciphertext),
                        cipher.final()
                    ])
                } catch (err) {
                    throw new JWEDecryptionFailed()
                }
            }

            module.exports = (JWA, JWK) => {
                ;['A128GCM', 'A192GCM', 'A256GCM'].forEach(jwaAlg => {
                    const size = parseInt(jwaAlg.substr(1, 3), 10)
                    if (getCiphers().includes(`aes-${size}-gcm`)) {
                        JWA.encrypt.set(jwaAlg, encrypt.bind(undefined, size))
                        JWA.decrypt.set(jwaAlg, decrypt.bind(undefined, size))
                        JWK.oct.encrypt[jwaAlg] = JWK.oct.decrypt[
                            jwaAlg
                        ] = key =>
                            (key.use === 'enc' || key.use === undefined) &&
                            key.length === size
                    }
                })
            }

            /***/
        },

        /***/ BOd6: /***/ function(module, exports, __webpack_require__) {
            const isObject = __webpack_require__('kF1/')
            const epoch = __webpack_require__('F4x3')
            const secs = __webpack_require__('o156')
            const getKey = __webpack_require__('oGTz')
            const { bare: verify } = __webpack_require__('ZXG7')
            const { JWTClaimInvalid, JWTExpired } = __webpack_require__('yt7c')

            const { isString, isNotString } = __webpack_require__('mRrf')
            const decode = __webpack_require__('7o4N')

            const isPayloadString = isString.bind(undefined, JWTClaimInvalid)
            const isOptionString = isString.bind(undefined, TypeError)

            const IDTOKEN = 'id_token'
            const LOGOUTTOKEN = 'logout_token'
            const ATJWT = 'at+JWT'

            const isTimestamp = (value, label, required = false) => {
                if (required && value === undefined) {
                    throw new JWTClaimInvalid(
                        `"${label}" claim is missing`,
                        label,
                        'missing'
                    )
                }

                if (
                    value !== undefined &&
                    (typeof value !== 'number' || !Number.isSafeInteger(value))
                ) {
                    throw new JWTClaimInvalid(
                        `"${label}" claim must be a unix timestamp`,
                        label,
                        'invalid'
                    )
                }
            }

            const isStringOrArrayOfStrings = (
                value,
                label,
                required = false
            ) => {
                if (required && value === undefined) {
                    throw new JWTClaimInvalid(
                        `"${label}" claim is missing`,
                        label,
                        'missing'
                    )
                }

                if (
                    value !== undefined &&
                    isNotString(value) && isNotArrayOfStrings(value)
                ) {
                    throw new JWTClaimInvalid(
                        `"${label}" claim must be a string or array of strings`,
                        label,
                        'invalid'
                    )
                }
            }

            const isNotArrayOfStrings = val =>
                !Array.isArray(val) || val.length === 0 || val.some(isNotString)

            const validateOptions = ({
                algorithms,
                audience,
                clockTolerance,
                complete = false,
                crit,
                ignoreExp = false,
                ignoreIat = false,
                ignoreNbf = false,
                issuer,
                jti,
                maxAuthAge,
                maxTokenAge,
                nonce,
                now = new Date(),
                profile,
                subject
            }) => {
                isOptionString(profile, 'options.profile')

                if (typeof complete !== 'boolean') {
                    throw new TypeError('options.complete must be a boolean')
                }

                if (typeof ignoreExp !== 'boolean') {
                    throw new TypeError('options.ignoreExp must be a boolean')
                }

                if (typeof ignoreNbf !== 'boolean') {
                    throw new TypeError('options.ignoreNbf must be a boolean')
                }

                if (typeof ignoreIat !== 'boolean') {
                    throw new TypeError('options.ignoreIat must be a boolean')
                }

                isOptionString(maxTokenAge, 'options.maxTokenAge')
                isOptionString(subject, 'options.subject')
                isOptionString(issuer, 'options.issuer')
                isOptionString(maxAuthAge, 'options.maxAuthAge')
                isOptionString(jti, 'options.jti')
                isOptionString(clockTolerance, 'options.clockTolerance')

                if (
                    audience !== undefined &&
                    isNotString(audience) && isNotArrayOfStrings(audience)
                ) {
                    throw new TypeError(
                        'options.audience must be a string or an array of strings'
                    )
                }

                if (
                    algorithms !== undefined &&
                    isNotArrayOfStrings(algorithms)
                ) {
                    throw new TypeError(
                        'options.algorithms must be an array of strings'
                    )
                }

                isOptionString(nonce, 'options.nonce')

                if (!(now instanceof Date) || !now.getTime()) {
                    throw new TypeError(
                        'options.now must be a valid Date object'
                    )
                }

                if (ignoreIat && maxTokenAge !== undefined) {
                    throw new TypeError(
                        'options.ignoreIat and options.maxTokenAge cannot used together'
                    )
                }

                if (crit !== undefined && isNotArrayOfStrings(crit)) {
                    throw new TypeError(
                        'options.crit must be an array of strings'
                    )
                }

                switch (profile) {
                    case IDTOKEN:
                        if (!issuer) {
                            throw new TypeError(
                                '"issuer" option is required to validate an ID Token'
                            )
                        }

                        if (!audience) {
                            throw new TypeError(
                                '"audience" option is required to validate an ID Token'
                            )
                        }

                        break
                    case ATJWT:
                        if (!issuer) {
                            throw new TypeError(
                                '"issuer" option is required to validate a JWT Access Token'
                            )
                        }

                        if (!audience) {
                            throw new TypeError(
                                '"audience" option is required to validate a JWT Access Token'
                            )
                        }

                        break
                    case LOGOUTTOKEN:
                        if (!issuer) {
                            throw new TypeError(
                                '"issuer" option is required to validate a Logout Token'
                            )
                        }

                        if (!audience) {
                            throw new TypeError(
                                '"audience" option is required to validate a Logout Token'
                            )
                        }

                        break
                    case undefined:
                        break
                    default:
                        throw new TypeError(
                            `unsupported options.profile value "${profile}"`
                        )
                }

                return {
                    algorithms,
                    audience,
                    clockTolerance,
                    complete,
                    crit,
                    ignoreExp,
                    ignoreIat,
                    ignoreNbf,
                    issuer,
                    jti,
                    maxAuthAge,
                    maxTokenAge,
                    nonce,
                    now,
                    profile,
                    subject
                }
            }

            const validateTypes = ({ header, payload }, profile, options) => {
                isPayloadString(
                    header.alg,
                    '"alg" header parameter',
                    'alg',
                    true
                )

                isTimestamp(
                    payload.iat,
                    'iat',
                    profile === IDTOKEN ||
                        profile === LOGOUTTOKEN ||
                        !!options.maxTokenAge
                )
                isTimestamp(
                    payload.exp,
                    'exp',
                    profile === IDTOKEN || profile === ATJWT
                )
                isTimestamp(
                    payload.auth_time,
                    'auth_time',
                    !!options.maxAuthAge
                )
                isTimestamp(payload.nbf, 'nbf')
                isPayloadString(
                    payload.jti,
                    '"jti" claim',
                    'jti',
                    profile === LOGOUTTOKEN || !!options.jti
                )
                isPayloadString(payload.acr, '"acr" claim', 'acr')
                isPayloadString(
                    payload.nonce,
                    '"nonce" claim',
                    'nonce',
                    !!options.nonce
                )
                isPayloadString(
                    payload.iss,
                    '"iss" claim',
                    'iss',
                    profile === IDTOKEN ||
                        profile === ATJWT ||
                        profile === LOGOUTTOKEN ||
                        !!options.issuer
                )
                isPayloadString(
                    payload.sub,
                    '"sub" claim',
                    'sub',
                    profile === IDTOKEN ||
                        profile === ATJWT ||
                        !!options.subject
                )
                isStringOrArrayOfStrings(
                    payload.aud,
                    'aud',
                    profile === IDTOKEN ||
                        profile === ATJWT ||
                        profile === LOGOUTTOKEN ||
                        !!options.audience
                )
                isPayloadString(
                    payload.azp,
                    '"azp" claim',
                    'azp',
                    profile === IDTOKEN &&
                        Array.isArray(payload.aud) &&
                        payload.aud.length > 1
                )
                isStringOrArrayOfStrings(payload.amr, 'amr')

                if (profile === ATJWT) {
                    isPayloadString(
                        payload.client_id,
                        '"client_id" claim',
                        'client_id',
                        true
                    )
                    isPayloadString(
                        header.typ,
                        '"typ" header parameter',
                        'typ',
                        true
                    )
                }

                if (profile === LOGOUTTOKEN) {
                    isPayloadString(payload.sid, '"sid" claim', 'sid')

                    if (!('sid' in payload) && !('sub' in payload)) {
                        throw new JWTClaimInvalid(
                            'either "sid" or "sub" (or both) claims must be present'
                        )
                    }

                    if ('nonce' in payload) {
                        throw new JWTClaimInvalid(
                            '"nonce" claim is prohibited',
                            'nonce',
                            'prohibited'
                        )
                    }

                    if (!('events' in payload)) {
                        throw new JWTClaimInvalid(
                            '"events" claim is missing',
                            'events',
                            'missing'
                        )
                    }

                    if (!isObject(payload.events)) {
                        throw new JWTClaimInvalid(
                            '"events" claim must be an object',
                            'events',
                            'invalid'
                        )
                    }

                    if (
                        !(
                            'http://schemas.openid.net/event/backchannel-logout' in
                            payload.events
                        )
                    ) {
                        throw new JWTClaimInvalid(
                            '"http://schemas.openid.net/event/backchannel-logout" member is missing in the "events" claim',
                            'events',
                            'invalid'
                        )
                    }

                    if (
                        !isObject(
                            payload.events[
                                'http://schemas.openid.net/event/backchannel-logout'
                            ]
                        )
                    ) {
                        throw new JWTClaimInvalid(
                            '"http://schemas.openid.net/event/backchannel-logout" member in the "events" claim must be an object',
                            'events',
                            'invalid'
                        )
                    }
                }
            }

            const checkAudiencePresence = (audPayload, audOption, profile) => {
                if (typeof audPayload === 'string') {
                    return audOption.includes(audPayload)
                }

                if (profile === ATJWT) {
                    // reject if it contains additional audiences that are not known aliases of the resource
                    // indicator of the current resource server
                    audOption = new Set(audOption)
                    return audPayload.every(Set.prototype.has.bind(audOption))
                } else {
                    // Each principal intended to process the JWT MUST
                    // identify itself with a value in the audience claim
                    audPayload = new Set(audPayload)
                    return audOption.some(Set.prototype.has.bind(audPayload))
                }
            }

            module.exports = (token, key, options = {}) => {
                if (!isObject(options)) {
                    throw new TypeError('options must be an object')
                }

                const {
                    algorithms,
                    audience,
                    clockTolerance,
                    complete,
                    crit,
                    ignoreExp,
                    ignoreIat,
                    ignoreNbf,
                    issuer,
                    jti,
                    maxAuthAge,
                    maxTokenAge,
                    nonce,
                    now,
                    profile,
                    subject
                } = (options = validateOptions(options))

                const decoded = decode(token, { complete: true })
                key = getKey(key, true)

                if (complete) {
                    ;({ key } = verify(
                        true,
                        'preparsed',
                        { decoded, token },
                        key,
                        { crit, algorithms, complete: true }
                    ))
                    decoded.key = key
                } else {
                    verify(true, 'preparsed', { decoded, token }, key, {
                        crit,
                        algorithms
                    })
                }

                const unix = epoch(now)
                validateTypes(decoded, profile, options)

                if (issuer && decoded.payload.iss !== issuer) {
                    throw new JWTClaimInvalid(
                        'unexpected "iss" claim value',
                        'iss',
                        'check_failed'
                    )
                }

                if (nonce && decoded.payload.nonce !== nonce) {
                    throw new JWTClaimInvalid(
                        'unexpected "nonce" claim value',
                        'nonce',
                        'check_failed'
                    )
                }

                if (subject && decoded.payload.sub !== subject) {
                    throw new JWTClaimInvalid(
                        'unexpected "sub" claim value',
                        'sub',
                        'check_failed'
                    )
                }

                if (jti && decoded.payload.jti !== jti) {
                    throw new JWTClaimInvalid(
                        'unexpected "jti" claim value',
                        'jti',
                        'check_failed'
                    )
                }

                if (
                    audience &&
                    !checkAudiencePresence(
                        decoded.payload.aud,
                        typeof audience === 'string' ? [audience] : audience,
                        profile
                    )
                ) {
                    throw new JWTClaimInvalid(
                        'unexpected "aud" claim value',
                        'aud',
                        'check_failed'
                    )
                }

                const tolerance = clockTolerance ? secs(clockTolerance) : 0

                if (maxAuthAge) {
                    const maxAuthAgeSeconds = secs(maxAuthAge)
                    if (
                        decoded.payload.auth_time + maxAuthAgeSeconds <
                        unix - tolerance
                    ) {
                        throw new JWTClaimInvalid(
                            '"auth_time" claim timestamp check failed (too much time has elapsed since the last End-User authentication)',
                            'auth_time',
                            'check_failed'
                        )
                    }
                }

                if (
                    !ignoreIat &&
                    !('exp' in decoded.payload) &&
                    'iat' in decoded.payload &&
                    decoded.payload.iat > unix + tolerance
                ) {
                    throw new JWTClaimInvalid(
                        '"iat" claim timestamp check failed (it should be in the past)',
                        'iat',
                        'check_failed'
                    )
                }

                if (
                    !ignoreNbf &&
                    'nbf' in decoded.payload &&
                    decoded.payload.nbf > unix + tolerance
                ) {
                    throw new JWTClaimInvalid(
                        '"nbf" claim timestamp check failed',
                        'nbf',
                        'check_failed'
                    )
                }

                if (
                    !ignoreExp &&
                    'exp' in decoded.payload &&
                    decoded.payload.exp <= unix - tolerance
                ) {
                    throw new JWTExpired(
                        '"exp" claim timestamp check failed',
                        'exp',
                        'check_failed'
                    )
                }

                if (maxTokenAge) {
                    const age = unix - decoded.payload.iat
                    const max = secs(maxTokenAge)

                    if (age - tolerance > max) {
                        throw new JWTExpired(
                            '"iat" claim timestamp check failed (too far in the past)',
                            'iat',
                            'check_failed'
                        )
                    }

                    if (age < 0 - tolerance) {
                        throw new JWTClaimInvalid(
                            '"iat" claim timestamp check failed (it should be in the past)',
                            'iat',
                            'check_failed'
                        )
                    }
                }

                if (
                    profile === IDTOKEN &&
                    Array.isArray(decoded.payload.aud) &&
                    decoded.payload.aud.length > 1 &&
                    decoded.payload.azp !== audience
                ) {
                    throw new JWTClaimInvalid(
                        'unexpected "azp" claim value',
                        'azp',
                        'check_failed'
                    )
                }

                if (profile === ATJWT && decoded.header.typ !== ATJWT) {
                    throw new JWTClaimInvalid(
                        'invalid JWT typ header value for the used validation profile',
                        'typ',
                        'check_failed'
                    )
                }

                return complete ? decoded : decoded.payload
            }

            /***/
        },

        /***/ BkRI: /***/ function(module, exports, __webpack_require__) {
            var baseClone = __webpack_require__('OBhP')

            /** Used to compose bitmasks for cloning. */
            var CLONE_DEEP_FLAG = 1,
                CLONE_SYMBOLS_FLAG = 4

            /**
             * This method is like `_.clone` except that it recursively clones `value`.
             *
             * @static
             * @memberOf _
             * @since 1.0.0
             * @category Lang
             * @param {*} value The value to recursively clone.
             * @returns {*} Returns the deep cloned value.
             * @see _.clone
             * @example
             *
             * var objects = [{ 'a': 1 }, { 'b': 2 }];
             *
             * var deep = _.cloneDeep(objects);
             * console.log(deep[0] === objects[0]);
             * // => false
             */
            function cloneDeep(value) {
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
            }

            module.exports = cloneDeep

            /***/
        },

        /***/ BzZA: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /*
    Encode functions adapted from:
    Version 1.0 12/25/99 Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
    http://www.onicos.com/staff/iz/amuse/javascript/expert/base64.txt
*/

            const Stream = __webpack_require__('msIP')

            const internals = {}

            exports.encode = function(buffer) {
                return Buffer.from(buffer.toString('base64'))
            }

            exports.Encoder = class Encoder extends Stream.Transform {
                constructor() {
                    super()
                    this._reminder = null
                }

                _transform(chunk, encoding, callback) {
                    let part = this._reminder
                        ? Buffer.concat([this._reminder, chunk])
                        : chunk
                    const remaining = part.length % 3
                    if (remaining) {
                        this._reminder = part.slice(part.length - remaining)
                        part = part.slice(0, part.length - remaining)
                    } else {
                        this._reminder = null
                    }

                    this.push(exports.encode(part))
                    return callback()
                }

                _flush(callback) {
                    if (this._reminder) {
                        this.push(exports.encode(this._reminder))
                    }

                    return callback()
                }
            }

            /***/
        },

        /***/ 'C/Kw': /***/ function(module, exports, __webpack_require__) {
            const { improvedDH } = __webpack_require__('pDDt')
            const { KEYLENGTHS } = __webpack_require__('N+nT')
            const { generateSync } = __webpack_require__('LDEB')
            const { name: secp256k1 } = __webpack_require__('F/JS')

            const derive = __webpack_require__('kZLX')

            const wrapKey = (key, payload, { enc }) => {
                const epk = generateSync(key.kty, key.crv)

                const derivedKey = derive(enc, KEYLENGTHS.get(enc), epk, key)

                return {
                    wrapped: derivedKey,
                    header: {
                        epk: { kty: key.kty, crv: key.crv, x: epk.x, y: epk.y }
                    }
                }
            }

            const unwrapKey = (key, payload, header) => {
                const { enc, epk } = header
                return derive(enc, KEYLENGTHS.get(enc), key, epk, header)
            }

            module.exports = (JWA, JWK) => {
                JWA.keyManagementEncrypt.set('ECDH-ES', wrapKey)
                JWA.keyManagementDecrypt.set('ECDH-ES', unwrapKey)
                JWK.EC.deriveKey['ECDH-ES'] = key =>
                    (key.use === 'enc' || key.use === undefined) &&
                    key.crv !== secp256k1

                if (improvedDH) {
                    JWK.OKP.deriveKey['ECDH-ES'] = key =>
                        (key.use === 'enc' || key.use === undefined) &&
                        key.keyObject.asymmetricKeyType.startsWith('x')
                }
            }

            /***/
        },

        /***/ CH3K: /***/ function(module, exports) {
            /**
             * Appends the elements of `values` to `array`.
             *
             * @private
             * @param {Array} array The array to modify.
             * @param {Array} values The values to append.
             * @returns {Array} Returns `array`.
             */
            function arrayPush(array, values) {
                var index = -1,
                    length = values.length,
                    offset = array.length

                while (++index < length) {
                    array[offset + index] = values[index]
                }
                return array
            }

            module.exports = arrayPush

            /***/
        },

        /***/ CMye: /***/ function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__('GoyQ')

            /**
             * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` if suitable for strict
             *  equality comparisons, else `false`.
             */
            function isStrictComparable(value) {
                return value === value && !isObject(value)
            }

            module.exports = isStrictComparable

            /***/
        },

        /***/ Cl1u: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Types = __webpack_require__('gdNv')

            const internals = {
                mismatched: null
            }

            module.exports = function(obj, ref, options) {
                options = Object.assign({ prototype: true }, options)

                return !!internals.isDeepEqual(obj, ref, options, [])
            }

            internals.isDeepEqual = function(obj, ref, options, seen) {
                if (obj === ref) {
                    // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
                    return obj !== 0 || 1 / obj === 1 / ref
                }

                const type = typeof obj

                if (type !== typeof ref) {
                    return false
                }

                if (obj === null || ref === null) {
                    return false
                }

                if (type === 'function') {
                    if (
                        !options.deepFunction ||
                        obj.toString() !== ref.toString()
                    ) {
                        return false
                    }

                    // Continue as object
                } else if (type !== 'object') {
                    return obj !== obj && ref !== ref // NaN
                }

                const instanceType = internals.getSharedType(
                    obj,
                    ref,
                    !!options.prototype
                )
                switch (instanceType) {
                    case Types.buffer:
                        return Buffer && Buffer.prototype.equals.call(obj, ref) // $lab:coverage:ignore$
                    case Types.promise:
                        return obj === ref
                    case Types.regex:
                        return obj.toString() === ref.toString()
                    case internals.mismatched:
                        return false
                }

                for (let i = seen.length - 1; i >= 0; --i) {
                    if (seen[i].isSame(obj, ref)) {
                        return true // If previous comparison failed, it would have stopped execution
                    }
                }

                seen.push(new internals.SeenEntry(obj, ref))

                try {
                    return !!internals.isDeepEqualObj(
                        instanceType,
                        obj,
                        ref,
                        options,
                        seen
                    )
                } finally {
                    seen.pop()
                }
            }

            internals.getSharedType = function(obj, ref, checkPrototype) {
                if (checkPrototype) {
                    if (
                        Object.getPrototypeOf(obj) !==
                        Object.getPrototypeOf(ref)
                    ) {
                        return internals.mismatched
                    }

                    return Types.getInternalProto(obj)
                }

                const type = Types.getInternalProto(obj)
                if (type !== Types.getInternalProto(ref)) {
                    return internals.mismatched
                }

                return type
            }

            internals.valueOf = function(obj) {
                const objValueOf = obj.valueOf
                if (objValueOf === undefined) {
                    return obj
                }

                try {
                    return objValueOf.call(obj)
                } catch (err) {
                    return err
                }
            }

            internals.hasOwnEnumerableProperty = function(obj, key) {
                return Object.prototype.propertyIsEnumerable.call(obj, key)
            }

            internals.isSetSimpleEqual = function(obj, ref) {
                for (const entry of obj) {
                    if (!ref.has(entry)) {
                        return false
                    }
                }

                return true
            }

            internals.isDeepEqualObj = function(
                instanceType,
                obj,
                ref,
                options,
                seen
            ) {
                const {
                    isDeepEqual,
                    valueOf,
                    hasOwnEnumerableProperty
                } = internals
                const { keys, getOwnPropertySymbols } = Object

                if (instanceType === Types.array) {
                    if (options.part) {
                        // Check if any index match any other index

                        for (const objValue of obj) {
                            for (const refValue of ref) {
                                if (
                                    isDeepEqual(
                                        objValue,
                                        refValue,
                                        options,
                                        seen
                                    )
                                ) {
                                    return true
                                }
                            }
                        }
                    } else {
                        if (obj.length !== ref.length) {
                            return false
                        }

                        for (let i = 0; i < obj.length; ++i) {
                            if (!isDeepEqual(obj[i], ref[i], options, seen)) {
                                return false
                            }
                        }

                        return true
                    }
                } else if (instanceType === Types.set) {
                    if (obj.size !== ref.size) {
                        return false
                    }

                    if (!internals.isSetSimpleEqual(obj, ref)) {
                        // Check for deep equality

                        const ref2 = new Set(ref)
                        for (const objEntry of obj) {
                            if (ref2.delete(objEntry)) {
                                continue
                            }

                            let found = false
                            for (const refEntry of ref2) {
                                if (
                                    isDeepEqual(
                                        objEntry,
                                        refEntry,
                                        options,
                                        seen
                                    )
                                ) {
                                    ref2.delete(refEntry)
                                    found = true
                                    break
                                }
                            }

                            if (!found) {
                                return false
                            }
                        }
                    }
                } else if (instanceType === Types.map) {
                    if (obj.size !== ref.size) {
                        return false
                    }

                    for (const [key, value] of obj) {
                        if (value === undefined && !ref.has(key)) {
                            return false
                        }

                        if (!isDeepEqual(value, ref.get(key), options, seen)) {
                            return false
                        }
                    }
                } else if (instanceType === Types.error) {
                    // Always check name and message

                    if (obj.name !== ref.name || obj.message !== ref.message) {
                        return false
                    }
                }

                // Check .valueOf()

                const valueOfObj = valueOf(obj)
                const valueOfRef = valueOf(ref)
                if (
                    (obj !== valueOfObj || ref !== valueOfRef) &&
                    !isDeepEqual(valueOfObj, valueOfRef, options, seen)
                ) {
                    return false
                }

                // Check properties

                const objKeys = keys(obj)
                if (
                    !options.part &&
                    objKeys.length !== keys(ref).length &&
                    !options.skip
                ) {
                    return false
                }

                let skipped = 0
                for (const key of objKeys) {
                    if (options.skip && options.skip.includes(key)) {
                        if (ref[key] === undefined) {
                            ++skipped
                        }

                        continue
                    }

                    if (!hasOwnEnumerableProperty(ref, key)) {
                        return false
                    }

                    if (!isDeepEqual(obj[key], ref[key], options, seen)) {
                        return false
                    }
                }

                if (
                    !options.part &&
                    objKeys.length - skipped !== keys(ref).length
                ) {
                    return false
                }

                // Check symbols

                if (options.symbols !== false) {
                    // Defaults to true
                    const objSymbols = getOwnPropertySymbols(obj)
                    const refSymbols = new Set(getOwnPropertySymbols(ref))

                    for (const key of objSymbols) {
                        if (!options.skip || !options.skip.includes(key)) {
                            if (hasOwnEnumerableProperty(obj, key)) {
                                if (!hasOwnEnumerableProperty(ref, key)) {
                                    return false
                                }

                                if (
                                    !isDeepEqual(
                                        obj[key],
                                        ref[key],
                                        options,
                                        seen
                                    )
                                ) {
                                    return false
                                }
                            } else if (hasOwnEnumerableProperty(ref, key)) {
                                return false
                            }
                        }

                        refSymbols.delete(key)
                    }

                    for (const key of refSymbols) {
                        if (hasOwnEnumerableProperty(ref, key)) {
                            return false
                        }
                    }
                }

                return true
            }

            internals.SeenEntry = class {
                constructor(obj, ref) {
                    this.obj = obj
                    this.ref = ref
                }

                isSame(obj, ref) {
                    return this.obj === obj && this.ref === ref
                }
            }

            /***/
        },

        /***/ ClL1: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Crypto = __webpack_require__('PJMN')

            const B64 = __webpack_require__('M8F5')
            const Boom = __webpack_require__('U3sn')
            const Bourne = __webpack_require__('5kZ8')
            const Cryptiles = __webpack_require__('ieHi')
            const Hoek = __webpack_require__('RXbi')

            const internals = {}

            exports.defaults = {
                encryption: {
                    saltBits: 256,
                    algorithm: 'aes-256-cbc',
                    iterations: 1,
                    minPasswordlength: 32
                },

                integrity: {
                    saltBits: 256,
                    algorithm: 'sha256',
                    iterations: 1,
                    minPasswordlength: 32
                },

                ttl: 0, // Milliseconds, 0 means forever
                timestampSkewSec: 60, // Seconds of permitted clock skew for incoming expirations
                localtimeOffsetMsec: 0 // Local clock time offset express in a number of milliseconds (positive or negative)
            }

            // Algorithm configuration

            exports.algorithms = {
                'aes-128-ctr': { keyBits: 128, ivBits: 128 },
                'aes-256-cbc': { keyBits: 256, ivBits: 128 },
                sha256: { keyBits: 256 }
            }

            // MAC normalization format version

            exports.macFormatVersion = '2' // Prevent comparison of mac values generated with different normalized string formats

            exports.macPrefix = 'Fe26.' + exports.macFormatVersion

            // Generate a unique encryption key

            /*
    const options =  {
        saltBits: 256,                                  // Ignored if salt is set
        salt: '4d8nr9q384nr9q384nr93q8nruq9348run',
        algorithm: 'aes-128-ctr',
        iterations: 10000,
        iv: 'sdfsdfsdfsdfscdrgercgesrcgsercg',          // Optional
        minPasswordlength: 32
    };
*/

            exports.generateKey = async function(password, options) {
                if (!password) {
                    throw new Boom('Empty password')
                }

                if (!options || typeof options !== 'object') {
                    throw new Boom('Bad options')
                }

                const algorithm = exports.algorithms[options.algorithm]
                if (!algorithm) {
                    throw new Boom('Unknown algorithm: ' + options.algorithm)
                }

                const result = {}

                if (Buffer.isBuffer(password)) {
                    if (password.length < algorithm.keyBits / 8) {
                        throw new Boom('Key buffer (password) too small')
                    }

                    result.key = password
                    result.salt = ''
                } else {
                    if (password.length < options.minPasswordlength) {
                        throw new Boom(
                            'Password string too short (min ' +
                                options.minPasswordlength +
                                ' characters required)'
                        )
                    }

                    let salt = options.salt
                    if (!salt) {
                        if (!options.saltBits) {
                            throw new Boom('Missing salt and saltBits options')
                        }

                        const randomSalt = Cryptiles.randomBits(
                            options.saltBits
                        )
                        salt = randomSalt.toString('hex')
                    }

                    const derivedKey = await internals.pbkdf2(
                        password,
                        salt,
                        options.iterations,
                        algorithm.keyBits / 8,
                        'sha1'
                    )

                    result.key = derivedKey
                    result.salt = salt
                }

                if (options.iv) {
                    result.iv = options.iv
                } else if (algorithm.ivBits) {
                    result.iv = Cryptiles.randomBits(algorithm.ivBits)
                }

                return result
            }

            // Encrypt data
            // options: see exports.generateKey()

            exports.encrypt = async function(password, options, data) {
                const key = await exports.generateKey(password, options)
                const cipher = Crypto.createCipheriv(
                    options.algorithm,
                    key.key,
                    key.iv
                )
                const encrypted = Buffer.concat([
                    cipher.update(data, 'utf8'),
                    cipher.final()
                ])

                return { encrypted, key }
            }

            // Decrypt data
            // options: see exports.generateKey()

            exports.decrypt = async function(password, options, data) {
                const key = await exports.generateKey(password, options)
                const decipher = Crypto.createDecipheriv(
                    options.algorithm,
                    key.key,
                    key.iv
                )
                let dec = decipher.update(data, null, 'utf8')
                dec = dec + decipher.final('utf8')

                return dec
            }

            // HMAC using a password
            // options: see exports.generateKey()

            exports.hmacWithPassword = async function(password, options, data) {
                const key = await exports.generateKey(password, options)
                const hmac = Crypto.createHmac(
                    options.algorithm,
                    key.key
                ).update(data)
                const digest = hmac
                    .digest('base64')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/\=/g, '')

                return {
                    digest,
                    salt: key.salt
                }
            }

            // Normalizes a password parameter into a { id, encryption, integrity } object
            // password: string, buffer or object with { id, secret } or { id, encryption, integrity }

            internals.normalizePassword = function(password) {
                if (
                    password &&
                    typeof password === 'object' &&
                    !Buffer.isBuffer(password)
                ) {
                    return {
                        id: password.id,
                        encryption: password.secret || password.encryption,
                        integrity: password.secret || password.integrity
                    }
                }

                return {
                    encryption: password,
                    integrity: password
                }
            }

            // Encrypt and HMAC an object
            // password: string, buffer or object with { id, secret } or { id, encryption, integrity }
            // options: see exports.defaults

            exports.seal = async function(object, password, options) {
                options = Object.assign({}, options) // Shallow cloned to prevent changes during async operations

                const now = Date.now() + (options.localtimeOffsetMsec || 0) // Measure now before any other processing

                // Serialize object

                const objectString = internals.stringify(object)

                // Obtain password

                let passwordId = ''
                password = internals.normalizePassword(password)
                if (password.id) {
                    if (!/^\w+$/.test(password.id)) {
                        throw new Boom('Invalid password id')
                    }

                    passwordId = password.id
                }

                // Encrypt object string

                const { encrypted, key } = await exports.encrypt(
                    password.encryption,
                    options.encryption,
                    objectString
                )

                // Base64url the encrypted value

                const encryptedB64 = B64.base64urlEncode(encrypted)
                const iv = B64.base64urlEncode(key.iv)
                const expiration = options.ttl ? now + options.ttl : ''
                const macBaseString =
                    exports.macPrefix +
                    '*' +
                    passwordId +
                    '*' +
                    key.salt +
                    '*' +
                    iv +
                    '*' +
                    encryptedB64 +
                    '*' +
                    expiration

                // Mac the combined values

                const mac = await exports.hmacWithPassword(
                    password.integrity,
                    options.integrity,
                    macBaseString
                )

                // Put it all together

                // prefix*[password-id]*encryption-salt*encryption-iv*encrypted*[expiration]*hmac-salt*hmac
                // Allowed URI query name/value characters: *-. \d \w

                const sealed = macBaseString + '*' + mac.salt + '*' + mac.digest
                return sealed
            }

            // Decrypt and validate sealed string
            // password: string, buffer or object with { id: secret } or { id: { encryption, integrity } }
            // options: see exports.defaults

            exports.unseal = async function(sealed, password, options) {
                options = Object.assign({}, options) // Shallow cloned to prevent changes during async operations

                const now = Date.now() + (options.localtimeOffsetMsec || 0) // Measure now before any other processing

                // Break string into components

                const parts = sealed.split('*')
                if (parts.length !== 8) {
                    throw new Boom('Incorrect number of sealed components')
                }

                const macPrefix = parts[0]
                const passwordId = parts[1]
                const encryptionSalt = parts[2]
                const encryptionIv = parts[3]
                const encryptedB64 = parts[4]
                const expiration = parts[5]
                const hmacSalt = parts[6]
                const hmac = parts[7]
                const macBaseString =
                    macPrefix +
                    '*' +
                    passwordId +
                    '*' +
                    encryptionSalt +
                    '*' +
                    encryptionIv +
                    '*' +
                    encryptedB64 +
                    '*' +
                    expiration

                // Check prefix

                if (macPrefix !== exports.macPrefix) {
                    throw new Boom('Wrong mac prefix')
                }

                // Check expiration

                if (expiration) {
                    if (!expiration.match(/^\d+$/)) {
                        throw new Boom('Invalid expiration')
                    }

                    const exp = parseInt(expiration, 10)
                    if (exp <= now - options.timestampSkewSec * 1000) {
                        throw new Boom('Expired seal')
                    }
                }

                // Obtain password

                if (!password) {
                    throw new Boom('Empty password')
                }

                if (
                    typeof password === 'object' &&
                    !Buffer.isBuffer(password)
                ) {
                    password = password[passwordId || 'default']
                    if (!password) {
                        throw new Boom('Cannot find password: ' + passwordId)
                    }
                }

                password = internals.normalizePassword(password)

                // Check hmac

                const macOptions = Hoek.clone(options.integrity)
                macOptions.salt = hmacSalt
                const mac = await exports.hmacWithPassword(
                    password.integrity,
                    macOptions,
                    macBaseString
                )

                if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
                    throw new Boom('Bad hmac value')
                }

                // Decrypt

                try {
                    var encrypted = B64.base64urlDecode(encryptedB64, 'buffer')
                } catch (err) {
                    throw Boom.boomify(err)
                }

                const decryptOptions = Hoek.clone(options.encryption)
                decryptOptions.salt = encryptionSalt

                try {
                    decryptOptions.iv = B64.base64urlDecode(
                        encryptionIv,
                        'buffer'
                    )
                } catch (err) {
                    throw Boom.boomify(err)
                }

                const decrypted = await exports.decrypt(
                    password.encryption,
                    decryptOptions,
                    encrypted
                )

                // Parse JSON

                try {
                    return Bourne.parse(decrypted)
                } catch (err) {
                    throw new Boom(
                        'Failed parsing sealed object JSON: ' + err.message
                    )
                }
            }

            internals.stringify = function(object) {
                try {
                    return JSON.stringify(object)
                } catch (err) {
                    throw new Boom('Failed to stringify object: ' + err.message)
                }
            }

            internals.pbkdf2 = function(...args) {
                return new Promise((resolve, reject) => {
                    const next = (err, result) => {
                        if (err) {
                            return reject(Boom.boomify(err))
                        }

                        resolve(result)
                    }

                    args.push(next)
                    Crypto.pbkdf2(...args)
                })
            }

            /***/
        },

        /***/ Cwc5: /***/ function(module, exports, __webpack_require__) {
            var baseIsNative = __webpack_require__('NKxu'),
                getValue = __webpack_require__('Npjl')

            /**
             * Gets the native function at `key` of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {string} key The key of the method to get.
             * @returns {*} Returns the function if it's native, else `undefined`.
             */
            function getNative(object, key) {
                var value = getValue(object, key)
                return baseIsNative(value) ? value : undefined
            }

            module.exports = getNative

            /***/
        },

        /***/ D5mk: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = object => {
                const result = {}

                for (const [key, value] of Object.entries(object)) {
                    result[key.toLowerCase()] = value
                }

                return result
            }

            /***/
        },

        /***/ DSRE: /***/ function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */ ;(function(module) {
                var root = __webpack_require__('Kz5y'),
                    stubFalse = __webpack_require__('B8du')

                /** Detect free variable `exports`. */
                var freeExports =
                    true && exports && !exports.nodeType && exports

                /** Detect free variable `module`. */
                var freeModule =
                    freeExports &&
                    typeof module == 'object' &&
                    module &&
                    !module.nodeType &&
                    module

                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports =
                    freeModule && freeModule.exports === freeExports

                /** Built-in value references. */
                var Buffer = moduleExports ? root.Buffer : undefined

                /* Built-in method references for those with the same name as other `lodash` methods. */
                var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined

                /**
                 * Checks if `value` is a buffer.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                 * @example
                 *
                 * _.isBuffer(new Buffer(2));
                 * // => true
                 *
                 * _.isBuffer(new Uint8Array(2));
                 * // => false
                 */
                var isBuffer = nativeIsBuffer || stubFalse

                module.exports = isBuffer

                /* WEBPACK VAR INJECTION */
            }.call(this, __webpack_require__('YuTi')(module)))

            /***/
        },

        /***/ 'Dw+G': /***/ function(module, exports, __webpack_require__) {
            var copyObject = __webpack_require__('juv8'),
                keysIn = __webpack_require__('mTTR')

            /**
             * The base implementation of `_.assignIn` without support for multiple sources
             * or `customizer` functions.
             *
             * @private
             * @param {Object} object The destination object.
             * @param {Object} source The source object.
             * @returns {Object} Returns `object`.
             */
            function baseAssignIn(object, source) {
                return object && copyObject(source, keysIn(source), object)
            }

            module.exports = baseAssignIn

            /***/
        },

        /***/ E1OP: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { PassThrough } = __webpack_require__('msIP')

            module.exports = options => {
                options = Object.assign({}, options)

                const { array } = options
                let { encoding } = options
                const buffer = encoding === 'buffer'
                let objectMode = false

                if (array) {
                    objectMode = !(encoding || buffer)
                } else {
                    encoding = encoding || 'utf8'
                }

                if (buffer) {
                    encoding = null
                }

                let len = 0
                const ret = []
                const stream = new PassThrough({ objectMode })

                if (encoding) {
                    stream.setEncoding(encoding)
                }

                stream.on('data', chunk => {
                    ret.push(chunk)

                    if (objectMode) {
                        len = ret.length
                    } else {
                        len += chunk.length
                    }
                })

                stream.getBufferedValue = () => {
                    if (array) {
                        return ret
                    }

                    return buffer ? Buffer.concat(ret, len) : ret.join('')
                }

                stream.getBufferedLength = () => len

                return stream
            }

            /***/
        },

        /***/ E2jh: /***/ function(module, exports, __webpack_require__) {
            var coreJsData = __webpack_require__('2gN3')

            /** Used to detect methods masquerading as native. */
            var maskSrcKey = (function() {
                var uid = /[^.]+$/.exec(
                    (coreJsData &&
                        coreJsData.keys &&
                        coreJsData.keys.IE_PROTO) ||
                        ''
                )
                return uid ? 'Symbol(src)_1.' + uid : ''
            })()

            /**
             * Checks if `func` has its source masked.
             *
             * @private
             * @param {Function} func The function to check.
             * @returns {boolean} Returns `true` if `func` is masked, else `false`.
             */
            function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func
            }

            module.exports = isMasked

            /***/
        },

        /***/ E8LI: /***/ function(module, exports, __webpack_require__) {
            module.exports = {
                der: __webpack_require__('ZUdF'),
                pem: __webpack_require__('c1/D')
            }

            /***/
        },

        /***/ EA7m: /***/ function(module, exports, __webpack_require__) {
            var identity = __webpack_require__('zZ0H'),
                overRest = __webpack_require__('Ioao'),
                setToString = __webpack_require__('wclG')

            /**
             * The base implementation of `_.rest` which doesn't validate or coerce arguments.
             *
             * @private
             * @param {Function} func The function to apply a rest parameter to.
             * @param {number} [start=func.length-1] The start position of the rest parameter.
             * @returns {Function} Returns the new function.
             */
            function baseRest(func, start) {
                return setToString(overRest(func, start, identity), func + '')
            }

            module.exports = baseRest

            /***/
        },

        /***/ EB1F: /***/ function(module, exports) {
            module.exports = new Map([
                ['A128CBC-HS256', 256],
                ['A128GCM', 128],
                ['A192CBC-HS384', 384],
                ['A192GCM', 192],
                ['A256CBC-HS512', 512],
                ['A256GCM', 256]
            ])

            /***/
        },

        /***/ EEGq: /***/ function(module, exports, __webpack_require__) {
            var copyObject = __webpack_require__('juv8'),
                getSymbolsIn = __webpack_require__('oCl/')

            /**
             * Copies own and inherited symbols of `source` to `object`.
             *
             * @private
             * @param {Object} source The object to copy symbols from.
             * @param {Object} [object={}] The object to copy symbols to.
             * @returns {Object} Returns `object`.
             */
            function copySymbolsIn(source, object) {
                return copyObject(source, getSymbolsIn(source), object)
            }

            module.exports = copySymbolsIn

            /***/
        },

        /***/ EpBk: /***/ function(module, exports) {
            /**
             * Checks if `value` is suitable for use as unique object key.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
             */
            function isKeyable(value) {
                var type = typeof value
                return type == 'string' ||
                    type == 'number' ||
                    type == 'symbol' ||
                    type == 'boolean'
                    ? value !== '__proto__'
                    : value === null
            }

            module.exports = isKeyable

            /***/
        },

        /***/ ExA7: /***/ function(module, exports) {
            /**
             * Checks if `value` is object-like. A value is object-like if it's not `null`
             * and has a `typeof` result of "object".
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
             * @example
             *
             * _.isObjectLike({});
             * // => true
             *
             * _.isObjectLike([1, 2, 3]);
             * // => true
             *
             * _.isObjectLike(_.noop);
             * // => false
             *
             * _.isObjectLike(null);
             * // => false
             */
            function isObjectLike(value) {
                return value != null && typeof value == 'object'
            }

            module.exports = isObjectLike

            /***/
        },

        /***/ 'F/5w': /***/ function(module, exports) {
            //TODO: handle reviver/dehydrate function like normal
            //and handle indentation, like normal.
            //if anyone needs this... please send pull request.

            exports.stringify = function stringify(o) {
                if ('undefined' == typeof o) return o

                if (o && Buffer.isBuffer(o))
                    return JSON.stringify(':base64:' + o.toString('base64'))

                if (o && o.toJSON) o = o.toJSON()

                if (o && 'object' === typeof o) {
                    var s = ''
                    var array = Array.isArray(o)
                    s = array ? '[' : '{'
                    var first = true

                    for (var k in o) {
                        var ignore =
                            'function' == typeof o[k] ||
                            (!array && 'undefined' === typeof o[k])
                        if (Object.hasOwnProperty.call(o, k) && !ignore) {
                            if (!first) s += ','
                            first = false
                            if (array) {
                                if (o[k] == undefined) s += 'null'
                                else s += stringify(o[k])
                            } else if (o[k] !== void 0) {
                                s += stringify(k) + ':' + stringify(o[k])
                            }
                        }
                    }

                    s += array ? ']' : '}'

                    return s
                } else if ('string' === typeof o) {
                    return JSON.stringify(/^:/.test(o) ? ':' + o : o)
                } else if ('undefined' === typeof o) {
                    return 'null'
                } else return JSON.stringify(o)
            }

            exports.parse = function(s) {
                return JSON.parse(s, function(key, value) {
                    if ('string' === typeof value) {
                        if (/^:base64:/.test(value))
                            return new Buffer(value.substring(8), 'base64')
                        else
                            return /^:/.test(value) ? value.substring(1) : value
                    }
                    return value
                })
            }

            /***/
        },

        /***/ 'F/JS': /***/ function(module, exports, __webpack_require__) {
            const { deprecate } = __webpack_require__('jK02')

            const deprecation = deprecate(() => {},
            '"P-256K" EC curve name is deprecated')

            module.exports = {
                name: 'secp256k1',
                rename(value) {
                    if (value !== 'secp256k1') {
                        deprecation()
                    }
                    module.exports.name = value
                }
            }

            /***/
        },

        /***/ F4x3: /***/ function(module, exports) {
            module.exports = date => Math.floor(date.getTime() / 1000)

            /***/
        },

        /***/ FMKJ: /***/ function(module, exports) {
            module.exports = require('zlib')

            /***/
        },

        /***/ 'FUB/': /***/ function(module, exports, __webpack_require__) {
            const { JWKKeySupport, JOSENotSupported } = __webpack_require__(
                'yt7c'
            )
            const {
                KEY_MANAGEMENT_ENCRYPT,
                KEY_MANAGEMENT_DECRYPT
            } = __webpack_require__('ehsS')

            const { JWA, JWK } = __webpack_require__('N+nT')

            // sign, verify
            __webpack_require__('IWF7')(JWA, JWK)
            __webpack_require__('/sST')(JWA, JWK)
            __webpack_require__('MoRj')(JWA, JWK)
            __webpack_require__('hnhG')(JWA, JWK)
            __webpack_require__('5fWB')(JWA, JWK)
            __webpack_require__('w8yO')(JWA)

            // encrypt, decrypt
            __webpack_require__('d4WF')(JWA, JWK)
            __webpack_require__('BJV5')(JWA, JWK)

            // wrapKey, unwrapKey
            __webpack_require__('hk9D')(JWA, JWK)
            __webpack_require__('bUME')(JWA, JWK)
            __webpack_require__('xfr8')(JWA, JWK)

            // deriveKey
            __webpack_require__('q2Us')(JWA, JWK)
            __webpack_require__('C/Kw')(JWA, JWK)
            __webpack_require__('n8pu')(JWA, JWK)

            const check = (key, op, alg) => {
                const cache = `_${op}_${alg}`

                let label
                let keyOp
                if (op === 'keyManagementEncrypt') {
                    label = 'key management (encryption)'
                    keyOp = KEY_MANAGEMENT_ENCRYPT
                } else if (op === 'keyManagementDecrypt') {
                    label = 'key management (decryption)'
                    keyOp = KEY_MANAGEMENT_DECRYPT
                }

                if (cache in key) {
                    if (key[cache]) {
                        return
                    }
                    throw new JWKKeySupport(
                        `the key does not support ${alg} ${label ||
                            op} algorithm`
                    )
                }

                let value = true
                if (!JWA[op].has(alg)) {
                    throw new JOSENotSupported(
                        `unsupported ${label || op} alg: ${alg}`
                    )
                } else if (!key.algorithms(keyOp).has(alg)) {
                    value = false
                }

                Object.defineProperty(key, cache, { value, enumerable: false })

                if (!value) {
                    return check(key, op, alg)
                }
            }

            module.exports = {
                check,
                sign: (alg, key, payload) => {
                    check(key, 'sign', alg)
                    return JWA.sign.get(alg)(key, payload)
                },
                verify: (alg, key, payload, signature) => {
                    check(key, 'verify', alg)
                    return JWA.verify.get(alg)(key, payload, signature)
                },
                keyManagementEncrypt: (alg, key, payload, opts) => {
                    check(key, 'keyManagementEncrypt', alg)
                    return JWA.keyManagementEncrypt.get(alg)(key, payload, opts)
                },
                keyManagementDecrypt: (alg, key, payload, opts) => {
                    check(key, 'keyManagementDecrypt', alg)
                    return JWA.keyManagementDecrypt.get(alg)(key, payload, opts)
                },
                encrypt: (alg, key, cleartext, opts) => {
                    check(key, 'encrypt', alg)
                    return JWA.encrypt.get(alg)(key, cleartext, opts)
                },
                decrypt: (alg, key, ciphertext, opts) => {
                    check(key, 'decrypt', alg)
                    return JWA.decrypt.get(alg)(key, ciphertext, opts)
                }
            }

            /***/
        },

        /***/ FZoo: /***/ function(module, exports, __webpack_require__) {
            var assignValue = __webpack_require__('MrPd'),
                castPath = __webpack_require__('4uTw'),
                isIndex = __webpack_require__('wJg7'),
                isObject = __webpack_require__('GoyQ'),
                toKey = __webpack_require__('9Nap')

            /**
             * The base implementation of `_.set`.
             *
             * @private
             * @param {Object} object The object to modify.
             * @param {Array|string} path The path of the property to set.
             * @param {*} value The value to set.
             * @param {Function} [customizer] The function to customize path creation.
             * @returns {Object} Returns `object`.
             */
            function baseSet(object, path, value, customizer) {
                if (!isObject(object)) {
                    return object
                }
                path = castPath(path, object)

                var index = -1,
                    length = path.length,
                    lastIndex = length - 1,
                    nested = object

                while (nested != null && ++index < length) {
                    var key = toKey(path[index]),
                        newValue = value

                    if (index != lastIndex) {
                        var objValue = nested[key]
                        newValue = customizer
                            ? customizer(objValue, key, nested)
                            : undefined
                        if (newValue === undefined) {
                            newValue = isObject(objValue)
                                ? objValue
                                : isIndex(path[index + 1])
                                ? []
                                : {}
                        }
                    }
                    assignValue(nested, key, newValue)
                    nested = nested[key]
                }
                return object
            }

            module.exports = baseSet

            /***/
        },

        /***/ 'Fo+H': /***/ function(module, exports) {
            module.exports = {
                sign: new Map(),
                verify: new Map(),
                keyManagementEncrypt: new Map(),
                keyManagementDecrypt: new Map(),
                encrypt: new Map(),
                decrypt: new Map()
            }

            /***/
        },

        /***/ 'Fow+': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Stringify = __webpack_require__('VraX')

            const internals = {}

            module.exports = class extends Error {
                constructor(args) {
                    const msgs = args
                        .filter(arg => arg !== '')
                        .map(arg => {
                            return typeof arg === 'string'
                                ? arg
                                : arg instanceof Error
                                ? arg.message
                                : Stringify(arg)
                        })

                    super(msgs.join(' ') || 'Unknown error')

                    if (typeof Error.captureStackTrace === 'function') {
                        // $lab:coverage:ignore$
                        Error.captureStackTrace(this, exports.assert)
                    }
                }
            }

            /***/
        },

        /***/ G6z8: /***/ function(module, exports, __webpack_require__) {
            var baseGetAllKeys = __webpack_require__('fR/l'),
                getSymbolsIn = __webpack_require__('oCl/'),
                keysIn = __webpack_require__('mTTR')

            /**
             * Creates an array of own and inherited enumerable property names and
             * symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names and symbols.
             */
            function getAllKeysIn(object) {
                return baseGetAllKeys(object, keysIn, getSymbolsIn)
            }

            module.exports = getAllKeysIn

            /***/
        },

        /***/ G8Mo: /***/ function(module, exports, __webpack_require__) {
            // 7.1.1 ToPrimitive(input [, PreferredType])
            var isObject = __webpack_require__('93I4')
            // instead of the ES6 spec version, we didn't implement @@toPrimitive case
            // and the second argument - flag - preferred type is a string
            module.exports = function(it, S) {
                if (!isObject(it)) return it
                var fn, val
                if (
                    S &&
                    typeof (fn = it.toString) == 'function' &&
                    !isObject((val = fn.call(it)))
                )
                    return val
                if (
                    typeof (fn = it.valueOf) == 'function' &&
                    !isObject((val = fn.call(it)))
                )
                    return val
                if (
                    !S &&
                    typeof (fn = it.toString) == 'function' &&
                    !isObject((val = fn.call(it)))
                )
                    return val
                throw TypeError("Can't convert object to primitive value")
            }

            /***/
        },

        /***/ GCLL: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Assert = __webpack_require__('GlC0')

            const internals = {}

            module.exports = function(attribute) {
                // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

                Assert(
                    /^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(
                        attribute
                    ),
                    'Bad attribute value (' + attribute + ')'
                )

                return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"') // Escape quotes and slash
            }

            /***/
        },

        /***/ GDhZ: /***/ function(module, exports, __webpack_require__) {
            var baseIsEqual = __webpack_require__('wF/u'),
                get = __webpack_require__('mwIZ'),
                hasIn = __webpack_require__('hgQt'),
                isKey = __webpack_require__('9ggG'),
                isStrictComparable = __webpack_require__('CMye'),
                matchesStrictComparable = __webpack_require__('IOzZ'),
                toKey = __webpack_require__('9Nap')

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1,
                COMPARE_UNORDERED_FLAG = 2

            /**
             * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
             *
             * @private
             * @param {string} path The path of the property to get.
             * @param {*} srcValue The value to match.
             * @returns {Function} Returns the new spec function.
             */
            function baseMatchesProperty(path, srcValue) {
                if (isKey(path) && isStrictComparable(srcValue)) {
                    return matchesStrictComparable(toKey(path), srcValue)
                }
                return function(object) {
                    var objValue = get(object, path)
                    return objValue === undefined && objValue === srcValue
                        ? hasIn(object, path)
                        : baseIsEqual(
                              srcValue,
                              objValue,
                              COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG
                          )
                }
            }

            module.exports = baseMatchesProperty

            /***/
        },

        /***/ GNiM: /***/ function(module, exports, __webpack_require__) {
            var memoizeCapped = __webpack_require__('I01J')

            /** Used to match property names within property paths. */
            var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g

            /** Used to match backslashes in property paths. */
            var reEscapeChar = /\\(\\)?/g

            /**
             * Converts `string` to a property path array.
             *
             * @private
             * @param {string} string The string to convert.
             * @returns {Array} Returns the property path array.
             */
            var stringToPath = memoizeCapped(function(string) {
                var result = []
                if (string.charCodeAt(0) === 46 /* . */) {
                    result.push('')
                }
                string.replace(rePropName, function(
                    match,
                    number,
                    quote,
                    subString
                ) {
                    result.push(
                        quote
                            ? subString.replace(reEscapeChar, '$1')
                            : number || match
                    )
                })
                return result
            })

            module.exports = stringToPath

            /***/
        },

        /***/ GX0O: /***/ function(
            module,
            __webpack_exports__,
            __webpack_require__
        ) {
            'use strict'
            __webpack_require__.r(__webpack_exports__)

            /* harmony default export */ __webpack_exports__[
                'default'
            ] = function(ctx) {
                return Promise.all([])
            }

            /***/
        },

        /***/ GhER: /***/ function(module, exports, __webpack_require__) {
            const { deprecate } = __webpack_require__('jK02')

            const {
                createPublicKey,
                createPrivateKey,
                createSecretKey,
                KeyObject
            } = __webpack_require__('1ALl')
            const base64url = __webpack_require__('Xab3')
            const isObject = __webpack_require__('kF1/')
            const { jwkToPem } = __webpack_require__('gXwc')
            const errors = __webpack_require__('yt7c')

            const RSAKey = __webpack_require__('RoCg')
            const ECKey = __webpack_require__('3HlQ')
            const OKPKey = __webpack_require__('vC2k')
            const OctKey = __webpack_require__('BBt9')

            const importable = new Set(['string', 'buffer', 'object'])

            const mergedParameters = (target = {}, source = {}) => {
                return {
                    alg: source.alg,
                    key_ops: source.key_ops,
                    kid: source.kid,
                    use: source.use,
                    x5c: source.x5c,
                    x5t: source.x5t,
                    'x5t#S256': source['x5t#S256'],
                    ...target
                }
            }

            const openSSHpublicKey = /^[a-zA-Z0-9-]+ (?:[a-zA-Z0-9+/])*(?:==|=)?(?: .*)?$/

            const asKey = (
                key,
                parameters,
                { calculateMissingRSAPrimes = false } = {}
            ) => {
                let privateKey, publicKey, secret

                if (!importable.has(typeof key)) {
                    throw new TypeError(
                        'key argument must be a string, buffer or an object'
                    )
                }

                if (parameters !== undefined && !isObject(parameters)) {
                    throw new TypeError(
                        'parameters argument must be a plain object when provided'
                    )
                }

                if (key instanceof KeyObject) {
                    switch (key.type) {
                        case 'private':
                            privateKey = key
                            break
                        case 'public':
                            publicKey = key
                            break
                        case 'secret':
                            secret = key
                            break
                    }
                } else if (
                    typeof key === 'object' &&
                    key &&
                    'kty' in key &&
                    key.kty === 'oct'
                ) {
                    // symmetric key <Object>
                    try {
                        secret = createSecretKey(
                            base64url.decodeToBuffer(key.k)
                        )
                    } catch (err) {
                        if (!('k' in key)) {
                            secret = { type: 'secret' }
                        }
                    }
                    parameters = mergedParameters(parameters, key)
                } else if (typeof key === 'object' && key && 'kty' in key) {
                    // assume JWK formatted asymmetric key <Object>
                    ;({ calculateMissingRSAPrimes = false } = parameters || {
                        calculateMissingRSAPrimes
                    })
                    let pem

                    try {
                        pem = jwkToPem(key, { calculateMissingRSAPrimes })
                    } catch (err) {
                        if (err instanceof errors.JOSEError) {
                            throw err
                        }
                    }

                    if (pem && key.d) {
                        privateKey = createPrivateKey(pem)
                    } else if (pem) {
                        publicKey = createPublicKey(pem)
                    }

                    parameters = mergedParameters({}, key)
                } else if (
                    key &&
                    (typeof key === 'object' || typeof key === 'string')
                ) {
                    // <Object> | <string> | <Buffer> passed to crypto.createPrivateKey or crypto.createPublicKey or <Buffer> passed to crypto.createSecretKey
                    try {
                        privateKey = createPrivateKey(key)
                    } catch (err) {
                        if (err instanceof errors.JOSEError) {
                            throw err
                        }
                    }

                    try {
                        publicKey = createPublicKey(key)
                        if (
                            key.startsWith('-----BEGIN CERTIFICATE-----') &&
                            (!parameters || !('x5c' in parameters))
                        ) {
                            parameters = mergedParameters(parameters, {
                                x5c: [
                                    key.replace(
                                        /(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g,
                                        ''
                                    )
                                ]
                            })
                        }
                    } catch (err) {
                        if (err instanceof errors.JOSEError) {
                            throw err
                        }
                    }

                    try {
                        // this is to filter out invalid PEM keys and certs, i'll rather have them fail import then
                        // have them imported as symmetric "oct" keys
                        if (
                            !key.includes('-----BEGIN') &&
                            !openSSHpublicKey.test(
                                key.toString('ascii').replace(/[\r\n]/g, '')
                            )
                        ) {
                            secret = createSecretKey(
                                Buffer.isBuffer(key) ? key : Buffer.from(key)
                            )
                        }
                    } catch (err) {}
                }

                const keyObject = privateKey || publicKey || secret

                if (privateKey || publicKey) {
                    switch (keyObject.asymmetricKeyType) {
                        case 'rsa':
                            return new RSAKey(keyObject, parameters)
                        case 'ec':
                            return new ECKey(keyObject, parameters)
                        case 'ed25519':
                        case 'ed448':
                        case 'x25519':
                        case 'x448':
                            return new OKPKey(keyObject, parameters)
                        default:
                            throw new errors.JOSENotSupported(
                                'only RSA, EC and OKP asymmetric keys are supported'
                            )
                    }
                } else if (secret) {
                    return new OctKey(keyObject, parameters)
                }

                throw new errors.JWKImportFailed('key import failed')
            }

            module.exports = asKey
            Object.defineProperty(asKey, 'deprecated', {
                value: deprecate((key, parameters) => {
                    return asKey(key, parameters, {
                        calculateMissingRSAPrimes: true
                    })
                }, 'JWK.importKey() is deprecated, use JWK.asKey() instead'),
                enumerable: false
            })

            /***/
        },

        /***/ Gi0A: /***/ function(module, exports, __webpack_require__) {
            var getTag = __webpack_require__('QqLw'),
                isObjectLike = __webpack_require__('ExA7')

            /** `Object#toString` result references. */
            var mapTag = '[object Map]'

            /**
             * The base implementation of `_.isMap` without Node.js optimizations.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a map, else `false`.
             */
            function baseIsMap(value) {
                return isObjectLike(value) && getTag(value) == mapTag
            }

            module.exports = baseIsMap

            /***/
        },

        /***/ GlC0: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const AssertError = __webpack_require__('Fow+')

            const internals = {}

            module.exports = function(condition, ...args) {
                if (condition) {
                    return
                }

                if (args.length === 1 && args[0] instanceof Error) {
                    throw args[0]
                }

                throw new AssertError(args)
            }

            /***/
        },

        /***/ GoyQ: /***/ function(module, exports) {
            /**
             * Checks if `value` is the
             * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
             * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an object, else `false`.
             * @example
             *
             * _.isObject({});
             * // => true
             *
             * _.isObject([1, 2, 3]);
             * // => true
             *
             * _.isObject(_.noop);
             * // => true
             *
             * _.isObject(null);
             * // => false
             */
            function isObject(value) {
                var type = typeof value
                return value != null && (type == 'object' || type == 'function')
            }

            module.exports = isObject

            /***/
        },

        /***/ H8j4: /***/ function(module, exports, __webpack_require__) {
            var getMapData = __webpack_require__('QkVE')

            /**
             * Sets the map `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf MapCache
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the map cache instance.
             */
            function mapCacheSet(key, value) {
                var data = getMapData(this, key),
                    size = data.size

                data.set(key, value)
                this.size += data.size == size ? 0 : 1
                return this
            }

            module.exports = mapCacheSet

            /***/
        },

        /***/ HDyB: /***/ function(module, exports, __webpack_require__) {
            var Symbol = __webpack_require__('nmnc'),
                Uint8Array = __webpack_require__('JHRd'),
                eq = __webpack_require__('ljhN'),
                equalArrays = __webpack_require__('or5M'),
                mapToArray = __webpack_require__('7fqy'),
                setToArray = __webpack_require__('rEGp')

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1,
                COMPARE_UNORDERED_FLAG = 2

            /** `Object#toString` result references. */
            var boolTag = '[object Boolean]',
                dateTag = '[object Date]',
                errorTag = '[object Error]',
                mapTag = '[object Map]',
                numberTag = '[object Number]',
                regexpTag = '[object RegExp]',
                setTag = '[object Set]',
                stringTag = '[object String]',
                symbolTag = '[object Symbol]'

            var arrayBufferTag = '[object ArrayBuffer]',
                dataViewTag = '[object DataView]'

            /** Used to convert symbols to primitives and strings. */
            var symbolProto = Symbol ? Symbol.prototype : undefined,
                symbolValueOf = symbolProto ? symbolProto.valueOf : undefined

            /**
             * A specialized version of `baseIsEqualDeep` for comparing objects of
             * the same `toStringTag`.
             *
             * **Note:** This function only supports comparing values with tags of
             * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {string} tag The `toStringTag` of the objects to compare.
             * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
             * @param {Function} customizer The function to customize comparisons.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Object} stack Tracks traversed `object` and `other` objects.
             * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
             */
            function equalByTag(
                object,
                other,
                tag,
                bitmask,
                customizer,
                equalFunc,
                stack
            ) {
                switch (tag) {
                    case dataViewTag:
                        if (
                            object.byteLength != other.byteLength ||
                            object.byteOffset != other.byteOffset
                        ) {
                            return false
                        }
                        object = object.buffer
                        other = other.buffer

                    case arrayBufferTag:
                        if (
                            object.byteLength != other.byteLength ||
                            !equalFunc(
                                new Uint8Array(object),
                                new Uint8Array(other)
                            )
                        ) {
                            return false
                        }
                        return true

                    case boolTag:
                    case dateTag:
                    case numberTag:
                        // Coerce booleans to `1` or `0` and dates to milliseconds.
                        // Invalid dates are coerced to `NaN`.
                        return eq(+object, +other)

                    case errorTag:
                        return (
                            object.name == other.name &&
                            object.message == other.message
                        )

                    case regexpTag:
                    case stringTag:
                        // Coerce regexes to strings and treat strings, primitives and objects,
                        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                        // for more details.
                        return object == other + ''

                    case mapTag:
                        var convert = mapToArray

                    case setTag:
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG
                        convert || (convert = setToArray)

                        if (object.size != other.size && !isPartial) {
                            return false
                        }
                        // Assume cyclic values are equal.
                        var stacked = stack.get(object)
                        if (stacked) {
                            return stacked == other
                        }
                        bitmask |= COMPARE_UNORDERED_FLAG

                        // Recursively compare objects (susceptible to call stack limits).
                        stack.set(object, other)
                        var result = equalArrays(
                            convert(object),
                            convert(other),
                            bitmask,
                            customizer,
                            equalFunc,
                            stack
                        )
                        stack['delete'](object)
                        return result

                    case symbolTag:
                        if (symbolValueOf) {
                            return (
                                symbolValueOf.call(object) ==
                                symbolValueOf.call(other)
                            )
                        }
                }
                return false
            }

            module.exports = equalByTag

            /***/
        },

        /***/ HEcb: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // Description of supported double byte encodings and aliases.
            // Tables are not require()-d until they are needed to speed up library load.
            // require()-s are direct to support Browserify.

            module.exports = {
                // == Japanese/ShiftJIS ====================================================
                // All japanese encodings are based on JIS X set of standards:
                // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
                // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes.
                //              Has several variations in 1978, 1983, 1990 and 1997.
                // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
                // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
                //              2 planes, first is superset of 0208, second - revised 0212.
                //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

                // Byte encodings are:
                //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
                //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
                //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
                //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
                //               0x00-0x7F       - lower part of 0201
                //               0x8E, 0xA1-0xDF - upper part of 0201
                //               (0xA1-0xFE)x2   - 0208 plane (94x94).
                //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
                //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
                //               Used as-is in ISO2022 family.
                //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII,
                //                0201-1976 Roman, 0208-1978, 0208-1983.
                //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
                //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
                //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
                //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
                //
                // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
                //
                // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

                shiftjis: {
                    type: '_dbcs',
                    table: function() {
                        return __webpack_require__('lPSh')
                    },
                    encodeAdd: { '\u00a5': 0x5c, '\u203E': 0x7e },
                    encodeSkipVals: [{ from: 0xed40, to: 0xf940 }]
                },
                csshiftjis: 'shiftjis',
                mskanji: 'shiftjis',
                sjis: 'shiftjis',
                windows31j: 'shiftjis',
                ms31j: 'shiftjis',
                xsjis: 'shiftjis',
                windows932: 'shiftjis',
                ms932: 'shiftjis',
                '932': 'shiftjis',
                cp932: 'shiftjis',

                eucjp: {
                    type: '_dbcs',
                    table: function() {
                        return __webpack_require__('SYHD')
                    },
                    encodeAdd: { '\u00a5': 0x5c, '\u203E': 0x7e }
                },

                // TODO: KDDI extension to Shift_JIS
                // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
                // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.

                // == Chinese/GBK ==========================================================
                // http://en.wikipedia.org/wiki/GBK
                // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

                // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
                gb2312: 'cp936',
                gb231280: 'cp936',
                gb23121980: 'cp936',
                csgb2312: 'cp936',
                csiso58gb231280: 'cp936',
                euccn: 'cp936',

                // Microsoft's CP936 is a subset and approximation of GBK.
                windows936: 'cp936',
                ms936: 'cp936',
                '936': 'cp936',
                cp936: {
                    type: '_dbcs',
                    table: function() {
                        return __webpack_require__('sv2S')
                    }
                },

                // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
                gbk: {
                    type: '_dbcs',
                    table: function() {
                        return __webpack_require__('sv2S').concat(
                            __webpack_require__('hHSr')
                        )
                    }
                },
                xgbk: 'gbk',
                isoir58: 'gbk',

                // GB18030 is an algorithmic extension of GBK.
                // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
                // http://icu-project.org/docs/papers/gb18030.html
                // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
                // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
                gb18030: {
                    type: '_dbcs',
                    table: function() {
                        return __webpack_require__('sv2S').concat(
                            __webpack_require__('hHSr')
                        )
                    },
                    gb18030: function() {
                        return __webpack_require__('fPfv')
                    },
                    encodeSkipVals: [0x80],
                    encodeAdd: { '': 0xa2e3 }
                },

                chinese: 'gb18030',

                // == Korean ===============================================================
                // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
                windows949: 'cp949',
                ms949: 'cp949',
                '949': 'cp949',
                cp949: {
                    type: '_dbcs',
                    table: function() {
                        return __webpack_require__('5WRQ')
                    }
                },

                cseuckr: 'cp949',
                csksc56011987: 'cp949',
                euckr: 'cp949',
                isoir149: 'cp949',
                korean: 'cp949',
                ksc56011987: 'cp949',
                ksc56011989: 'cp949',
                ksc5601: 'cp949',

                // == Big5/Taiwan/Hong Kong ================================================
                // There are lots of tables for Big5 and cp950. Please see the following links for history:
                // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
                // Variations, in roughly number of defined chars:
                //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
                //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
                //  * Big5-2003 (Taiwan standard) almost superset of cp950.
                //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
                //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard.
                //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
                //    Plus, it has 4 combining sequences.
                //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
                //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
                //    Implementations are not consistent within browsers; sometimes labeled as just big5.
                //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
                //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
                //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
                //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
                //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
                //
                // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
                // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

                windows950: 'cp950',
                ms950: 'cp950',
                '950': 'cp950',
                cp950: {
                    type: '_dbcs',
                    table: function() {
                        return __webpack_require__('htfN')
                    }
                },

                // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
                big5: 'big5hkscs',
                big5hkscs: {
                    type: '_dbcs',
                    table: function() {
                        return __webpack_require__('htfN').concat(
                            __webpack_require__('cfAG')
                        )
                    },
                    encodeSkipVals: [0xa2cc]
                },

                cnbig5: 'big5hkscs',
                csbig5: 'big5hkscs',
                xxbig5: 'big5hkscs'
            }

            /***/
        },

        /***/ HKOu: /***/ function(module, exports) {
            module.exports = function() {
                this.seq().obj(
                    this.key('version').int(),
                    this.key('privateKey').octstr(),
                    this.key('parameters')
                        .explicit(0)
                        .optional()
                        .choice({ namedCurve: this.objid() }),
                    this.key('publicKey')
                        .explicit(1)
                        .optional()
                        .bitstr()
                )
            }

            /***/
        },

        /***/ HOxn: /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5'),
                root = __webpack_require__('Kz5y')

            /* Built-in method references that are verified to be native. */
            var Promise = getNative(root, 'Promise')

            module.exports = Promise

            /***/
        },

        /***/ HpLx: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * depd
             * Copyright(c) 2014 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module exports.
             */

            module.exports = callSiteToString

            /**
             * Format a CallSite file location to a string.
             */

            function callSiteFileLocation(callSite) {
                var fileName
                var fileLocation = ''

                if (callSite.isNative()) {
                    fileLocation = 'native'
                } else if (callSite.isEval()) {
                    fileName = callSite.getScriptNameOrSourceURL()
                    if (!fileName) {
                        fileLocation = callSite.getEvalOrigin()
                    }
                } else {
                    fileName = callSite.getFileName()
                }

                if (fileName) {
                    fileLocation += fileName

                    var lineNumber = callSite.getLineNumber()
                    if (lineNumber != null) {
                        fileLocation += ':' + lineNumber

                        var columnNumber = callSite.getColumnNumber()
                        if (columnNumber) {
                            fileLocation += ':' + columnNumber
                        }
                    }
                }

                return fileLocation || 'unknown source'
            }

            /**
             * Format a CallSite to a string.
             */

            function callSiteToString(callSite) {
                var addSuffix = true
                var fileLocation = callSiteFileLocation(callSite)
                var functionName = callSite.getFunctionName()
                var isConstructor = callSite.isConstructor()
                var isMethodCall = !(callSite.isToplevel() || isConstructor)
                var line = ''

                if (isMethodCall) {
                    var methodName = callSite.getMethodName()
                    var typeName = getConstructorName(callSite)

                    if (functionName) {
                        if (typeName && functionName.indexOf(typeName) !== 0) {
                            line += typeName + '.'
                        }

                        line += functionName

                        if (
                            methodName &&
                            functionName.lastIndexOf('.' + methodName) !==
                                functionName.length - methodName.length - 1
                        ) {
                            line += ' [as ' + methodName + ']'
                        }
                    } else {
                        line += typeName + '.' + (methodName || '<anonymous>')
                    }
                } else if (isConstructor) {
                    line += 'new ' + (functionName || '<anonymous>')
                } else if (functionName) {
                    line += functionName
                } else {
                    addSuffix = false
                    line += fileLocation
                }

                if (addSuffix) {
                    line += ' (' + fileLocation + ')'
                }

                return line
            }

            /**
             * Get constructor name of reviver.
             */

            function getConstructorName(obj) {
                var receiver = obj.receiver
                return (
                    (receiver.constructor && receiver.constructor.name) || null
                )
            }

            /***/
        },

        /***/ HpSD: /***/ function(module, exports) {
            // Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py

            // -- Normalization --
            // A string of any other type is interpreted as a URI either the form of scheme
            // "://" authority path-abempty [ "?" query ] [ "#" fragment ] or authority
            // path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986] and is
            // normalized according to the following rules:
            //
            // If the user input Identifier does not have an RFC 3986 [RFC3986] scheme
            // portion, the string is interpreted as [userinfo "@"] host [":" port]
            // path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986].
            // If the userinfo component is present and all of the path component, query
            // component, and port component are empty, the acct scheme is assumed. In this
            // case, the normalized URI is formed by prefixing acct: to the string as the
            // scheme. Per the 'acct' URI Scheme [ID.ietfappsawgaccturi], if there is an
            // at-sign character ('@') in the userinfo component, it needs to be
            // percent-encoded as described in RFC 3986 [RFC3986].
            // For all other inputs without a scheme portion, the https scheme is assumed,
            // and the normalized URI is formed by prefixing https:// to the string as the
            // scheme.
            // If the resulting URI contains a fragment portion, it MUST be stripped off
            // together with the fragment delimiter character "#".
            // The WebFinger [ID.ietfappsawgwebfinger] Resource in this case is the
            // resulting URI, and the WebFinger Host is the authority component.
            //
            // Note: Since the definition of authority in RFC 3986 [RFC3986] is
            // [ userinfo "@" ] host [ ":" port ], it is legal to have a user input
            // identifier like userinfo@host:port, e.g., alice@example.com:8080.

            const PORT = /^\d+$/

            function hasScheme(input) {
                if (input.includes('://')) return true

                const authority = input.replace(/(\/|\?)/g, '#').split('#')[0]
                if (authority.includes(':')) {
                    const index = authority.indexOf(':')
                    const hostOrPort = authority.slice(index + 1)
                    if (!PORT.test(hostOrPort)) {
                        return true
                    }
                }

                return false
            }

            function acctSchemeAssumed(input) {
                if (!input.includes('@')) return false
                const parts = input.split('@')
                const host = parts[parts.length - 1]
                return !(
                    host.includes(':') ||
                    host.includes('/') ||
                    host.includes('?')
                )
            }

            function normalize(input) {
                if (typeof input !== 'string') {
                    throw new TypeError('input must be a string')
                }

                let output
                if (hasScheme(input)) {
                    output = input
                } else if (acctSchemeAssumed(input)) {
                    output = `acct:${input}`
                } else {
                    output = `https://${input}`
                }

                return output.split('#')[0]
            }

            module.exports = normalize

            /***/
        },

        /***/ HrFp: /***/ function(module, exports, __webpack_require__) {
            /* eslint-disable max-classes-per-file */

            const { inspect, deprecate } = __webpack_require__('jK02')
            const stdhttp = __webpack_require__('KEll')
            const crypto = __webpack_require__('PJMN')
            const { strict: assert } = __webpack_require__('Qs3B')
            const querystring = __webpack_require__('8xkj')
            const url = __webpack_require__('bzos')

            const { ParseError } = __webpack_require__('AfMj')
            const jose = __webpack_require__('xZSz')
            const base64url = __webpack_require__('+00W')
            const defaultsDeep = __webpack_require__('P4Tr')
            const defaults = __webpack_require__('la6v')
            const merge = __webpack_require__('QkVN')
            const isPlainObject = __webpack_require__('YO3V')
            const tokenHash = __webpack_require__('ZfBq')

            const {
                assertSigningAlgValuesSupport,
                assertIssuerConfiguration
            } = __webpack_require__('N+si')
            const pick = __webpack_require__('LZmR')
            const processResponse = __webpack_require__('WeJA')
            const TokenSet = __webpack_require__('IgmS')
            const { OPError, RPError } = __webpack_require__('L71r')
            const now = __webpack_require__('PbSP')
            const { random } = __webpack_require__('iAgo')
            const request = __webpack_require__('UwMm')
            const {
                CALLBACK_PROPERTIES,
                CLIENT_DEFAULTS,
                JWT_CONTENT,
                CLOCK_TOLERANCE
            } = __webpack_require__('TJm8')
            const issuerRegistry = __webpack_require__('0Aai')
            const instance = __webpack_require__('0pkK')
            const {
                authenticatedPost,
                resolveResponseType,
                resolveRedirectUri
            } = __webpack_require__('/JKO')
            const DeviceFlowHandle = __webpack_require__('LMPv')

            function pickCb(input) {
                return pick(input, ...CALLBACK_PROPERTIES)
            }

            function authorizationHeaderValue(token, tokenType = 'Bearer') {
                return `${tokenType} ${token}`
            }

            function cleanUpClaims(claims) {
                if (Object.keys(claims._claim_names).length === 0) {
                    delete claims._claim_names
                }
                if (Object.keys(claims._claim_sources).length === 0) {
                    delete claims._claim_sources
                }
            }

            function assignClaim(
                target,
                source,
                sourceName,
                throwOnMissing = true
            ) {
                return ([claim, inSource]) => {
                    if (inSource === sourceName) {
                        if (throwOnMissing && source[claim] === undefined) {
                            throw new RPError(
                                `expected claim "${claim}" in "${sourceName}"`
                            )
                        } else if (source[claim] !== undefined) {
                            target[claim] = source[claim]
                        }
                        delete target._claim_names[claim]
                    }
                }
            }

            function verifyPresence(payload, jwt, prop) {
                if (payload[prop] === undefined) {
                    throw new RPError({
                        message: `missing required JWT property ${prop}`,
                        jwt
                    })
                }
            }

            function authorizationParams(params) {
                const authParams = {
                    client_id: this.client_id,
                    scope: 'openid',
                    response_type: resolveResponseType.call(this),
                    redirect_uri: resolveRedirectUri.call(this),
                    ...params
                }

                Object.entries(authParams).forEach(([key, value]) => {
                    if (value === null || value === undefined) {
                        delete authParams[key]
                    } else if (key === 'claims' && typeof value === 'object') {
                        authParams[key] = JSON.stringify(value)
                    } else if (key === 'resource' && Array.isArray(value)) {
                        authParams[key] = value
                    } else if (typeof value !== 'string') {
                        authParams[key] = String(value)
                    }
                })

                return authParams
            }

            async function claimJWT(label, jwt) {
                try {
                    const { header, payload } = jose.JWT.decode(jwt, {
                        complete: true
                    })
                    const { iss } = payload

                    if (header.alg === 'none') {
                        return payload
                    }

                    let key
                    if (!iss || iss === this.issuer.issuer) {
                        key = await this.issuer.queryKeyStore(header)
                    } else if (issuerRegistry.has(iss)) {
                        key = await issuerRegistry
                            .get(iss)
                            .queryKeyStore(header)
                    } else {
                        const discovered = await this.issuer.constructor.discover(
                            iss
                        )
                        key = await discovered.queryKeyStore(header)
                    }
                    return jose.JWT.verify(jwt, key)
                } catch (err) {
                    if (
                        err instanceof RPError ||
                        err instanceof OPError ||
                        err.name === 'AggregateError'
                    ) {
                        throw err
                    } else {
                        throw new RPError({
                            printf: [
                                'failed to validate the %s JWT (%s: %s)',
                                label,
                                err.name,
                                err.message
                            ],
                            jwt
                        })
                    }
                }
            }

            function getKeystore(jwks) {
                const keystore = jose.JWKS.asKeyStore(jwks)
                if (keystore.all().some(key => key.type !== 'private')) {
                    throw new TypeError('jwks must only contain private keys')
                }
                return keystore
            }

            // if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead
            // this is in place to take care of most common pitfalls when first using discovered Issuers without
            // the support for default values defined by Discovery 1.0
            function checkBasicSupport(client, metadata, properties) {
                try {
                    const supported =
                        client.issuer.token_endpoint_auth_methods_supported
                    if (
                        !supported.includes(
                            properties.token_endpoint_auth_method
                        )
                    ) {
                        if (supported.includes('client_secret_post')) {
                            properties.token_endpoint_auth_method =
                                'client_secret_post'
                        }
                    }
                } catch (err) {}
            }

            function handleCommonMistakes(client, metadata, properties) {
                if (!metadata.token_endpoint_auth_method) {
                    // if no explicit value was provided
                    checkBasicSupport(client, metadata, properties)
                }

                // :fp: c'mon people... RTFM
                if (metadata.redirect_uri) {
                    if (metadata.redirect_uris) {
                        throw new TypeError(
                            'provide a redirect_uri or redirect_uris, not both'
                        )
                    }
                    properties.redirect_uris = [metadata.redirect_uri]
                    delete properties.redirect_uri
                }

                if (metadata.response_type) {
                    if (metadata.response_types) {
                        throw new TypeError(
                            'provide a response_type or response_types, not both'
                        )
                    }
                    properties.response_types = [metadata.response_type]
                    delete properties.response_type
                }
            }

            function getDefaultsForEndpoint(endpoint, issuer, properties) {
                if (!issuer[`${endpoint}_endpoint`]) return

                const tokenEndpointAuthMethod =
                    properties.token_endpoint_auth_method
                const tokenEndpointAuthSigningAlg =
                    properties.token_endpoint_auth_signing_alg

                const eam = `${endpoint}_endpoint_auth_method`
                const easa = `${endpoint}_endpoint_auth_signing_alg`

                if (
                    properties[eam] === undefined &&
                    properties[easa] === undefined
                ) {
                    if (tokenEndpointAuthMethod !== undefined) {
                        properties[eam] = tokenEndpointAuthMethod
                    }
                    if (tokenEndpointAuthSigningAlg !== undefined) {
                        properties[easa] = tokenEndpointAuthSigningAlg
                    }
                }
            }

            class BaseClient {}

            module.exports = (issuer, aadIssValidation = false) =>
                class Client extends BaseClient {
                    /**
                     * @name constructor
                     * @api public
                     */
                    constructor(metadata = {}, jwks) {
                        super()

                        if (
                            typeof metadata.client_id !== 'string' ||
                            !metadata.client_id
                        ) {
                            throw new TypeError('client_id is required')
                        }

                        const properties = { ...CLIENT_DEFAULTS, ...metadata }

                        handleCommonMistakes(this, metadata, properties)

                        assertSigningAlgValuesSupport(
                            'token',
                            this.issuer,
                            properties
                        )

                        ;['introspection', 'revocation'].forEach(endpoint => {
                            getDefaultsForEndpoint(
                                endpoint,
                                this.issuer,
                                properties
                            )
                            assertSigningAlgValuesSupport(
                                endpoint,
                                this.issuer,
                                properties
                            )
                        })

                        Object.entries(properties).forEach(([key, value]) => {
                            instance(this)
                                .get('metadata')
                                .set(key, value)
                            if (!this[key]) {
                                Object.defineProperty(this, key, {
                                    get() {
                                        return instance(this)
                                            .get('metadata')
                                            .get(key)
                                    },
                                    enumerable: true
                                })
                            }
                        })

                        if (jwks !== undefined) {
                            const keystore = getKeystore.call(this, jwks)
                            instance(this).set('keystore', keystore)
                        }

                        this[CLOCK_TOLERANCE] = 0
                    }

                    /**
                     * @name authorizationUrl
                     * @api public
                     */
                    authorizationUrl(params = {}) {
                        if (!isPlainObject(params)) {
                            throw new TypeError('params must be a plain object')
                        }
                        assertIssuerConfiguration(
                            this.issuer,
                            'authorization_endpoint'
                        )
                        const target = url.parse(
                            this.issuer.authorization_endpoint,
                            true
                        )
                        target.search = null
                        target.query = {
                            ...target.query,
                            ...authorizationParams.call(this, params)
                        }
                        return url.format(target)
                    }

                    /**
                     * @name authorizationPost
                     * @api public
                     */
                    authorizationPost(params = {}) {
                        if (!isPlainObject(params)) {
                            throw new TypeError('params must be a plain object')
                        }
                        const inputs = authorizationParams.call(this, params)
                        const formInputs = Object.keys(inputs)
                            .map(
                                name =>
                                    `<input type="hidden" name="${name}" value="${inputs[name]}"/>`
                            )
                            .join('\n')

                        return `<!DOCTYPE html>
<head>
  <title>Requesting Authorization</title>
</head>
<body onload="javascript:document.forms[0].submit()">
  <form method="post" action="${this.issuer.authorization_endpoint}">
    ${formInputs}
  </form>
</body>
</html>`
                    }

                    /**
                     * @name endSessionUrl
                     * @api public
                     */
                    endSessionUrl(params = {}) {
                        assertIssuerConfiguration(
                            this.issuer,
                            'end_session_endpoint'
                        )

                        const { 0: postLogout, length } =
                            this.post_logout_redirect_uris || []

                        const {
                            post_logout_redirect_uri = length === 1
                                ? postLogout
                                : undefined
                        } = params

                        let hint = params.id_token_hint

                        if (hint instanceof TokenSet) {
                            if (!hint.id_token) {
                                throw new TypeError(
                                    'id_token not present in TokenSet'
                                )
                            }
                            hint = hint.id_token
                        }

                        const target = url.parse(
                            this.issuer.end_session_endpoint,
                            true
                        )
                        target.search = null
                        target.query = {
                            ...params,
                            ...target.query,
                            ...{
                                post_logout_redirect_uri,
                                id_token_hint: hint
                            }
                        }

                        Object.entries(target.query).forEach(([key, value]) => {
                            if (value === null || value === undefined) {
                                delete target.query[key]
                            }
                        })

                        return url.format(target)
                    }

                    /**
                     * @name callbackParams
                     * @api public
                     */
                    callbackParams(input) {
                        // eslint-disable-line class-methods-use-this
                        const isIncomingMessage =
                            input instanceof stdhttp.IncomingMessage ||
                            (input && input.method && input.url)
                        const isString = typeof input === 'string'

                        if (!isString && !isIncomingMessage) {
                            throw new TypeError(
                                '#callbackParams only accepts string urls, http.IncomingMessage or a lookalike'
                            )
                        }

                        if (isIncomingMessage) {
                            switch (input.method) {
                                case 'GET':
                                    return pickCb(
                                        url.parse(input.url, true).query
                                    )
                                case 'POST':
                                    if (input.body === undefined) {
                                        throw new TypeError(
                                            'incoming message body missing, include a body parser prior to this method call'
                                        )
                                    }
                                    switch (typeof input.body) {
                                        case 'object':
                                        case 'string':
                                            if (Buffer.isBuffer(input.body)) {
                                                return pickCb(
                                                    querystring.parse(
                                                        input.body.toString(
                                                            'utf-8'
                                                        )
                                                    )
                                                )
                                            }
                                            if (
                                                typeof input.body === 'string'
                                            ) {
                                                return pickCb(
                                                    querystring.parse(
                                                        input.body
                                                    )
                                                )
                                            }

                                            return pickCb(input.body)
                                        default:
                                            throw new TypeError(
                                                'invalid IncomingMessage body object'
                                            )
                                    }
                                default:
                                    throw new TypeError(
                                        'invalid IncomingMessage method'
                                    )
                            }
                        } else {
                            return pickCb(url.parse(input, true).query)
                        }
                    }

                    /**
                     * @name callback
                     * @api public
                     */
                    async callback(
                        redirectUri,
                        parameters,
                        checks = {},
                        { exchangeBody, clientAssertionPayload } = {}
                    ) {
                        let params = pickCb(parameters)

                        if (checks.jarm && !('response' in parameters)) {
                            throw new RPError({
                                message: 'expected a JARM response',
                                checks,
                                params
                            })
                        } else if ('response' in parameters) {
                            const decrypted = await this.decryptJARM(
                                params.response
                            )
                            params = await this.validateJARM(decrypted)
                        }

                        if (this.default_max_age && !checks.max_age) {
                            checks.max_age = this.default_max_age
                        }

                        if (params.state && !checks.state) {
                            throw new TypeError(
                                'checks.state argument is missing'
                            )
                        }

                        if (!params.state && checks.state) {
                            throw new RPError({
                                message: 'state missing from the response',
                                checks,
                                params
                            })
                        }

                        if (checks.state !== params.state) {
                            throw new RPError({
                                printf: [
                                    'state mismatch, expected %s, got: %s',
                                    checks.state,
                                    params.state
                                ],
                                checks,
                                params
                            })
                        }

                        if (params.error) {
                            throw new OPError(params)
                        }

                        const RESPONSE_TYPE_REQUIRED_PARAMS = {
                            code: ['code'],
                            id_token: ['id_token'],
                            token: ['access_token', 'token_type']
                        }

                        if (checks.response_type) {
                            for (const type of checks.response_type.split(
                                ' '
                            )) {
                                // eslint-disable-line no-restricted-syntax
                                if (type === 'none') {
                                    if (
                                        params.code ||
                                        params.id_token ||
                                        params.access_token
                                    ) {
                                        throw new RPError({
                                            message:
                                                'unexpected params encountered for "none" response',
                                            checks,
                                            params
                                        })
                                    }
                                } else {
                                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[
                                        type
                                    ]) {
                                        // eslint-disable-line no-restricted-syntax, max-len
                                        if (!params[param]) {
                                            throw new RPError({
                                                message: `${param} missing from response`,
                                                checks,
                                                params
                                            })
                                        }
                                    }
                                }
                            }
                        }

                        if (params.id_token) {
                            const tokenset = new TokenSet(params)
                            await this.decryptIdToken(tokenset)
                            await this.validateIdToken(
                                tokenset,
                                checks.nonce,
                                'authorization',
                                checks.max_age,
                                checks.state
                            )

                            if (!params.code) {
                                return tokenset
                            }
                        }

                        if (params.code) {
                            const tokenset = await this.grant(
                                {
                                    ...exchangeBody,
                                    grant_type: 'authorization_code',
                                    code: params.code,
                                    redirect_uri: redirectUri,
                                    code_verifier: checks.code_verifier
                                },
                                { clientAssertionPayload }
                            )

                            await this.decryptIdToken(tokenset)
                            await this.validateIdToken(
                                tokenset,
                                checks.nonce,
                                'token',
                                checks.max_age
                            )

                            if (params.session_state) {
                                tokenset.session_state = params.session_state
                            }

                            return tokenset
                        }

                        return new TokenSet(params)
                    }

                    /**
                     * @name oauthCallback
                     * @api public
                     */
                    async oauthCallback(
                        redirectUri,
                        parameters,
                        checks = {},
                        { exchangeBody, clientAssertionPayload } = {}
                    ) {
                        let params = pickCb(parameters)

                        if (checks.jarm && !('response' in parameters)) {
                            throw new RPError({
                                message: 'expected a JARM response',
                                checks,
                                params
                            })
                        } else if ('response' in parameters) {
                            const decrypted = await this.decryptJARM(
                                params.response
                            )
                            params = await this.validateJARM(decrypted)
                        }

                        if (params.state && !checks.state) {
                            throw new TypeError(
                                'checks.state argument is missing'
                            )
                        }

                        if (!params.state && checks.state) {
                            throw new RPError({
                                message: 'state missing from the response',
                                checks,
                                params
                            })
                        }

                        if (checks.state !== params.state) {
                            throw new RPError({
                                printf: [
                                    'state mismatch, expected %s, got: %s',
                                    checks.state,
                                    params.state
                                ],
                                checks,
                                params
                            })
                        }

                        if (params.error) {
                            throw new OPError(params)
                        }

                        const RESPONSE_TYPE_REQUIRED_PARAMS = {
                            code: ['code'],
                            token: ['access_token', 'token_type']
                        }

                        if (checks.response_type) {
                            for (const type of checks.response_type.split(
                                ' '
                            )) {
                                // eslint-disable-line no-restricted-syntax
                                if (type === 'none') {
                                    if (
                                        params.code ||
                                        params.id_token ||
                                        params.access_token
                                    ) {
                                        throw new RPError({
                                            message:
                                                'unexpected params encountered for "none" response',
                                            checks,
                                            params
                                        })
                                    }
                                }

                                if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {
                                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[
                                        type
                                    ]) {
                                        // eslint-disable-line no-restricted-syntax, max-len
                                        if (!params[param]) {
                                            throw new RPError({
                                                message: `${param} missing from response`,
                                                checks,
                                                params
                                            })
                                        }
                                    }
                                }
                            }
                        }

                        if (params.code) {
                            return this.grant(
                                {
                                    ...exchangeBody,
                                    grant_type: 'authorization_code',
                                    code: params.code,
                                    redirect_uri: redirectUri,
                                    code_verifier: checks.code_verifier
                                },
                                { clientAssertionPayload }
                            )
                        }

                        return new TokenSet(params)
                    }

                    /**
                     * @name decryptIdToken
                     * @api private
                     */
                    async decryptIdToken(token) {
                        if (!this.id_token_encrypted_response_alg) {
                            return token
                        }

                        let idToken = token

                        if (idToken instanceof TokenSet) {
                            if (!idToken.id_token) {
                                throw new TypeError(
                                    'id_token not present in TokenSet'
                                )
                            }
                            idToken = idToken.id_token
                        }

                        const expectedAlg = this.id_token_encrypted_response_alg
                        const expectedEnc = this.id_token_encrypted_response_enc

                        const result = await this.decryptJWE(
                            idToken,
                            expectedAlg,
                            expectedEnc
                        )

                        if (token instanceof TokenSet) {
                            token.id_token = result
                            return token
                        }

                        return result
                    }

                    async validateJWTUserinfo(body) {
                        const expectedAlg = this.userinfo_signed_response_alg

                        return this.validateJWT(body, expectedAlg, [])
                    }

                    /**
                     * @name decryptJARM
                     * @api private
                     */
                    async decryptJARM(response) {
                        if (!this.authorization_encrypted_response_alg) {
                            return response
                        }

                        const expectedAlg = this
                            .authorization_encrypted_response_alg
                        const expectedEnc = this
                            .authorization_encrypted_response_enc

                        return this.decryptJWE(
                            response,
                            expectedAlg,
                            expectedEnc
                        )
                    }

                    /**
                     * @name validateJARM
                     * @api private
                     */
                    async validateJARM(response) {
                        const expectedAlg = this
                            .authorization_signed_response_alg
                        const { payload } = await this.validateJWT(
                            response,
                            expectedAlg,
                            ['iss', 'exp', 'aud']
                        )
                        return pickCb(payload)
                    }

                    /**
                     * @name decryptJWTUserinfo
                     * @api private
                     */
                    async decryptJWTUserinfo(body) {
                        if (!this.userinfo_encrypted_response_alg) {
                            return body
                        }

                        const expectedAlg = this.userinfo_encrypted_response_alg
                        const expectedEnc = this.userinfo_encrypted_response_enc

                        return this.decryptJWE(body, expectedAlg, expectedEnc)
                    }

                    /**
                     * @name decryptJWE
                     * @api private
                     */
                    async decryptJWE(
                        jwe,
                        expectedAlg,
                        expectedEnc = 'A128CBC-HS256'
                    ) {
                        const header = JSON.parse(
                            base64url.decode(jwe.split('.')[0])
                        )

                        if (header.alg !== expectedAlg) {
                            throw new RPError({
                                printf: [
                                    'unexpected JWE alg received, expected %s, got: %s',
                                    expectedAlg,
                                    header.alg
                                ],
                                jwt: jwe
                            })
                        }

                        if (header.enc !== expectedEnc) {
                            throw new RPError({
                                printf: [
                                    'unexpected JWE enc received, expected %s, got: %s',
                                    expectedEnc,
                                    header.enc
                                ],
                                jwt: jwe
                            })
                        }

                        let keyOrStore

                        if (expectedAlg.match(/^(?:RSA|ECDH)/)) {
                            keyOrStore = instance(this).get('keystore')
                        } else {
                            keyOrStore = await this.joseSecret(
                                expectedAlg === 'dir'
                                    ? expectedEnc
                                    : expectedAlg
                            )
                        }

                        const payload = jose.JWE.decrypt(jwe, keyOrStore)
                        return payload.toString('utf8')
                    }

                    /**
                     * @name validateIdToken
                     * @api private
                     */
                    async validateIdToken(
                        tokenSet,
                        nonce,
                        returnedBy,
                        maxAge,
                        state
                    ) {
                        let idToken = tokenSet

                        const expectedAlg = this.id_token_signed_response_alg

                        const isTokenSet = idToken instanceof TokenSet

                        if (isTokenSet) {
                            if (!idToken.id_token) {
                                throw new TypeError(
                                    'id_token not present in TokenSet'
                                )
                            }
                            idToken = idToken.id_token
                        }

                        idToken = String(idToken)

                        const timestamp = now()
                        const {
                            protected: header,
                            payload,
                            key
                        } = await this.validateJWT(idToken, expectedAlg)

                        if (
                            maxAge ||
                            (maxAge !== null && this.require_auth_time)
                        ) {
                            if (!payload.auth_time) {
                                throw new RPError({
                                    message:
                                        'missing required JWT property auth_time',
                                    jwt: idToken
                                })
                            }
                            if (!Number.isInteger(payload.auth_time)) {
                                throw new RPError({
                                    message:
                                        'JWT auth_time claim must be a JSON number integer',
                                    jwt: idToken
                                })
                            }
                        }

                        if (
                            maxAge &&
                            payload.auth_time + maxAge <
                                timestamp - this[CLOCK_TOLERANCE]
                        ) {
                            throw new RPError({
                                printf: [
                                    'too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i',
                                    maxAge,
                                    payload.auth_time,
                                    timestamp - this[CLOCK_TOLERANCE]
                                ],
                                jwt: idToken
                            })
                        }

                        if (
                            nonce !== null &&
                            (payload.nonce || nonce !== undefined) &&
                            payload.nonce !== nonce
                        ) {
                            throw new RPError({
                                printf: [
                                    'nonce mismatch, expected %s, got: %s',
                                    nonce,
                                    payload.nonce
                                ],
                                jwt: idToken
                            })
                        }

                        if (returnedBy === 'authorization') {
                            if (!payload.at_hash && tokenSet.access_token) {
                                throw new RPError({
                                    message:
                                        'missing required property at_hash',
                                    jwt: idToken
                                })
                            }

                            if (!payload.c_hash && tokenSet.code) {
                                throw new RPError({
                                    message: 'missing required property c_hash',
                                    jwt: idToken
                                })
                            }

                            const fapi = this.constructor.name === 'FAPIClient'

                            if (fapi) {
                                if (payload.iat < timestamp - 3600) {
                                    throw new RPError({
                                        printf: [
                                            'JWT issued too far in the past, now %i, iat %i',
                                            timestamp,
                                            payload.iat
                                        ],
                                        jwt: idToken
                                    })
                                }

                                if (
                                    !payload.s_hash &&
                                    (tokenSet.state || state)
                                ) {
                                    throw new RPError({
                                        message:
                                            'missing required property s_hash',
                                        jwt: idToken
                                    })
                                }
                            }

                            if (payload.s_hash) {
                                if (!state) {
                                    throw new TypeError(
                                        'cannot verify s_hash, "checks.state" property not provided'
                                    )
                                }

                                try {
                                    tokenHash.validate(
                                        { claim: 's_hash', source: 'state' },
                                        payload.s_hash,
                                        state,
                                        header.alg,
                                        key && key.crv
                                    )
                                } catch (err) {
                                    throw new RPError({
                                        message: err.message,
                                        jwt: idToken
                                    })
                                }
                            }
                        }

                        if (
                            tokenSet.access_token &&
                            payload.at_hash !== undefined
                        ) {
                            try {
                                tokenHash.validate(
                                    {
                                        claim: 'at_hash',
                                        source: 'access_token'
                                    },
                                    payload.at_hash,
                                    tokenSet.access_token,
                                    header.alg,
                                    key && key.crv
                                )
                            } catch (err) {
                                throw new RPError({
                                    message: err.message,
                                    jwt: idToken
                                })
                            }
                        }

                        if (tokenSet.code && payload.c_hash !== undefined) {
                            try {
                                tokenHash.validate(
                                    { claim: 'c_hash', source: 'code' },
                                    payload.c_hash,
                                    tokenSet.code,
                                    header.alg,
                                    key && key.crv
                                )
                            } catch (err) {
                                throw new RPError({
                                    message: err.message,
                                    jwt: idToken
                                })
                            }
                        }

                        return tokenSet
                    }

                    /**
                     * @name validateJWT
                     * @api private
                     */
                    async validateJWT(
                        jwt,
                        expectedAlg,
                        required = ['iss', 'sub', 'aud', 'exp', 'iat']
                    ) {
                        const isSelfIssued =
                            this.issuer.issuer === 'https://self-issued.me'
                        const timestamp = now()
                        let header
                        let payload
                        try {
                            ;({ header, payload } = jose.JWT.decode(jwt, {
                                complete: true
                            }))
                        } catch (err) {
                            throw new RPError({
                                printf: [
                                    'failed to decode JWT (%s: %s)',
                                    err.name,
                                    err.message
                                ],
                                jwt
                            })
                        }

                        if (header.alg !== expectedAlg) {
                            throw new RPError({
                                printf: [
                                    'unexpected JWT alg received, expected %s, got: %s',
                                    expectedAlg,
                                    header.alg
                                ],
                                jwt
                            })
                        }

                        if (isSelfIssued) {
                            required = [...required, 'sub_jwk'] // eslint-disable-line no-param-reassign
                        }

                        required.forEach(
                            verifyPresence.bind(undefined, payload, jwt)
                        )

                        if (payload.iss !== undefined) {
                            let expectedIss = this.issuer.issuer

                            if (aadIssValidation) {
                                expectedIss = this.issuer.issuer.replace(
                                    '{tenantid}',
                                    payload.tid
                                )
                            }

                            if (payload.iss !== expectedIss) {
                                throw new RPError({
                                    printf: [
                                        'unexpected iss value, expected %s, got: %s',
                                        expectedIss,
                                        payload.iss
                                    ],
                                    jwt
                                })
                            }
                        }

                        if (payload.iat !== undefined) {
                            if (!Number.isInteger(payload.iat)) {
                                throw new RPError({
                                    message:
                                        'JWT iat claim must be a JSON number integer',
                                    jwt
                                })
                            }
                        }

                        if (payload.nbf !== undefined) {
                            if (!Number.isInteger(payload.nbf)) {
                                throw new RPError({
                                    message:
                                        'JWT nbf claim must be a JSON number integer',
                                    jwt
                                })
                            }
                            if (
                                payload.nbf >
                                timestamp + this[CLOCK_TOLERANCE]
                            ) {
                                throw new RPError({
                                    printf: [
                                        'JWT not active yet, now %i, nbf %i',
                                        timestamp + this[CLOCK_TOLERANCE],
                                        payload.nbf
                                    ],
                                    jwt
                                })
                            }
                        }

                        if (payload.exp !== undefined) {
                            if (!Number.isInteger(payload.exp)) {
                                throw new RPError({
                                    message:
                                        'JWT exp claim must be a JSON number integer',
                                    jwt
                                })
                            }
                            if (
                                timestamp - this[CLOCK_TOLERANCE] >=
                                payload.exp
                            ) {
                                throw new RPError({
                                    printf: [
                                        'JWT expired, now %i, exp %i',
                                        timestamp - this[CLOCK_TOLERANCE],
                                        payload.exp
                                    ],
                                    jwt
                                })
                            }
                        }

                        if (payload.aud !== undefined) {
                            if (Array.isArray(payload.aud)) {
                                if (payload.aud.length > 1 && !payload.azp) {
                                    throw new RPError({
                                        message:
                                            'missing required JWT property azp',
                                        jwt
                                    })
                                }

                                if (!payload.aud.includes(this.client_id)) {
                                    throw new RPError({
                                        printf: [
                                            'aud is missing the client_id, expected %s to be included in %j',
                                            this.client_id,
                                            payload.aud
                                        ],
                                        jwt
                                    })
                                }
                            } else if (payload.aud !== this.client_id) {
                                throw new RPError({
                                    printf: [
                                        'aud mismatch, expected %s, got: %s',
                                        this.client_id,
                                        payload.aud
                                    ],
                                    jwt
                                })
                            }
                        }

                        if (
                            payload.azp !== undefined &&
                            payload.azp !== this.client_id
                        ) {
                            throw new RPError({
                                printf: [
                                    'azp must be the client_id, expected %s, got: %s',
                                    this.client_id,
                                    payload.azp
                                ],
                                jwt
                            })
                        }

                        let key

                        if (isSelfIssued) {
                            try {
                                assert(isPlainObject(payload.sub_jwk))
                                key = jose.JWK.asKey(payload.sub_jwk)
                                assert.equal(key.type, 'public')
                            } catch (err) {
                                throw new RPError({
                                    message:
                                        'failed to use sub_jwk claim as an asymmetric JSON Web Key',
                                    jwt
                                })
                            }
                            if (key.thumbprint !== payload.sub) {
                                throw new RPError({
                                    message:
                                        'failed to match the subject with sub_jwk',
                                    jwt
                                })
                            }
                        } else if (header.alg.startsWith('HS')) {
                            key = await this.joseSecret()
                        } else if (header.alg !== 'none') {
                            key = await this.issuer.queryKeyStore(header)
                        }

                        if (!key && header.alg === 'none') {
                            return { protected: header, payload }
                        }

                        try {
                            return jose.JWS.verify(jwt, key, { complete: true })
                        } catch (err) {
                            throw new RPError({
                                message: 'failed to validate JWT signature',
                                jwt
                            })
                        }
                    }

                    /**
                     * @name refresh
                     * @api public
                     */
                    async refresh(
                        refreshToken,
                        { exchangeBody, clientAssertionPayload } = {}
                    ) {
                        let token = refreshToken

                        if (token instanceof TokenSet) {
                            if (!token.refresh_token) {
                                throw new TypeError(
                                    'refresh_token not present in TokenSet'
                                )
                            }
                            token = token.refresh_token
                        }

                        const tokenset = await this.grant(
                            {
                                ...exchangeBody,
                                grant_type: 'refresh_token',
                                refresh_token: String(token)
                            },
                            { clientAssertionPayload }
                        )

                        if (tokenset.id_token) {
                            await this.decryptIdToken(tokenset)
                            await this.validateIdToken(
                                tokenset,
                                null,
                                'token',
                                null
                            )
                        }

                        return tokenset
                    }

                    async requestResource(
                        resourceUrl,
                        accessToken,
                        {
                            method,
                            headers,
                            body,
                            tokenType = accessToken instanceof TokenSet
                                ? accessToken.token_type
                                : 'Bearer'
                        } = {}
                    ) {
                        if (accessToken instanceof TokenSet) {
                            if (!accessToken.access_token) {
                                throw new TypeError(
                                    'access_token not present in TokenSet'
                                )
                            }
                            accessToken = accessToken.access_token // eslint-disable-line no-param-reassign
                        }

                        const requestOpts = {
                            headers: {
                                Authorization: authorizationHeaderValue(
                                    accessToken,
                                    tokenType
                                ),
                                ...headers
                            },
                            body
                        }

                        const mTLS = !!this
                            .tls_client_certificate_bound_access_tokens

                        return request.call(
                            this,
                            {
                                ...requestOpts,
                                encoding: null,
                                method,
                                url: resourceUrl
                            },
                            { mTLS }
                        )
                    }

                    /**
                     * @name userinfo
                     * @api public
                     */
                    async userinfo(
                        accessToken,
                        { verb = 'GET', via = 'header', tokenType, params } = {}
                    ) {
                        // TODO: in v4.x remove verb in favour of method
                        assertIssuerConfiguration(
                            this.issuer,
                            'userinfo_endpoint'
                        )
                        const options = {
                            tokenType,
                            method: String(verb).toUpperCase()
                        }

                        if (
                            options.method !== 'GET' &&
                            options.method !== 'POST'
                        ) {
                            throw new TypeError(
                                '#userinfo() verb can only be POST or a GET'
                            )
                        }

                        if (via === 'query' && options.method !== 'GET') {
                            throw new TypeError(
                                'userinfo endpoints will only parse query strings for GET requests'
                            )
                        } else if (
                            via === 'body' &&
                            options.method !== 'POST'
                        ) {
                            throw new TypeError('can only send body on POST')
                        }

                        const jwt = !!(
                            this.userinfo_signed_response_alg ||
                            this.userinfo_encrypted_response_alg
                        )

                        if (jwt) {
                            options.headers = { Accept: 'application/jwt' }
                        } else {
                            options.headers = { Accept: 'application/json' }
                        }

                        const mTLS = !!this
                            .tls_client_certificate_bound_access_tokens

                        let targetUrl
                        if (mTLS && this.issuer.mtls_endpoint_aliases) {
                            targetUrl = this.issuer.mtls_endpoint_aliases
                                .userinfo_endpoint
                        }

                        targetUrl = new url.URL(
                            targetUrl || this.issuer.userinfo_endpoint
                        )

                        // when via is not header we clear the Authorization header and add either
                        // query string parameters or urlencoded body access_token parameter
                        if (via === 'query') {
                            options.headers.Authorization = undefined
                            targetUrl.searchParams.append(
                                'access_token',
                                accessToken instanceof TokenSet
                                    ? accessToken.access_token
                                    : accessToken
                            )
                        } else if (via === 'body') {
                            options.headers.Authorization = undefined
                            options.headers['Content-Type'] =
                                'application/x-www-form-urlencoded'
                            options.body = new url.URLSearchParams()
                            options.body.append(
                                'access_token',
                                accessToken instanceof TokenSet
                                    ? accessToken.access_token
                                    : accessToken
                            )
                        }

                        // handle additional parameters, GET via querystring, POST via urlencoded body
                        if (params) {
                            if (options.method === 'GET') {
                                Object.entries(params).forEach(
                                    ([key, value]) => {
                                        targetUrl.searchParams.append(
                                            key,
                                            value
                                        )
                                    }
                                )
                            } else if (options.body) {
                                // POST && via body
                                Object.entries(params).forEach(
                                    ([key, value]) => {
                                        options.body.append(key, value)
                                    }
                                )
                            } else {
                                // POST && via header
                                options.body = new url.URLSearchParams()
                                options.headers['Content-Type'] =
                                    'application/x-www-form-urlencoded'
                                Object.entries(params).forEach(
                                    ([key, value]) => {
                                        options.body.append(key, value)
                                    }
                                )
                            }
                        }

                        if (options.body) {
                            options.body = options.body.toString()
                        }

                        const response = await this.requestResource(
                            targetUrl,
                            accessToken,
                            options
                        )

                        let parsed = processResponse(response, { bearer: true })

                        if (jwt) {
                            if (
                                !JWT_CONTENT.test(
                                    response.headers['content-type']
                                )
                            ) {
                                throw new RPError({
                                    message:
                                        'expected application/jwt response from the userinfo_endpoint',
                                    response
                                })
                            }

                            const body = response.body.toString()
                            const userinfo = await this.decryptJWTUserinfo(body)
                            if (!this.userinfo_signed_response_alg) {
                                try {
                                    parsed = JSON.parse(userinfo)
                                    assert(isPlainObject(parsed))
                                } catch (err) {
                                    throw new RPError({
                                        message:
                                            'failed to parse userinfo JWE payload as JSON',
                                        jwt: userinfo
                                    })
                                }
                            } else {
                                ;({
                                    payload: parsed
                                } = await this.validateJWTUserinfo(userinfo))
                            }
                        } else {
                            try {
                                parsed = JSON.parse(response.body)
                            } catch (error) {
                                const parseError = new ParseError(
                                    error,
                                    response.statusCode,
                                    response.request.gotOptions,
                                    response.body
                                )
                                Object.defineProperty(parseError, 'response', {
                                    value: response
                                })
                                throw parseError
                            }
                        }

                        if (
                            accessToken instanceof TokenSet &&
                            accessToken.id_token
                        ) {
                            const expectedSub = accessToken.claims().sub
                            if (parsed.sub !== expectedSub) {
                                throw new RPError({
                                    printf: [
                                        'userinfo sub mismatch, expected %s, got: %s',
                                        expectedSub,
                                        parsed.sub
                                    ],
                                    body: parsed,
                                    jwt: accessToken.id_token
                                })
                            }
                        }

                        return parsed
                    }

                    /**
                     * @name derivedKey
                     * @api private
                     */
                    async derivedKey(len) {
                        const cacheKey = `${len}_key`
                        if (instance(this).has(cacheKey)) {
                            return instance(this).get(cacheKey)
                        }

                        const derivedBuffer = crypto
                            .createHash('sha256')
                            .update(this.client_secret)
                            .digest()
                            .slice(0, len / 8)

                        const key = jose.JWK.asKey({
                            k: base64url.encode(derivedBuffer),
                            kty: 'oct'
                        })
                        instance(this).set(cacheKey, key)

                        return key
                    }

                    /**
                     * @name joseSecret
                     * @api private
                     */
                    async joseSecret(alg) {
                        if (!this.client_secret) {
                            throw new TypeError('client_secret is required')
                        }
                        if (/^A(\d{3})(?:GCM)?KW$/.test(alg)) {
                            return this.derivedKey(parseInt(RegExp.$1, 10))
                        }

                        if (/^A(\d{3})(?:GCM|CBC-HS(\d{3}))$/.test(alg)) {
                            return this.derivedKey(
                                parseInt(RegExp.$2 || RegExp.$1, 10)
                            )
                        }

                        if (instance(this).has('jose_secret')) {
                            return instance(this).get('jose_secret')
                        }

                        const key = jose.JWK.asKey({
                            k: base64url.encode(this.client_secret),
                            kty: 'oct'
                        })
                        instance(this).set('jose_secret', key)

                        return key
                    }

                    /**
                     * @name grant
                     * @api public
                     */
                    async grant(body, { clientAssertionPayload } = {}) {
                        assertIssuerConfiguration(this.issuer, 'token_endpoint')
                        const response = await authenticatedPost.call(
                            this,
                            'token',
                            {
                                form: true,
                                body,
                                json: true
                            },
                            { clientAssertionPayload }
                        )
                        const responseBody = processResponse(response)

                        return new TokenSet(responseBody)
                    }

                    /**
                     * @name deviceAuthorization
                     * @api public
                     */
                    async deviceAuthorization(
                        params = {},
                        { exchangeBody, clientAssertionPayload } = {}
                    ) {
                        assertIssuerConfiguration(
                            this.issuer,
                            'device_authorization_endpoint'
                        )
                        assertIssuerConfiguration(this.issuer, 'token_endpoint')

                        const body = authorizationParams.call(this, {
                            client_id: this.client_id,
                            redirect_uri: null,
                            response_type: null,
                            ...params
                        })

                        const response = await authenticatedPost.call(
                            this,
                            'device_authorization',
                            {
                                form: true,
                                body,
                                json: true
                            },
                            {
                                clientAssertionPayload,
                                endpointAuthMethod: 'token'
                            }
                        )
                        const responseBody = processResponse(response)

                        return new DeviceFlowHandle({
                            client: this,
                            exchangeBody,
                            clientAssertionPayload,
                            response: responseBody,
                            maxAge: params.max_age
                        })
                    }

                    /**
                     * @name revoke
                     * @api public
                     */
                    async revoke(
                        token,
                        hint,
                        { revokeBody, clientAssertionPayload } = {}
                    ) {
                        assertIssuerConfiguration(
                            this.issuer,
                            'revocation_endpoint'
                        )
                        if (hint !== undefined && typeof hint !== 'string') {
                            throw new TypeError('hint must be a string')
                        }

                        const body = { ...revokeBody, token }

                        if (hint) {
                            body.token_type_hint = hint
                        }

                        const response = await authenticatedPost.call(
                            this,
                            'revocation',
                            {
                                body,
                                form: true
                            },
                            { clientAssertionPayload }
                        )
                        processResponse(response, { body: false })
                    }

                    /**
                     * @name introspect
                     * @api public
                     */
                    async introspect(
                        token,
                        hint,
                        { introspectBody, clientAssertionPayload } = {}
                    ) {
                        assertIssuerConfiguration(
                            this.issuer,
                            'introspection_endpoint'
                        )
                        if (hint !== undefined && typeof hint !== 'string') {
                            throw new TypeError('hint must be a string')
                        }

                        const body = { ...introspectBody, token }
                        if (hint) {
                            body.token_type_hint = hint
                        }

                        const response = await authenticatedPost.call(
                            this,
                            'introspection',
                            { body, form: true, json: true },
                            { clientAssertionPayload }
                        )

                        const responseBody = processResponse(response)

                        return responseBody
                    }

                    /**
                     * @name fetchDistributedClaims
                     * @api public
                     */
                    async fetchDistributedClaims(claims, tokens = {}) {
                        if (!isPlainObject(claims)) {
                            throw new TypeError(
                                'claims argument must be a plain object'
                            )
                        }

                        if (!isPlainObject(claims._claim_sources)) {
                            return claims
                        }

                        if (!isPlainObject(claims._claim_names)) {
                            return claims
                        }

                        const distributedSources = Object.entries(
                            claims._claim_sources
                        ).filter(([, value]) => value && value.endpoint)

                        await Promise.all(
                            distributedSources.map(
                                async ([sourceName, def]) => {
                                    try {
                                        const requestOpts = {
                                            headers: {
                                                Accept: 'application/jwt',
                                                Authorization: authorizationHeaderValue(
                                                    def.access_token ||
                                                        tokens[sourceName]
                                                )
                                            }
                                        }

                                        const response = await request.call(
                                            this,
                                            {
                                                ...requestOpts,
                                                method: 'GET',
                                                url: def.endpoint
                                            }
                                        )
                                        const body = processResponse(response, {
                                            bearer: true
                                        })

                                        const decoded = await claimJWT.call(
                                            this,
                                            'distributed',
                                            body
                                        )
                                        delete claims._claim_sources[sourceName]
                                        Object.entries(
                                            claims._claim_names
                                        ).forEach(
                                            assignClaim(
                                                claims,
                                                decoded,
                                                sourceName,
                                                false
                                            )
                                        )
                                    } catch (err) {
                                        err.src = sourceName
                                        throw err
                                    }
                                }
                            )
                        )

                        cleanUpClaims(claims)
                        return claims
                    }

                    /**
                     * @name unpackAggregatedClaims
                     * @api public
                     */
                    async unpackAggregatedClaims(claims) {
                        if (!isPlainObject(claims)) {
                            throw new TypeError(
                                'claims argument must be a plain object'
                            )
                        }

                        if (!isPlainObject(claims._claim_sources)) {
                            return claims
                        }

                        if (!isPlainObject(claims._claim_names)) {
                            return claims
                        }

                        const aggregatedSources = Object.entries(
                            claims._claim_sources
                        ).filter(([, value]) => value && value.JWT)

                        await Promise.all(
                            aggregatedSources.map(async ([sourceName, def]) => {
                                try {
                                    const decoded = await claimJWT.call(
                                        this,
                                        'aggregated',
                                        def.JWT
                                    )
                                    delete claims._claim_sources[sourceName]
                                    Object.entries(claims._claim_names).forEach(
                                        assignClaim(claims, decoded, sourceName)
                                    )
                                } catch (err) {
                                    err.src = sourceName
                                    throw err
                                }
                            })
                        )

                        cleanUpClaims(claims)
                        return claims
                    }

                    /**
                     * @name register
                     * @api public
                     */
                    static async register(
                        properties,
                        { initialAccessToken, jwks } = {}
                    ) {
                        assertIssuerConfiguration(
                            this.issuer,
                            'registration_endpoint'
                        )

                        if (
                            jwks !== undefined &&
                            !(properties.jwks || properties.jwks_uri)
                        ) {
                            const keystore = getKeystore.call(this, jwks)
                            properties.jwks = keystore.toJWKS(false)
                        }

                        const response = await request.call(this, {
                            headers: initialAccessToken
                                ? {
                                      Authorization: authorizationHeaderValue(
                                          initialAccessToken
                                      )
                                  }
                                : undefined,
                            json: true,
                            body: properties,
                            url: this.issuer.registration_endpoint,
                            method: 'POST'
                        })
                        const responseBody = processResponse(response, {
                            statusCode: 201,
                            bearer: true
                        })

                        return new this(responseBody, jwks)
                    }

                    /**
                     * @name metadata
                     * @api public
                     */
                    get metadata() {
                        const copy = {}
                        instance(this)
                            .get('metadata')
                            .forEach((value, key) => {
                                copy[key] = value
                            })
                        return copy
                    }

                    /**
                     * @name fromUri
                     * @api public
                     */
                    static async fromUri(
                        registrationClientUri,
                        registrationAccessToken,
                        jwks
                    ) {
                        const response = await request.call(this, {
                            method: 'GET',
                            url: registrationClientUri,
                            json: true,
                            headers: {
                                Authorization: authorizationHeaderValue(
                                    registrationAccessToken
                                )
                            }
                        })
                        const responseBody = processResponse(response, {
                            bearer: true
                        })

                        return new this(responseBody, jwks)
                    }

                    /**
                     * @name requestObject
                     * @api public
                     */
                    async requestObject(requestObject = {}, algorithms = {}) {
                        if (!isPlainObject(requestObject)) {
                            throw new TypeError(
                                'requestObject must be a plain object'
                            )
                        }

                        defaults(
                            algorithms,
                            {
                                sign: this.request_object_signing_alg,
                                encrypt: {
                                    alg: this.request_object_encryption_alg,
                                    enc:
                                        this.request_object_encryption_enc ||
                                        'A128CBC-HS256'
                                }
                            },
                            {
                                sign: 'none'
                            }
                        )

                        let signed
                        let key

                        const alg = algorithms.sign
                        const header = { alg, typ: 'JWT' }
                        const payload = JSON.stringify(
                            defaults({}, requestObject, {
                                iss: this.client_id,
                                aud: this.issuer.issuer,
                                client_id: this.client_id,
                                jti: random(),
                                iat: now(),
                                exp: now() + 300
                            })
                        )

                        if (alg === 'none') {
                            signed = [
                                base64url.encode(JSON.stringify(header)),
                                base64url.encode(payload),
                                ''
                            ].join('.')
                        } else {
                            const symmetric = alg.startsWith('HS')
                            if (symmetric) {
                                key = await this.joseSecret()
                            } else {
                                const keystore = instance(this).get('keystore')

                                if (!keystore) {
                                    throw new TypeError(
                                        `no keystore present for client, cannot sign using alg ${alg}`
                                    )
                                }
                                key = keystore.get({ alg, use: 'sig' })
                                if (!key) {
                                    throw new TypeError(
                                        `no key to sign with found for alg ${alg}`
                                    )
                                }
                            }

                            signed = jose.JWS.sign(payload, key, {
                                ...header,
                                kid: symmetric ? undefined : key.kid
                            })
                        }

                        if (!algorithms.encrypt.alg) {
                            return signed
                        }

                        const fields = {
                            alg: algorithms.encrypt.alg,
                            enc: algorithms.encrypt.enc,
                            cty: 'JWT'
                        }

                        if (fields.alg.match(/^(RSA|ECDH)/)) {
                            ;[key] = await this.issuer.queryKeyStore(
                                {
                                    alg: fields.alg,
                                    enc: fields.enc,
                                    use: 'enc'
                                },
                                { allowMulti: true }
                            )
                        } else {
                            key = await this.joseSecret(
                                fields.alg === 'dir' ? fields.enc : fields.alg
                            )
                        }

                        return jose.JWE.encrypt(signed, key, {
                            ...fields,
                            kid: key.kty === 'oct' ? undefined : key.kid
                        })
                    }

                    /**
                     * @name issuer
                     * @api public
                     */
                    static get issuer() {
                        return issuer
                    }

                    /**
                     * @name issuer
                     * @api public
                     */
                    get issuer() {
                        // eslint-disable-line class-methods-use-this
                        return issuer
                    }

                    /* istanbul ignore next */
                    [inspect.custom]() {
                        return `${this.constructor.name} ${inspect(
                            this.metadata,
                            {
                                depth: Infinity,
                                colors: process.stdout.isTTY,
                                compact: false,
                                sorted: true
                            }
                        )}`
                    }
                }

            // TODO: remove in 4.x
            BaseClient.prototype.resource = deprecate(
                /* istanbul ignore next */
                async function resource(resourceUrl, accessToken, options) {
                    let token = accessToken
                    const opts = merge(
                        {
                            verb: 'GET',
                            via: 'header'
                        },
                        options
                    )

                    if (token instanceof TokenSet) {
                        if (!token.access_token) {
                            throw new TypeError(
                                'access_token not present in TokenSet'
                            )
                        }
                        opts.tokenType = opts.tokenType || token.token_type
                        token = token.access_token
                    }

                    const verb = String(opts.verb).toUpperCase()
                    let requestOpts

                    switch (opts.via) {
                        case 'query':
                            if (verb !== 'GET') {
                                throw new TypeError(
                                    'resource servers should only parse query strings for GET requests'
                                )
                            }
                            requestOpts = { query: { access_token: token } }
                            break
                        case 'body':
                            if (verb !== 'POST') {
                                throw new TypeError(
                                    'can only send body on POST'
                                )
                            }
                            requestOpts = {
                                form: true,
                                body: { access_token: token }
                            }
                            break
                        default:
                            requestOpts = {
                                headers: {
                                    Authorization: authorizationHeaderValue(
                                        token,
                                        opts.tokenType
                                    )
                                }
                            }
                    }

                    if (opts.params) {
                        if (verb === 'POST') {
                            defaultsDeep(requestOpts, { body: opts.params })
                        } else {
                            defaultsDeep(requestOpts, { query: opts.params })
                        }
                    }

                    if (opts.headers) {
                        defaultsDeep(requestOpts, { headers: opts.headers })
                    }

                    const mTLS = !!this
                        .tls_client_certificate_bound_access_tokens

                    return request.call(
                        this,
                        {
                            ...requestOpts,
                            encoding: null,
                            method: verb,
                            url: resourceUrl
                        },
                        { mTLS }
                    )
                },
                'client.resource() is deprecated, use client.requestResource() instead, see docs for API details'
            )

            module.exports.BaseClient = BaseClient

            /***/
        },

        /***/ Hsns: /***/ function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__('93I4')
            var document = __webpack_require__('5T2Y').document
            // typeof document.createElement is 'object' in old IE
            var is = isObject(document) && isObject(document.createElement)
            module.exports = function(it) {
                return is ? document.createElement(it) : {}
            }

            /***/
        },

        /***/ Hvzi: /***/ function(module, exports) {
            /**
             * Removes `key` and its value from the hash.
             *
             * @private
             * @name delete
             * @memberOf Hash
             * @param {Object} hash The hash to modify.
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key]
                this.size -= result ? 1 : 0
                return result
            }

            module.exports = hashDelete

            /***/
        },

        /***/ HwNo: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = function(Yallist) {
                Yallist.prototype[Symbol.iterator] = function*() {
                    for (let walker = this.head; walker; walker = walker.next) {
                        yield walker.value
                    }
                }
            }

            /***/
        },

        /***/ HyWp: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // A linked list to keep track of recently-used-ness
            const Yallist = __webpack_require__('XPeR')

            const MAX = Symbol('max')
            const LENGTH = Symbol('length')
            const LENGTH_CALCULATOR = Symbol('lengthCalculator')
            const ALLOW_STALE = Symbol('allowStale')
            const MAX_AGE = Symbol('maxAge')
            const DISPOSE = Symbol('dispose')
            const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
            const LRU_LIST = Symbol('lruList')
            const CACHE = Symbol('cache')
            const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

            const naiveLength = () => 1

            // lruList is a yallist where the head is the youngest
            // item, and the tail is the oldest.  the list contains the Hit
            // objects as the entries.
            // Each Hit object has a reference to its Yallist.Node.  This
            // never changes.
            //
            // cache is a Map (or PseudoMap) that matches the keys to
            // the Yallist.Node object.
            class LRUCache {
                constructor(options) {
                    if (typeof options === 'number') options = { max: options }

                    if (!options) options = {}

                    if (
                        options.max &&
                        (typeof options.max !== 'number' || options.max < 0)
                    )
                        throw new TypeError('max must be a non-negative number')
                    // Kind of weird to have a default max of Infinity, but oh well.
                    const max = (this[MAX] = options.max || Infinity)

                    const lc = options.length || naiveLength
                    this[LENGTH_CALCULATOR] =
                        typeof lc !== 'function' ? naiveLength : lc
                    this[ALLOW_STALE] = options.stale || false
                    if (options.maxAge && typeof options.maxAge !== 'number')
                        throw new TypeError('maxAge must be a number')
                    this[MAX_AGE] = options.maxAge || 0
                    this[DISPOSE] = options.dispose
                    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
                    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
                    this.reset()
                }

                // resize the cache when the max changes.
                set max(mL) {
                    if (typeof mL !== 'number' || mL < 0)
                        throw new TypeError('max must be a non-negative number')

                    this[MAX] = mL || Infinity
                    trim(this)
                }
                get max() {
                    return this[MAX]
                }

                set allowStale(allowStale) {
                    this[ALLOW_STALE] = !!allowStale
                }
                get allowStale() {
                    return this[ALLOW_STALE]
                }

                set maxAge(mA) {
                    if (typeof mA !== 'number')
                        throw new TypeError(
                            'maxAge must be a non-negative number'
                        )

                    this[MAX_AGE] = mA
                    trim(this)
                }
                get maxAge() {
                    return this[MAX_AGE]
                }

                // resize the cache when the lengthCalculator changes.
                set lengthCalculator(lC) {
                    if (typeof lC !== 'function') lC = naiveLength

                    if (lC !== this[LENGTH_CALCULATOR]) {
                        this[LENGTH_CALCULATOR] = lC
                        this[LENGTH] = 0
                        this[LRU_LIST].forEach(hit => {
                            hit.length = this[LENGTH_CALCULATOR](
                                hit.value,
                                hit.key
                            )
                            this[LENGTH] += hit.length
                        })
                    }
                    trim(this)
                }
                get lengthCalculator() {
                    return this[LENGTH_CALCULATOR]
                }

                get length() {
                    return this[LENGTH]
                }
                get itemCount() {
                    return this[LRU_LIST].length
                }

                rforEach(fn, thisp) {
                    thisp = thisp || this
                    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
                        const prev = walker.prev
                        forEachStep(this, fn, walker, thisp)
                        walker = prev
                    }
                }

                forEach(fn, thisp) {
                    thisp = thisp || this
                    for (let walker = this[LRU_LIST].head; walker !== null; ) {
                        const next = walker.next
                        forEachStep(this, fn, walker, thisp)
                        walker = next
                    }
                }

                keys() {
                    return this[LRU_LIST].toArray().map(k => k.key)
                }

                values() {
                    return this[LRU_LIST].toArray().map(k => k.value)
                }

                reset() {
                    if (
                        this[DISPOSE] &&
                        this[LRU_LIST] &&
                        this[LRU_LIST].length
                    ) {
                        this[LRU_LIST].forEach(hit =>
                            this[DISPOSE](hit.key, hit.value)
                        )
                    }

                    this[CACHE] = new Map() // hash of items by key
                    this[LRU_LIST] = new Yallist() // list of items in order of use recency
                    this[LENGTH] = 0 // length of items in the list
                }

                dump() {
                    return this[LRU_LIST].map(hit =>
                        isStale(this, hit)
                            ? false
                            : {
                                  k: hit.key,
                                  v: hit.value,
                                  e: hit.now + (hit.maxAge || 0)
                              }
                    )
                        .toArray()
                        .filter(h => h)
                }

                dumpLru() {
                    return this[LRU_LIST]
                }

                set(key, value, maxAge) {
                    maxAge = maxAge || this[MAX_AGE]

                    if (maxAge && typeof maxAge !== 'number')
                        throw new TypeError('maxAge must be a number')

                    const now = maxAge ? Date.now() : 0
                    const len = this[LENGTH_CALCULATOR](value, key)

                    if (this[CACHE].has(key)) {
                        if (len > this[MAX]) {
                            del(this, this[CACHE].get(key))
                            return false
                        }

                        const node = this[CACHE].get(key)
                        const item = node.value

                        // dispose of the old one before overwriting
                        // split out into 2 ifs for better coverage tracking
                        if (this[DISPOSE]) {
                            if (!this[NO_DISPOSE_ON_SET])
                                this[DISPOSE](key, item.value)
                        }

                        item.now = now
                        item.maxAge = maxAge
                        item.value = value
                        this[LENGTH] += len - item.length
                        item.length = len
                        this.get(key)
                        trim(this)
                        return true
                    }

                    const hit = new Entry(key, value, len, now, maxAge)

                    // oversized objects fall out of cache automatically.
                    if (hit.length > this[MAX]) {
                        if (this[DISPOSE]) this[DISPOSE](key, value)

                        return false
                    }

                    this[LENGTH] += hit.length
                    this[LRU_LIST].unshift(hit)
                    this[CACHE].set(key, this[LRU_LIST].head)
                    trim(this)
                    return true
                }

                has(key) {
                    if (!this[CACHE].has(key)) return false
                    const hit = this[CACHE].get(key).value
                    return !isStale(this, hit)
                }

                get(key) {
                    return get(this, key, true)
                }

                peek(key) {
                    return get(this, key, false)
                }

                pop() {
                    const node = this[LRU_LIST].tail
                    if (!node) return null

                    del(this, node)
                    return node.value
                }

                del(key) {
                    del(this, this[CACHE].get(key))
                }

                load(arr) {
                    // reset the cache
                    this.reset()

                    const now = Date.now()
                    // A previous serialized cache has the most recent items first
                    for (let l = arr.length - 1; l >= 0; l--) {
                        const hit = arr[l]
                        const expiresAt = hit.e || 0
                        if (expiresAt === 0)
                            // the item was created without expiration in a non aged cache
                            this.set(hit.k, hit.v)
                        else {
                            const maxAge = expiresAt - now
                            // dont add already expired items
                            if (maxAge > 0) {
                                this.set(hit.k, hit.v, maxAge)
                            }
                        }
                    }
                }

                prune() {
                    this[CACHE].forEach((value, key) => get(this, key, false))
                }
            }

            const get = (self, key, doUse) => {
                const node = self[CACHE].get(key)
                if (node) {
                    const hit = node.value
                    if (isStale(self, hit)) {
                        del(self, node)
                        if (!self[ALLOW_STALE]) return undefined
                    } else {
                        if (doUse) {
                            if (self[UPDATE_AGE_ON_GET])
                                node.value.now = Date.now()
                            self[LRU_LIST].unshiftNode(node)
                        }
                    }
                    return hit.value
                }
            }

            const isStale = (self, hit) => {
                if (!hit || (!hit.maxAge && !self[MAX_AGE])) return false

                const diff = Date.now() - hit.now
                return hit.maxAge
                    ? diff > hit.maxAge
                    : self[MAX_AGE] && diff > self[MAX_AGE]
            }

            const trim = self => {
                if (self[LENGTH] > self[MAX]) {
                    for (
                        let walker = self[LRU_LIST].tail;
                        self[LENGTH] > self[MAX] && walker !== null;

                    ) {
                        // We know that we're about to delete this one, and also
                        // what the next least recently used key will be, so just
                        // go ahead and set it now.
                        const prev = walker.prev
                        del(self, walker)
                        walker = prev
                    }
                }
            }

            const del = (self, node) => {
                if (node) {
                    const hit = node.value
                    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value)

                    self[LENGTH] -= hit.length
                    self[CACHE].delete(hit.key)
                    self[LRU_LIST].removeNode(node)
                }
            }

            class Entry {
                constructor(key, value, length, now, maxAge) {
                    this.key = key
                    this.value = value
                    this.length = length
                    this.now = now
                    this.maxAge = maxAge || 0
                }
            }

            const forEachStep = (self, fn, node, thisp) => {
                let hit = node.value
                if (isStale(self, hit)) {
                    del(self, node)
                    if (!self[ALLOW_STALE]) hit = undefined
                }
                if (hit) fn.call(thisp, hit.value, hit.key, self)
            }

            module.exports = LRUCache

            /***/
        },

        /***/ I01J: /***/ function(module, exports, __webpack_require__) {
            var memoize = __webpack_require__('44Ds')

            /** Used as the maximum memoize cache size. */
            var MAX_MEMOIZE_SIZE = 500

            /**
             * A specialized version of `_.memoize` which clears the memoized function's
             * cache when it exceeds `MAX_MEMOIZE_SIZE`.
             *
             * @private
             * @param {Function} func The function to have its output memoized.
             * @returns {Function} Returns the new memoized function.
             */
            function memoizeCapped(func) {
                var result = memoize(func, function(key) {
                    if (cache.size === MAX_MEMOIZE_SIZE) {
                        cache.clear()
                    }
                    return key
                })

                var cache = result.cache
                return result
            }

            module.exports = memoizeCapped

            /***/
        },

        /***/ IOzZ: /***/ function(module, exports) {
            /**
             * A specialized version of `matchesProperty` for source values suitable
             * for strict equality comparisons, i.e. `===`.
             *
             * @private
             * @param {string} key The key of the property to get.
             * @param {*} srcValue The value to match.
             * @returns {Function} Returns the new spec function.
             */
            function matchesStrictComparable(key, srcValue) {
                return function(object) {
                    if (object == null) {
                        return false
                    }
                    return (
                        object[key] === srcValue &&
                        (srcValue !== undefined || key in Object(object))
                    )
                }
            }

            module.exports = matchesStrictComparable

            /***/
        },

        /***/ IWF7: /***/ function(module, exports, __webpack_require__) {
            const { createHmac } = __webpack_require__('PJMN')

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const timingSafeEqual = __webpack_require__('kuaU')
            const resolveNodeAlg = __webpack_require__('uGJc')
            const { asInput } = __webpack_require__('1ALl')

            const sign = (
                jwaAlg,
                hmacAlg,
                { [KEYOBJECT]: keyObject },
                payload
            ) => {
                const hmac = createHmac(hmacAlg, asInput(keyObject, false))
                hmac.update(payload)
                return hmac.digest()
            }

            const verify = (jwaAlg, hmacAlg, key, payload, signature) => {
                const expected = sign(jwaAlg, hmacAlg, key, payload)
                const actual = signature

                return timingSafeEqual(actual, expected)
            }

            module.exports = (JWA, JWK) => {
                ;['HS256', 'HS384', 'HS512'].forEach(jwaAlg => {
                    const hmacAlg = resolveNodeAlg(jwaAlg)
                    JWA.sign.set(jwaAlg, sign.bind(undefined, jwaAlg, hmacAlg))
                    JWA.verify.set(
                        jwaAlg,
                        verify.bind(undefined, jwaAlg, hmacAlg)
                    )
                    JWK.oct.sign[jwaAlg] = JWK.oct.verify[jwaAlg] = key =>
                        key.use === 'sig' || key.use === undefined
                })
            }

            /***/
        },

        /***/ IgmS: /***/ function(module, exports, __webpack_require__) {
            const base64url = __webpack_require__('+00W')
            const assign = __webpack_require__('3OWR')

            const now = __webpack_require__('PbSP')

            class TokenSet {
                /**
                 * @name constructor
                 * @api public
                 */
                constructor(values) {
                    assign(this, values)
                }

                /**
                 * @name expires_in=
                 * @api public
                 */
                set expires_in(value) {
                    // eslint-disable-line camelcase
                    this.expires_at = now() + Number(value)
                }

                /**
                 * @name expires_in
                 * @api public
                 */
                get expires_in() {
                    // eslint-disable-line camelcase
                    return Math.max.apply(null, [this.expires_at - now(), 0])
                }

                /**
                 * @name expired
                 * @api public
                 */
                expired() {
                    return this.expires_in === 0
                }

                /**
                 * @name claims
                 * @api public
                 */
                claims() {
                    if (!this.id_token) {
                        throw new TypeError('id_token not present in TokenSet')
                    }

                    return JSON.parse(
                        base64url.decode(this.id_token.split('.')[1])
                    )
                }
            }

            module.exports = TokenSet

            /***/
        },

        /***/ Ioao: /***/ function(module, exports, __webpack_require__) {
            var apply = __webpack_require__('heNW')

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeMax = Math.max

            /**
             * A specialized version of `baseRest` which transforms the rest array.
             *
             * @private
             * @param {Function} func The function to apply a rest parameter to.
             * @param {number} [start=func.length-1] The start position of the rest parameter.
             * @param {Function} transform The rest array transform.
             * @returns {Function} Returns the new function.
             */
            function overRest(func, start, transform) {
                start = nativeMax(
                    start === undefined ? func.length - 1 : start,
                    0
                )
                return function() {
                    var args = arguments,
                        index = -1,
                        length = nativeMax(args.length - start, 0),
                        array = Array(length)

                    while (++index < length) {
                        array[index] = args[start + index]
                    }
                    index = -1
                    var otherArgs = Array(start + 1)
                    while (++index < start) {
                        otherArgs[index] = args[index]
                    }
                    otherArgs[start] = transform(array)
                    return apply(func, this, otherArgs)
                }
            }

            module.exports = overRest

            /***/
        },

        /***/ Itc5: /***/ function(
            module,
            __webpack_exports__,
            __webpack_require__
        ) {
            'use strict'
            __webpack_require__.r(__webpack_exports__)
            /* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                'bzos'
            )
            /* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
                url__WEBPACK_IMPORTED_MODULE_0__
            )
            /* harmony import */ var next_dist_next_server_server_api_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                'PCLx'
            )
            /* harmony import */ var next_dist_next_server_server_api_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
                next_dist_next_server_server_api_utils__WEBPACK_IMPORTED_MODULE_1__
            )
            /* harmony import */ var next_plugin_loader_middleware_on_init_server___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
                'GX0O'
            )
            /* harmony import */ var next_plugin_loader_middleware_on_error_server___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
                'KqAr'
            )

            /* harmony default export */ __webpack_exports__[
                'default'
            ] = async (req, res) => {
                try {
                    await Object(
                        next_plugin_loader_middleware_on_init_server___WEBPACK_IMPORTED_MODULE_2__[
                            'default'
                        ]
                    )()
                    const params = {}
                    const resolver = __webpack_require__('6U0C')
                    Object(
                        next_dist_next_server_server_api_utils__WEBPACK_IMPORTED_MODULE_1__[
                            'apiResolver'
                        ]
                    )(
                        req,
                        res,
                        params,
                        resolver,
                        next_plugin_loader_middleware_on_error_server___WEBPACK_IMPORTED_MODULE_3__[
                            'default'
                        ]
                    )
                } catch (err) {
                    console.error(err)
                    await Object(
                        next_plugin_loader_middleware_on_error_server___WEBPACK_IMPORTED_MODULE_3__[
                            'default'
                        ]
                    )(err)
                    res.statusCode = 500
                    res.end('Internal Server Error')
                }
            }

            /***/
        },

        /***/ J0Hf: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            function sessionHandler(sessionStore) {
                return req => {
                    if (!req) {
                        throw new Error('Request is not available')
                    }
                    return sessionStore.read(req)
                }
            }
            exports.default = sessionHandler
            //# sourceMappingURL=session.js.map

            /***/
        },

        /***/ JBE3: /***/ function(module, exports, __webpack_require__) {
            var baseMerge = __webpack_require__('+Qka'),
                createAssigner = __webpack_require__('LsHQ')

            /**
             * This method is like `_.merge` except that it accepts `customizer` which
             * is invoked to produce the merged values of the destination and source
             * properties. If `customizer` returns `undefined`, merging is handled by the
             * method instead. The `customizer` is invoked with six arguments:
             * (objValue, srcValue, key, object, source, stack).
             *
             * **Note:** This method mutates `object`.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Object
             * @param {Object} object The destination object.
             * @param {...Object} sources The source objects.
             * @param {Function} customizer The function to customize assigned values.
             * @returns {Object} Returns `object`.
             * @example
             *
             * function customizer(objValue, srcValue) {
             *   if (_.isArray(objValue)) {
             *     return objValue.concat(srcValue);
             *   }
             * }
             *
             * var object = { 'a': [1], 'b': [2] };
             * var other = { 'a': [3], 'b': [4] };
             *
             * _.mergeWith(object, other, customizer);
             * // => { 'a': [1, 3], 'b': [2, 4] }
             */
            var mergeWith = createAssigner(function(
                object,
                source,
                srcIndex,
                customizer
            ) {
                baseMerge(object, source, srcIndex, customizer)
            })

            module.exports = mergeWith

            /***/
        },

        /***/ JHRd: /***/ function(module, exports, __webpack_require__) {
            var root = __webpack_require__('Kz5y')

            /** Built-in value references. */
            var Uint8Array = root.Uint8Array

            module.exports = Uint8Array

            /***/
        },

        /***/ JHgL: /***/ function(module, exports, __webpack_require__) {
            var getMapData = __webpack_require__('QkVE')

            /**
             * Gets the map value for `key`.
             *
             * @private
             * @name get
             * @memberOf MapCache
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function mapCacheGet(key) {
                return getMapData(this, key).get(key)
            }

            module.exports = mapCacheGet

            /***/
        },

        /***/ JSQU: /***/ function(module, exports, __webpack_require__) {
            var nativeCreate = __webpack_require__('YESw')

            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__'

            /**
             * Sets the hash `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf Hash
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the hash instance.
             */
            function hashSet(key, value) {
                var data = this.__data__
                this.size += this.has(key) ? 0 : 1
                data[key] =
                    nativeCreate && value === undefined ? HASH_UNDEFINED : value
                return this
            }

            module.exports = hashSet

            /***/
        },

        /***/ JTzB: /***/ function(module, exports, __webpack_require__) {
            var baseGetTag = __webpack_require__('NykK'),
                isObjectLike = __webpack_require__('ExA7')

            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]'

            /**
             * The base implementation of `_.isArguments`.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an `arguments` object,
             */
            function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag
            }

            module.exports = baseIsArguments

            /***/
        },

        /***/ 'JlL/': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = [
                'beforeError',
                'init',
                'beforeRequest',
                'beforeRedirect',
                'beforeRetry',
                'afterResponse'
            ]

            /***/
        },

        /***/ Juji: /***/ function(module, exports) {
            /**
             * The base implementation of `_.hasIn` without support for deep paths.
             *
             * @private
             * @param {Object} [object] The object to query.
             * @param {Array|string} key The key to check.
             * @returns {boolean} Returns `true` if `key` exists, else `false`.
             */
            function baseHasIn(object, key) {
                return object != null && key in Object(object)
            }

            module.exports = baseHasIn

            /***/
        },

        /***/ JwZZ: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var Buffer = __webpack_require__('NkYg').Buffer,
                Transform = __webpack_require__('msIP').Transform

            // == Exports ==================================================================
            module.exports = function(iconv) {
                // Additional Public API.
                iconv.encodeStream = function encodeStream(encoding, options) {
                    return new IconvLiteEncoderStream(
                        iconv.getEncoder(encoding, options),
                        options
                    )
                }

                iconv.decodeStream = function decodeStream(encoding, options) {
                    return new IconvLiteDecoderStream(
                        iconv.getDecoder(encoding, options),
                        options
                    )
                }

                iconv.supportsStreams = true

                // Not published yet.
                iconv.IconvLiteEncoderStream = IconvLiteEncoderStream
                iconv.IconvLiteDecoderStream = IconvLiteDecoderStream
                iconv._collect = IconvLiteDecoderStream.prototype.collect
            }

            // == Encoder stream =======================================================
            function IconvLiteEncoderStream(conv, options) {
                this.conv = conv
                options = options || {}
                options.decodeStrings = false // We accept only strings, so we don't need to decode them.
                Transform.call(this, options)
            }

            IconvLiteEncoderStream.prototype = Object.create(
                Transform.prototype,
                {
                    constructor: { value: IconvLiteEncoderStream }
                }
            )

            IconvLiteEncoderStream.prototype._transform = function(
                chunk,
                encoding,
                done
            ) {
                if (typeof chunk != 'string')
                    return done(
                        new Error(
                            'Iconv encoding stream needs strings as its input.'
                        )
                    )
                try {
                    var res = this.conv.write(chunk)
                    if (res && res.length) this.push(res)
                    done()
                } catch (e) {
                    done(e)
                }
            }

            IconvLiteEncoderStream.prototype._flush = function(done) {
                try {
                    var res = this.conv.end()
                    if (res && res.length) this.push(res)
                    done()
                } catch (e) {
                    done(e)
                }
            }

            IconvLiteEncoderStream.prototype.collect = function(cb) {
                var chunks = []
                this.on('error', cb)
                this.on('data', function(chunk) {
                    chunks.push(chunk)
                })
                this.on('end', function() {
                    cb(null, Buffer.concat(chunks))
                })
                return this
            }

            // == Decoder stream =======================================================
            function IconvLiteDecoderStream(conv, options) {
                this.conv = conv
                options = options || {}
                options.encoding = this.encoding = 'utf8' // We output strings.
                Transform.call(this, options)
            }

            IconvLiteDecoderStream.prototype = Object.create(
                Transform.prototype,
                {
                    constructor: { value: IconvLiteDecoderStream }
                }
            )

            IconvLiteDecoderStream.prototype._transform = function(
                chunk,
                encoding,
                done
            ) {
                if (!Buffer.isBuffer(chunk))
                    return done(
                        new Error(
                            'Iconv decoding stream needs buffers as its input.'
                        )
                    )
                try {
                    var res = this.conv.write(chunk)
                    if (res && res.length) this.push(res, this.encoding)
                    done()
                } catch (e) {
                    done(e)
                }
            }

            IconvLiteDecoderStream.prototype._flush = function(done) {
                try {
                    var res = this.conv.end()
                    if (res && res.length) this.push(res, this.encoding)
                    done()
                } catch (e) {
                    done(e)
                }
            }

            IconvLiteDecoderStream.prototype.collect = function(cb) {
                var res = ''
                this.on('error', cb)
                this.on('data', function(chunk) {
                    res += chunk
                })
                this.on('end', function() {
                    cb(null, res)
                })
                return this
            }

            /***/
        },

        /***/ K0QS: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { Transform } = __webpack_require__('msIP')

            module.exports = {
                download(response, emitter, downloadBodySize) {
                    let downloaded = 0

                    return new Transform({
                        transform(chunk, encoding, callback) {
                            downloaded += chunk.length

                            const percent = downloadBodySize
                                ? downloaded / downloadBodySize
                                : 0

                            // Let `flush()` be responsible for emitting the last event
                            if (percent < 1) {
                                emitter.emit('downloadProgress', {
                                    percent,
                                    transferred: downloaded,
                                    total: downloadBodySize
                                })
                            }

                            callback(null, chunk)
                        },

                        flush(callback) {
                            emitter.emit('downloadProgress', {
                                percent: 1,
                                transferred: downloaded,
                                total: downloadBodySize
                            })

                            callback()
                        }
                    })
                },

                upload(request, emitter, uploadBodySize) {
                    const uploadEventFrequency = 150
                    let uploaded = 0
                    let progressInterval

                    emitter.emit('uploadProgress', {
                        percent: 0,
                        transferred: 0,
                        total: uploadBodySize
                    })

                    request.once('error', () => {
                        clearInterval(progressInterval)
                    })

                    request.once('response', () => {
                        clearInterval(progressInterval)

                        emitter.emit('uploadProgress', {
                            percent: 1,
                            transferred: uploaded,
                            total: uploadBodySize
                        })
                    })

                    request.once('socket', socket => {
                        const onSocketConnect = () => {
                            progressInterval = setInterval(() => {
                                const lastUploaded = uploaded
                                /* istanbul ignore next: see #490 (occurs randomly!) */
                                const headersSize = request._header
                                    ? Buffer.byteLength(request._header)
                                    : 0
                                uploaded = socket.bytesWritten - headersSize

                                // Don't emit events with unchanged progress and
                                // prevent last event from being emitted, because
                                // it's emitted when `response` is emitted
                                if (
                                    uploaded === lastUploaded ||
                                    uploaded === uploadBodySize
                                ) {
                                    return
                                }

                                emitter.emit('uploadProgress', {
                                    percent: uploadBodySize
                                        ? uploaded / uploadBodySize
                                        : 0,
                                    transferred: uploaded,
                                    total: uploadBodySize
                                })
                            }, uploadEventFrequency)
                        }

                        /* istanbul ignore next: hard to test */
                        if (socket.connecting) {
                            socket.once('connect', onSocketConnect)
                        } else if (socket.writable) {
                            // The socket is being reused from pool,
                            // so the connect event will not be emitted
                            onSocketConnect()
                        }
                    })
                }
            }

            /***/
        },

        /***/ KEll: /***/ function(module, exports) {
            module.exports = require('http')

            /***/
        },

        /***/ KMkd: /***/ function(module, exports) {
            /**
             * Removes all key-value entries from the list cache.
             *
             * @private
             * @name clear
             * @memberOf ListCache
             */
            function listCacheClear() {
                this.__data__ = []
                this.size = 0
            }

            module.exports = listCacheClear

            /***/
        },

        /***/ KQbz: /***/ function(module, exports) {
            module.exports = (a = {}, b = {}) => {
                const keysA = Object.keys(a)
                const keysB = new Set(Object.keys(b))
                return !keysA.some(ka => keysB.has(ka))
            }

            /***/
        },

        /***/ KUxP: /***/ function(module, exports) {
            module.exports = function(exec) {
                try {
                    return !!exec()
                } catch (e) {
                    return true
                }
            }

            /***/
        },

        /***/ KfNM: /***/ function(module, exports) {
            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var nativeObjectToString = objectProto.toString

            /**
             * Converts `value` to a string using `Object.prototype.toString`.
             *
             * @private
             * @param {*} value The value to convert.
             * @returns {string} Returns the converted string.
             */
            function objectToString(value) {
                return nativeObjectToString.call(value)
            }

            module.exports = objectToString

            /***/
        },

        /***/ KqAr: /***/ function(
            module,
            __webpack_exports__,
            __webpack_require__
        ) {
            'use strict'
            __webpack_require__.r(__webpack_exports__)

            /* harmony default export */ __webpack_exports__[
                'default'
            ] = function(ctx) {
                return Promise.all([])
            }

            /***/
        },

        /***/ KqF2: /***/ function(module, exports) {
            module.exports = new Map([
                ['A128CBC-HS256', 128],
                ['A128GCM', 96],
                ['A128GCMKW', 96],
                ['A192CBC-HS384', 128],
                ['A192GCM', 96],
                ['A192GCMKW', 96],
                ['A256CBC-HS512', 128],
                ['A256GCM', 96],
                ['A256GCMKW', 96]
            ])

            /***/
        },

        /***/ Kz5y: /***/ function(module, exports, __webpack_require__) {
            var freeGlobal = __webpack_require__('WFqU')

            /** Detect free variable `self`. */
            var freeSelf =
                typeof self == 'object' &&
                self &&
                self.Object === Object &&
                self

            /** Used as a reference to the global object. */
            var root = freeGlobal || freeSelf || Function('return this')()

            module.exports = root

            /***/
        },

        /***/ L71r: /***/ function(module, exports, __webpack_require__) {
            /* eslint-disable camelcase */
            const { format } = __webpack_require__('jK02')

            const assign = __webpack_require__('3OWR')
            const makeError = __webpack_require__('b1HN')

            function OPError(
                {
                    error_description,
                    error,
                    error_uri,
                    session_state,
                    state,
                    scope
                },
                response
            ) {
                OPError.super.call(
                    this,
                    !error_description
                        ? error
                        : `${error} (${error_description})`
                )

                assign(
                    this,
                    { error },
                    error_description && { error_description },
                    error_uri && { error_uri },
                    state && { state },
                    scope && { scope },
                    session_state && { session_state }
                )

                if (response) {
                    Object.defineProperty(this, 'response', {
                        value: response
                    })
                }
            }

            makeError(OPError)

            function RPError(...args) {
                if (typeof args[0] === 'string') {
                    RPError.super.call(this, format(...args))
                } else {
                    const { message, printf, response, ...rest } = args[0]
                    if (printf) {
                        RPError.super.call(this, format(...printf))
                    } else {
                        RPError.super.call(this, message)
                    }
                    assign(this, rest)
                    if (response) {
                        Object.defineProperty(this, 'response', {
                            value: response
                        })
                    }
                }
            }

            makeError(RPError)

            module.exports = {
                OPError,
                RPError
            }

            /***/
        },

        /***/ L8xA: /***/ function(module, exports) {
            /**
             * Removes `key` and its value from the stack.
             *
             * @private
             * @name delete
             * @memberOf Stack
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function stackDelete(key) {
                var data = this.__data__,
                    result = data['delete'](key)

                this.size = data.size
                return result
            }

            module.exports = stackDelete

            /***/
        },

        /***/ LDEB: /***/ function(module, exports, __webpack_require__) {
            const errors = __webpack_require__('yt7c')

            const importKey = __webpack_require__('GhER')

            const RSAKey = __webpack_require__('RoCg')
            const ECKey = __webpack_require__('3HlQ')
            const OKPKey = __webpack_require__('vC2k')
            const OctKey = __webpack_require__('BBt9')

            const generate = async (
                kty,
                crvOrSize,
                params,
                generatePrivate = true
            ) => {
                switch (kty) {
                    case 'RSA':
                        return importKey(
                            await RSAKey.generate(crvOrSize, generatePrivate),
                            params
                        )
                    case 'EC':
                        return importKey(
                            await ECKey.generate(crvOrSize, generatePrivate),
                            params
                        )
                    case 'OKP':
                        return importKey(
                            await OKPKey.generate(crvOrSize, generatePrivate),
                            params
                        )
                    case 'oct':
                        return importKey(
                            await OctKey.generate(crvOrSize, generatePrivate),
                            params
                        )
                    default:
                        throw new errors.JOSENotSupported(
                            `unsupported key type: ${kty}`
                        )
                }
            }

            const generateSync = (
                kty,
                crvOrSize,
                params,
                generatePrivate = true
            ) => {
                switch (kty) {
                    case 'RSA':
                        return importKey(
                            RSAKey.generateSync(crvOrSize, generatePrivate),
                            params
                        )
                    case 'EC':
                        return importKey(
                            ECKey.generateSync(crvOrSize, generatePrivate),
                            params
                        )
                    case 'OKP':
                        return importKey(
                            OKPKey.generateSync(crvOrSize, generatePrivate),
                            params
                        )
                    case 'oct':
                        return importKey(
                            OctKey.generateSync(crvOrSize, generatePrivate),
                            params
                        )
                    default:
                        throw new errors.JOSENotSupported(
                            `unsupported key type: ${kty}`
                        )
                }
            }

            module.exports.generate = generate
            module.exports.generateSync = generateSync

            /***/
        },

        /***/ LMPv: /***/ function(module, exports, __webpack_require__) {
            /* eslint-disable camelcase */
            const { inspect } = __webpack_require__('jK02')

            const { RPError, OPError } = __webpack_require__('L71r')
            const instance = __webpack_require__('0pkK')
            const now = __webpack_require__('PbSP')
            const { authenticatedPost } = __webpack_require__('/JKO')
            const processResponse = __webpack_require__('WeJA')
            const TokenSet = __webpack_require__('IgmS')

            class DeviceFlowHandle {
                constructor({
                    client,
                    exchangeBody,
                    clientAssertionPayload,
                    response,
                    maxAge
                }) {
                    ;['verification_uri', 'user_code', 'device_code'].forEach(
                        prop => {
                            if (
                                typeof response[prop] !== 'string' ||
                                !response[prop]
                            ) {
                                throw new RPError(
                                    `expected ${prop} string to be returned by Device Authorization Response, got %j`,
                                    response[prop]
                                )
                            }
                        }
                    )

                    if (!Number.isSafeInteger(response.expires_in)) {
                        throw new RPError(
                            'expected expires_in number to be returned by Device Authorization Response, got %j',
                            response.expires_in
                        )
                    }

                    instance(this).expires_at = now() + response.expires_in
                    instance(this).client = client
                    instance(this).maxAge = maxAge
                    instance(this).exchangeBody = exchangeBody
                    instance(
                        this
                    ).clientAssertionPayload = clientAssertionPayload
                    instance(this).response = response
                    instance(this).interval = response.interval * 1000 || 5000
                }

                async poll() {
                    if (this.expired()) {
                        throw new RPError(
                            'the device code %j has expired and the device authorization session has concluded',
                            this.device_code
                        )
                    }

                    await new Promise(resolve =>
                        setTimeout(resolve, instance(this).interval)
                    )

                    const response = await authenticatedPost.call(
                        instance(this).client,
                        'token',
                        {
                            form: true,
                            body: {
                                ...instance(this).exchangeBody,
                                grant_type:
                                    'urn:ietf:params:oauth:grant-type:device_code',
                                device_code: this.device_code
                            },
                            json: true
                        },
                        {
                            clientAssertionPayload: instance(this)
                                .clientAssertionPayload
                        }
                    )

                    let responseBody
                    try {
                        responseBody = processResponse(response)
                    } catch (err) {
                        switch (err instanceof OPError && err.error) {
                            case 'slow_down':
                                instance(this).interval += 5000
                            case 'authorization_pending': // eslint-disable-line no-fallthrough
                                return this.poll()
                            default:
                                throw err
                        }
                    }

                    const tokenset = new TokenSet(responseBody)

                    if ('id_token' in tokenset) {
                        await instance(this).client.decryptIdToken(tokenset)
                        await instance(this).client.validateIdToken(
                            tokenset,
                            undefined,
                            'token',
                            instance(this).maxAge
                        )
                    }

                    return tokenset
                }

                get device_code() {
                    return instance(this).response.device_code
                }

                get user_code() {
                    return instance(this).response.user_code
                }

                get verification_uri() {
                    return instance(this).response.verification_uri
                }

                get verification_uri_complete() {
                    return instance(this).response.verification_uri_complete
                }

                get expires_in() {
                    return Math.max.apply(null, [
                        instance(this).expires_at - now(),
                        0
                    ])
                }

                expired() {
                    return this.expires_in === 0
                }

                /* istanbul ignore next */
                [inspect.custom]() {
                    return `${this.constructor.name} ${inspect(
                        instance(this).response,
                        {
                            depth: Infinity,
                            colors: process.stdout.isTTY,
                            compact: false,
                            sorted: true
                        }
                    )}`
                }
            }

            module.exports = DeviceFlowHandle

            /***/
        },

        /***/ LXxW: /***/ function(module, exports) {
            /**
             * A specialized version of `_.filter` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {Array} Returns the new filtered array.
             */
            function arrayFilter(array, predicate) {
                var index = -1,
                    length = array == null ? 0 : array.length,
                    resIndex = 0,
                    result = []

                while (++index < length) {
                    var value = array[index]
                    if (predicate(value, index, array)) {
                        result[resIndex++] = value
                    }
                }
                return result
            }

            module.exports = arrayFilter

            /***/
        },

        /***/ LZmR: /***/ function(module, exports) {
            module.exports = function pick(object, ...paths) {
                const obj = {}
                for (const path of paths) {
                    // eslint-disable-line no-restricted-syntax
                    if (object[path]) {
                        obj[path] = object[path]
                    }
                }
                return obj
            }

            /***/
        },

        /***/ LcsW: /***/ function(module, exports, __webpack_require__) {
            var overArg = __webpack_require__('kekF')

            /** Built-in value references. */
            var getPrototype = overArg(Object.getPrototypeOf, Object)

            module.exports = getPrototype

            /***/
        },

        /***/ LsHQ: /***/ function(module, exports, __webpack_require__) {
            var baseRest = __webpack_require__('EA7m'),
                isIterateeCall = __webpack_require__('mv/X')

            /**
             * Creates a function like `_.assign`.
             *
             * @private
             * @param {Function} assigner The function to assign values.
             * @returns {Function} Returns the new assigner function.
             */
            function createAssigner(assigner) {
                return baseRest(function(object, sources) {
                    var index = -1,
                        length = sources.length,
                        customizer =
                            length > 1 ? sources[length - 1] : undefined,
                        guard = length > 2 ? sources[2] : undefined

                    customizer =
                        assigner.length > 3 && typeof customizer == 'function'
                            ? (length--, customizer)
                            : undefined

                    if (
                        guard &&
                        isIterateeCall(sources[0], sources[1], guard)
                    ) {
                        customizer = length < 3 ? undefined : customizer
                        length = 1
                    }
                    object = Object(object)
                    while (++index < length) {
                        var source = sources[index]
                        if (source) {
                            assigner(object, source, index, customizer)
                        }
                    }
                    return object
                })
            }

            module.exports = createAssigner

            /***/
        },

        /***/ M8F5: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Hoek = __webpack_require__('RXbi')

            const Decoder = __webpack_require__('ONme')
            const Encoder = __webpack_require__('BzZA')

            exports.decode = Decoder.decode

            exports.encode = Encoder.encode

            exports.Decoder = Decoder.Decoder

            exports.Encoder = Encoder.Encoder

            // Base64url (RFC 4648) encode

            exports.base64urlEncode = function(value, encoding) {
                Hoek.assert(
                    typeof value === 'string' || Buffer.isBuffer(value),
                    'value must be string or buffer'
                )
                const buf = Buffer.isBuffer(value)
                    ? value
                    : Buffer.from(value, encoding || 'binary')
                return buf
                    .toString('base64')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/\=/g, '')
            }

            // Base64url (RFC 4648) decode

            exports.base64urlDecode = function(value, encoding) {
                if (typeof value !== 'string') {
                    throw new Error('Value not a string')
                }

                if (!/^[\w\-]*$/.test(value)) {
                    throw new Error('Invalid character')
                }

                const buf = Buffer.from(value, 'base64')
                return encoding === 'buffer'
                    ? buf
                    : buf.toString(encoding || 'binary')
            }

            /***/
        },

        /***/ MMmD: /***/ function(module, exports, __webpack_require__) {
            var isFunction = __webpack_require__('lSCD'),
                isLength = __webpack_require__('shjB')

            /**
             * Checks if `value` is array-like. A value is considered array-like if it's
             * not a function and has a `value.length` that's an integer greater than or
             * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
             * @example
             *
             * _.isArrayLike([1, 2, 3]);
             * // => true
             *
             * _.isArrayLike(document.body.children);
             * // => true
             *
             * _.isArrayLike('abc');
             * // => true
             *
             * _.isArrayLike(_.noop);
             * // => false
             */
            function isArrayLike(value) {
                return (
                    value != null &&
                    isLength(value.length) &&
                    !isFunction(value)
                )
            }

            module.exports = isArrayLike

            /***/
        },

        /***/ MoRj: /***/ function(module, exports, __webpack_require__) {
            const {
                sign: signOneShot,
                verify: verifyOneShot
            } = __webpack_require__('PJMN')

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const { edDSASupported } = __webpack_require__('pDDt')

            const sign = ({ [KEYOBJECT]: keyObject }, payload) => {
                if (typeof payload === 'string') {
                    payload = Buffer.from(payload)
                }
                return signOneShot(undefined, payload, keyObject)
            }

            const verify = ({ [KEYOBJECT]: keyObject }, payload, signature) => {
                return verifyOneShot(undefined, payload, keyObject, signature)
            }

            module.exports = (JWA, JWK) => {
                if (edDSASupported) {
                    JWA.sign.set('EdDSA', sign)
                    JWA.verify.set('EdDSA', verify)
                    JWK.OKP.sign.EdDSA = key =>
                        key.private && JWK.OKP.verify.EdDSA(key)
                    JWK.OKP.verify.EdDSA = key =>
                        (key.use === 'sig' || key.use === undefined) &&
                        key.keyObject.asymmetricKeyType.startsWith('ed')
                }
            }

            /***/
        },

        /***/ MrPd: /***/ function(module, exports, __webpack_require__) {
            var baseAssignValue = __webpack_require__('hypo'),
                eq = __webpack_require__('ljhN')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Assigns `value` to `key` of `object` if the existing value is not equivalent
             * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
             * for equality comparisons.
             *
             * @private
             * @param {Object} object The object to modify.
             * @param {string} key The key of the property to assign.
             * @param {*} value The value to assign.
             */
            function assignValue(object, key, value) {
                var objValue = object[key]
                if (
                    !(
                        hasOwnProperty.call(object, key) && eq(objValue, value)
                    ) ||
                    (value === undefined && !(key in object))
                ) {
                    baseAssignValue(object, key, value)
                }
            }

            module.exports = assignValue

            /***/
        },

        /***/ MrQC: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { Readable } = __webpack_require__('msIP')

            module.exports = input =>
                new Readable({
                    read() {
                        this.push(input)
                        this.push(null)
                    }
                })

            /***/
        },

        /***/ Mu3n: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            class CookieSessionStoreSettings {
                constructor(settings) {
                    this.cookieSecret = settings.cookieSecret
                    if (!this.cookieSecret || !this.cookieSecret.length) {
                        throw new Error(
                            'The cookieSecret setting is empty or null'
                        )
                    }
                    if (this.cookieSecret.length < 32) {
                        throw new Error(
                            'The cookieSecret should be at least 32 characters long'
                        )
                    }
                    this.cookieName = settings.cookieName || 'a0:session'
                    if (!this.cookieName || !this.cookieName.length) {
                        throw new Error(
                            'The cookieName setting is empty or null'
                        )
                    }
                    this.cookieLifetime = settings.cookieLifetime || 60 * 60 * 8
                    this.cookiePath = settings.cookiePath || '/'
                    if (!this.cookiePath || !this.cookiePath.length) {
                        throw new Error(
                            'The cookiePath setting is empty or null'
                        )
                    }
                    this.storeIdToken = settings.storeIdToken || false
                    this.storeAccessToken = settings.storeAccessToken || false
                    this.storeRefreshToken = settings.storeRefreshToken || false
                }
            }
            exports.default = CookieSessionStoreSettings
            //# sourceMappingURL=settings.js.map

            /***/
        },

        /***/ MvSz: /***/ function(module, exports, __webpack_require__) {
            var arrayFilter = __webpack_require__('LXxW'),
                stubArray = __webpack_require__('0ycA')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Built-in value references. */
            var propertyIsEnumerable = objectProto.propertyIsEnumerable

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeGetSymbols = Object.getOwnPropertySymbols

            /**
             * Creates an array of the own enumerable symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of symbols.
             */
            var getSymbols = !nativeGetSymbols
                ? stubArray
                : function(object) {
                      if (object == null) {
                          return []
                      }
                      object = Object(object)
                      return arrayFilter(nativeGetSymbols(object), function(
                          symbol
                      ) {
                          return propertyIsEnumerable.call(object, symbol)
                      })
                  }

            module.exports = getSymbols

            /***/
        },

        /***/ 'N+nT': /***/ function(module, exports, __webpack_require__) {
            const EC_CURVES = __webpack_require__('b9eJ')
            const IVLENGTHS = __webpack_require__('KqF2')
            const JWA = __webpack_require__('Fo+H')
            const JWK = __webpack_require__('OgAF')
            const KEYLENGTHS = __webpack_require__('EB1F')
            const OKP_CURVES = __webpack_require__('AlvL')
            const ECDH_DERIVE_LENGTHS = __webpack_require__('aOmh')

            module.exports = {
                EC_CURVES,
                ECDH_DERIVE_LENGTHS,
                IVLENGTHS,
                JWA,
                JWK,
                KEYLENGTHS,
                OKP_CURVES
            }

            /***/
        },

        /***/ 'N+si': /***/ function(module, exports) {
            function assertSigningAlgValuesSupport(
                endpoint,
                issuer,
                properties
            ) {
                if (!issuer[`${endpoint}_endpoint`]) return

                const eam = `${endpoint}_endpoint_auth_method`
                const easa = `${endpoint}_endpoint_auth_signing_alg`
                const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`

                if (
                    properties[eam] &&
                    properties[eam].endsWith('_jwt') &&
                    !properties[easa] &&
                    !issuer[easavs]
                ) {
                    throw new TypeError(
                        `${easavs} must be configured on the issuer if ${easa} is not defined on a client`
                    )
                }
            }

            function assertIssuerConfiguration(issuer, endpoint) {
                if (!issuer[endpoint]) {
                    throw new TypeError(
                        `${endpoint} must be configured on the issuer`
                    )
                }
            }

            module.exports = {
                assertSigningAlgValuesSupport,
                assertIssuerConfiguration
            }

            /***/
        },

        /***/ NCJl: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // TODO: Use the `URL` global when targeting Node.js 10
            const URLParser =
                typeof URL === 'undefined'
                    ? __webpack_require__('bzos').URL
                    : URL

            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
            const DATA_URL_DEFAULT_MIME_TYPE = 'text/plain'
            const DATA_URL_DEFAULT_CHARSET = 'us-ascii'

            const testParameter = (name, filters) => {
                return filters.some(filter =>
                    filter instanceof RegExp
                        ? filter.test(name)
                        : filter === name
                )
            }

            const normalizeDataURL = (urlString, { stripHash }) => {
                const parts = urlString.match(/^data:(.*?),(.*?)(?:#(.*))?$/)

                if (!parts) {
                    throw new Error(`Invalid URL: ${urlString}`)
                }

                const mediaType = parts[1].split(';')
                const body = parts[2]
                const hash = stripHash ? '' : parts[3]

                let base64 = false

                if (mediaType[mediaType.length - 1] === 'base64') {
                    mediaType.pop()
                    base64 = true
                }

                // Lowercase MIME type
                const mimeType = (mediaType.shift() || '').toLowerCase()
                const attributes = mediaType
                    .map(attribute => {
                        let [key, value = ''] = attribute
                            .split('=')
                            .map(string => string.trim())

                        // Lowercase `charset`
                        if (key === 'charset') {
                            value = value.toLowerCase()

                            if (value === DATA_URL_DEFAULT_CHARSET) {
                                return ''
                            }
                        }

                        return `${key}${value ? `=${value}` : ''}`
                    })
                    .filter(Boolean)

                const normalizedMediaType = [...attributes]

                if (base64) {
                    normalizedMediaType.push('base64')
                }

                if (
                    normalizedMediaType.length !== 0 ||
                    (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)
                ) {
                    normalizedMediaType.unshift(mimeType)
                }

                return `data:${normalizedMediaType.join(';')},${
                    base64 ? body.trim() : body
                }${hash ? `#${hash}` : ''}`
            }

            const normalizeUrl = (urlString, options) => {
                options = {
                    defaultProtocol: 'http:',
                    normalizeProtocol: true,
                    forceHttp: false,
                    forceHttps: false,
                    stripAuthentication: true,
                    stripHash: false,
                    stripWWW: true,
                    removeQueryParameters: [/^utm_\w+/i],
                    removeTrailingSlash: true,
                    removeDirectoryIndex: false,
                    sortQueryParameters: true,
                    ...options
                }

                // TODO: Remove this at some point in the future
                if (Reflect.has(options, 'normalizeHttps')) {
                    throw new Error(
                        'options.normalizeHttps is renamed to options.forceHttp'
                    )
                }

                if (Reflect.has(options, 'normalizeHttp')) {
                    throw new Error(
                        'options.normalizeHttp is renamed to options.forceHttps'
                    )
                }

                if (Reflect.has(options, 'stripFragment')) {
                    throw new Error(
                        'options.stripFragment is renamed to options.stripHash'
                    )
                }

                urlString = urlString.trim()

                // Data URL
                if (/^data:/i.test(urlString)) {
                    return normalizeDataURL(urlString, options)
                }

                const hasRelativeProtocol = urlString.startsWith('//')
                const isRelativeUrl =
                    !hasRelativeProtocol && /^\.*\//.test(urlString)

                // Prepend protocol
                if (!isRelativeUrl) {
                    urlString = urlString.replace(
                        /^(?!(?:\w+:)?\/\/)|^\/\//,
                        options.defaultProtocol
                    )
                }

                const urlObj = new URLParser(urlString)

                if (options.forceHttp && options.forceHttps) {
                    throw new Error(
                        'The `forceHttp` and `forceHttps` options cannot be used together'
                    )
                }

                if (options.forceHttp && urlObj.protocol === 'https:') {
                    urlObj.protocol = 'http:'
                }

                if (options.forceHttps && urlObj.protocol === 'http:') {
                    urlObj.protocol = 'https:'
                }

                // Remove auth
                if (options.stripAuthentication) {
                    urlObj.username = ''
                    urlObj.password = ''
                }

                // Remove hash
                if (options.stripHash) {
                    urlObj.hash = ''
                }

                // Remove duplicate slashes if not preceded by a protocol
                if (urlObj.pathname) {
                    // TODO: Use the following instead when targeting Node.js 10
                    // `urlObj.pathname = urlObj.pathname.replace(/(?<!https?:)\/{2,}/g, '/');`
                    urlObj.pathname = urlObj.pathname.replace(
                        /((?!:).|^)\/{2,}/g,
                        (_, p1) => {
                            if (/^(?!\/)/g.test(p1)) {
                                return `${p1}/`
                            }

                            return '/'
                        }
                    )
                }

                // Decode URI octets
                if (urlObj.pathname) {
                    urlObj.pathname = decodeURI(urlObj.pathname)
                }

                // Remove directory index
                if (options.removeDirectoryIndex === true) {
                    options.removeDirectoryIndex = [/^index\.[a-z]+$/]
                }

                if (
                    Array.isArray(options.removeDirectoryIndex) &&
                    options.removeDirectoryIndex.length > 0
                ) {
                    let pathComponents = urlObj.pathname.split('/')
                    const lastComponent =
                        pathComponents[pathComponents.length - 1]

                    if (
                        testParameter(
                            lastComponent,
                            options.removeDirectoryIndex
                        )
                    ) {
                        pathComponents = pathComponents.slice(
                            0,
                            pathComponents.length - 1
                        )
                        urlObj.pathname =
                            pathComponents.slice(1).join('/') + '/'
                    }
                }

                if (urlObj.hostname) {
                    // Remove trailing dot
                    urlObj.hostname = urlObj.hostname.replace(/\.$/, '')

                    // Remove `www.`
                    if (
                        options.stripWWW &&
                        /^www\.([a-z\-\d]{2,63})\.([a-z.]{2,5})$/.test(
                            urlObj.hostname
                        )
                    ) {
                        // Each label should be max 63 at length (min: 2).
                        // The extension should be max 5 at length (min: 2).
                        // Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
                        urlObj.hostname = urlObj.hostname.replace(/^www\./, '')
                    }
                }

                // Remove query unwanted parameters
                if (Array.isArray(options.removeQueryParameters)) {
                    for (const key of [...urlObj.searchParams.keys()]) {
                        if (testParameter(key, options.removeQueryParameters)) {
                            urlObj.searchParams.delete(key)
                        }
                    }
                }

                // Sort query parameters
                if (options.sortQueryParameters) {
                    urlObj.searchParams.sort()
                }

                if (options.removeTrailingSlash) {
                    urlObj.pathname = urlObj.pathname.replace(/\/$/, '')
                }

                // Take advantage of many of the Node `url` normalizations
                urlString = urlObj.toString()

                // Remove ending `/`
                if (
                    (options.removeTrailingSlash || urlObj.pathname === '/') &&
                    urlObj.hash === ''
                ) {
                    urlString = urlString.replace(/\/$/, '')
                }

                // Restore relative protocol, if applicable
                if (hasRelativeProtocol && !options.normalizeProtocol) {
                    urlString = urlString.replace(/^http:\/\//, '//')
                }

                // Remove http/https
                if (options.stripProtocol) {
                    urlString = urlString.replace(/^(?:https?:)?\/\//, '')
                }

                return urlString
            }

            module.exports = normalizeUrl
            // TODO: Remove this for the next major release
            module.exports.default = normalizeUrl

            /***/
        },

        /***/ NFjz: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const pump = __webpack_require__('b1mx')
            const bufferStream = __webpack_require__('E1OP')

            class MaxBufferError extends Error {
                constructor() {
                    super('maxBuffer exceeded')
                    this.name = 'MaxBufferError'
                }
            }

            function getStream(inputStream, options) {
                if (!inputStream) {
                    return Promise.reject(new Error('Expected a stream'))
                }

                options = Object.assign({ maxBuffer: Infinity }, options)

                const { maxBuffer } = options

                let stream
                return new Promise((resolve, reject) => {
                    const rejectPromise = error => {
                        if (error) {
                            // A null check
                            error.bufferedData = stream.getBufferedValue()
                        }
                        reject(error)
                    }

                    stream = pump(inputStream, bufferStream(options), error => {
                        if (error) {
                            rejectPromise(error)
                            return
                        }

                        resolve()
                    })

                    stream.on('data', () => {
                        if (stream.getBufferedLength() > maxBuffer) {
                            rejectPromise(new MaxBufferError())
                        }
                    })
                }).then(() => stream.getBufferedValue())
            }

            module.exports = getStream
            module.exports.buffer = (stream, options) =>
                getStream(
                    stream,
                    Object.assign({}, options, { encoding: 'buffer' })
                )
            module.exports.array = (stream, options) =>
                getStream(stream, Object.assign({}, options, { array: true }))
            module.exports.MaxBufferError = MaxBufferError

            /***/
        },

        /***/ NHoT: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const is = __webpack_require__('6mOv')

            module.exports = url => {
                const options = {
                    protocol: url.protocol,
                    hostname: url.hostname.startsWith('[')
                        ? url.hostname.slice(1, -1)
                        : url.hostname,
                    hash: url.hash,
                    search: url.search,
                    pathname: url.pathname,
                    href: url.href
                }

                if (is.string(url.port) && url.port.length > 0) {
                    options.port = Number(url.port)
                }

                if (url.username || url.password) {
                    options.auth = `${url.username}:${url.password}`
                }

                options.path = is.null(url.search)
                    ? url.pathname
                    : `${url.pathname}${url.search}`

                return options
            }

            /***/
        },

        /***/ NKxu: /***/ function(module, exports, __webpack_require__) {
            var isFunction = __webpack_require__('lSCD'),
                isMasked = __webpack_require__('E2jh'),
                isObject = __webpack_require__('GoyQ'),
                toSource = __webpack_require__('3Fdi')

            /**
             * Used to match `RegExp`
             * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
             */
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g

            /** Used to detect host constructors (Safari). */
            var reIsHostCtor = /^\[object .+?Constructor\]$/

            /** Used for built-in method references. */
            var funcProto = Function.prototype,
                objectProto = Object.prototype

            /** Used to resolve the decompiled source of functions. */
            var funcToString = funcProto.toString

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /** Used to detect if a method is native. */
            var reIsNative = RegExp(
                '^' +
                    funcToString
                        .call(hasOwnProperty)
                        .replace(reRegExpChar, '\\$&')
                        .replace(
                            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                            '$1.*?'
                        ) +
                    '$'
            )

            /**
             * The base implementation of `_.isNative` without bad shim checks.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a native function,
             *  else `false`.
             */
            function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                    return false
                }
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor
                return pattern.test(toSource(value))
            }

            module.exports = baseIsNative

            /***/
        },

        /***/ Ndh8: /***/ function(module, exports, __webpack_require__) {
            const url = __webpack_require__('bzos')
            const { strict: assert } = __webpack_require__('Qs3B')

            module.exports = target => {
                try {
                    const { protocol } = new url.URL(target)
                    assert(protocol.match(/^(https?:)$/))
                    return true
                } catch (err) {
                    throw new TypeError(
                        'only valid absolute URLs can be requested'
                    )
                }
            }

            /***/
        },

        /***/ NegM: /***/ function(module, exports, __webpack_require__) {
            var dP = __webpack_require__('2faE')
            var createDesc = __webpack_require__('rr1i')
            module.exports = __webpack_require__('jmDH')
                ? function(object, key, value) {
                      return dP.f(object, key, createDesc(1, value))
                  }
                : function(object, key, value) {
                      object[key] = value
                      return object
                  }

            /***/
        },

        /***/ NkYg: /***/ function(module, exports) {
            module.exports = require('buffer')

            /***/
        },

        /***/ Nndd: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            exports.default = '0.4.0'
            //# sourceMappingURL=version.js.map

            /***/
        },

        /***/ Npjl: /***/ function(module, exports) {
            /**
             * Gets the value at `key` of `object`.
             *
             * @private
             * @param {Object} [object] The object to query.
             * @param {string} key The key of the property to get.
             * @returns {*} Returns the property value.
             */
            function getValue(object, key) {
                return object == null ? undefined : object[key]
            }

            module.exports = getValue

            /***/
        },

        /***/ NykK: /***/ function(module, exports, __webpack_require__) {
            var Symbol = __webpack_require__('nmnc'),
                getRawTag = __webpack_require__('AP2z'),
                objectToString = __webpack_require__('KfNM')

            /** `Object#toString` result references. */
            var nullTag = '[object Null]',
                undefinedTag = '[object Undefined]'

            /** Built-in value references. */
            var symToStringTag = Symbol ? Symbol.toStringTag : undefined

            /**
             * The base implementation of `getTag` without fallbacks for buggy environments.
             *
             * @private
             * @param {*} value The value to query.
             * @returns {string} Returns the `toStringTag`.
             */
            function baseGetTag(value) {
                if (value == null) {
                    return value === undefined ? undefinedTag : nullTag
                }
                return symToStringTag && symToStringTag in Object(value)
                    ? getRawTag(value)
                    : objectToString(value)
            }

            module.exports = baseGetTag

            /***/
        },

        /***/ O0PD: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Reach = __webpack_require__('mmuM')

            const internals = {}

            exports.keys = function(obj, options = {}) {
                return options.symbols !== false
                    ? Reflect.ownKeys(obj)
                    : Object.getOwnPropertyNames(obj) // Defaults to true
            }

            exports.store = function(source, keys) {
                const storage = new Map()
                for (let i = 0; i < keys.length; ++i) {
                    const key = keys[i]
                    const value = Reach(source, key)
                    if (
                        typeof value === 'object' ||
                        typeof value === 'function'
                    ) {
                        storage.set(key, value)
                        internals.reachSet(source, key, undefined)
                    }
                }

                return storage
            }

            exports.restore = function(copy, source, storage) {
                for (const [key, value] of storage) {
                    internals.reachSet(copy, key, value)
                    internals.reachSet(source, key, value)
                }
            }

            internals.reachSet = function(obj, key, value) {
                const path = Array.isArray(key) ? key : key.split('.')
                let ref = obj
                for (let i = 0; i < path.length; ++i) {
                    const segment = path[i]
                    if (i + 1 === path.length) {
                        ref[segment] = value
                    }

                    ref = ref[segment]
                }
            }

            /***/
        },

        /***/ O0oS: /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5')

            var defineProperty = (function() {
                try {
                    var func = getNative(Object, 'defineProperty')
                    func({}, '', {})
                    return func
                } catch (e) {}
            })()

            module.exports = defineProperty

            /***/
        },

        /***/ O3E8: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const openid_client_1 = __webpack_require__('ecj1')
            function getClient(settings) {
                let client = null
                const clientSettings = settings.oidcClient || {
                    httpTimeout: 2500
                }
                return () =>
                    tslib_1.__awaiter(this, void 0, void 0, function*() {
                        if (client) {
                            return client
                        }
                        const issuer = yield openid_client_1.Issuer.discover(
                            `https://${settings.domain}/`
                        )
                        client = new issuer.Client({
                            client_id: settings.clientId,
                            client_secret: settings.clientSecret,
                            redirect_uris: [settings.redirectUri],
                            response_types: ['code']
                        })
                        if (clientSettings.httpTimeout) {
                            const timeout = clientSettings.httpTimeout
                            client[
                                openid_client_1.custom.http_options
                            ] = function setHttpOptions(options) {
                                return Object.assign(
                                    Object.assign({}, options),
                                    { timeout }
                                )
                            }
                        }
                        if (clientSettings.clockTolerance) {
                            client[openid_client_1.custom.clock_tolerance] =
                                clientSettings.clockTolerance / 1000
                        }
                        return client
                    })
            }
            exports.default = getClient
            //# sourceMappingURL=oidc-client.js.map

            /***/
        },

        /***/ O7RO: /***/ function(module, exports, __webpack_require__) {
            var isStrictComparable = __webpack_require__('CMye'),
                keys = __webpack_require__('7GkX')

            /**
             * Gets the property names, values, and compare flags of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the match data of `object`.
             */
            function getMatchData(object) {
                var result = keys(object),
                    length = result.length

                while (length--) {
                    var key = result[length],
                        value = object[key]

                    result[length] = [key, value, isStrictComparable(value)]
                }
                return result
            }

            module.exports = getMatchData

            /***/
        },

        /***/ O9d4: /***/ function(module, exports) {
            module.exports = obj => JSON.parse(JSON.stringify(obj))

            /***/
        },

        /***/ O9zF: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Readable = __webpack_require__('msIP').Readable
            const lowercaseKeys = __webpack_require__('y1+z')

            class Response extends Readable {
                constructor(statusCode, headers, body, url) {
                    if (typeof statusCode !== 'number') {
                        throw new TypeError(
                            'Argument `statusCode` should be a number'
                        )
                    }
                    if (typeof headers !== 'object') {
                        throw new TypeError(
                            'Argument `headers` should be an object'
                        )
                    }
                    if (!(body instanceof Buffer)) {
                        throw new TypeError(
                            'Argument `body` should be a buffer'
                        )
                    }
                    if (typeof url !== 'string') {
                        throw new TypeError('Argument `url` should be a string')
                    }

                    super()
                    this.statusCode = statusCode
                    this.headers = lowercaseKeys(headers)
                    this.body = body
                    this.url = url
                }

                _read() {
                    this.push(this.body)
                    this.push(null)
                }
            }

            module.exports = Response

            /***/
        },

        /***/ OBhP: /***/ function(module, exports, __webpack_require__) {
            var Stack = __webpack_require__('fmRc'),
                arrayEach = __webpack_require__('gFfm'),
                assignValue = __webpack_require__('MrPd'),
                baseAssign = __webpack_require__('WwFo'),
                baseAssignIn = __webpack_require__('Dw+G'),
                cloneBuffer = __webpack_require__('5Tg0'),
                copyArray = __webpack_require__('Q1l4'),
                copySymbols = __webpack_require__('VOtZ'),
                copySymbolsIn = __webpack_require__('EEGq'),
                getAllKeys = __webpack_require__('qZTm'),
                getAllKeysIn = __webpack_require__('G6z8'),
                getTag = __webpack_require__('QqLw'),
                initCloneArray = __webpack_require__('yHx3'),
                initCloneByTag = __webpack_require__('wrZu'),
                initCloneObject = __webpack_require__('+iFO'),
                isArray = __webpack_require__('Z0cm'),
                isBuffer = __webpack_require__('DSRE'),
                isMap = __webpack_require__('zEVN'),
                isObject = __webpack_require__('GoyQ'),
                isSet = __webpack_require__('1+5i'),
                keys = __webpack_require__('7GkX')

            /** Used to compose bitmasks for cloning. */
            var CLONE_DEEP_FLAG = 1,
                CLONE_FLAT_FLAG = 2,
                CLONE_SYMBOLS_FLAG = 4

            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]',
                arrayTag = '[object Array]',
                boolTag = '[object Boolean]',
                dateTag = '[object Date]',
                errorTag = '[object Error]',
                funcTag = '[object Function]',
                genTag = '[object GeneratorFunction]',
                mapTag = '[object Map]',
                numberTag = '[object Number]',
                objectTag = '[object Object]',
                regexpTag = '[object RegExp]',
                setTag = '[object Set]',
                stringTag = '[object String]',
                symbolTag = '[object Symbol]',
                weakMapTag = '[object WeakMap]'

            var arrayBufferTag = '[object ArrayBuffer]',
                dataViewTag = '[object DataView]',
                float32Tag = '[object Float32Array]',
                float64Tag = '[object Float64Array]',
                int8Tag = '[object Int8Array]',
                int16Tag = '[object Int16Array]',
                int32Tag = '[object Int32Array]',
                uint8Tag = '[object Uint8Array]',
                uint8ClampedTag = '[object Uint8ClampedArray]',
                uint16Tag = '[object Uint16Array]',
                uint32Tag = '[object Uint32Array]'

            /** Used to identify `toStringTag` values supported by `_.clone`. */
            var cloneableTags = {}
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[
                arrayBufferTag
            ] = cloneableTags[dataViewTag] = cloneableTags[
                boolTag
            ] = cloneableTags[dateTag] = cloneableTags[
                float32Tag
            ] = cloneableTags[float64Tag] = cloneableTags[
                int8Tag
            ] = cloneableTags[int16Tag] = cloneableTags[
                int32Tag
            ] = cloneableTags[mapTag] = cloneableTags[
                numberTag
            ] = cloneableTags[objectTag] = cloneableTags[
                regexpTag
            ] = cloneableTags[setTag] = cloneableTags[
                stringTag
            ] = cloneableTags[symbolTag] = cloneableTags[
                uint8Tag
            ] = cloneableTags[uint8ClampedTag] = cloneableTags[
                uint16Tag
            ] = cloneableTags[uint32Tag] = true
            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[
                weakMapTag
            ] = false

            /**
             * The base implementation of `_.clone` and `_.cloneDeep` which tracks
             * traversed objects.
             *
             * @private
             * @param {*} value The value to clone.
             * @param {boolean} bitmask The bitmask flags.
             *  1 - Deep clone
             *  2 - Flatten inherited properties
             *  4 - Clone symbols
             * @param {Function} [customizer] The function to customize cloning.
             * @param {string} [key] The key of `value`.
             * @param {Object} [object] The parent object of `value`.
             * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
             * @returns {*} Returns the cloned value.
             */
            function baseClone(value, bitmask, customizer, key, object, stack) {
                var result,
                    isDeep = bitmask & CLONE_DEEP_FLAG,
                    isFlat = bitmask & CLONE_FLAT_FLAG,
                    isFull = bitmask & CLONE_SYMBOLS_FLAG

                if (customizer) {
                    result = object
                        ? customizer(value, key, object, stack)
                        : customizer(value)
                }
                if (result !== undefined) {
                    return result
                }
                if (!isObject(value)) {
                    return value
                }
                var isArr = isArray(value)
                if (isArr) {
                    result = initCloneArray(value)
                    if (!isDeep) {
                        return copyArray(value, result)
                    }
                } else {
                    var tag = getTag(value),
                        isFunc = tag == funcTag || tag == genTag

                    if (isBuffer(value)) {
                        return cloneBuffer(value, isDeep)
                    }
                    if (
                        tag == objectTag ||
                        tag == argsTag ||
                        (isFunc && !object)
                    ) {
                        result = isFlat || isFunc ? {} : initCloneObject(value)
                        if (!isDeep) {
                            return isFlat
                                ? copySymbolsIn(
                                      value,
                                      baseAssignIn(result, value)
                                  )
                                : copySymbols(value, baseAssign(result, value))
                        }
                    } else {
                        if (!cloneableTags[tag]) {
                            return object ? value : {}
                        }
                        result = initCloneByTag(value, tag, isDeep)
                    }
                }
                // Check for circular references and return its corresponding clone.
                stack || (stack = new Stack())
                var stacked = stack.get(value)
                if (stacked) {
                    return stacked
                }
                stack.set(value, result)

                if (isSet(value)) {
                    value.forEach(function(subValue) {
                        result.add(
                            baseClone(
                                subValue,
                                bitmask,
                                customizer,
                                subValue,
                                value,
                                stack
                            )
                        )
                    })
                } else if (isMap(value)) {
                    value.forEach(function(subValue, key) {
                        result.set(
                            key,
                            baseClone(
                                subValue,
                                bitmask,
                                customizer,
                                key,
                                value,
                                stack
                            )
                        )
                    })
                }

                var keysFunc = isFull
                    ? isFlat
                        ? getAllKeysIn
                        : getAllKeys
                    : isFlat
                    ? keysIn
                    : keys

                var props = isArr ? undefined : keysFunc(value)
                arrayEach(props || value, function(subValue, key) {
                    if (props) {
                        key = subValue
                        subValue = value[key]
                    }
                    // Recursively populate clone (susceptible to call stack limits).
                    assignValue(
                        result,
                        key,
                        baseClone(
                            subValue,
                            bitmask,
                            customizer,
                            key,
                            value,
                            stack
                        )
                    )
                })
                return result
            }

            module.exports = baseClone

            /***/
        },

        /***/ OHZa: /***/ function(module, exports, __webpack_require__) {
            const isDisjoint = __webpack_require__('KQbz')
            const base64url = __webpack_require__('Xab3')
            let validateCrit = __webpack_require__('urXW')
            const { JWEInvalid, JOSENotSupported } = __webpack_require__('yt7c')

            validateCrit = validateCrit.bind(undefined, JWEInvalid)

            module.exports = (
                prot,
                unprotected,
                recipients,
                checkAlgorithms,
                crit
            ) => {
                if (typeof prot === 'string') {
                    try {
                        prot = base64url.JSON.decode(prot)
                    } catch (err) {
                        throw new JWEInvalid(
                            'could not parse JWE protected header'
                        )
                    }
                }

                let alg = []
                const enc = new Set()
                if (
                    !isDisjoint(prot, unprotected) ||
                    !recipients.every(({ header }) => {
                        if (typeof header === 'object') {
                            alg.push(header.alg)
                            enc.add(header.enc)
                        }
                        const combined = { ...unprotected, ...header }
                        validateCrit(prot, combined, crit)
                        if ('zip' in combined) {
                            throw new JWEInvalid(
                                '"zip" Header Parameter MUST be integrity protected'
                            )
                        } else if (
                            prot &&
                            'zip' in prot &&
                            prot.zip !== 'DEF'
                        ) {
                            throw new JOSENotSupported(
                                'only "DEF" compression algorithm is supported'
                            )
                        }
                        return (
                            isDisjoint(header, prot) &&
                            isDisjoint(header, unprotected)
                        )
                    })
                ) {
                    throw new JWEInvalid(
                        'JWE Shared Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint'
                    )
                }

                if (typeof prot === 'object') {
                    alg.push(prot.alg)
                    enc.add(prot.enc)
                }
                if (typeof unprotected === 'object') {
                    alg.push(unprotected.alg)
                    enc.add(unprotected.enc)
                }

                alg = alg.filter(Boolean)
                enc.delete(undefined)

                if (recipients.length !== 1) {
                    if (alg.includes('dir') || alg.includes('ECDH-ES')) {
                        throw new JWEInvalid(
                            'dir and ECDH-ES alg may only be used with a single recipient'
                        )
                    }
                }

                if (checkAlgorithms) {
                    if (alg.length !== recipients.length) {
                        throw new JWEInvalid('missing Key Management algorithm')
                    }
                    if (enc.size === 0) {
                        throw new JWEInvalid(
                            'missing Content Encryption algorithm'
                        )
                    } else if (enc.size !== 1) {
                        throw new JWEInvalid(
                            'there must only be one Content Encryption algorithm'
                        )
                    }
                } else {
                    if (enc.size > 1) {
                        throw new JWEInvalid(
                            'there must only be one Content Encryption algorithm'
                        )
                    }
                }

                return [...enc][0]
            }

            /***/
        },

        /***/ ONme: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /*
    Decode functions adapted from:
    Version 1.0 12/25/99 Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
    http://www.onicos.com/staff/iz/amuse/javascript/expert/base64.txt
*/

            const Stream = __webpack_require__('msIP')

            const internals = {
                decodeChars: [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    62,
                    -1,
                    -1,
                    -1,
                    63,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ]
            }

            exports.decode = function(buffer) {
                const decodeChars = internals.decodeChars
                const len = buffer.length
                const allocated = Math.ceil(len / 4) * 3
                const result = Buffer.alloc(allocated)

                let c1
                let c2
                let c3
                let c4
                let j = 0

                for (let i = 0; i < len; ) {
                    do {
                        c1 = decodeChars[buffer[i++] & 0xff]
                    } while (i < len && c1 === -1)

                    if (c1 === -1) {
                        break
                    }

                    do {
                        c2 = decodeChars[buffer[i++] & 0xff]
                    } while (i < len && c2 === -1)

                    if (c2 === -1) {
                        break
                    }

                    result[j++] = (c1 << 2) | ((c2 & 0x30) >> 4)

                    do {
                        c3 = buffer[i++] & 0xff
                        if (c3 === 61) {
                            // =
                            return result.slice(0, j)
                        }

                        c3 = decodeChars[c3]
                    } while (i < len && c3 === -1)

                    if (c3 === -1) {
                        break
                    }

                    result[j++] = ((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)

                    do {
                        c4 = buffer[i++] & 0xff
                        if (c4 === 61) {
                            // =
                            return result.slice(0, j)
                        }

                        c4 = decodeChars[c4]
                    } while (i < len && c4 === -1)

                    if (c4 !== -1) {
                        result[j++] = ((c3 & 0x03) << 6) | c4
                    }
                }

                return j === allocated ? result : result.slice(0, j)
            }

            exports.Decoder = class Decoder extends Stream.Transform {
                constructor() {
                    super()
                    this._reminder = null
                }

                _transform(chunk, encoding, callback) {
                    let part = this._reminder
                        ? Buffer.concat([this._reminder, chunk])
                        : chunk
                    const remaining = part.length % 4
                    if (remaining) {
                        this._reminder = part.slice(part.length - remaining)
                        part = part.slice(0, part.length - remaining)
                    } else {
                        this._reminder = null
                    }

                    this.push(exports.decode(part))
                    return callback()
                }

                _flush(callback) {
                    if (this._reminder) {
                        this.push(exports.decode(this._reminder))
                    }

                    return callback()
                }
            }

            /***/
        },

        /***/ 'Of+w': /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5'),
                root = __webpack_require__('Kz5y')

            /* Built-in method references that are verified to be native. */
            var WeakMap = getNative(root, 'WeakMap')

            module.exports = WeakMap

            /***/
        },

        /***/ OgAF: /***/ function(module, exports) {
            module.exports = {
                oct: {
                    decrypt: {},
                    deriveKey: {},
                    encrypt: {},
                    sign: {},
                    unwrapKey: {},
                    verify: {},
                    wrapKey: {}
                },
                EC: {
                    decrypt: {},
                    deriveKey: {},
                    encrypt: {},
                    sign: {},
                    unwrapKey: {},
                    verify: {},
                    wrapKey: {}
                },
                RSA: {
                    decrypt: {},
                    deriveKey: {},
                    encrypt: {},
                    sign: {},
                    unwrapKey: {},
                    verify: {},
                    wrapKey: {}
                },
                OKP: {
                    decrypt: {},
                    deriveKey: {},
                    encrypt: {},
                    sign: {},
                    unwrapKey: {},
                    verify: {},
                    wrapKey: {}
                }
            }

            /***/
        },

        /***/ P4Tr: /***/ function(module, exports, __webpack_require__) {
            var apply = __webpack_require__('heNW'),
                baseRest = __webpack_require__('EA7m'),
                customDefaultsMerge = __webpack_require__('4DFU'),
                mergeWith = __webpack_require__('JBE3')

            /**
             * This method is like `_.defaults` except that it recursively assigns
             * default properties.
             *
             * **Note:** This method mutates `object`.
             *
             * @static
             * @memberOf _
             * @since 3.10.0
             * @category Object
             * @param {Object} object The destination object.
             * @param {...Object} [sources] The source objects.
             * @returns {Object} Returns `object`.
             * @see _.defaults
             * @example
             *
             * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
             * // => { 'a': { 'b': 2, 'c': 3 } }
             */
            var defaultsDeep = baseRest(function(args) {
                args.push(undefined, customDefaultsMerge)
                return apply(mergeWith, undefined, args)
            })

            module.exports = defaultsDeep

            /***/
        },

        /***/ 'PC/d': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const login_1 = tslib_1.__importDefault(__webpack_require__('1gXH'))
            const logout_1 = tslib_1.__importDefault(
                __webpack_require__('m2VO')
            )
            const callback_1 = tslib_1.__importDefault(
                __webpack_require__('5sNo')
            )
            const profile_1 = tslib_1.__importDefault(
                __webpack_require__('2KX+')
            )
            const session_1 = tslib_1.__importDefault(
                __webpack_require__('J0Hf')
            )
            const require_authentication_1 = tslib_1.__importDefault(
                __webpack_require__('9YuQ')
            )
            exports.default = {
                CallbackHandler: callback_1.default,
                LoginHandler: login_1.default,
                LogoutHandler: logout_1.default,
                ProfileHandler: profile_1.default,
                SessionHandler: session_1.default,
                RequireAuthentication: require_authentication_1.default
            }
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ PCLx: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var __importDefault =
                (this && this.__importDefault) ||
                function(mod) {
                    return mod && mod.__esModule ? mod : { default: mod }
                }
            Object.defineProperty(exports, '__esModule', { value: true })
            const stream_1 = __webpack_require__('msIP')
            const raw_body_1 = __importDefault(__webpack_require__('fbmr'))
            const content_type_1 = __webpack_require__('tA+R')
            const load_components_1 = __webpack_require__('AWHq')
            async function apiResolver(
                req,
                res,
                params,
                resolverModule,
                onError
            ) {
                try {
                    let config = {}
                    let bodyParser = true
                    if (!resolverModule) {
                        res.statusCode = 404
                        res.end('Not Found')
                        return
                    }
                    if (resolverModule.config) {
                        config = resolverModule.config
                        if (config.api && config.api.bodyParser === false) {
                            bodyParser = false
                        }
                    }
                    // Parsing of cookies
                    setLazyProp({ req }, 'cookies', getCookieParser(req))
                    // Parsing query string
                    setLazyProp({ req, params }, 'query', getQueryParser(req))
                    // // Parsing of body
                    if (bodyParser) {
                        req.body = await parseBody(
                            req,
                            config.api &&
                                config.api.bodyParser &&
                                config.api.bodyParser.sizeLimit
                                ? config.api.bodyParser.sizeLimit
                                : '1mb'
                        )
                    }
                    res.status = statusCode => sendStatusCode(res, statusCode)
                    res.send = data => sendData(res, data)
                    res.json = data => sendJson(res, data)
                    const resolver = load_components_1.interopDefault(
                        resolverModule
                    )
                    resolver(req, res)
                } catch (err) {
                    if (err instanceof ApiError) {
                        sendError(res, err.statusCode, err.message)
                    } else {
                        console.error(err)
                        if (onError) await onError({ err })
                        sendError(res, 500, 'Internal Server Error')
                    }
                }
            }
            exports.apiResolver = apiResolver
            /**
             * Parse incoming message like `json` or `urlencoded`
             * @param req request object
             */
            async function parseBody(req, limit) {
                const contentType = content_type_1.parse(
                    req.headers['content-type'] || 'text/plain'
                )
                const { type, parameters } = contentType
                const encoding = parameters.charset || 'utf-8'
                let buffer
                try {
                    buffer = await raw_body_1.default(req, { encoding, limit })
                } catch (e) {
                    if (e.type === 'entity.too.large') {
                        throw new ApiError(413, `Body exceeded ${limit} limit`)
                    } else {
                        throw new ApiError(400, 'Invalid body')
                    }
                }
                const body = buffer.toString()
                if (
                    type === 'application/json' ||
                    type === 'application/ld+json'
                ) {
                    return parseJson(body)
                } else if (type === 'application/x-www-form-urlencoded') {
                    const qs = __webpack_require__('8xkj')
                    return qs.decode(body)
                } else {
                    return body
                }
            }
            exports.parseBody = parseBody
            /**
             * Parse `JSON` and handles invalid `JSON` strings
             * @param str `JSON` string
             */
            function parseJson(str) {
                try {
                    return JSON.parse(str)
                } catch (e) {
                    throw new ApiError(400, 'Invalid JSON')
                }
            }
            /**
             * Parsing query arguments from request `url` string
             * @param url of request
             * @returns Object with key name of query argument and its value
             */
            function getQueryParser({ url }) {
                return function parseQuery() {
                    const { URL } = __webpack_require__('bzos')
                    // we provide a placeholder base url because we only want searchParams
                    const params = new URL(url, 'https://n').searchParams
                    const query = {}
                    for (const [key, value] of params) {
                        if (query[key]) {
                            if (Array.isArray(query[key])) {
                                query[key].push(value)
                            } else {
                                query[key] = [query[key], value]
                            }
                        } else {
                            query[key] = value
                        }
                    }
                    return query
                }
            }
            exports.getQueryParser = getQueryParser
            /**
             * Parse cookies from `req` header
             * @param req request object
             */
            function getCookieParser(req) {
                return function parseCookie() {
                    const header = req.headers.cookie
                    if (!header) {
                        return {}
                    }
                    const { parse } = __webpack_require__('iVi/')
                    return parse(
                        Array.isArray(header) ? header.join(';') : header
                    )
                }
            }
            exports.getCookieParser = getCookieParser
            /**
             *
             * @param res response object
             * @param statusCode `HTTP` status code of response
             */
            function sendStatusCode(res, statusCode) {
                res.statusCode = statusCode
                return res
            }
            exports.sendStatusCode = sendStatusCode
            /**
             * Send `any` body to response
             * @param res response object
             * @param body of response
             */
            function sendData(res, body) {
                if (body === null) {
                    res.end()
                    return
                }
                const contentType = res.getHeader('Content-Type')
                if (Buffer.isBuffer(body)) {
                    if (!contentType) {
                        res.setHeader(
                            'Content-Type',
                            'application/octet-stream'
                        )
                    }
                    res.setHeader('Content-Length', body.length)
                    res.end(body)
                    return
                }
                if (body instanceof stream_1.Stream) {
                    if (!contentType) {
                        res.setHeader(
                            'Content-Type',
                            'application/octet-stream'
                        )
                    }
                    body.pipe(res)
                    return
                }
                let str = body
                // Stringify JSON body
                if (typeof body === 'object' || typeof body === 'number') {
                    str = JSON.stringify(body)
                    res.setHeader(
                        'Content-Type',
                        'application/json; charset=utf-8'
                    )
                }
                res.setHeader('Content-Length', Buffer.byteLength(str))
                res.end(str)
            }
            exports.sendData = sendData
            /**
             * Send `JSON` object
             * @param res response object
             * @param jsonBody of data
             */
            function sendJson(res, jsonBody) {
                // Set header to application/json
                res.setHeader('Content-Type', 'application/json; charset=utf-8')
                // Use send to handle request
                res.send(jsonBody)
            }
            exports.sendJson = sendJson
            /**
             * Custom error class
             */
            class ApiError extends Error {
                constructor(statusCode, message) {
                    super(message)
                    this.statusCode = statusCode
                }
            }
            exports.ApiError = ApiError
            /**
             * Sends error in `response`
             * @param res response object
             * @param statusCode of response
             * @param message of response
             */
            function sendError(res, statusCode, message) {
                res.statusCode = statusCode
                res.statusMessage = message
                res.end(message)
            }
            exports.sendError = sendError
            /**
             * Execute getter function only if its needed
             * @param LazyProps `req` and `params` for lazyProp
             * @param prop name of property
             * @param getter function to get data
             */
            function setLazyProp({ req, params }, prop, getter) {
                const opts = { configurable: true, enumerable: true }
                const optsReset = Object.assign({}, opts, { writable: true })
                Object.defineProperty(
                    req,
                    prop,
                    Object.assign({}, opts, {
                        get: () => {
                            let value = getter()
                            if (params && typeof params !== 'boolean') {
                                value = Object.assign({}, value, params)
                            }
                            // we set the property on the object to avoid recalculating it
                            Object.defineProperty(
                                req,
                                prop,
                                Object.assign({}, optsReset, { value })
                            )
                            return value
                        },
                        set: value => {
                            Object.defineProperty(
                                req,
                                prop,
                                Object.assign({}, optsReset, { value })
                            )
                        }
                    })
                )
            }
            exports.setLazyProp = setLazyProp

            /***/
        },

        /***/ PJMN: /***/ function(module, exports) {
            module.exports = require('crypto')

            /***/
        },

        /***/ 'PJv+': /***/ function(module, exports) {
            function webpackEmptyContext(req) {
                var e = new Error("Cannot find module '" + req + "'")
                e.code = 'MODULE_NOT_FOUND'
                throw e
            }
            webpackEmptyContext.keys = function() {
                return []
            }
            webpackEmptyContext.resolve = webpackEmptyContext
            module.exports = webpackEmptyContext
            webpackEmptyContext.id = 'PJv+'

            /***/
        },

        /***/ PQ6H: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // Manually added data to be used by sbcs codec in addition to generated one.

            module.exports = {
                // Not supported by iconv, not sure why.
                '10029': 'maccenteuro',
                maccenteuro: {
                    type: '_sbcs',
                    chars:
                        ''
                },

                '808': 'cp808',
                ibm808: 'cp808',
                cp808: {
                    type: '_sbcs',
                    chars:
                        ''
                },

                mik: {
                    type: '_sbcs',
                    chars:
                        ''
                },

                // Aliases of generated encodings.
                ascii8bit: 'ascii',
                usascii: 'ascii',
                ansix34: 'ascii',
                ansix341968: 'ascii',
                ansix341986: 'ascii',
                csascii: 'ascii',
                cp367: 'ascii',
                ibm367: 'ascii',
                isoir6: 'ascii',
                iso646us: 'ascii',
                iso646irv: 'ascii',
                us: 'ascii',

                latin1: 'iso88591',
                latin2: 'iso88592',
                latin3: 'iso88593',
                latin4: 'iso88594',
                latin5: 'iso88599',
                latin6: 'iso885910',
                latin7: 'iso885913',
                latin8: 'iso885914',
                latin9: 'iso885915',
                latin10: 'iso885916',

                csisolatin1: 'iso88591',
                csisolatin2: 'iso88592',
                csisolatin3: 'iso88593',
                csisolatin4: 'iso88594',
                csisolatincyrillic: 'iso88595',
                csisolatinarabic: 'iso88596',
                csisolatingreek: 'iso88597',
                csisolatinhebrew: 'iso88598',
                csisolatin5: 'iso88599',
                csisolatin6: 'iso885910',

                l1: 'iso88591',
                l2: 'iso88592',
                l3: 'iso88593',
                l4: 'iso88594',
                l5: 'iso88599',
                l6: 'iso885910',
                l7: 'iso885913',
                l8: 'iso885914',
                l9: 'iso885915',
                l10: 'iso885916',

                isoir14: 'iso646jp',
                isoir57: 'iso646cn',
                isoir100: 'iso88591',
                isoir101: 'iso88592',
                isoir109: 'iso88593',
                isoir110: 'iso88594',
                isoir144: 'iso88595',
                isoir127: 'iso88596',
                isoir126: 'iso88597',
                isoir138: 'iso88598',
                isoir148: 'iso88599',
                isoir157: 'iso885910',
                isoir166: 'tis620',
                isoir179: 'iso885913',
                isoir199: 'iso885914',
                isoir203: 'iso885915',
                isoir226: 'iso885916',

                cp819: 'iso88591',
                ibm819: 'iso88591',

                cyrillic: 'iso88595',

                arabic: 'iso88596',
                arabic8: 'iso88596',
                ecma114: 'iso88596',
                asmo708: 'iso88596',

                greek: 'iso88597',
                greek8: 'iso88597',
                ecma118: 'iso88597',
                elot928: 'iso88597',

                hebrew: 'iso88598',
                hebrew8: 'iso88598',

                turkish: 'iso88599',
                turkish8: 'iso88599',

                thai: 'iso885911',
                thai8: 'iso885911',

                celtic: 'iso885914',
                celtic8: 'iso885914',
                isoceltic: 'iso885914',

                tis6200: 'tis620',
                tis62025291: 'tis620',
                tis62025330: 'tis620',

                '10000': 'macroman',
                '10006': 'macgreek',
                '10007': 'maccyrillic',
                '10079': 'maciceland',
                '10081': 'macturkish',

                cspc8codepage437: 'cp437',
                cspc775baltic: 'cp775',
                cspc850multilingual: 'cp850',
                cspcp852: 'cp852',
                cspc862latinhebrew: 'cp862',
                cpgr: 'cp869',

                msee: 'cp1250',
                mscyrl: 'cp1251',
                msansi: 'cp1252',
                msgreek: 'cp1253',
                msturk: 'cp1254',
                mshebr: 'cp1255',
                msarab: 'cp1256',
                winbaltrim: 'cp1257',

                cp20866: 'koi8r',
                '20866': 'koi8r',
                ibm878: 'koi8r',
                cskoi8r: 'koi8r',

                cp21866: 'koi8u',
                '21866': 'koi8u',
                ibm1168: 'koi8u',

                strk10482002: 'rk1048',

                tcvn5712: 'tcvn',
                tcvn57121: 'tcvn',

                gb198880: 'iso646cn',
                cn: 'iso646cn',

                csiso14jisc6220ro: 'iso646jp',
                jisc62201969ro: 'iso646jp',
                jp: 'iso646jp',

                cshproman8: 'hproman8',
                r8: 'hproman8',
                roman8: 'hproman8',
                xroman8: 'hproman8',
                ibm1051: 'hproman8',

                mac: 'macintosh',
                csmacintosh: 'macintosh'
            }

            /***/
        },

        /***/ PbSP: /***/ function(module, exports) {
            module.exports = () => Math.floor(Date.now() / 1000)

            /***/
        },

        /***/ PsWn: /***/ function(module, exports) {
            const MAX_INT32 = Math.pow(2, 32)

            module.exports = (value, buf = Buffer.allocUnsafe(8)) => {
                const high = Math.floor(value / MAX_INT32)
                const low = value % MAX_INT32

                buf.writeUInt32BE(high, 0)
                buf.writeUInt32BE(low, 4)
                return buf
            }

            /***/
        },

        /***/ Pxi6: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Reach = __webpack_require__('mmuM')

            const internals = {}

            module.exports = function(obj, template, options) {
                return template.replace(/{([^}]+)}/g, ($0, chain) => {
                    const value = Reach(obj, chain, options)
                    return value === undefined || value === null ? '' : value
                })
            }

            /***/
        },

        /***/ Q1l4: /***/ function(module, exports) {
            /**
             * Copies the values of `source` to `array`.
             *
             * @private
             * @param {Array} source The array to copy values from.
             * @param {Array} [array=[]] The array to copy values to.
             * @returns {Array} Returns `array`.
             */
            function copyArray(source, array) {
                var index = -1,
                    length = source.length

                array || (array = Array(length))
                while (++index < length) {
                    array[index] = source[index]
                }
                return array
            }

            module.exports = copyArray

            /***/
        },

        /***/ QQHG: /***/ function(module, exports, __webpack_require__) {
            const { inherits } = __webpack_require__('jK02')

            const DERDecoder = __webpack_require__('R7nf')

            function PEMDecoder(entity) {
                DERDecoder.call(this, entity)
                this.enc = 'pem'
            }
            inherits(PEMDecoder, DERDecoder)

            PEMDecoder.prototype.decode = function decode(data, options) {
                const lines = data.toString().split(/[\r\n]+/g)

                const label = options.label.toUpperCase()

                const re = /^-----(BEGIN|END) ([^-]+)-----$/
                let start = -1
                let end = -1
                for (let i = 0; i < lines.length; i++) {
                    const match = lines[i].match(re)
                    if (match === null) {
                        continue
                    }

                    if (match[2] !== label) {
                        continue
                    }

                    if (start === -1) {
                        if (match[1] !== 'BEGIN') {
                            break
                        }
                        start = i
                    } else {
                        if (match[1] !== 'END') {
                            break
                        }
                        end = i
                        break
                    }
                }
                if (start === -1 || end === -1) {
                    throw new Error(`PEM section not found for: ${label}`)
                }

                const base64 = lines.slice(start + 1, end).join('')
                // Remove excessive symbols
                base64.replace(/[^a-z0-9+/=]+/gi, '')

                const input = Buffer.from(base64, 'base64')
                return DERDecoder.prototype.decode.call(this, input, options)
            }

            module.exports = PEMDecoder

            /***/
        },

        /***/ QcOe: /***/ function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__('GoyQ'),
                isPrototype = __webpack_require__('6sVZ'),
                nativeKeysIn = __webpack_require__('7Ix3')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             */
            function baseKeysIn(object) {
                if (!isObject(object)) {
                    return nativeKeysIn(object)
                }
                var isProto = isPrototype(object),
                    result = []

                for (var key in object) {
                    if (
                        !(
                            key == 'constructor' &&
                            (isProto || !hasOwnProperty.call(object, key))
                        )
                    ) {
                        result.push(key)
                    }
                }
                return result
            }

            module.exports = baseKeysIn

            /***/
        },

        /***/ QkVE: /***/ function(module, exports, __webpack_require__) {
            var isKeyable = __webpack_require__('EpBk')

            /**
             * Gets the data for `map`.
             *
             * @private
             * @param {Object} map The map to query.
             * @param {string} key The reference key.
             * @returns {*} Returns the map data.
             */
            function getMapData(map, key) {
                var data = map.__data__
                return isKeyable(key)
                    ? data[typeof key == 'string' ? 'string' : 'hash']
                    : data.map
            }

            module.exports = getMapData

            /***/
        },

        /***/ QkVN: /***/ function(module, exports, __webpack_require__) {
            var baseMerge = __webpack_require__('+Qka'),
                createAssigner = __webpack_require__('LsHQ')

            /**
             * This method is like `_.assign` except that it recursively merges own and
             * inherited enumerable string keyed properties of source objects into the
             * destination object. Source properties that resolve to `undefined` are
             * skipped if a destination value exists. Array and plain object properties
             * are merged recursively. Other objects and value types are overridden by
             * assignment. Source objects are applied from left to right. Subsequent
             * sources overwrite property assignments of previous sources.
             *
             * **Note:** This method mutates `object`.
             *
             * @static
             * @memberOf _
             * @since 0.5.0
             * @category Object
             * @param {Object} object The destination object.
             * @param {...Object} [sources] The source objects.
             * @returns {Object} Returns `object`.
             * @example
             *
             * var object = {
             *   'a': [{ 'b': 2 }, { 'd': 4 }]
             * };
             *
             * var other = {
             *   'a': [{ 'c': 3 }, { 'e': 5 }]
             * };
             *
             * _.merge(object, other);
             * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
             */
            var merge = createAssigner(function(object, source, srcIndex) {
                baseMerge(object, source, srcIndex)
            })

            module.exports = merge

            /***/
        },

        /***/ QoRX: /***/ function(module, exports) {
            /**
             * A specialized version of `_.some` for arrays without support for iteratee
             * shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {boolean} Returns `true` if any element passes the predicate check,
             *  else `false`.
             */
            function arraySome(array, predicate) {
                var index = -1,
                    length = array == null ? 0 : array.length

                while (++index < length) {
                    if (predicate(array[index], index, array)) {
                        return true
                    }
                }
                return false
            }

            module.exports = arraySome

            /***/
        },

        /***/ QqLw: /***/ function(module, exports, __webpack_require__) {
            var DataView = __webpack_require__('tadb'),
                Map = __webpack_require__('ebwN'),
                Promise = __webpack_require__('HOxn'),
                Set = __webpack_require__('yGk4'),
                WeakMap = __webpack_require__('Of+w'),
                baseGetTag = __webpack_require__('NykK'),
                toSource = __webpack_require__('3Fdi')

            /** `Object#toString` result references. */
            var mapTag = '[object Map]',
                objectTag = '[object Object]',
                promiseTag = '[object Promise]',
                setTag = '[object Set]',
                weakMapTag = '[object WeakMap]'

            var dataViewTag = '[object DataView]'

            /** Used to detect maps, sets, and weakmaps. */
            var dataViewCtorString = toSource(DataView),
                mapCtorString = toSource(Map),
                promiseCtorString = toSource(Promise),
                setCtorString = toSource(Set),
                weakMapCtorString = toSource(WeakMap)

            /**
             * Gets the `toStringTag` of `value`.
             *
             * @private
             * @param {*} value The value to query.
             * @returns {string} Returns the `toStringTag`.
             */
            var getTag = baseGetTag

            // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
            if (
                (DataView &&
                    getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
                (Map && getTag(new Map()) != mapTag) ||
                (Promise && getTag(Promise.resolve()) != promiseTag) ||
                (Set && getTag(new Set()) != setTag) ||
                (WeakMap && getTag(new WeakMap()) != weakMapTag)
            ) {
                getTag = function(value) {
                    var result = baseGetTag(value),
                        Ctor =
                            result == objectTag ? value.constructor : undefined,
                        ctorString = Ctor ? toSource(Ctor) : ''

                    if (ctorString) {
                        switch (ctorString) {
                            case dataViewCtorString:
                                return dataViewTag
                            case mapCtorString:
                                return mapTag
                            case promiseCtorString:
                                return promiseTag
                            case setCtorString:
                                return setTag
                            case weakMapCtorString:
                                return weakMapTag
                        }
                    }
                    return result
                }
            }

            module.exports = getTag

            /***/
        },

        /***/ Qs2e: /***/ function(module, exports) {
            module.exports = require('net')

            /***/
        },

        /***/ Qs3B: /***/ function(module, exports) {
            module.exports = require('assert')

            /***/
        },

        /***/ Qxd3: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            class CancelError extends Error {
                constructor(reason) {
                    super(reason || 'Promise was canceled')
                    this.name = 'CancelError'
                }

                get isCanceled() {
                    return true
                }
            }

            class PCancelable {
                static fn(userFn) {
                    return (...args) => {
                        return new PCancelable((resolve, reject, onCancel) => {
                            args.push(onCancel)
                            userFn(...args).then(resolve, reject)
                        })
                    }
                }

                constructor(executor) {
                    this._cancelHandlers = []
                    this._isPending = true
                    this._isCanceled = false
                    this._rejectOnCancel = true

                    this._promise = new Promise((resolve, reject) => {
                        this._reject = reject

                        const onResolve = value => {
                            this._isPending = false
                            resolve(value)
                        }

                        const onReject = error => {
                            this._isPending = false
                            reject(error)
                        }

                        const onCancel = handler => {
                            this._cancelHandlers.push(handler)
                        }

                        Object.defineProperties(onCancel, {
                            shouldReject: {
                                get: () => this._rejectOnCancel,
                                set: bool => {
                                    this._rejectOnCancel = bool
                                }
                            }
                        })

                        return executor(onResolve, onReject, onCancel)
                    })
                }

                then(onFulfilled, onRejected) {
                    return this._promise.then(onFulfilled, onRejected)
                }

                catch(onRejected) {
                    return this._promise.catch(onRejected)
                }

                finally(onFinally) {
                    return this._promise.finally(onFinally)
                }

                cancel(reason) {
                    if (!this._isPending || this._isCanceled) {
                        return
                    }

                    if (this._cancelHandlers.length > 0) {
                        try {
                            for (const handler of this._cancelHandlers) {
                                handler()
                            }
                        } catch (error) {
                            this._reject(error)
                        }
                    }

                    this._isCanceled = true
                    if (this._rejectOnCancel) {
                        this._reject(new CancelError(reason))
                    }
                }

                get isCanceled() {
                    return this._isCanceled
                }
            }

            Object.setPrototypeOf(PCancelable.prototype, Promise.prototype)

            module.exports = PCancelable
            module.exports.default = PCancelable

            module.exports.CancelError = CancelError

            /***/
        },

        /***/ R7nf: /***/ function(module, exports, __webpack_require__) {
            /* global BigInt */
            const { inherits } = __webpack_require__('jK02')

            const { DecoderBuffer } = __webpack_require__('Z9M3')
            const Node = __webpack_require__('k+0e')

            // Import DER constants
            const der = __webpack_require__('1Gj5')

            function DERDecoder(entity) {
                this.enc = 'der'
                this.name = entity.name
                this.entity = entity

                // Construct base tree
                this.tree = new DERNode()
                this.tree._init(entity.body)
            }

            DERDecoder.prototype.decode = function decode(data, options) {
                if (!DecoderBuffer.isDecoderBuffer(data)) {
                    data = new DecoderBuffer(data, options)
                }

                return this.tree._decode(data, options)
            }

            // Tree methods

            function DERNode(parent) {
                Node.call(this, 'der', parent)
            }
            inherits(DERNode, Node)

            DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
                if (buffer.isEmpty()) {
                    return false
                }

                const state = buffer.save()
                const decodedTag = derDecodeTag(
                    buffer,
                    `Failed to peek tag: "${tag}"`
                )
                if (buffer.isError(decodedTag)) {
                    return decodedTag
                }

                buffer.restore(state)

                return (
                    decodedTag.tag === tag ||
                    decodedTag.tagStr === tag ||
                    decodedTag.tagStr + 'of' === tag ||
                    any
                )
            }

            DERNode.prototype._decodeTag = function decodeTag(
                buffer,
                tag,
                any
            ) {
                const decodedTag = derDecodeTag(
                    buffer,
                    `Failed to decode tag of "${tag}"`
                )
                if (buffer.isError(decodedTag)) {
                    return decodedTag
                }

                let len = derDecodeLen(
                    buffer,
                    decodedTag.primitive,
                    `Failed to get length of "${tag}"`
                )

                // Failure
                if (buffer.isError(len)) {
                    return len
                }

                if (
                    !any &&
                    decodedTag.tag !== tag &&
                    decodedTag.tagStr !== tag &&
                    decodedTag.tagStr + 'of' !== tag
                ) {
                    return buffer.error(`Failed to match tag: "${tag}"`)
                }

                if (decodedTag.primitive || len !== null) {
                    return buffer.skip(len, `Failed to match body of: "${tag}"`)
                }

                // Indefinite length... find END tag
                const state = buffer.save()
                const res = this._skipUntilEnd(
                    buffer,
                    `Failed to skip indefinite length body: "${this.tag}"`
                )
                if (buffer.isError(res)) {
                    return res
                }

                len = buffer.offset - state.offset
                buffer.restore(state)
                return buffer.skip(len, `Failed to match body of: "${tag}"`)
            }

            DERNode.prototype._skipUntilEnd = function skipUntilEnd(
                buffer,
                fail
            ) {
                for (;;) {
                    const tag = derDecodeTag(buffer, fail)
                    if (buffer.isError(tag)) {
                        return tag
                    }
                    const len = derDecodeLen(buffer, tag.primitive, fail)
                    if (buffer.isError(len)) {
                        return len
                    }

                    let res
                    if (tag.primitive || len !== null) {
                        res = buffer.skip(len)
                    } else {
                        res = this._skipUntilEnd(buffer, fail)
                    }

                    // Failure
                    if (buffer.isError(res)) {
                        return res
                    }

                    if (tag.tagStr === 'end') {
                        break
                    }
                }
            }

            DERNode.prototype._decodeList = function decodeList(
                buffer,
                tag,
                decoder,
                options
            ) {
                const result = []
                while (!buffer.isEmpty()) {
                    const possibleEnd = this._peekTag(buffer, 'end')
                    if (buffer.isError(possibleEnd)) {
                        return possibleEnd
                    }

                    const res = decoder.decode(buffer, 'der', options)
                    if (buffer.isError(res) && possibleEnd) {
                        break
                    }
                    result.push(res)
                }
                return result
            }

            DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
                if (tag === 'bitstr') {
                    const unused = buffer.readUInt8()
                    if (buffer.isError(unused)) {
                        return unused
                    }
                    return { unused: unused, data: buffer.raw() }
                } else if (tag === 'bmpstr') {
                    const raw = buffer.raw()
                    if (raw.length % 2 === 1) {
                        return buffer.error(
                            'Decoding of string type: bmpstr length mismatch'
                        )
                    }

                    let str = ''
                    for (let i = 0; i < raw.length / 2; i++) {
                        str += String.fromCharCode(raw.readUInt16BE(i * 2))
                    }
                    return str
                } else if (tag === 'numstr') {
                    const numstr = buffer.raw().toString('ascii')
                    if (!this._isNumstr(numstr)) {
                        return buffer.error(
                            'Decoding of string type: numstr unsupported characters'
                        )
                    }
                    return numstr
                } else if (tag === 'octstr') {
                    return buffer.raw()
                } else if (tag === 'objDesc') {
                    return buffer.raw()
                } else if (tag === 'printstr') {
                    const printstr = buffer.raw().toString('ascii')
                    if (!this._isPrintstr(printstr)) {
                        return buffer.error(
                            'Decoding of string type: printstr unsupported characters'
                        )
                    }
                    return printstr
                } else if (/str$/.test(tag)) {
                    return buffer.raw().toString()
                } else {
                    return buffer.error(
                        `Decoding of string type: ${tag} unsupported`
                    )
                }
            }

            DERNode.prototype._decodeObjid = function decodeObjid(
                buffer,
                values,
                relative
            ) {
                let result
                const identifiers = []
                let ident = 0
                let subident = 0
                while (!buffer.isEmpty()) {
                    subident = buffer.readUInt8()
                    ident <<= 7
                    ident |= subident & 0x7f
                    if ((subident & 0x80) === 0) {
                        identifiers.push(ident)
                        ident = 0
                    }
                }
                if (subident & 0x80) {
                    identifiers.push(ident)
                }

                const first = (identifiers[0] / 40) | 0
                const second = identifiers[0] % 40

                if (relative) {
                    result = identifiers
                } else {
                    result = [first, second].concat(identifiers.slice(1))
                }

                if (values) {
                    let tmp = values[result.join(' ')]
                    if (tmp === undefined) {
                        tmp = values[result.join('.')]
                    }
                    if (tmp !== undefined) {
                        result = tmp
                    }
                }

                return result
            }

            DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
                const str = buffer.raw().toString()

                let year
                let mon
                let day
                let hour
                let min
                let sec
                if (tag === 'gentime') {
                    year = str.slice(0, 4) | 0
                    mon = str.slice(4, 6) | 0
                    day = str.slice(6, 8) | 0
                    hour = str.slice(8, 10) | 0
                    min = str.slice(10, 12) | 0
                    sec = str.slice(12, 14) | 0
                } else if (tag === 'utctime') {
                    year = str.slice(0, 2) | 0
                    mon = str.slice(2, 4) | 0
                    day = str.slice(4, 6) | 0
                    hour = str.slice(6, 8) | 0
                    min = str.slice(8, 10) | 0
                    sec = str.slice(10, 12) | 0
                    if (year < 70) {
                        year = 2000 + year
                    } else {
                        year = 1900 + year
                    }
                } else {
                    return buffer.error(
                        `Decoding ${tag} time is not supported yet`
                    )
                }

                return Date.UTC(year, mon - 1, day, hour, min, sec, 0)
            }

            DERNode.prototype._decodeNull = function decodeNull() {
                return null
            }

            DERNode.prototype._decodeBool = function decodeBool(buffer) {
                const res = buffer.readUInt8()
                if (buffer.isError(res)) {
                    return res
                } else {
                    return res !== 0
                }
            }

            DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
                // Bigint, return as it is (assume big endian)
                const raw = buffer.raw()
                let res = BigInt(`0x${raw.toString('hex')}`)

                if (values) {
                    res = values[res.toString(10)] || res
                }

                return res
            }

            DERNode.prototype._use = function use(entity, obj) {
                if (typeof entity === 'function') {
                    entity = entity(obj)
                }
                return entity._getDecoder('der').tree
            }

            // Utility methods

            function derDecodeTag(buf, fail) {
                let tag = buf.readUInt8(fail)
                if (buf.isError(tag)) {
                    return tag
                }

                const cls = der.tagClass[tag >> 6]
                const primitive = (tag & 0x20) === 0

                // Multi-octet tag - load
                if ((tag & 0x1f) === 0x1f) {
                    let oct = tag
                    tag = 0
                    while ((oct & 0x80) === 0x80) {
                        oct = buf.readUInt8(fail)
                        if (buf.isError(oct)) {
                            return oct
                        }

                        tag <<= 7
                        tag |= oct & 0x7f
                    }
                } else {
                    tag &= 0x1f
                }
                const tagStr = der.tag[tag]

                return {
                    cls: cls,
                    primitive: primitive,
                    tag: tag,
                    tagStr: tagStr
                }
            }

            function derDecodeLen(buf, primitive, fail) {
                let len = buf.readUInt8(fail)
                if (buf.isError(len)) {
                    return len
                }

                // Indefinite form
                if (!primitive && len === 0x80) {
                    return null
                }

                // Definite form
                if ((len & 0x80) === 0) {
                    // Short form
                    return len
                }

                // Long form
                const num = len & 0x7f
                if (num > 4) {
                    return buf.error('length octect is too long')
                }

                len = 0
                for (let i = 0; i < num; i++) {
                    len <<= 8
                    const j = buf.readUInt8(fail)
                    if (buf.isError(j)) {
                        return j
                    }
                    len |= j
                }

                return len
            }

            module.exports = DERDecoder

            /***/
        },

        /***/ RF0s: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            var pad_string_1 = __webpack_require__('vUsp')
            function encode(input, encoding) {
                if (encoding === void 0) {
                    encoding = 'utf8'
                }
                if (Buffer.isBuffer(input)) {
                    return fromBase64(input.toString('base64'))
                }
                return fromBase64(
                    Buffer.from(input, encoding).toString('base64')
                )
            }
            function decode(base64url, encoding) {
                if (encoding === void 0) {
                    encoding = 'utf8'
                }
                return Buffer.from(toBase64(base64url), 'base64').toString(
                    encoding
                )
            }
            function toBase64(base64url) {
                base64url = base64url.toString()
                return pad_string_1
                    .default(base64url)
                    .replace(/\-/g, '+')
                    .replace(/_/g, '/')
            }
            function fromBase64(base64) {
                return base64
                    .replace(/=/g, '')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
            }
            function toBuffer(base64url) {
                return Buffer.from(toBase64(base64url), 'base64')
            }
            var base64url = encode
            base64url.encode = encode
            base64url.decode = decode
            base64url.toBase64 = toBase64
            base64url.fromBase64 = fromBase64
            base64url.toBuffer = toBuffer
            exports.default = base64url

            /***/
        },

        /***/ RFts: /***/ function(module, exports, __webpack_require__) {
            const { improvedDH } = __webpack_require__('pDDt')

            if (improvedDH) {
                const { diffieHellman } = __webpack_require__('PJMN')

                const { KeyObject } = __webpack_require__('1ALl')
                const importKey = __webpack_require__('GhER')

                module.exports = ({ keyObject: privateKey }, publicKey) => {
                    if (!(publicKey instanceof KeyObject)) {
                        ;({ keyObject: publicKey } = importKey(publicKey))
                    }

                    return diffieHellman({ privateKey, publicKey })
                }
            } else {
                const {
                    createECDH,
                    constants: { POINT_CONVERSION_UNCOMPRESSED }
                } = __webpack_require__('PJMN')

                const base64url = __webpack_require__('Xab3')

                const crvToCurve = crv => {
                    switch (crv) {
                        case 'P-256':
                            return 'prime256v1'
                        case 'P-384':
                            return 'secp384r1'
                        case 'P-521':
                            return 'secp521r1'
                    }
                }

                const UNCOMPRESSED = Buffer.alloc(
                    1,
                    POINT_CONVERSION_UNCOMPRESSED
                )
                const pubToBuffer = (x, y) =>
                    Buffer.concat([
                        UNCOMPRESSED,
                        base64url.decodeToBuffer(x),
                        base64url.decodeToBuffer(y)
                    ])

                module.exports = ({ crv, d }, { x, y }) => {
                    const curve = crvToCurve(crv)
                    const exchange = createECDH(curve)

                    exchange.setPrivateKey(base64url.decodeToBuffer(d))

                    return exchange.computeSecret(pubToBuffer(x, y))
                }
            }

            /***/
        },

        /***/ RGIU: /***/ function(module, exports, __webpack_require__) {
            const { randomBytes } = __webpack_require__('PJMN')

            const { createSecretKey } = __webpack_require__('1ALl')
            const { KEYLENGTHS } = __webpack_require__('N+nT')
            const Key = __webpack_require__('BBt9')

            module.exports = alg => {
                const keyLength = KEYLENGTHS.get(alg)

                if (!keyLength) {
                    return new Key({ type: 'secret' })
                }

                return new Key(createSecretKey(randomBytes(keyLength / 8)), {
                    use: 'enc',
                    alg
                })
            }

            /***/
        },

        /***/ RIp3: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var crypto = __webpack_require__('PJMN')

            /**
             * Exported function
             *
             * Options:
             *
             *  - `algorithm` hash algo to be used by this instance: *'sha1', 'md5'
             *  - `excludeValues` {true|*false} hash object keys, values ignored
             *  - `encoding` hash encoding, supports 'buffer', '*hex', 'binary', 'base64'
             *  - `ignoreUnknown` {true|*false} ignore unknown object types
             *  - `replacer` optional function that replaces values before hashing
             *  - `respectFunctionProperties` {*true|false} consider function properties when hashing
             *  - `respectFunctionNames` {*true|false} consider 'name' property of functions for hashing
             *  - `respectType` {*true|false} Respect special properties (prototype, constructor)
             *    when hashing to distinguish between types
             *  - `unorderedArrays` {true|*false} Sort all arrays before hashing
             *  - `unorderedSets` {*true|false} Sort `Set` and `Map` instances before hashing
             *  * = default
             *
             * @param {object} object value to hash
             * @param {object} options hashing options
             * @return {string} hash value
             * @api public
             */
            exports = module.exports = objectHash

            function objectHash(object, options) {
                options = applyDefaults(object, options)

                return hash(object, options)
            }

            /**
             * Exported sugar methods
             *
             * @param {object} object value to hash
             * @return {string} hash value
             * @api public
             */
            exports.sha1 = function(object) {
                return objectHash(object)
            }
            exports.keys = function(object) {
                return objectHash(object, {
                    excludeValues: true,
                    algorithm: 'sha1',
                    encoding: 'hex'
                })
            }
            exports.MD5 = function(object) {
                return objectHash(object, { algorithm: 'md5', encoding: 'hex' })
            }
            exports.keysMD5 = function(object) {
                return objectHash(object, {
                    algorithm: 'md5',
                    encoding: 'hex',
                    excludeValues: true
                })
            }

            // Internals
            var hashes = crypto.getHashes
                ? crypto.getHashes().slice()
                : ['sha1', 'md5']
            hashes.push('passthrough')
            var encodings = ['buffer', 'hex', 'binary', 'base64']

            function applyDefaults(object, sourceOptions) {
                sourceOptions = sourceOptions || {}

                // create a copy rather than mutating
                var options = {}
                options.algorithm = sourceOptions.algorithm || 'sha1'
                options.encoding = sourceOptions.encoding || 'hex'
                options.excludeValues = sourceOptions.excludeValues
                    ? true
                    : false
                options.algorithm = options.algorithm.toLowerCase()
                options.encoding = options.encoding.toLowerCase()
                options.ignoreUnknown =
                    sourceOptions.ignoreUnknown !== true ? false : true // default to false
                options.respectType =
                    sourceOptions.respectType === false ? false : true // default to true
                options.respectFunctionNames =
                    sourceOptions.respectFunctionNames === false ? false : true
                options.respectFunctionProperties =
                    sourceOptions.respectFunctionProperties === false
                        ? false
                        : true
                options.unorderedArrays =
                    sourceOptions.unorderedArrays !== true ? false : true // default to false
                options.unorderedSets =
                    sourceOptions.unorderedSets === false ? false : true // default to false
                options.unorderedObjects =
                    sourceOptions.unorderedObjects === false ? false : true // default to true
                options.replacer = sourceOptions.replacer || undefined
                options.excludeKeys = sourceOptions.excludeKeys || undefined

                if (typeof object === 'undefined') {
                    throw new Error('Object argument required.')
                }

                // if there is a case-insensitive match in the hashes list, accept it
                // (i.e. SHA256 for sha256)
                for (var i = 0; i < hashes.length; ++i) {
                    if (
                        hashes[i].toLowerCase() ===
                        options.algorithm.toLowerCase()
                    ) {
                        options.algorithm = hashes[i]
                    }
                }

                if (hashes.indexOf(options.algorithm) === -1) {
                    throw new Error(
                        'Algorithm "' +
                            options.algorithm +
                            '"  not supported. ' +
                            'supported values: ' +
                            hashes.join(', ')
                    )
                }

                if (
                    encodings.indexOf(options.encoding) === -1 &&
                    options.algorithm !== 'passthrough'
                ) {
                    throw new Error(
                        'Encoding "' +
                            options.encoding +
                            '"  not supported. ' +
                            'supported values: ' +
                            encodings.join(', ')
                    )
                }

                return options
            }

            /** Check if the given function is a native function */
            function isNativeFunction(f) {
                if (typeof f !== 'function') {
                    return false
                }
                var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i
                return exp.exec(Function.prototype.toString.call(f)) != null
            }

            function hash(object, options) {
                var hashingStream

                if (options.algorithm !== 'passthrough') {
                    hashingStream = crypto.createHash(options.algorithm)
                } else {
                    hashingStream = new PassThrough()
                }

                if (typeof hashingStream.write === 'undefined') {
                    hashingStream.write = hashingStream.update
                    hashingStream.end = hashingStream.update
                }

                var hasher = typeHasher(options, hashingStream)
                hasher.dispatch(object)
                if (!hashingStream.update) {
                    hashingStream.end('')
                }

                if (hashingStream.digest) {
                    return hashingStream.digest(
                        options.encoding === 'buffer'
                            ? undefined
                            : options.encoding
                    )
                }

                var buf = hashingStream.read()
                if (options.encoding === 'buffer') {
                    return buf
                }

                return buf.toString(options.encoding)
            }

            /**
             * Expose streaming API
             *
             * @param {object} object  Value to serialize
             * @param {object} options  Options, as for hash()
             * @param {object} stream  A stream to write the serializiation to
             * @api public
             */
            exports.writeToStream = function(object, options, stream) {
                if (typeof stream === 'undefined') {
                    stream = options
                    options = {}
                }

                options = applyDefaults(object, options)

                return typeHasher(options, stream).dispatch(object)
            }

            function typeHasher(options, writeTo, context) {
                context = context || []
                var write = function(str) {
                    if (writeTo.update) {
                        return writeTo.update(str, 'utf8')
                    } else {
                        return writeTo.write(str, 'utf8')
                    }
                }

                return {
                    dispatch: function(value) {
                        if (options.replacer) {
                            value = options.replacer(value)
                        }

                        var type = typeof value
                        if (value === null) {
                            type = 'null'
                        }

                        //console.log("[DEBUG] Dispatch: ", value, "->", type, " -> ", "_" + type);

                        return this['_' + type](value)
                    },
                    _object: function(object) {
                        var pattern = /\[object (.*)\]/i
                        var objString = Object.prototype.toString.call(object)
                        var objType = pattern.exec(objString)
                        if (!objType) {
                            // object type did not match [object ...]
                            objType = 'unknown:[' + objString + ']'
                        } else {
                            objType = objType[1] // take only the class name
                        }

                        objType = objType.toLowerCase()

                        var objectNumber = null

                        if ((objectNumber = context.indexOf(object)) >= 0) {
                            return this.dispatch(
                                '[CIRCULAR:' + objectNumber + ']'
                            )
                        } else {
                            context.push(object)
                        }

                        if (
                            typeof Buffer !== 'undefined' &&
                            Buffer.isBuffer &&
                            Buffer.isBuffer(object)
                        ) {
                            write('buffer:')
                            return write(object)
                        }

                        if (
                            objType !== 'object' &&
                            objType !== 'function' &&
                            objType !== 'asyncfunction'
                        ) {
                            if (this['_' + objType]) {
                                this['_' + objType](object)
                            } else if (options.ignoreUnknown) {
                                return write('[' + objType + ']')
                            } else {
                                throw new Error(
                                    'Unknown object type "' + objType + '"'
                                )
                            }
                        } else {
                            var keys = Object.keys(object)
                            if (options.unorderedObjects) {
                                keys = keys.sort()
                            }
                            // Make sure to incorporate special properties, so
                            // Types with different prototypes will produce
                            // a different hash and objects derived from
                            // different functions (`new Foo`, `new Bar`) will
                            // produce different hashes.
                            // We never do this for native functions since some
                            // seem to break because of that.
                            if (
                                options.respectType !== false &&
                                !isNativeFunction(object)
                            ) {
                                keys.splice(
                                    0,
                                    0,
                                    'prototype',
                                    '__proto__',
                                    'constructor'
                                )
                            }

                            if (options.excludeKeys) {
                                keys = keys.filter(function(key) {
                                    return !options.excludeKeys(key)
                                })
                            }

                            write('object:' + keys.length + ':')
                            var self = this
                            return keys.forEach(function(key) {
                                self.dispatch(key)
                                write(':')
                                if (!options.excludeValues) {
                                    self.dispatch(object[key])
                                }
                                write(',')
                            })
                        }
                    },
                    _array: function(arr, unordered) {
                        unordered =
                            typeof unordered !== 'undefined'
                                ? unordered
                                : options.unorderedArrays !== false // default to options.unorderedArrays

                        var self = this
                        write('array:' + arr.length + ':')
                        if (!unordered || arr.length <= 1) {
                            return arr.forEach(function(entry) {
                                return self.dispatch(entry)
                            })
                        }

                        // the unordered case is a little more complicated:
                        // since there is no canonical ordering on objects,
                        // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,
                        // we first serialize each entry using a PassThrough stream
                        // before sorting.
                        // also: we cant use the same context array for all entries
                        // since the order of hashing should *not* matter. instead,
                        // we keep track of the additions to a copy of the context array
                        // and add all of them to the global context array when were done
                        var contextAdditions = []
                        var entries = arr.map(function(entry) {
                            var strm = new PassThrough()
                            var localContext = context.slice() // make copy
                            var hasher = typeHasher(options, strm, localContext)
                            hasher.dispatch(entry)
                            // take only what was added to localContext and append it to contextAdditions
                            contextAdditions = contextAdditions.concat(
                                localContext.slice(context.length)
                            )
                            return strm.read().toString()
                        })
                        context = context.concat(contextAdditions)
                        entries.sort()
                        return this._array(entries, false)
                    },
                    _date: function(date) {
                        return write('date:' + date.toJSON())
                    },
                    _symbol: function(sym) {
                        return write('symbol:' + sym.toString())
                    },
                    _error: function(err) {
                        return write('error:' + err.toString())
                    },
                    _boolean: function(bool) {
                        return write('bool:' + bool.toString())
                    },
                    _string: function(string) {
                        write('string:' + string.length + ':')
                        write(string.toString())
                    },
                    _function: function(fn) {
                        write('fn:')
                        if (isNativeFunction(fn)) {
                            this.dispatch('[native]')
                        } else {
                            this.dispatch(fn.toString())
                        }

                        if (options.respectFunctionNames !== false) {
                            // Make sure we can still distinguish native functions
                            // by their name, otherwise String and Function will
                            // have the same hash
                            this.dispatch('function-name:' + String(fn.name))
                        }

                        if (options.respectFunctionProperties) {
                            this._object(fn)
                        }
                    },
                    _number: function(number) {
                        return write('number:' + number.toString())
                    },
                    _xml: function(xml) {
                        return write('xml:' + xml.toString())
                    },
                    _null: function() {
                        return write('Null')
                    },
                    _undefined: function() {
                        return write('Undefined')
                    },
                    _regexp: function(regex) {
                        return write('regex:' + regex.toString())
                    },
                    _uint8array: function(arr) {
                        write('uint8array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _uint8clampedarray: function(arr) {
                        write('uint8clampedarray:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _int8array: function(arr) {
                        write('uint8array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _uint16array: function(arr) {
                        write('uint16array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _int16array: function(arr) {
                        write('uint16array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _uint32array: function(arr) {
                        write('uint32array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _int32array: function(arr) {
                        write('uint32array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _float32array: function(arr) {
                        write('float32array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _float64array: function(arr) {
                        write('float64array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _arraybuffer: function(arr) {
                        write('arraybuffer:')
                        return this.dispatch(new Uint8Array(arr))
                    },
                    _url: function(url) {
                        return write('url:' + url.toString(), 'utf8')
                    },
                    _map: function(map) {
                        write('map:')
                        var arr = Array.from(map)
                        return this._array(arr, options.unorderedSets !== false)
                    },
                    _set: function(set) {
                        write('set:')
                        var arr = Array.from(set)
                        return this._array(arr, options.unorderedSets !== false)
                    },
                    _blob: function() {
                        if (options.ignoreUnknown) {
                            return write('[blob]')
                        }

                        throw Error(
                            'Hashing Blob objects is currently not supported\n' +
                                '(see https://github.com/puleos/object-hash/issues/26)\n' +
                                'Use "options.replacer" or "options.ignoreUnknown"\n'
                        )
                    },
                    _domwindow: function() {
                        return write('domwindow')
                    },
                    /* Node.js standard native objects */
                    _process: function() {
                        return write('process')
                    },
                    _timer: function() {
                        return write('timer')
                    },
                    _pipe: function() {
                        return write('pipe')
                    },
                    _tcp: function() {
                        return write('tcp')
                    },
                    _udp: function() {
                        return write('udp')
                    },
                    _tty: function() {
                        return write('tty')
                    },
                    _statwatcher: function() {
                        return write('statwatcher')
                    },
                    _securecontext: function() {
                        return write('securecontext')
                    },
                    _connection: function() {
                        return write('connection')
                    },
                    _zlib: function() {
                        return write('zlib')
                    },
                    _context: function() {
                        return write('context')
                    },
                    _nodescript: function() {
                        return write('nodescript')
                    },
                    _httpparser: function() {
                        return write('httpparser')
                    },
                    _dataview: function() {
                        return write('dataview')
                    },
                    _signal: function() {
                        return write('signal')
                    },
                    _fsevent: function() {
                        return write('fsevent')
                    },
                    _tlswrap: function() {
                        return write('tlswrap')
                    }
                }
            }

            // Mini-implementation of stream.PassThrough
            // We are far from having need for the full implementation, and we can
            // make assumptions like "many writes, then only one final read"
            // and we can ignore encoding specifics
            function PassThrough() {
                return {
                    buf: '',

                    write: function(b) {
                        this.buf += b
                    },

                    end: function(b) {
                        this.buf += b
                    },

                    read: function() {
                        return this.buf
                    }
                }
            }

            /***/
        },

        /***/ 'RU/L': /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('Rqdy')
            var $Object = __webpack_require__('WEpk').Object
            module.exports = function defineProperty(it, key, desc) {
                return $Object.defineProperty(it, key, desc)
            }

            /***/
        },

        /***/ RXbi: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = {
                applyToDefaults: __webpack_require__('Rsz9'),
                assert: __webpack_require__('GlC0'),
                Bench: __webpack_require__('rMgD'),
                block: __webpack_require__('RsAt'),
                clone: __webpack_require__('qnp3'),
                contain: __webpack_require__('781u'),
                deepEqual: __webpack_require__('Cl1u'),
                Error: __webpack_require__('Fow+'),
                escapeHeaderAttribute: __webpack_require__('GCLL'),
                escapeHtml: __webpack_require__('3Zki'),
                escapeJson: __webpack_require__('zCb7'),
                escapeRegex: __webpack_require__('zosA'),
                flatten: __webpack_require__('s8OG'),
                ignore: __webpack_require__('kl4A'),
                intersect: __webpack_require__('uWJx'),
                isPromise: __webpack_require__('hpEj'),
                merge: __webpack_require__('5ZhA'),
                once: __webpack_require__('i8G8'),
                reach: __webpack_require__('mmuM'),
                reachTemplate: __webpack_require__('Pxi6'),
                stringify: __webpack_require__('VraX'),
                wait: __webpack_require__('gAB1')
            }

            /***/
        },

        /***/ Ra3S: /***/ function(module, exports) {
            module.exports = function() {
                this.seq().obj(
                    this.key('version').int({ 0: 'two-prime', 1: 'multi' }),
                    this.key('n').int(),
                    this.key('e').int(),
                    this.key('d').int(),
                    this.key('p').int(),
                    this.key('q').int(),
                    this.key('dp').int(),
                    this.key('dq').int(),
                    this.key('qi').int()
                )
            }

            /***/
        },

        /***/ RoCg: /***/ function(module, exports, __webpack_require__) {
            const {
                generateKeyPairSync,
                generateKeyPair: async
            } = __webpack_require__('PJMN')
            const { promisify } = __webpack_require__('jK02')

            const {
                THUMBPRINT_MATERIAL,
                JWK_MEMBERS,
                PUBLIC_MEMBERS,
                PRIVATE_MEMBERS,
                KEY_MANAGEMENT_DECRYPT,
                KEY_MANAGEMENT_ENCRYPT
            } = __webpack_require__('ehsS')
            const { keyObjectSupported } = __webpack_require__('pDDt')
            const { createPublicKey, createPrivateKey } = __webpack_require__(
                '1ALl'
            )

            const Key = __webpack_require__('//Cd')

            const generateKeyPair = promisify(async)

            const RSA_PUBLIC = new Set(['e', 'n'])
            Object.freeze(RSA_PUBLIC)
            const RSA_PRIVATE = new Set([
                ...RSA_PUBLIC,
                'd',
                'p',
                'q',
                'dp',
                'dq',
                'qi'
            ])
            Object.freeze(RSA_PRIVATE)

            // RSA Key Type
            class RSAKey extends Key {
                constructor(...args) {
                    super(...args)
                    this[JWK_MEMBERS]()
                    Object.defineProperties(this, {
                        kty: {
                            value: 'RSA',
                            enumerable: true
                        },
                        length: {
                            get() {
                                Object.defineProperty(this, 'length', {
                                    value:
                                        Buffer.byteLength(this.n, 'base64') * 8,
                                    configurable: false
                                })

                                return this.length
                            },
                            configurable: true
                        }
                    })
                }

                static get [PUBLIC_MEMBERS]() {
                    return RSA_PUBLIC
                }

                static get [PRIVATE_MEMBERS]() {
                    return RSA_PRIVATE
                }

                // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special
                // JSON.stringify handling in V8
                [THUMBPRINT_MATERIAL]() {
                    return { e: this.e, kty: 'RSA', n: this.n }
                }

                [KEY_MANAGEMENT_ENCRYPT]() {
                    return this.algorithms('wrapKey')
                }

                [KEY_MANAGEMENT_DECRYPT]() {
                    return this.algorithms('unwrapKey')
                }

                static async generate(len = 2048, privat = true) {
                    if (
                        !Number.isSafeInteger(len) ||
                        len < 512 ||
                        len % 8 !== 0 ||
                        ('electron' in process.versions && len % 128 !== 0)
                    ) {
                        throw new TypeError('invalid bit length')
                    }

                    let privateKey, publicKey

                    if (keyObjectSupported) {
                        ;({
                            privateKey,
                            publicKey
                        } = await generateKeyPair('rsa', {
                            modulusLength: len
                        }))
                        return privat ? privateKey : publicKey
                    }

                    ;({ privateKey, publicKey } = await generateKeyPair('rsa', {
                        modulusLength: len,
                        publicKeyEncoding: { type: 'spki', format: 'pem' },
                        privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
                    }))

                    if (privat) {
                        return createPrivateKey(privateKey)
                    } else {
                        return createPublicKey(publicKey)
                    }
                }

                static generateSync(len = 2048, privat = true) {
                    if (
                        !Number.isSafeInteger(len) ||
                        len < 512 ||
                        len % 8 !== 0 ||
                        ('electron' in process.versions && len % 128 !== 0)
                    ) {
                        throw new TypeError('invalid bit length')
                    }

                    let privateKey, publicKey

                    if (keyObjectSupported) {
                        ;({ privateKey, publicKey } = generateKeyPairSync(
                            'rsa',
                            { modulusLength: len }
                        ))
                        return privat ? privateKey : publicKey
                    }

                    ;({ privateKey, publicKey } = generateKeyPairSync('rsa', {
                        modulusLength: len,
                        publicKeyEncoding: { type: 'spki', format: 'pem' },
                        privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
                    }))

                    if (privat) {
                        return createPrivateKey(privateKey)
                    } else {
                        return createPublicKey(publicKey)
                    }
                }
            }

            module.exports = RSAKey

            /***/
        },

        /***/ Rqdy: /***/ function(module, exports, __webpack_require__) {
            var $export = __webpack_require__('Y7ZC')
            // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
            $export(
                $export.S + $export.F * !__webpack_require__('jmDH'),
                'Object',
                { defineProperty: __webpack_require__('2faE').f }
            )

            /***/
        },

        /***/ RsAt: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Ignore = __webpack_require__('kl4A')

            const internals = {}

            module.exports = function() {
                return new Promise(Ignore) // $lab:coverage:ignore$
            }

            /***/
        },

        /***/ Rsz9: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Assert = __webpack_require__('GlC0')
            const Clone = __webpack_require__('qnp3')
            const Merge = __webpack_require__('5ZhA')
            const Utils = __webpack_require__('O0PD')

            const internals = {}

            module.exports = function(defaults, source, options = {}) {
                Assert(
                    defaults && typeof defaults === 'object',
                    'Invalid defaults value: must be an object'
                )
                Assert(
                    !source || source === true || typeof source === 'object',
                    'Invalid source value: must be true, falsy or an object'
                )
                Assert(
                    typeof options === 'object',
                    'Invalid options: must be an object'
                )

                if (!source) {
                    // If no source, return null
                    return null
                }

                if (options.shallow) {
                    return internals.applyToDefaultsWithShallow(
                        defaults,
                        source,
                        options
                    )
                }

                const copy = Clone(defaults)

                if (source === true) {
                    // If source is set to true, use defaults
                    return copy
                }

                const nullOverride =
                    options.nullOverride !== undefined
                        ? options.nullOverride
                        : false
                return Merge(copy, source, { nullOverride, mergeArrays: false })
            }

            internals.applyToDefaultsWithShallow = function(
                defaults,
                source,
                options
            ) {
                const keys = options.shallow
                Assert(Array.isArray(keys), 'Invalid keys')

                options = Object.assign({}, options)
                options.shallow = false

                const copy = Clone(defaults, { shallow: keys })

                if (source === true) {
                    // If source is set to true, use defaults
                    return copy
                }

                const storage = Utils.store(source, keys) // Move shallow copy items to storage
                Merge(copy, source, { mergeArrays: false, nullOverride: false }) // Deep copy the rest
                Utils.restore(copy, source, storage) // Shallow copy the stored items and restore
                return copy
            }

            /***/
        },

        /***/ S6im: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = (string, count = 1, options) => {
                options = {
                    indent: ' ',
                    includeEmptyLines: false,
                    ...options
                }

                if (typeof string !== 'string') {
                    throw new TypeError(
                        `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
                    )
                }

                if (typeof count !== 'number') {
                    throw new TypeError(
                        `Expected \`count\` to be a \`number\`, got \`${typeof count}\``
                    )
                }

                if (typeof options.indent !== 'string') {
                    throw new TypeError(
                        `Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``
                    )
                }

                if (count === 0) {
                    return string
                }

                const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm

                return string.replace(regex, options.indent.repeat(count))
            }

            /***/
        },

        /***/ SYHD: /***/ function(module) {
            module.exports = JSON.parse(
                '[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]'
            )

            /***/
        },

        /***/ SfRM: /***/ function(module, exports, __webpack_require__) {
            var nativeCreate = __webpack_require__('YESw')

            /**
             * Removes all key-value entries from the hash.
             *
             * @private
             * @name clear
             * @memberOf Hash
             */
            function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {}
                this.size = 0
            }

            module.exports = hashClear

            /***/
        },

        /***/ SmFm: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * unpipe
             * Copyright(c) 2015 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module exports.
             * @public
             */

            module.exports = unpipe

            /**
             * Determine if there are Node.js pipe-like data listeners.
             * @private
             */

            function hasPipeDataListeners(stream) {
                var listeners = stream.listeners('data')

                for (var i = 0; i < listeners.length; i++) {
                    if (listeners[i].name === 'ondata') {
                        return true
                    }
                }

                return false
            }

            /**
             * Unpipe a stream from all destinations.
             *
             * @param {object} stream
             * @public
             */

            function unpipe(stream) {
                if (!stream) {
                    throw new TypeError('argument stream is required')
                }

                if (typeof stream.unpipe === 'function') {
                    // new-style
                    stream.unpipe()
                    return
                }

                // Node.js 0.8 hack
                if (!hasPipeDataListeners(stream)) {
                    return
                }

                var listener
                var listeners = stream.listeners('close')

                for (var i = 0; i < listeners.length; i++) {
                    listener = listeners[i]

                    if (
                        listener.name !== 'cleanup' &&
                        listener.name !== 'onclose'
                    ) {
                        continue
                    }

                    // invoke the listener
                    listener.call(stream)
                }
            }

            /***/
        },

        /***/ SwXk: /***/ function(module, exports, __webpack_require__) {
            const isObject = __webpack_require__('kF1/')
            let validateCrit = __webpack_require__('urXW')
            const { JWSInvalid } = __webpack_require__('yt7c')

            validateCrit = validateCrit.bind(undefined, JWSInvalid)

            const compactSerializer = (payload, [recipient]) => {
                return `${recipient.protected}.${payload}.${recipient.signature}`
            }
            compactSerializer.validate = (
                jws,
                { 0: { unprotectedHeader, protectedHeader }, length }
            ) => {
                if (length !== 1 || unprotectedHeader) {
                    throw new JWSInvalid(
                        "JWS Compact Serialization doesn't support multiple recipients or JWS unprotected headers"
                    )
                }
                validateCrit(
                    protectedHeader,
                    unprotectedHeader,
                    protectedHeader ? protectedHeader.crit : undefined
                )
            }

            const flattenedSerializer = (payload, [recipient]) => {
                const { header, signature, protected: prot } = recipient

                return {
                    payload,
                    ...(prot ? { protected: prot } : undefined),
                    ...(header ? { header } : undefined),
                    signature
                }
            }
            flattenedSerializer.validate = (
                jws,
                { 0: { unprotectedHeader, protectedHeader }, length }
            ) => {
                if (length !== 1) {
                    throw new JWSInvalid(
                        "Flattened JWS JSON Serialization doesn't support multiple recipients"
                    )
                }
                validateCrit(
                    protectedHeader,
                    unprotectedHeader,
                    protectedHeader ? protectedHeader.crit : undefined
                )
            }

            const generalSerializer = (payload, recipients) => {
                return {
                    payload,
                    signatures: recipients.map(
                        ({ header, signature, protected: prot }) => {
                            return {
                                ...(prot ? { protected: prot } : undefined),
                                ...(header ? { header } : undefined),
                                signature
                            }
                        }
                    )
                }
            }
            generalSerializer.validate = (jws, recipients) => {
                recipients.forEach(({ protectedHeader, unprotectedHeader }) => {
                    validateCrit(
                        protectedHeader,
                        unprotectedHeader,
                        protectedHeader ? protectedHeader.crit : undefined
                    )
                })
            }

            const isJSON = input => {
                return (
                    isObject(input) &&
                    (typeof input.payload === 'string' ||
                        Buffer.isBuffer(input.payload))
                )
            }

            const isValidRecipient = recipient => {
                return (
                    isObject(recipient) &&
                    typeof recipient.signature === 'string' &&
                    (recipient.header === undefined ||
                        isObject(recipient.header)) &&
                    (recipient.protected === undefined ||
                        typeof recipient.protected === 'string')
                )
            }

            const isMultiRecipient = input => {
                if (
                    Array.isArray(input.signatures) &&
                    input.signatures.every(isValidRecipient)
                ) {
                    return true
                }

                return false
            }

            const detect = input => {
                if (
                    typeof input === 'string' &&
                    input.split('.').length === 3
                ) {
                    return 'compact'
                }

                if (isJSON(input)) {
                    if (isMultiRecipient(input)) {
                        return 'general'
                    }

                    if (isValidRecipient(input)) {
                        return 'flattened'
                    }
                }

                throw new JWSInvalid('JWS malformed or invalid serialization')
            }

            module.exports = {
                compact: compactSerializer,
                flattened: flattenedSerializer,
                general: generalSerializer,
                detect
            }

            /***/
        },

        /***/ T1AV: /***/ function(module, exports, __webpack_require__) {
            var assignMergeValue = __webpack_require__('t2Dn'),
                cloneBuffer = __webpack_require__('5Tg0'),
                cloneTypedArray = __webpack_require__('yP5f'),
                copyArray = __webpack_require__('Q1l4'),
                initCloneObject = __webpack_require__('+iFO'),
                isArguments = __webpack_require__('03A+'),
                isArray = __webpack_require__('Z0cm'),
                isArrayLikeObject = __webpack_require__('3L66'),
                isBuffer = __webpack_require__('DSRE'),
                isFunction = __webpack_require__('lSCD'),
                isObject = __webpack_require__('GoyQ'),
                isPlainObject = __webpack_require__('YO3V'),
                isTypedArray = __webpack_require__('c6wG'),
                safeGet = __webpack_require__('itsj'),
                toPlainObject = __webpack_require__('jeLo')

            /**
             * A specialized version of `baseMerge` for arrays and objects which performs
             * deep merges and tracks traversed objects enabling objects with circular
             * references to be merged.
             *
             * @private
             * @param {Object} object The destination object.
             * @param {Object} source The source object.
             * @param {string} key The key of the value to merge.
             * @param {number} srcIndex The index of `source`.
             * @param {Function} mergeFunc The function to merge values.
             * @param {Function} [customizer] The function to customize assigned values.
             * @param {Object} [stack] Tracks traversed source values and their merged
             *  counterparts.
             */
            function baseMergeDeep(
                object,
                source,
                key,
                srcIndex,
                mergeFunc,
                customizer,
                stack
            ) {
                var objValue = safeGet(object, key),
                    srcValue = safeGet(source, key),
                    stacked = stack.get(srcValue)

                if (stacked) {
                    assignMergeValue(object, key, stacked)
                    return
                }
                var newValue = customizer
                    ? customizer(
                          objValue,
                          srcValue,
                          key + '',
                          object,
                          source,
                          stack
                      )
                    : undefined

                var isCommon = newValue === undefined

                if (isCommon) {
                    var isArr = isArray(srcValue),
                        isBuff = !isArr && isBuffer(srcValue),
                        isTyped = !isArr && !isBuff && isTypedArray(srcValue)

                    newValue = srcValue
                    if (isArr || isBuff || isTyped) {
                        if (isArray(objValue)) {
                            newValue = objValue
                        } else if (isArrayLikeObject(objValue)) {
                            newValue = copyArray(objValue)
                        } else if (isBuff) {
                            isCommon = false
                            newValue = cloneBuffer(srcValue, true)
                        } else if (isTyped) {
                            isCommon = false
                            newValue = cloneTypedArray(srcValue, true)
                        } else {
                            newValue = []
                        }
                    } else if (
                        isPlainObject(srcValue) ||
                        isArguments(srcValue)
                    ) {
                        newValue = objValue
                        if (isArguments(objValue)) {
                            newValue = toPlainObject(objValue)
                        } else if (
                            !isObject(objValue) ||
                            isFunction(objValue)
                        ) {
                            newValue = initCloneObject(srcValue)
                        }
                    } else {
                        isCommon = false
                    }
                }
                if (isCommon) {
                    // Recursively merge objects and arrays (susceptible to call stack limits).
                    stack.set(srcValue, newValue)
                    mergeFunc(newValue, srcValue, srcIndex, customizer, stack)
                    stack['delete'](srcValue)
                }
                assignMergeValue(object, key, newValue)
            }

            module.exports = baseMergeDeep

            /***/
        },

        /***/ T1JI: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * statuses
             * Copyright(c) 2014 Jonathan Ong
             * Copyright(c) 2016 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module dependencies.
             * @private
             */

            var codes = __webpack_require__('tYgP')

            /**
             * Module exports.
             * @public
             */

            module.exports = status

            // status code to message map
            status.STATUS_CODES = codes

            // array of status codes
            status.codes = populateStatusesMap(status, codes)

            // status codes for redirects
            status.redirect = {
                300: true,
                301: true,
                302: true,
                303: true,
                305: true,
                307: true,
                308: true
            }

            // status codes for empty bodies
            status.empty = {
                204: true,
                205: true,
                304: true
            }

            // status codes for when you should retry the request
            status.retry = {
                502: true,
                503: true,
                504: true
            }

            /**
             * Populate the statuses map for given codes.
             * @private
             */

            function populateStatusesMap(statuses, codes) {
                var arr = []

                Object.keys(codes).forEach(function forEachCode(code) {
                    var message = codes[code]
                    var status = Number(code)

                    // Populate properties
                    statuses[status] = message
                    statuses[message] = status
                    statuses[message.toLowerCase()] = status

                    // Add to array
                    arr.push(status)
                })

                return arr
            }

            /**
             * Get the status code.
             *
             * Given a number, this will throw if it is not a known status
             * code, otherwise the code will be returned. Given a string,
             * the string will be parsed for a number and return the code
             * if valid, otherwise will lookup the code assuming this is
             * the status message.
             *
             * @param {string|number} code
             * @returns {number}
             * @public
             */

            function status(code) {
                if (typeof code === 'number') {
                    if (!status[code])
                        throw new Error('invalid status code: ' + code)
                    return code
                }

                if (typeof code !== 'string') {
                    throw new TypeError('code must be a number or string')
                }

                // '403'
                var n = parseInt(code, 10)
                if (!isNaN(n)) {
                    if (!status[n]) throw new Error('invalid status code: ' + n)
                    return n
                }

                n = status[code.toLowerCase()]
                if (!n)
                    throw new Error('invalid status message: "' + code + '"')
                return n
            }

            /***/
        },

        /***/ TJm8: /***/ function(module, exports) {
            const OIDC_DISCOVERY = '/.well-known/openid-configuration'
            const OAUTH2_DISCOVERY = '/.well-known/oauth-authorization-server'
            const WEBFINGER = '/.well-known/webfinger'
            const REL = 'http://openid.net/specs/connect/1.0/issuer'
            const AAD_MULTITENANT_DISCOVERY = new Set([
                `https://login.microsoftonline.com/common/v2.0${OIDC_DISCOVERY}`,
                `https://login.microsoftonline.com/organizations/v2.0${OIDC_DISCOVERY}`,
                `https://login.microsoftonline.com/consumers/v2.0${OIDC_DISCOVERY}`
            ])

            const CLIENT_DEFAULTS = {
                grant_types: ['authorization_code'],
                id_token_signed_response_alg: 'RS256',
                authorization_signed_response_alg: 'RS256',
                response_types: ['code'],
                token_endpoint_auth_method: 'client_secret_basic'
            }

            const ISSUER_DEFAULTS = {
                claim_types_supported: ['normal'],
                claims_parameter_supported: false,
                grant_types_supported: ['authorization_code', 'implicit'],
                request_parameter_supported: false,
                request_uri_parameter_supported: true,
                require_request_uri_registration: false,
                response_modes_supported: ['query', 'fragment'],
                token_endpoint_auth_methods_supported: ['client_secret_basic']
            }

            const CALLBACK_PROPERTIES = [
                'access_token', // 6749
                'code', // 6749
                'error', // 6749
                'error_description', // 6749
                'error_uri', // 6749
                'expires_in', // 6749
                'id_token', // Core 1.0
                'state', // 6749
                'token_type', // 6749
                'session_state', // Session Management
                'response' // JARM
            ]

            const JWT_CONTENT = /^application\/jwt/

            const HTTP_OPTIONS = Symbol('openid-client.custom.http-options')
            const CLOCK_TOLERANCE = Symbol(
                'openid-client.custom.clock-tolerance'
            )

            module.exports = {
                AAD_MULTITENANT_DISCOVERY,
                CALLBACK_PROPERTIES,
                CLIENT_DEFAULTS,
                CLOCK_TOLERANCE,
                HTTP_OPTIONS,
                ISSUER_DEFAULTS,
                JWT_CONTENT,
                OAUTH2_DISCOVERY,
                OIDC_DISCOVERY,
                REL,
                WEBFINGER
            }

            /***/
        },

        /***/ Tqu4: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = (url, opts) => {
                if (typeof url !== 'string') {
                    throw new TypeError(
                        `Expected \`url\` to be of type \`string\`, got \`${typeof url}\``
                    )
                }

                url = url.trim()
                opts = Object.assign({ https: false }, opts)

                if (/^\.*\/|^(?!localhost)\w+:/.test(url)) {
                    return url
                }

                return url.replace(
                    /^(?!(?:\w+:)?\/\/)/,
                    opts.https ? 'https://' : 'http://'
                )
            }

            /***/
        },

        /***/ U064: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var stream = __webpack_require__('msIP')

            function DuplexWrapper(options, writable, readable) {
                if (typeof readable === 'undefined') {
                    readable = writable
                    writable = options
                    options = null
                }

                stream.Duplex.call(this, options)

                if (typeof readable.read !== 'function') {
                    readable = new stream.Readable(options).wrap(readable)
                }

                this._writable = writable
                this._readable = readable
                this._waiting = false

                var self = this

                writable.once('finish', function() {
                    self.end()
                })

                this.once('finish', function() {
                    writable.end()
                })

                readable.on('readable', function() {
                    if (self._waiting) {
                        self._waiting = false
                        self._read()
                    }
                })

                readable.once('end', function() {
                    self.push(null)
                })

                if (
                    !options ||
                    typeof options.bubbleErrors === 'undefined' ||
                    options.bubbleErrors
                ) {
                    writable.on('error', function(err) {
                        self.emit('error', err)
                    })

                    readable.on('error', function(err) {
                        self.emit('error', err)
                    })
                }
            }

            DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {
                constructor: { value: DuplexWrapper }
            })

            DuplexWrapper.prototype._write = function _write(
                input,
                encoding,
                done
            ) {
                this._writable.write(input, encoding, done)
            }

            DuplexWrapper.prototype._read = function _read() {
                var buf
                var reads = 0
                while ((buf = this._readable.read()) !== null) {
                    this.push(buf)
                    reads++
                }
                if (reads === 0) {
                    this._waiting = true
                }
            }

            module.exports = function duplex2(options, writable, readable) {
                return new DuplexWrapper(options, writable, readable)
            }

            module.exports.DuplexWrapper = DuplexWrapper

            /***/
        },

        /***/ U3sn: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Hoek = __webpack_require__('RXbi')

            const internals = {
                codes: new Map([
                    [100, 'Continue'],
                    [101, 'Switching Protocols'],
                    [102, 'Processing'],
                    [200, 'OK'],
                    [201, 'Created'],
                    [202, 'Accepted'],
                    [203, 'Non-Authoritative Information'],
                    [204, 'No Content'],
                    [205, 'Reset Content'],
                    [206, 'Partial Content'],
                    [207, 'Multi-Status'],
                    [300, 'Multiple Choices'],
                    [301, 'Moved Permanently'],
                    [302, 'Moved Temporarily'],
                    [303, 'See Other'],
                    [304, 'Not Modified'],
                    [305, 'Use Proxy'],
                    [307, 'Temporary Redirect'],
                    [400, 'Bad Request'],
                    [401, 'Unauthorized'],
                    [402, 'Payment Required'],
                    [403, 'Forbidden'],
                    [404, 'Not Found'],
                    [405, 'Method Not Allowed'],
                    [406, 'Not Acceptable'],
                    [407, 'Proxy Authentication Required'],
                    [408, 'Request Time-out'],
                    [409, 'Conflict'],
                    [410, 'Gone'],
                    [411, 'Length Required'],
                    [412, 'Precondition Failed'],
                    [413, 'Request Entity Too Large'],
                    [414, 'Request-URI Too Large'],
                    [415, 'Unsupported Media Type'],
                    [416, 'Requested Range Not Satisfiable'],
                    [417, 'Expectation Failed'],
                    [418, "I'm a teapot"],
                    [422, 'Unprocessable Entity'],
                    [423, 'Locked'],
                    [424, 'Failed Dependency'],
                    [425, 'Unordered Collection'],
                    [426, 'Upgrade Required'],
                    [428, 'Precondition Required'],
                    [429, 'Too Many Requests'],
                    [431, 'Request Header Fields Too Large'],
                    [451, 'Unavailable For Legal Reasons'],
                    [500, 'Internal Server Error'],
                    [501, 'Not Implemented'],
                    [502, 'Bad Gateway'],
                    [503, 'Service Unavailable'],
                    [504, 'Gateway Time-out'],
                    [505, 'HTTP Version Not Supported'],
                    [506, 'Variant Also Negotiates'],
                    [507, 'Insufficient Storage'],
                    [509, 'Bandwidth Limit Exceeded'],
                    [510, 'Not Extended'],
                    [511, 'Network Authentication Required']
                ])
            }

            module.exports = internals.Boom = class extends Error {
                constructor(message, options = {}) {
                    if (message instanceof Error) {
                        return internals.Boom.boomify(
                            Hoek.clone(message),
                            options
                        )
                    }

                    const {
                        statusCode = 500,
                        data = null,
                        ctor = internals.Boom
                    } = options
                    const error = new Error(message ? message : undefined) // Avoids settings null message
                    Error.captureStackTrace(error, ctor) // Filter the stack to our external API
                    error.data = data
                    const boom = internals.initialize(error, statusCode)

                    Object.defineProperty(boom, 'typeof', { value: ctor })

                    if (options.decorate) {
                        Object.assign(boom, options.decorate)
                    }

                    return boom
                }

                static [Symbol.hasInstance](instance) {
                    return internals.Boom.isBoom(instance)
                }

                static isBoom(err) {
                    return err instanceof Error && !!err.isBoom
                }

                static boomify(err, options) {
                    Hoek.assert(
                        err instanceof Error,
                        'Cannot wrap non-Error object'
                    )

                    options = options || {}

                    if (options.data !== undefined) {
                        err.data = options.data
                    }

                    if (options.decorate) {
                        Object.assign(err, options.decorate)
                    }

                    if (!err.isBoom) {
                        return internals.initialize(
                            err,
                            options.statusCode || 500,
                            options.message
                        )
                    }

                    if (
                        options.override === false || // Defaults to true
                        (!options.statusCode && !options.message)
                    ) {
                        return err
                    }

                    return internals.initialize(
                        err,
                        options.statusCode || err.output.statusCode,
                        options.message
                    )
                }

                // 4xx Client Errors

                static badRequest(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 400,
                        data,
                        ctor: internals.Boom.badRequest
                    })
                }

                static unauthorized(message, scheme, attributes) {
                    // Or (message, wwwAuthenticate[])

                    const err = new internals.Boom(message, {
                        statusCode: 401,
                        ctor: internals.Boom.unauthorized
                    })

                    // function (message)

                    if (!scheme) {
                        return err
                    }

                    // function (message, wwwAuthenticate[])

                    if (typeof scheme !== 'string') {
                        err.output.headers['WWW-Authenticate'] = scheme.join(
                            ', '
                        )
                        return err
                    }

                    // function (message, scheme, attributes)

                    let wwwAuthenticate = `${scheme} `

                    if (attributes || message) {
                        err.output.payload.attributes = {}
                    }

                    if (attributes) {
                        if (typeof attributes === 'string') {
                            wwwAuthenticate += Hoek.escapeHeaderAttribute(
                                attributes
                            )
                            err.output.payload.attributes = attributes
                        } else {
                            wwwAuthenticate += Object.keys(attributes)
                                .map(name => {
                                    let value = attributes[name]
                                    if (value === null || value === undefined) {
                                        value = ''
                                    }

                                    err.output.payload.attributes[name] = value
                                    return `${name}="${Hoek.escapeHeaderAttribute(
                                        value.toString()
                                    )}"`
                                })
                                .join(', ')
                        }
                    }

                    if (message) {
                        if (attributes) {
                            wwwAuthenticate += ', '
                        }

                        wwwAuthenticate += `error="${Hoek.escapeHeaderAttribute(
                            message
                        )}"`
                        err.output.payload.attributes.error = message
                    } else {
                        err.isMissing = true
                    }

                    err.output.headers['WWW-Authenticate'] = wwwAuthenticate
                    return err
                }

                static paymentRequired(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 402,
                        data,
                        ctor: internals.Boom.paymentRequired
                    })
                }

                static forbidden(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 403,
                        data,
                        ctor: internals.Boom.forbidden
                    })
                }

                static notFound(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 404,
                        data,
                        ctor: internals.Boom.notFound
                    })
                }

                static methodNotAllowed(message, data, allow) {
                    const err = new internals.Boom(message, {
                        statusCode: 405,
                        data,
                        ctor: internals.Boom.methodNotAllowed
                    })

                    if (typeof allow === 'string') {
                        allow = [allow]
                    }

                    if (Array.isArray(allow)) {
                        err.output.headers.Allow = allow.join(', ')
                    }

                    return err
                }

                static notAcceptable(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 406,
                        data,
                        ctor: internals.Boom.notAcceptable
                    })
                }

                static proxyAuthRequired(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 407,
                        data,
                        ctor: internals.Boom.proxyAuthRequired
                    })
                }

                static clientTimeout(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 408,
                        data,
                        ctor: internals.Boom.clientTimeout
                    })
                }

                static conflict(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 409,
                        data,
                        ctor: internals.Boom.conflict
                    })
                }

                static resourceGone(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 410,
                        data,
                        ctor: internals.Boom.resourceGone
                    })
                }

                static lengthRequired(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 411,
                        data,
                        ctor: internals.Boom.lengthRequired
                    })
                }

                static preconditionFailed(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 412,
                        data,
                        ctor: internals.Boom.preconditionFailed
                    })
                }

                static entityTooLarge(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 413,
                        data,
                        ctor: internals.Boom.entityTooLarge
                    })
                }

                static uriTooLong(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 414,
                        data,
                        ctor: internals.Boom.uriTooLong
                    })
                }

                static unsupportedMediaType(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 415,
                        data,
                        ctor: internals.Boom.unsupportedMediaType
                    })
                }

                static rangeNotSatisfiable(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 416,
                        data,
                        ctor: internals.Boom.rangeNotSatisfiable
                    })
                }

                static expectationFailed(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 417,
                        data,
                        ctor: internals.Boom.expectationFailed
                    })
                }

                static teapot(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 418,
                        data,
                        ctor: internals.Boom.teapot
                    })
                }

                static badData(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 422,
                        data,
                        ctor: internals.Boom.badData
                    })
                }

                static locked(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 423,
                        data,
                        ctor: internals.Boom.locked
                    })
                }

                static failedDependency(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 424,
                        data,
                        ctor: internals.Boom.failedDependency
                    })
                }

                static preconditionRequired(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 428,
                        data,
                        ctor: internals.Boom.preconditionRequired
                    })
                }

                static tooManyRequests(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 429,
                        data,
                        ctor: internals.Boom.tooManyRequests
                    })
                }

                static illegal(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 451,
                        data,
                        ctor: internals.Boom.illegal
                    })
                }

                // 5xx Server Errors

                static internal(message, data, statusCode = 500) {
                    return internals.serverError(
                        message,
                        data,
                        statusCode,
                        internals.Boom.internal
                    )
                }

                static notImplemented(message, data) {
                    return internals.serverError(
                        message,
                        data,
                        501,
                        internals.Boom.notImplemented
                    )
                }

                static badGateway(message, data) {
                    return internals.serverError(
                        message,
                        data,
                        502,
                        internals.Boom.badGateway
                    )
                }

                static serverUnavailable(message, data) {
                    return internals.serverError(
                        message,
                        data,
                        503,
                        internals.Boom.serverUnavailable
                    )
                }

                static gatewayTimeout(message, data) {
                    return internals.serverError(
                        message,
                        data,
                        504,
                        internals.Boom.gatewayTimeout
                    )
                }

                static badImplementation(message, data) {
                    const err = internals.serverError(
                        message,
                        data,
                        500,
                        internals.Boom.badImplementation
                    )
                    err.isDeveloperError = true
                    return err
                }
            }

            internals.Boom.default = internals.Boom // Support ES6 module import

            internals.initialize = function(err, statusCode, message) {
                const numberCode = parseInt(statusCode, 10)
                Hoek.assert(
                    !isNaN(numberCode) && numberCode >= 400,
                    'First argument must be a number (400+):',
                    statusCode
                )

                err.isBoom = true
                err.isServer = numberCode >= 500

                if (!err.hasOwnProperty('data')) {
                    err.data = null
                }

                err.output = {
                    statusCode: numberCode,
                    payload: {},
                    headers: {}
                }

                Object.defineProperty(err, 'reformat', {
                    value: internals.reformat
                })

                if (!message && !err.message) {
                    err.reformat()
                    message = err.output.payload.error
                }

                if (message) {
                    const props =
                        Object.getOwnPropertyDescriptor(err, 'message') ||
                        Object.getOwnPropertyDescriptor(
                            Object.getPrototypeOf(err),
                            'message'
                        )
                    Hoek.assert(
                        props.configurable && !props.get,
                        'The error is not compatible with boom'
                    )

                    err.message =
                        message + (err.message ? ': ' + err.message : '')
                    err.output.payload.message = err.message
                }

                err.reformat()
                return err
            }

            internals.reformat = function(debug = false) {
                this.output.payload.statusCode = this.output.statusCode
                this.output.payload.error =
                    internals.codes.get(this.output.statusCode) || 'Unknown'

                if (this.output.statusCode === 500 && debug !== true) {
                    this.output.payload.message =
                        'An internal server error occurred' // Hide actual error from user
                } else if (this.message) {
                    this.output.payload.message = this.message
                }
            }

            internals.serverError = function(message, data, statusCode, ctor) {
                if (data instanceof Error && !data.isBoom) {
                    return internals.Boom.boomify(data, { statusCode, message })
                }

                return new internals.Boom(message, { statusCode, data, ctor })
            }

            /***/
        },

        /***/ 'UNi/': /***/ function(module, exports) {
            /**
             * The base implementation of `_.times` without support for iteratee shorthands
             * or max array length checks.
             *
             * @private
             * @param {number} n The number of times to invoke `iteratee`.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the array of results.
             */
            function baseTimes(n, iteratee) {
                var index = -1,
                    result = Array(n)

                while (++index < n) {
                    result[index] = iteratee(index)
                }
                return result
            }

            module.exports = baseTimes

            /***/
        },

        /***/ UwMm: /***/ function(module, exports, __webpack_require__) {
            const Got = __webpack_require__('AfMj')
            const defaultsDeep = __webpack_require__('P4Tr')

            const pkg = __webpack_require__('nK8a')

            const isAbsoluteUrl = __webpack_require__('Ndh8')
            const { HTTP_OPTIONS } = __webpack_require__('TJm8')

            let DEFAULT_HTTP_OPTIONS
            let got

            const setDefaults = options => {
                DEFAULT_HTTP_OPTIONS = defaultsDeep(
                    options,
                    DEFAULT_HTTP_OPTIONS
                )
                got = Got.extend(DEFAULT_HTTP_OPTIONS)
            }

            setDefaults({
                followRedirect: false,
                headers: {
                    'User-Agent': `${pkg.name}/${pkg.version} (${pkg.homepage})`
                },
                retry: 0,
                timeout: 2500,
                throwHttpErrors: false
            })

            module.exports = function request(options, { mTLS = false } = {}) {
                const { url } = options
                isAbsoluteUrl(url)
                const optsFn = this[HTTP_OPTIONS]
                let opts
                if (optsFn) {
                    opts = optsFn.call(
                        this,
                        defaultsDeep(options, DEFAULT_HTTP_OPTIONS)
                    )
                } else {
                    opts = options
                }

                if (mTLS && (!opts.key || !opts.cert)) {
                    throw new TypeError(
                        'mutual-TLS certificate and key not set'
                    )
                }
                return got(opts)
            }

            module.exports.setDefaults = setDefaults

            /***/
        },

        /***/ V6Ve: /***/ function(module, exports, __webpack_require__) {
            var overArg = __webpack_require__('kekF')

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeKeys = overArg(Object.keys, Object)

            module.exports = nativeKeys

            /***/
        },

        /***/ VOtZ: /***/ function(module, exports, __webpack_require__) {
            var copyObject = __webpack_require__('juv8'),
                getSymbols = __webpack_require__('MvSz')

            /**
             * Copies own symbols of `source` to `object`.
             *
             * @private
             * @param {Object} source The object to copy symbols from.
             * @param {Object} [object={}] The object to copy symbols to.
             * @returns {Object} Returns `object`.
             */
            function copySymbols(source, object) {
                return copyObject(source, getSymbols(source), object)
            }

            module.exports = copySymbols

            /***/
        },

        /***/ VZIC: /***/ function(module, exports, __webpack_require__) {
            const { Reporter } = __webpack_require__('1WHo')
            const { DecoderBuffer, EncoderBuffer } = __webpack_require__('Z9M3')
            const Node = __webpack_require__('k+0e')

            module.exports = {
                DecoderBuffer,
                EncoderBuffer,
                Node,
                Reporter
            }

            /***/
        },

        /***/ VaNO: /***/ function(module, exports) {
            /**
             * Checks if a stack value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf Stack
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function stackHas(key) {
                return this.__data__.has(key)
            }

            module.exports = stackHas

            /***/
        },

        /***/ VmuJ: /***/ function(module, exports, __webpack_require__) {
            var wrappy = __webpack_require__('1jOq')
            module.exports = wrappy(once)
            module.exports.strict = wrappy(onceStrict)

            once.proto = once(function() {
                Object.defineProperty(Function.prototype, 'once', {
                    value: function() {
                        return once(this)
                    },
                    configurable: true
                })

                Object.defineProperty(Function.prototype, 'onceStrict', {
                    value: function() {
                        return onceStrict(this)
                    },
                    configurable: true
                })
            })

            function once(fn) {
                var f = function() {
                    if (f.called) return f.value
                    f.called = true
                    return (f.value = fn.apply(this, arguments))
                }
                f.called = false
                return f
            }

            function onceStrict(fn) {
                var f = function() {
                    if (f.called) throw new Error(f.onceError)
                    f.called = true
                    return (f.value = fn.apply(this, arguments))
                }
                var name = fn.name || 'Function wrapped with `once`'
                f.onceError = name + " shouldn't be called more than once"
                f.called = false
                return f
            }

            /***/
        },

        /***/ VraX: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(...args) {
                try {
                    return JSON.stringify.apply(null, args)
                } catch (err) {
                    return '[Cannot display object: ' + err.message + ']'
                }
            }

            /***/
        },

        /***/ WEpk: /***/ function(module, exports) {
            var core = (module.exports = { version: '2.6.11' })
            if (typeof __e == 'number') __e = core // eslint-disable-line no-undef

            /***/
        },

        /***/ WFqU: /***/ function(module, exports) {
            /** Detect free variable `global` from Node.js. */
            var freeGlobal =
                typeof global == 'object' &&
                global &&
                global.Object === Object &&
                global

            module.exports = freeGlobal

            /***/
        },

        /***/ WPgm: /***/ function(module, exports, __webpack_require__) {
            const KeyStore = __webpack_require__('aIoy')

            module.exports = KeyStore

            /***/
        },

        /***/ WeJA: /***/ function(module, exports, __webpack_require__) {
            const { STATUS_CODES } = __webpack_require__('KEll')
            const { format } = __webpack_require__('jK02')

            const { OPError } = __webpack_require__('L71r')

            const REGEXP = /(\w+)=("[^"]*")/g
            const throwAuthenticateErrors = response => {
                const params = {}
                try {
                    while (
                        REGEXP.exec(response.headers['www-authenticate']) !==
                        null
                    ) {
                        if (RegExp.$1 && RegExp.$2) {
                            params[RegExp.$1] = RegExp.$2.slice(1, -1)
                        }
                    }
                } catch (err) {}

                if (params.error) {
                    throw new OPError(params, response)
                }
            }

            const isStandardBodyError = response => {
                let result = false
                try {
                    let jsonbody
                    if (
                        typeof response.body !== 'object' ||
                        Buffer.isBuffer(response.body)
                    ) {
                        jsonbody = JSON.parse(response.body)
                    } else {
                        jsonbody = response.body
                    }
                    result =
                        typeof jsonbody.error === 'string' &&
                        jsonbody.error.length
                    if (result) response.body = jsonbody
                } catch (err) {}

                return result
            }

            function processResponse(
                response,
                { statusCode = 200, body = true, bearer = false } = {}
            ) {
                if (response.statusCode !== statusCode) {
                    if (bearer) {
                        throwAuthenticateErrors(response)
                    }

                    if (isStandardBodyError(response)) {
                        throw new OPError(response.body, response)
                    }

                    throw new OPError(
                        {
                            error: format(
                                'expected %i %s, got: %i %s',
                                statusCode,
                                STATUS_CODES[statusCode],
                                response.statusCode,
                                STATUS_CODES[response.statusCode]
                            )
                        },
                        response
                    )
                }

                if (body && !response.body) {
                    throw new OPError(
                        {
                            error: format(
                                'expected %i %s with body but no body was returned',
                                statusCode,
                                STATUS_CODES[statusCode]
                            )
                        },
                        response
                    )
                }

                return response.body
            }

            module.exports = processResponse

            /***/
        },

        /***/ WwFo: /***/ function(module, exports, __webpack_require__) {
            var copyObject = __webpack_require__('juv8'),
                keys = __webpack_require__('7GkX')

            /**
             * The base implementation of `_.assign` without support for multiple sources
             * or `customizer` functions.
             *
             * @private
             * @param {Object} object The destination object.
             * @param {Object} source The source object.
             * @returns {Object} Returns `object`.
             */
            function baseAssign(object, source) {
                return object && copyObject(source, keys(source), object)
            }

            module.exports = baseAssign

            /***/
        },

        /***/ X3uD: /***/ function(module, exports, __webpack_require__) {
            const { randomBytes } = __webpack_require__('PJMN')

            const { IVLENGTHS } = __webpack_require__('N+nT')

            module.exports = alg => randomBytes(IVLENGTHS.get(alg) / 8)

            /***/
        },

        /***/ XPeR: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = Yallist

            Yallist.Node = Node
            Yallist.create = Yallist

            function Yallist(list) {
                var self = this
                if (!(self instanceof Yallist)) {
                    self = new Yallist()
                }

                self.tail = null
                self.head = null
                self.length = 0

                if (list && typeof list.forEach === 'function') {
                    list.forEach(function(item) {
                        self.push(item)
                    })
                } else if (arguments.length > 0) {
                    for (var i = 0, l = arguments.length; i < l; i++) {
                        self.push(arguments[i])
                    }
                }

                return self
            }

            Yallist.prototype.removeNode = function(node) {
                if (node.list !== this) {
                    throw new Error(
                        'removing node which does not belong to this list'
                    )
                }

                var next = node.next
                var prev = node.prev

                if (next) {
                    next.prev = prev
                }

                if (prev) {
                    prev.next = next
                }

                if (node === this.head) {
                    this.head = next
                }
                if (node === this.tail) {
                    this.tail = prev
                }

                node.list.length--
                node.next = null
                node.prev = null
                node.list = null

                return next
            }

            Yallist.prototype.unshiftNode = function(node) {
                if (node === this.head) {
                    return
                }

                if (node.list) {
                    node.list.removeNode(node)
                }

                var head = this.head
                node.list = this
                node.next = head
                if (head) {
                    head.prev = node
                }

                this.head = node
                if (!this.tail) {
                    this.tail = node
                }
                this.length++
            }

            Yallist.prototype.pushNode = function(node) {
                if (node === this.tail) {
                    return
                }

                if (node.list) {
                    node.list.removeNode(node)
                }

                var tail = this.tail
                node.list = this
                node.prev = tail
                if (tail) {
                    tail.next = node
                }

                this.tail = node
                if (!this.head) {
                    this.head = node
                }
                this.length++
            }

            Yallist.prototype.push = function() {
                for (var i = 0, l = arguments.length; i < l; i++) {
                    push(this, arguments[i])
                }
                return this.length
            }

            Yallist.prototype.unshift = function() {
                for (var i = 0, l = arguments.length; i < l; i++) {
                    unshift(this, arguments[i])
                }
                return this.length
            }

            Yallist.prototype.pop = function() {
                if (!this.tail) {
                    return undefined
                }

                var res = this.tail.value
                this.tail = this.tail.prev
                if (this.tail) {
                    this.tail.next = null
                } else {
                    this.head = null
                }
                this.length--
                return res
            }

            Yallist.prototype.shift = function() {
                if (!this.head) {
                    return undefined
                }

                var res = this.head.value
                this.head = this.head.next
                if (this.head) {
                    this.head.prev = null
                } else {
                    this.tail = null
                }
                this.length--
                return res
            }

            Yallist.prototype.forEach = function(fn, thisp) {
                thisp = thisp || this
                for (var walker = this.head, i = 0; walker !== null; i++) {
                    fn.call(thisp, walker.value, i, this)
                    walker = walker.next
                }
            }

            Yallist.prototype.forEachReverse = function(fn, thisp) {
                thisp = thisp || this
                for (
                    var walker = this.tail, i = this.length - 1;
                    walker !== null;
                    i--
                ) {
                    fn.call(thisp, walker.value, i, this)
                    walker = walker.prev
                }
            }

            Yallist.prototype.get = function(n) {
                for (
                    var i = 0, walker = this.head;
                    walker !== null && i < n;
                    i++
                ) {
                    // abort out of the list early if we hit a cycle
                    walker = walker.next
                }
                if (i === n && walker !== null) {
                    return walker.value
                }
            }

            Yallist.prototype.getReverse = function(n) {
                for (
                    var i = 0, walker = this.tail;
                    walker !== null && i < n;
                    i++
                ) {
                    // abort out of the list early if we hit a cycle
                    walker = walker.prev
                }
                if (i === n && walker !== null) {
                    return walker.value
                }
            }

            Yallist.prototype.map = function(fn, thisp) {
                thisp = thisp || this
                var res = new Yallist()
                for (var walker = this.head; walker !== null; ) {
                    res.push(fn.call(thisp, walker.value, this))
                    walker = walker.next
                }
                return res
            }

            Yallist.prototype.mapReverse = function(fn, thisp) {
                thisp = thisp || this
                var res = new Yallist()
                for (var walker = this.tail; walker !== null; ) {
                    res.push(fn.call(thisp, walker.value, this))
                    walker = walker.prev
                }
                return res
            }

            Yallist.prototype.reduce = function(fn, initial) {
                var acc
                var walker = this.head
                if (arguments.length > 1) {
                    acc = initial
                } else if (this.head) {
                    walker = this.head.next
                    acc = this.head.value
                } else {
                    throw new TypeError(
                        'Reduce of empty list with no initial value'
                    )
                }

                for (var i = 0; walker !== null; i++) {
                    acc = fn(acc, walker.value, i)
                    walker = walker.next
                }

                return acc
            }

            Yallist.prototype.reduceReverse = function(fn, initial) {
                var acc
                var walker = this.tail
                if (arguments.length > 1) {
                    acc = initial
                } else if (this.tail) {
                    walker = this.tail.prev
                    acc = this.tail.value
                } else {
                    throw new TypeError(
                        'Reduce of empty list with no initial value'
                    )
                }

                for (var i = this.length - 1; walker !== null; i--) {
                    acc = fn(acc, walker.value, i)
                    walker = walker.prev
                }

                return acc
            }

            Yallist.prototype.toArray = function() {
                var arr = new Array(this.length)
                for (var i = 0, walker = this.head; walker !== null; i++) {
                    arr[i] = walker.value
                    walker = walker.next
                }
                return arr
            }

            Yallist.prototype.toArrayReverse = function() {
                var arr = new Array(this.length)
                for (var i = 0, walker = this.tail; walker !== null; i++) {
                    arr[i] = walker.value
                    walker = walker.prev
                }
                return arr
            }

            Yallist.prototype.slice = function(from, to) {
                to = to || this.length
                if (to < 0) {
                    to += this.length
                }
                from = from || 0
                if (from < 0) {
                    from += this.length
                }
                var ret = new Yallist()
                if (to < from || to < 0) {
                    return ret
                }
                if (from < 0) {
                    from = 0
                }
                if (to > this.length) {
                    to = this.length
                }
                for (
                    var i = 0, walker = this.head;
                    walker !== null && i < from;
                    i++
                ) {
                    walker = walker.next
                }
                for (; walker !== null && i < to; i++, walker = walker.next) {
                    ret.push(walker.value)
                }
                return ret
            }

            Yallist.prototype.sliceReverse = function(from, to) {
                to = to || this.length
                if (to < 0) {
                    to += this.length
                }
                from = from || 0
                if (from < 0) {
                    from += this.length
                }
                var ret = new Yallist()
                if (to < from || to < 0) {
                    return ret
                }
                if (from < 0) {
                    from = 0
                }
                if (to > this.length) {
                    to = this.length
                }
                for (
                    var i = this.length, walker = this.tail;
                    walker !== null && i > to;
                    i--
                ) {
                    walker = walker.prev
                }
                for (; walker !== null && i > from; i--, walker = walker.prev) {
                    ret.push(walker.value)
                }
                return ret
            }

            Yallist.prototype.splice = function(
                start,
                deleteCount /*, ...nodes */
            ) {
                if (start > this.length) {
                    start = this.length - 1
                }
                if (start < 0) {
                    start = this.length + start
                }

                for (
                    var i = 0, walker = this.head;
                    walker !== null && i < start;
                    i++
                ) {
                    walker = walker.next
                }

                var ret = []
                for (var i = 0; walker && i < deleteCount; i++) {
                    ret.push(walker.value)
                    walker = this.removeNode(walker)
                }
                if (walker === null) {
                    walker = this.tail
                }

                if (walker !== this.head && walker !== this.tail) {
                    walker = walker.prev
                }

                for (var i = 2; i < arguments.length; i++) {
                    walker = insert(this, walker, arguments[i])
                }
                return ret
            }

            Yallist.prototype.reverse = function() {
                var head = this.head
                var tail = this.tail
                for (var walker = head; walker !== null; walker = walker.prev) {
                    var p = walker.prev
                    walker.prev = walker.next
                    walker.next = p
                }
                this.head = tail
                this.tail = head
                return this
            }

            function insert(self, node, value) {
                var inserted =
                    node === self.head
                        ? new Node(value, null, node, self)
                        : new Node(value, node, node.next, self)

                if (inserted.next === null) {
                    self.tail = inserted
                }
                if (inserted.prev === null) {
                    self.head = inserted
                }

                self.length++

                return inserted
            }

            function push(self, item) {
                self.tail = new Node(item, self.tail, null, self)
                if (!self.head) {
                    self.head = self.tail
                }
                self.length++
            }

            function unshift(self, item) {
                self.head = new Node(item, null, self.head, self)
                if (!self.tail) {
                    self.tail = self.head
                }
                self.length++
            }

            function Node(value, prev, next, list) {
                if (!(this instanceof Node)) {
                    return new Node(value, prev, next, list)
                }

                this.list = list
                this.value = value

                if (prev) {
                    prev.next = this
                    this.prev = prev
                } else {
                    this.prev = null
                }

                if (next) {
                    next.prev = this
                    this.next = next
                } else {
                    this.next = null
                }
            }

            try {
                // add if support for Symbol.iterator is present
                __webpack_require__('HwNo')(Yallist)
            } catch (er) {}

            /***/
        },

        /***/ XYm9: /***/ function(module, exports, __webpack_require__) {
            var cloneArrayBuffer = __webpack_require__('+K+b')

            /**
             * Creates a clone of `dataView`.
             *
             * @private
             * @param {Object} dataView The data view to clone.
             * @param {boolean} [isDeep] Specify a deep clone.
             * @returns {Object} Returns the cloned data view.
             */
            function cloneDataView(dataView, isDeep) {
                var buffer = isDeep
                    ? cloneArrayBuffer(dataView.buffer)
                    : dataView.buffer
                return new dataView.constructor(
                    buffer,
                    dataView.byteOffset,
                    dataView.byteLength
                )
            }

            module.exports = cloneDataView

            /***/
        },

        /***/ Xab3: /***/ function(module, exports) {
            /* global BigInt */

            const fromBase64 = base64 => {
                return base64
                    .replace(/=/g, '')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
            }

            const encode = (input, encoding = 'utf8') => {
                return fromBase64(
                    Buffer.from(input, encoding).toString('base64')
                )
            }

            const encodeBuffer = buf => {
                return fromBase64(buf.toString('base64'))
            }

            const decodeToBuffer = input => {
                return Buffer.from(input, 'base64')
            }

            const decode = (input, encoding = 'utf8') => {
                return decodeToBuffer(input).toString(encoding)
            }

            const b64uJSON = {
                encode: input => {
                    return encode(JSON.stringify(input))
                },
                decode: (input, encoding = 'utf8') => {
                    return JSON.parse(decode(input, encoding))
                }
            }

            b64uJSON.decode.try = (input, encoding = 'utf8') => {
                try {
                    return b64uJSON.decode(input, encoding)
                } catch (err) {
                    return decode(input, encoding)
                }
            }

            const bnToBuf = bn => {
                let hex = BigInt(bn).toString(16)
                if (hex.length % 2) {
                    hex = `0${hex}`
                }

                const len = hex.length / 2
                const u8 = new Uint8Array(len)

                let i = 0
                let j = 0
                while (i < len) {
                    u8[i] = parseInt(hex.slice(j, j + 2), 16)
                    i += 1
                    j += 2
                }

                return u8
            }

            const encodeBigInt = bn => encodeBuffer(Buffer.from(bnToBuf(bn)))

            module.exports.decode = decode
            module.exports.decodeToBuffer = decodeToBuffer
            module.exports.encode = encode
            module.exports.encodeBuffer = encodeBuffer
            module.exports.JSON = b64uJSON
            module.exports.encodeBigInt = encodeBigInt

            /***/
        },

        /***/ Xi7e: /***/ function(module, exports, __webpack_require__) {
            var listCacheClear = __webpack_require__('KMkd'),
                listCacheDelete = __webpack_require__('adU4'),
                listCacheGet = __webpack_require__('tMB7'),
                listCacheHas = __webpack_require__('+6XX'),
                listCacheSet = __webpack_require__('Z8oC')

            /**
             * Creates an list cache object.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function ListCache(entries) {
                var index = -1,
                    length = entries == null ? 0 : entries.length

                this.clear()
                while (++index < length) {
                    var entry = entries[index]
                    this.set(entry[0], entry[1])
                }
            }

            // Add methods to `ListCache`.
            ListCache.prototype.clear = listCacheClear
            ListCache.prototype['delete'] = listCacheDelete
            ListCache.prototype.get = listCacheGet
            ListCache.prototype.has = listCacheHas
            ListCache.prototype.set = listCacheSet

            module.exports = ListCache

            /***/
        },

        /***/ Y7ZC: /***/ function(module, exports, __webpack_require__) {
            var global = __webpack_require__('5T2Y')
            var core = __webpack_require__('WEpk')
            var ctx = __webpack_require__('2GTP')
            var hide = __webpack_require__('NegM')
            var has = __webpack_require__('B+OT')
            var PROTOTYPE = 'prototype'

            var $export = function(type, name, source) {
                var IS_FORCED = type & $export.F
                var IS_GLOBAL = type & $export.G
                var IS_STATIC = type & $export.S
                var IS_PROTO = type & $export.P
                var IS_BIND = type & $export.B
                var IS_WRAP = type & $export.W
                var exports = IS_GLOBAL ? core : core[name] || (core[name] = {})
                var expProto = exports[PROTOTYPE]
                var target = IS_GLOBAL
                    ? global
                    : IS_STATIC
                    ? global[name]
                    : (global[name] || {})[PROTOTYPE]
                var key, own, out
                if (IS_GLOBAL) source = name
                for (key in source) {
                    // contains in native
                    own = !IS_FORCED && target && target[key] !== undefined
                    if (own && has(exports, key)) continue
                    // export native or passed
                    out = own ? target[key] : source[key]
                    // prevent global pollution for namespaces
                    exports[key] =
                        IS_GLOBAL && typeof target[key] != 'function'
                            ? source[key]
                            : // bind timers to global for call from export context
                            IS_BIND && own
                            ? ctx(out, global)
                            : // wrap global constructors for prevent change them in library
                            IS_WRAP && target[key] == out
                            ? (function(C) {
                                  var F = function(a, b, c) {
                                      if (this instanceof C) {
                                          switch (arguments.length) {
                                              case 0:
                                                  return new C()
                                              case 1:
                                                  return new C(a)
                                              case 2:
                                                  return new C(a, b)
                                          }
                                          return new C(a, b, c)
                                      }
                                      return C.apply(this, arguments)
                                  }
                                  F[PROTOTYPE] = C[PROTOTYPE]
                                  return F
                                  // make static versions for prototype methods
                              })(out)
                            : IS_PROTO && typeof out == 'function'
                            ? ctx(Function.call, out)
                            : out
                    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
                    if (IS_PROTO) {
                        ;(exports.virtual || (exports.virtual = {}))[key] = out
                        // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
                        if (type & $export.R && expProto && !expProto[key])
                            hide(expProto, key, out)
                    }
                }
            }
            // type bitmap
            $export.F = 1 // forced
            $export.G = 2 // global
            $export.S = 4 // static
            $export.P = 8 // proto
            $export.B = 16 // bind
            $export.W = 32 // wrap
            $export.U = 64 // safe
            $export.R = 128 // real proto method for `library`
            module.exports = $export

            /***/
        },

        /***/ YESw: /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5')

            /* Built-in method references that are verified to be native. */
            var nativeCreate = getNative(Object, 'create')

            module.exports = nativeCreate

            /***/
        },

        /***/ YFSu: /***/ function(module, exports) {
            module.exports = function() {
                this.octstr()
                    .contains()
                    .obj(this.key('privateKey').octstr())
            }

            /***/
        },

        /***/ YNnK: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const PassThrough = __webpack_require__('msIP').PassThrough
            const zlib = __webpack_require__('FMKJ')
            const mimicResponse = __webpack_require__('qsvm')

            module.exports = response => {
                // TODO: Use Array#includes when targeting Node.js 6
                if (
                    ['gzip', 'deflate'].indexOf(
                        response.headers['content-encoding']
                    ) === -1
                ) {
                    return response
                }

                const unzip = zlib.createUnzip()
                const stream = new PassThrough()

                mimicResponse(response, stream)

                unzip.on('error', err => {
                    if (err.code === 'Z_BUF_ERROR') {
                        stream.end()
                        return
                    }

                    stream.emit('error', err)
                })

                response.pipe(unzip).pipe(stream)

                return stream
            }

            /***/
        },

        /***/ YO3V: /***/ function(module, exports, __webpack_require__) {
            var baseGetTag = __webpack_require__('NykK'),
                getPrototype = __webpack_require__('LcsW'),
                isObjectLike = __webpack_require__('ExA7')

            /** `Object#toString` result references. */
            var objectTag = '[object Object]'

            /** Used for built-in method references. */
            var funcProto = Function.prototype,
                objectProto = Object.prototype

            /** Used to resolve the decompiled source of functions. */
            var funcToString = funcProto.toString

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /** Used to infer the `Object` constructor. */
            var objectCtorString = funcToString.call(Object)

            /**
             * Checks if `value` is a plain object, that is, an object created by the
             * `Object` constructor or one with a `[[Prototype]]` of `null`.
             *
             * @static
             * @memberOf _
             * @since 0.8.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
             * @example
             *
             * function Foo() {
             *   this.a = 1;
             * }
             *
             * _.isPlainObject(new Foo);
             * // => false
             *
             * _.isPlainObject([1, 2, 3]);
             * // => false
             *
             * _.isPlainObject({ 'x': 0, 'y': 0 });
             * // => true
             *
             * _.isPlainObject(Object.create(null));
             * // => true
             */
            function isPlainObject(value) {
                if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                    return false
                }
                var proto = getPrototype(value)
                if (proto === null) {
                    return true
                }
                var Ctor =
                    hasOwnProperty.call(proto, 'constructor') &&
                    proto.constructor
                return (
                    typeof Ctor == 'function' &&
                    Ctor instanceof Ctor &&
                    funcToString.call(Ctor) == objectCtorString
                )
            }

            module.exports = isPlainObject

            /***/
        },

        /***/ YuTi: /***/ function(module, exports) {
            module.exports = function(module) {
                if (!module.webpackPolyfill) {
                    module.deprecate = function() {}
                    module.paths = []
                    // module.parent = undefined by default
                    if (!module.children) module.children = []
                    Object.defineProperty(module, 'loaded', {
                        enumerable: true,
                        get: function() {
                            return module.l
                        }
                    })
                    Object.defineProperty(module, 'id', {
                        enumerable: true,
                        get: function() {
                            return module.i
                        }
                    })
                    module.webpackPolyfill = 1
                }
                return module
            }

            /***/
        },

        /***/ Z0cm: /***/ function(module, exports) {
            /**
             * Checks if `value` is classified as an `Array` object.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an array, else `false`.
             * @example
             *
             * _.isArray([1, 2, 3]);
             * // => true
             *
             * _.isArray(document.body.children);
             * // => false
             *
             * _.isArray('abc');
             * // => false
             *
             * _.isArray(_.noop);
             * // => false
             */
            var isArray = Array.isArray

            module.exports = isArray

            /***/
        },

        /***/ Z8oC: /***/ function(module, exports, __webpack_require__) {
            var assocIndexOf = __webpack_require__('y1pI')

            /**
             * Sets the list cache `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf ListCache
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the list cache instance.
             */
            function listCacheSet(key, value) {
                var data = this.__data__,
                    index = assocIndexOf(data, key)

                if (index < 0) {
                    ++this.size
                    data.push([key, value])
                } else {
                    data[index][1] = value
                }
                return this
            }

            module.exports = listCacheSet

            /***/
        },

        /***/ Z9M3: /***/ function(module, exports, __webpack_require__) {
            const { inherits } = __webpack_require__('jK02')

            const { Reporter } = __webpack_require__('1WHo')

            function DecoderBuffer(base, options) {
                Reporter.call(this, options)
                if (!Buffer.isBuffer(base)) {
                    this.error('Input not Buffer')
                    return
                }

                this.base = base
                this.offset = 0
                this.length = base.length
            }
            inherits(DecoderBuffer, Reporter)

            DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
                if (data instanceof DecoderBuffer) {
                    return true
                }

                // Or accept compatible API
                const isCompatible =
                    typeof data === 'object' &&
                    Buffer.isBuffer(data.base) &&
                    data.constructor.name === 'DecoderBuffer' &&
                    typeof data.offset === 'number' &&
                    typeof data.length === 'number' &&
                    typeof data.save === 'function' &&
                    typeof data.restore === 'function' &&
                    typeof data.isEmpty === 'function' &&
                    typeof data.readUInt8 === 'function' &&
                    typeof data.skip === 'function' &&
                    typeof data.raw === 'function'

                return isCompatible
            }

            DecoderBuffer.prototype.save = function save() {
                return {
                    offset: this.offset,
                    reporter: Reporter.prototype.save.call(this)
                }
            }

            DecoderBuffer.prototype.restore = function restore(save) {
                // Return skipped data
                const res = new DecoderBuffer(this.base)
                res.offset = save.offset
                res.length = this.offset

                this.offset = save.offset
                Reporter.prototype.restore.call(this, save.reporter)

                return res
            }

            DecoderBuffer.prototype.isEmpty = function isEmpty() {
                return this.offset === this.length
            }

            DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
                if (this.offset + 1 <= this.length) {
                    return this.base.readUInt8(this.offset++, true)
                } else {
                    return this.error(fail || 'DecoderBuffer overrun')
                }
            }

            DecoderBuffer.prototype.skip = function skip(bytes, fail) {
                if (!(this.offset + bytes <= this.length)) {
                    return this.error(fail || 'DecoderBuffer overrun')
                }

                const res = new DecoderBuffer(this.base)

                // Share reporter state
                res._reporterState = this._reporterState

                res.offset = this.offset
                res.length = this.offset + bytes
                this.offset += bytes
                return res
            }

            DecoderBuffer.prototype.raw = function raw(save) {
                return this.base.slice(
                    save ? save.offset : this.offset,
                    this.length
                )
            }

            function EncoderBuffer(value, reporter) {
                if (Array.isArray(value)) {
                    this.length = 0
                    this.value = value.map(function(item) {
                        if (!EncoderBuffer.isEncoderBuffer(item)) {
                            item = new EncoderBuffer(item, reporter)
                        }
                        this.length += item.length
                        return item
                    }, this)
                } else if (typeof value === 'number') {
                    if (!(value >= 0 && value <= 0xff)) {
                        return reporter.error('non-byte EncoderBuffer value')
                    }
                    this.value = value
                    this.length = 1
                } else if (typeof value === 'string') {
                    this.value = value
                    this.length = Buffer.byteLength(value)
                } else if (Buffer.isBuffer(value)) {
                    this.value = value
                    this.length = value.length
                } else {
                    return reporter.error(`Unsupported type: ${typeof value}`)
                }
            }

            EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
                if (data instanceof EncoderBuffer) {
                    return true
                }

                // Or accept compatible API
                const isCompatible =
                    typeof data === 'object' &&
                    data.constructor.name === 'EncoderBuffer' &&
                    typeof data.length === 'number' &&
                    typeof data.join === 'function'

                return isCompatible
            }

            EncoderBuffer.prototype.join = function join(out, offset) {
                if (!out) {
                    out = Buffer.alloc(this.length)
                }
                if (!offset) {
                    offset = 0
                }

                if (this.length === 0) {
                    return out
                }

                if (Array.isArray(this.value)) {
                    this.value.forEach(function(item) {
                        item.join(out, offset)
                        offset += item.length
                    })
                } else {
                    if (typeof this.value === 'number') {
                        out[offset] = this.value
                    } else if (typeof this.value === 'string') {
                        out.write(this.value, offset)
                    } else if (Buffer.isBuffer(this.value)) {
                        this.value.copy(out, offset)
                    }
                    offset += this.length
                }

                return out
            }

            module.exports = {
                DecoderBuffer,
                EncoderBuffer
            }

            /***/
        },

        /***/ ZCpW: /***/ function(module, exports, __webpack_require__) {
            var baseIsMatch = __webpack_require__('lm/5'),
                getMatchData = __webpack_require__('O7RO'),
                matchesStrictComparable = __webpack_require__('IOzZ')

            /**
             * The base implementation of `_.matches` which doesn't clone `source`.
             *
             * @private
             * @param {Object} source The object of property values to match.
             * @returns {Function} Returns the new spec function.
             */
            function baseMatches(source) {
                var matchData = getMatchData(source)
                if (matchData.length == 1 && matchData[0][2]) {
                    return matchesStrictComparable(
                        matchData[0][0],
                        matchData[0][1]
                    )
                }
                return function(object) {
                    return (
                        object === source ||
                        baseIsMatch(object, source, matchData)
                    )
                }
            }

            module.exports = baseMatches

            /***/
        },

        /***/ ZUdF: /***/ function(module, exports, __webpack_require__) {
            /* global BigInt */
            const { inherits } = __webpack_require__('jK02')

            const Node = __webpack_require__('k+0e')
            const der = __webpack_require__('1Gj5')

            function DEREncoder(entity) {
                this.enc = 'der'
                this.name = entity.name
                this.entity = entity

                // Construct base tree
                this.tree = new DERNode()
                this.tree._init(entity.body)
            }

            DEREncoder.prototype.encode = function encode(data, reporter) {
                return this.tree._encode(data, reporter).join()
            }

            // Tree methods

            function DERNode(parent) {
                Node.call(this, 'der', parent)
            }
            inherits(DERNode, Node)

            DERNode.prototype._encodeComposite = function encodeComposite(
                tag,
                primitive,
                cls,
                content
            ) {
                const encodedTag = encodeTag(tag, primitive, cls, this.reporter)

                // Short form
                if (content.length < 0x80) {
                    const header = Buffer.alloc(2)
                    header[0] = encodedTag
                    header[1] = content.length
                    return this._createEncoderBuffer([header, content])
                }

                // Long form
                // Count octets required to store length
                let lenOctets = 1
                for (let i = content.length; i >= 0x100; i >>= 8) {
                    lenOctets++
                }

                const header = Buffer.alloc(1 + 1 + lenOctets)
                header[0] = encodedTag
                header[1] = 0x80 | lenOctets

                for (
                    let i = 1 + lenOctets, j = content.length;
                    j > 0;
                    i--, j >>= 8
                ) {
                    header[i] = j & 0xff
                }

                return this._createEncoderBuffer([header, content])
            }

            DERNode.prototype._encodeStr = function encodeStr(str, tag) {
                if (tag === 'bitstr') {
                    return this._createEncoderBuffer([str.unused | 0, str.data])
                } else if (tag === 'bmpstr') {
                    const buf = Buffer.alloc(str.length * 2)
                    for (let i = 0; i < str.length; i++) {
                        buf.writeUInt16BE(str.charCodeAt(i), i * 2)
                    }
                    return this._createEncoderBuffer(buf)
                } else if (tag === 'numstr') {
                    if (!this._isNumstr(str)) {
                        return this.reporter.error(
                            'Encoding of string type: numstr supports only digits and space'
                        )
                    }
                    return this._createEncoderBuffer(str)
                } else if (tag === 'printstr') {
                    if (!this._isPrintstr(str)) {
                        return this.reporter.error(
                            'Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark'
                        )
                    }
                    return this._createEncoderBuffer(str)
                } else if (/str$/.test(tag)) {
                    return this._createEncoderBuffer(str)
                } else if (tag === 'objDesc') {
                    return this._createEncoderBuffer(str)
                } else {
                    return this.reporter.error(
                        `Encoding of string type: ${tag} unsupported`
                    )
                }
            }

            DERNode.prototype._encodeObjid = function encodeObjid(
                id,
                values,
                relative
            ) {
                if (typeof id === 'string') {
                    if (!values) {
                        return this.reporter.error(
                            'string objid given, but no values map found'
                        )
                    }
                    if (!Object.prototype.hasOwnProperty.call(values, id)) {
                        return this.reporter.error(
                            'objid not found in values map'
                        )
                    }
                    id = values[id].split(/[\s.]+/g)
                    for (let i = 0; i < id.length; i++) {
                        id[i] |= 0
                    }
                } else if (Array.isArray(id)) {
                    id = id.slice()
                    for (let i = 0; i < id.length; i++) {
                        id[i] |= 0
                    }
                }

                if (!Array.isArray(id)) {
                    return this.reporter.error(
                        `objid() should be either array or string, got: ${JSON.stringify(
                            id
                        )}`
                    )
                }

                if (!relative) {
                    if (id[1] >= 40) {
                        return this.reporter.error(
                            'Second objid identifier OOB'
                        )
                    }
                    id.splice(0, 2, id[0] * 40 + id[1])
                }

                // Count number of octets
                let size = 0
                for (let i = 0; i < id.length; i++) {
                    let ident = id[i]
                    for (size++; ident >= 0x80; ident >>= 7) {
                        size++
                    }
                }

                const objid = Buffer.alloc(size)
                let offset = objid.length - 1
                for (let i = id.length - 1; i >= 0; i--) {
                    let ident = id[i]
                    objid[offset--] = ident & 0x7f
                    while ((ident >>= 7) > 0) {
                        objid[offset--] = 0x80 | (ident & 0x7f)
                    }
                }

                return this._createEncoderBuffer(objid)
            }

            function two(num) {
                if (num < 10) {
                    return `0${num}`
                } else {
                    return num
                }
            }

            DERNode.prototype._encodeTime = function encodeTime(time, tag) {
                let str
                const date = new Date(time)

                if (tag === 'gentime') {
                    str = [
                        two(date.getUTCFullYear()),
                        two(date.getUTCMonth() + 1),
                        two(date.getUTCDate()),
                        two(date.getUTCHours()),
                        two(date.getUTCMinutes()),
                        two(date.getUTCSeconds()),
                        'Z'
                    ].join('')
                } else if (tag === 'utctime') {
                    str = [
                        two(date.getUTCFullYear() % 100),
                        two(date.getUTCMonth() + 1),
                        two(date.getUTCDate()),
                        two(date.getUTCHours()),
                        two(date.getUTCMinutes()),
                        two(date.getUTCSeconds()),
                        'Z'
                    ].join('')
                } else {
                    this.reporter.error(
                        `Encoding ${tag} time is not supported yet`
                    )
                }

                return this._encodeStr(str, 'octstr')
            }

            DERNode.prototype._encodeNull = function encodeNull() {
                return this._createEncoderBuffer('')
            }

            function bnToBuf(bn) {
                var hex = BigInt(bn).toString(16)
                if (hex.length % 2) {
                    hex = '0' + hex
                }

                var len = hex.length / 2
                var u8 = new Uint8Array(len)

                var i = 0
                var j = 0
                while (i < len) {
                    u8[i] = parseInt(hex.slice(j, j + 2), 16)
                    i += 1
                    j += 2
                }

                return u8
            }

            DERNode.prototype._encodeInt = function encodeInt(num, values) {
                if (typeof num === 'string') {
                    if (!values) {
                        return this.reporter.error(
                            'String int or enum given, but no values map'
                        )
                    }
                    if (!Object.prototype.hasOwnProperty.call(values, num)) {
                        return this.reporter.error(
                            `Values map doesn't contain: ${JSON.stringify(num)}`
                        )
                    }
                    num = values[num]
                }

                if (typeof num === 'bigint') {
                    const numArray = [...bnToBuf(num)]
                    if (numArray[0] & 0x80) {
                        numArray.unshift(0)
                    }
                    num = Buffer.from(numArray)
                }

                if (Buffer.isBuffer(num)) {
                    let size = num.length
                    if (num.length === 0) {
                        size++
                    }

                    const out = Buffer.alloc(size)
                    num.copy(out)
                    if (num.length === 0) {
                        out[0] = 0
                    }
                    return this._createEncoderBuffer(out)
                }

                if (num < 0x80) {
                    return this._createEncoderBuffer(num)
                }

                if (num < 0x100) {
                    return this._createEncoderBuffer([0, num])
                }

                let size = 1
                for (let i = num; i >= 0x100; i >>= 8) {
                    size++
                }

                const out = new Array(size)
                for (let i = out.length - 1; i >= 0; i--) {
                    out[i] = num & 0xff
                    num >>= 8
                }
                if (out[0] & 0x80) {
                    out.unshift(0)
                }

                return this._createEncoderBuffer(Buffer.from(out))
            }

            DERNode.prototype._encodeBool = function encodeBool(value) {
                return this._createEncoderBuffer(value ? 0xff : 0)
            }

            DERNode.prototype._use = function use(entity, obj) {
                if (typeof entity === 'function') {
                    entity = entity(obj)
                }
                return entity._getEncoder('der').tree
            }

            DERNode.prototype._skipDefault = function skipDefault(
                dataBuffer,
                reporter,
                parent
            ) {
                const state = this._baseState
                let i
                if (state.default === null) {
                    return false
                }

                const data = dataBuffer.join()
                if (state.defaultBuffer === undefined) {
                    state.defaultBuffer = this._encodeValue(
                        state.default,
                        reporter,
                        parent
                    ).join()
                }

                if (data.length !== state.defaultBuffer.length) {
                    return false
                }

                for (i = 0; i < data.length; i++) {
                    if (data[i] !== state.defaultBuffer[i]) {
                        return false
                    }
                }

                return true
            }

            // Utility methods

            function encodeTag(tag, primitive, cls, reporter) {
                let res

                if (tag === 'seqof') {
                    tag = 'seq'
                } else if (tag === 'setof') {
                    tag = 'set'
                }

                if (Object.prototype.hasOwnProperty.call(der.tagByName, tag)) {
                    res = der.tagByName[tag]
                } else if (typeof tag === 'number' && (tag | 0) === tag) {
                    res = tag
                } else {
                    return reporter.error(`Unknown tag: ${tag}`)
                }

                if (res >= 0x1f) {
                    return reporter.error(
                        'Multi-octet tag encoding unsupported'
                    )
                }

                if (!primitive) {
                    res |= 0x20
                }

                res |= der.tagClassByName[cls || 'universal'] << 6

                return res
            }

            module.exports = DEREncoder

            /***/
        },

        /***/ ZWtO: /***/ function(module, exports, __webpack_require__) {
            var castPath = __webpack_require__('4uTw'),
                toKey = __webpack_require__('9Nap')

            /**
             * The base implementation of `_.get` without support for default values.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Array|string} path The path of the property to get.
             * @returns {*} Returns the resolved value.
             */
            function baseGet(object, path) {
                path = castPath(path, object)

                var index = 0,
                    length = path.length

                while (object != null && index < length) {
                    object = object[toKey(path[index++])]
                }
                return index && index == length ? object : undefined
            }

            module.exports = baseGet

            /***/
        },

        /***/ ZXG7: /***/ function(module, exports, __webpack_require__) {
            const base64url = __webpack_require__('Xab3')
            const isDisjoint = __webpack_require__('KQbz')
            let validateCrit = __webpack_require__('urXW')
            const getKey = __webpack_require__('oGTz')
            const { KeyStore } = __webpack_require__('WPgm')
            const errors = __webpack_require__('yt7c')
            const { check, verify } = __webpack_require__('FUB/')

            const { detect: resolveSerialization } = __webpack_require__('SwXk')

            validateCrit = validateCrit.bind(undefined, errors.JWSInvalid)
            const SINGLE_RECIPIENT = new Set([
                'compact',
                'flattened',
                'preparsed'
            ])

            /*
             * @public
             */
            const jwsVerify = (
                skipDisjointCheck,
                serialization,
                jws,
                key,
                {
                    crit = [],
                    complete = false,
                    algorithms,
                    parse = true,
                    encoding = 'utf8'
                } = {}
            ) => {
                key = getKey(key, true)

                if (
                    algorithms !== undefined &&
                    (!Array.isArray(algorithms) ||
                        algorithms.some(s => typeof s !== 'string' || !s))
                ) {
                    throw new TypeError(
                        '"algorithms" option must be an array of non-empty strings'
                    )
                } else if (algorithms) {
                    algorithms = new Set(algorithms)
                }

                if (
                    !Array.isArray(crit) ||
                    crit.some(s => typeof s !== 'string' || !s)
                ) {
                    throw new TypeError(
                        '"crit" option must be an array of non-empty strings'
                    )
                }

                if (!serialization) {
                    serialization = resolveSerialization(jws)
                }

                let prot // protected header
                let header // unprotected header
                let payload
                let signature
                let alg

                // treat general format with one recipient as flattened
                // skips iteration and avoids multi errors in this case
                if (
                    serialization === 'general' &&
                    jws.signatures.length === 1
                ) {
                    serialization = 'flattened'
                    const { signatures, ...root } = jws
                    jws = { ...root, ...signatures[0] }
                }

                let decoded

                if (SINGLE_RECIPIENT.has(serialization)) {
                    let parsedProt = {}

                    switch (serialization) {
                        case 'compact': // compact serialization format
                            ;[prot, payload, signature] = jws.split('.')
                            break
                        case 'flattened': // flattened serialization format
                            ;({
                                protected: prot,
                                payload,
                                signature,
                                header
                            } = jws)
                            break
                        case 'preparsed': {
                            // from the JWT module
                            ;({ decoded } = jws)
                            ;[prot, payload, signature] = jws.token.split('.')
                            break
                        }
                    }

                    if (!header) {
                        skipDisjointCheck = true
                    }

                    if (decoded) {
                        parsedProt = decoded.header
                    } else if (prot) {
                        try {
                            parsedProt = base64url.JSON.decode(prot)
                        } catch (err) {
                            throw new errors.JWSInvalid(
                                'could not parse JWS protected header'
                            )
                        }
                    } else {
                        skipDisjointCheck = skipDisjointCheck || true
                    }

                    if (!skipDisjointCheck && !isDisjoint(parsedProt, header)) {
                        throw new errors.JWSInvalid(
                            'JWS Protected and JWS Unprotected Header Parameter names must be disjoint'
                        )
                    }

                    const combinedHeader = { ...parsedProt, ...header }
                    validateCrit(parsedProt, header, crit)

                    alg = parsedProt.alg || (header && header.alg)
                    if (!alg) {
                        throw new errors.JWSInvalid(
                            'missing JWS signature algorithm'
                        )
                    } else if (algorithms && !algorithms.has(alg)) {
                        throw new errors.JOSEAlgNotWhitelisted(
                            'alg not whitelisted'
                        )
                    }

                    if (key instanceof KeyStore) {
                        const keystore = key
                        const keys = keystore.all({
                            kid: combinedHeader.kid,
                            alg: combinedHeader.alg,
                            key_ops: ['verify']
                        })
                        switch (keys.length) {
                            case 0:
                                throw new errors.JWKSNoMatchingKey()
                            case 1:
                                // treat the call as if a Key instance was passed in
                                // skips iteration and avoids multi errors in this case
                                key = keys[0]
                                break
                            default: {
                                const errs = []
                                for (const key of keys) {
                                    try {
                                        return jwsVerify(
                                            true,
                                            serialization,
                                            jws,
                                            key,
                                            {
                                                crit,
                                                complete,
                                                encoding,
                                                parse,
                                                algorithms: algorithms
                                                    ? [...algorithms]
                                                    : undefined
                                            }
                                        )
                                    } catch (err) {
                                        errs.push(err)
                                        continue
                                    }
                                }

                                const multi = new errors.JOSEMultiError(errs)
                                if (
                                    [...multi].some(
                                        e =>
                                            e instanceof
                                            errors.JWSVerificationFailed
                                    )
                                ) {
                                    throw new errors.JWSVerificationFailed()
                                }
                                throw multi
                            }
                        }
                    }

                    check(key, 'verify', alg)

                    const toBeVerified = Buffer.concat([
                        Buffer.from(prot || ''),
                        Buffer.from('.'),
                        Buffer.isBuffer(payload)
                            ? payload
                            : Buffer.from(payload)
                    ])

                    if (
                        !verify(
                            alg,
                            key,
                            toBeVerified,
                            base64url.decodeToBuffer(signature)
                        )
                    ) {
                        throw new errors.JWSVerificationFailed()
                    }

                    if (
                        !combinedHeader.crit ||
                        !combinedHeader.crit.includes('b64') ||
                        combinedHeader.b64
                    ) {
                        if (parse) {
                            payload = decoded
                                ? decoded.payload
                                : base64url.JSON.decode.try(payload, encoding)
                        } else {
                            payload = base64url.decodeToBuffer(payload)
                        }
                    }

                    if (complete) {
                        const result = { payload, key }
                        if (prot) result.protected = parsedProt
                        if (header) result.header = header
                        return result
                    }

                    return payload
                }

                // general serialization format
                const { signatures, ...root } = jws
                const errs = []
                for (const recipient of signatures) {
                    try {
                        return jwsVerify(
                            false,
                            'flattened',
                            { ...root, ...recipient },
                            key,
                            {
                                crit,
                                complete,
                                encoding,
                                parse,
                                algorithms: algorithms
                                    ? [...algorithms]
                                    : undefined
                            }
                        )
                    } catch (err) {
                        errs.push(err)
                        continue
                    }
                }

                const multi = new errors.JOSEMultiError(errs)
                if (
                    [...multi].some(
                        e => e instanceof errors.JWSVerificationFailed
                    )
                ) {
                    throw new errors.JWSVerificationFailed()
                } else if (
                    [...multi].every(e => e instanceof errors.JWKSNoMatchingKey)
                ) {
                    throw new errors.JWKSNoMatchingKey()
                }
                throw multi
            }

            module.exports = {
                bare: jwsVerify,
                verify: jwsVerify.bind(undefined, false, undefined)
            }

            /***/
        },

        /***/ ZfBq: /***/ function(module, exports, __webpack_require__) {
            const { strict: assert } = __webpack_require__('Qs3B')
            const { createHash } = __webpack_require__('PJMN')
            const { format } = __webpack_require__('jK02')

            const shake256 = __webpack_require__('5sMl')

            const fromBase64 = base64 =>
                base64
                    .replace(/=/g, '')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
            const encode = input => fromBase64(input.toString('base64'))

            /** SPECIFICATION
             * Its (_hash) value is the base64url encoding of the left-most half of the hash of the octets of
             * the ASCII representation of the token value, where the hash algorithm used is the hash algorithm
             * used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is
             * RS256, hash the token value with SHA-256, then take the left-most 128 bits and base64url encode
             * them. The _hash value is a case sensitive string.
             */

            /**
             * @name getHash
             * @api private
             *
             * returns the sha length based off the JOSE alg heade value, defaults to sha256
             *
             * @param token {String} token value to generate the hash from
             * @param alg {String} ID Token JOSE header alg value (i.e. RS256, HS384, ES512, PS256)
             * @param [crv] {String} For EdDSA the curve decides what hash algorithm is used. Required for EdDSA
             */
            function getHash(alg, crv) {
                switch (alg) {
                    case 'HS256':
                    case 'RS256':
                    case 'PS256':
                    case 'ES256':
                    case 'ES256K':
                        return createHash('sha256')

                    case 'HS384':
                    case 'RS384':
                    case 'PS384':
                    case 'ES384':
                        return createHash('sha384')

                    case 'HS512':
                    case 'RS512':
                    case 'PS512':
                    case 'ES512':
                        return createHash('sha512')

                    case 'EdDSA':
                        switch (crv) {
                            case 'Ed25519':
                                return createHash('sha512')
                            case 'Ed448':
                                if (!shake256) {
                                    throw new TypeError(
                                        'Ed448 *_hash calculation is not supported in your Node.js runtime version'
                                    )
                                }

                                return createHash('shake256', {
                                    outputLength: 114
                                })
                            default:
                                throw new TypeError(
                                    'unrecognized or invalid EdDSA curve provided'
                                )
                        }

                    default:
                        throw new TypeError(
                            'unrecognized or invalid JWS algorithm provided'
                        )
                }
            }

            function generate(token, alg, crv) {
                const digest = getHash(alg, crv)
                    .update(token)
                    .digest()
                return encode(digest.slice(0, digest.length / 2))
            }

            function validate(names, actual, source, alg, crv) {
                if (typeof names.claim !== 'string' || !names.claim) {
                    throw new TypeError(
                        'names.claim must be a non-empty string'
                    )
                }

                if (typeof names.source !== 'string' || !names.source) {
                    throw new TypeError(
                        'names.source must be a non-empty string'
                    )
                }

                assert(
                    typeof actual === 'string' && actual,
                    `${names.claim} must be a non-empty string`
                )
                assert(
                    typeof source === 'string' && source,
                    `${names.source} must be a non-empty string`
                )

                let expected
                let msg
                try {
                    expected = generate(source, alg, crv)
                } catch (err) {
                    msg = format(
                        '%s could not be validated (%s)',
                        names.claim,
                        err.message
                    )
                }

                msg =
                    msg ||
                    format(
                        '%s mismatch, expected %s, got: %s',
                        names.claim,
                        expected,
                        actual
                    )

                assert.equal(expected, actual, msg)
            }

            module.exports = {
                validate,
                generate
            }

            /***/
        },

        /***/ a9ph: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var Buffer = __webpack_require__('xZGU').Buffer

            // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
            // correspond to encoded bytes (if 128 - then lower half is ASCII).

            exports._sbcs = SBCSCodec
            function SBCSCodec(codecOptions, iconv) {
                if (!codecOptions)
                    throw new Error('SBCS codec is called without the data.')

                // Prepare char buffer for decoding.
                if (
                    !codecOptions.chars ||
                    (codecOptions.chars.length !== 128 &&
                        codecOptions.chars.length !== 256)
                )
                    throw new Error(
                        "Encoding '" +
                            codecOptions.type +
                            "' has incorrect 'chars' (must be of len 128 or 256)"
                    )

                if (codecOptions.chars.length === 128) {
                    var asciiString = ''
                    for (var i = 0; i < 128; i++)
                        asciiString += String.fromCharCode(i)
                    codecOptions.chars = asciiString + codecOptions.chars
                }

                this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2')

                // Encoding buffer.
                var encodeBuf = Buffer.alloc(
                    65536,
                    iconv.defaultCharSingleByte.charCodeAt(0)
                )

                for (var i = 0; i < codecOptions.chars.length; i++)
                    encodeBuf[codecOptions.chars.charCodeAt(i)] = i

                this.encodeBuf = encodeBuf
            }

            SBCSCodec.prototype.encoder = SBCSEncoder
            SBCSCodec.prototype.decoder = SBCSDecoder

            function SBCSEncoder(options, codec) {
                this.encodeBuf = codec.encodeBuf
            }

            SBCSEncoder.prototype.write = function(str) {
                var buf = Buffer.alloc(str.length)
                for (var i = 0; i < str.length; i++)
                    buf[i] = this.encodeBuf[str.charCodeAt(i)]

                return buf
            }

            SBCSEncoder.prototype.end = function() {}

            function SBCSDecoder(options, codec) {
                this.decodeBuf = codec.decodeBuf
            }

            SBCSDecoder.prototype.write = function(buf) {
                // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
                var decodeBuf = this.decodeBuf
                var newBuf = Buffer.alloc(buf.length * 2)
                var idx1 = 0,
                    idx2 = 0
                for (var i = 0; i < buf.length; i++) {
                    idx1 = buf[i] * 2
                    idx2 = i * 2
                    newBuf[idx2] = decodeBuf[idx1]
                    newBuf[idx2 + 1] = decodeBuf[idx1 + 1]
                }
                return newBuf.toString('ucs2')
            }

            SBCSDecoder.prototype.end = function() {}

            /***/
        },

        /***/ aIoy: /***/ function(module, exports, __webpack_require__) {
            const { deprecate, inspect } = __webpack_require__('jK02')

            const isObject = __webpack_require__('kF1/')
            const { generate, generateSync } = __webpack_require__('LDEB')
            const { USES_MAPPING } = __webpack_require__('ehsS')
            const { None, isKey, asKey: importKey } = __webpack_require__(
                'lA9T'
            )

            const keyscore = (key, { alg, use, ops }) => {
                let score = 0

                if (alg && key.alg) {
                    score++
                }

                if (use && key.use) {
                    score++
                }

                if (ops && key.key_ops) {
                    score++
                }

                return score
            }

            class KeyStore {
                constructor(...keys) {
                    while (keys.some(Array.isArray)) {
                        keys = keys.flat
                            ? keys.flat()
                            : keys.reduce((acc, val) => {
                                  if (Array.isArray(val)) {
                                      return [...acc, ...val]
                                  }

                                  acc.push(val)
                                  return acc
                              }, [])
                    }
                    if (keys.some(k => !isKey(k) || k === None)) {
                        throw new TypeError(
                            'all keys must be instances of a key instantiated by JWK.asKey'
                        )
                    }

                    this._keys = new Set(keys)
                }

                all({
                    alg,
                    kid,
                    thumbprint,
                    use,
                    kty,
                    key_ops: ops,
                    x5t,
                    'x5t#S256': x5t256,
                    crv
                } = {}) {
                    if (
                        ops !== undefined &&
                        (!Array.isArray(ops) ||
                            !ops.length ||
                            ops.some(x => typeof x !== 'string'))
                    ) {
                        throw new TypeError(
                            '`key_ops` must be a non-empty array of strings'
                        )
                    }

                    const search = { alg, use, ops }
                    return [...this._keys]
                        .filter(key => {
                            let candidate = true

                            if (
                                candidate &&
                                kid !== undefined &&
                                key.kid !== kid
                            ) {
                                candidate = false
                            }

                            if (
                                candidate &&
                                thumbprint !== undefined &&
                                key.thumbprint !== thumbprint
                            ) {
                                candidate = false
                            }

                            if (
                                candidate &&
                                x5t !== undefined &&
                                key.x5t !== x5t
                            ) {
                                candidate = false
                            }

                            if (
                                candidate &&
                                x5t256 !== undefined &&
                                key['x5t#S256'] !== x5t256
                            ) {
                                candidate = false
                            }

                            if (
                                candidate &&
                                kty !== undefined &&
                                key.kty !== kty
                            ) {
                                candidate = false
                            }

                            if (
                                candidate &&
                                crv !== undefined &&
                                key.crv !== crv
                            ) {
                                candidate = false
                            }

                            if (
                                alg !== undefined &&
                                !key.algorithms().has(alg)
                            ) {
                                candidate = false
                            }

                            if (
                                candidate &&
                                use !== undefined &&
                                key.use !== undefined && key.use !== use
                            ) {
                                candidate = false
                            }

                            // TODO:
                            if (
                                candidate &&
                                ops !== undefined &&
                                (key.key_ops !== undefined ||
                                    key.use !== undefined)
                            ) {
                                let keyOps
                                if (key.key_ops) {
                                    keyOps = new Set(key.key_ops)
                                } else {
                                    keyOps = USES_MAPPING[key.use]
                                }
                                if (ops.some(x => !keyOps.has(x))) {
                                    candidate = false
                                }
                            }

                            return candidate
                        })
                        .sort(
                            (first, second) =>
                                keyscore(second, search) -
                                keyscore(first, search)
                        )
                }

                get(...args) {
                    return this.all(...args)[0]
                }

                add(key) {
                    if (!isKey(key) || key === None) {
                        throw new TypeError(
                            'key must be an instance of a key instantiated by JWK.asKey'
                        )
                    }

                    this._keys.add(key)
                }

                remove(key) {
                    if (!isKey(key)) {
                        throw new TypeError(
                            'key must be an instance of a key instantiated by JWK.asKey'
                        )
                    }

                    this._keys.delete(key)
                }

                toJWKS(priv = false) {
                    return {
                        keys: [...this._keys.values()].map(key =>
                            key.toJWK(
                                priv && (key.private || (key.secret && key.k))
                            )
                        )
                    }
                }

                async generate(...args) {
                    this._keys.add(await generate(...args))
                }

                generateSync(...args) {
                    this._keys.add(generateSync(...args))
                }

                get size() {
                    return this._keys.size
                }

                /* c8 ignore next 8 */
                [inspect.custom]() {
                    return `${this.constructor.name} ${inspect(
                        this.toJWKS(false),
                        {
                            depth: Infinity,
                            colors: process.stdout.isTTY,
                            compact: false,
                            sorted: true
                        }
                    )}`
                }

                *[Symbol.iterator]() {
                    for (const key of this._keys) {
                        yield key
                    }
                }
            }

            function asKeyStore(
                jwks,
                { ignoreErrors = false, calculateMissingRSAPrimes = false } = {}
            ) {
                if (
                    !isObject(jwks) ||
                    !Array.isArray(jwks.keys) ||
                    jwks.keys.some(k => !isObject(k) || !('kty' in k))
                ) {
                    throw new TypeError(
                        'jwks must be a JSON Web Key Set formatted object'
                    )
                }

                const keys = jwks.keys
                    .map(jwk => {
                        try {
                            return importKey(jwk, { calculateMissingRSAPrimes })
                        } catch (err) {
                            if (!ignoreErrors) {
                                throw err
                            }
                        }
                    })
                    .filter(Boolean)

                return new KeyStore(...keys)
            }

            Object.defineProperty(KeyStore, 'fromJWKS', {
                value: deprecate(
                    jwks =>
                        asKeyStore(jwks, { calculateMissingRSAPrimes: true }),
                    'JWKS.KeyStore.fromJWKS() is deprecated, use JWKS.asKeyStore() instead'
                ),
                enumerable: false
            })

            module.exports = { KeyStore, asKeyStore }

            /***/
        },

        /***/ aOmh: /***/ function(module, exports) {
            module.exports = new Map()

            /***/
        },

        /***/ adU4: /***/ function(module, exports, __webpack_require__) {
            var assocIndexOf = __webpack_require__('y1pI')

            /** Used for built-in method references. */
            var arrayProto = Array.prototype

            /** Built-in value references. */
            var splice = arrayProto.splice

            /**
             * Removes `key` and its value from the list cache.
             *
             * @private
             * @name delete
             * @memberOf ListCache
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function listCacheDelete(key) {
                var data = this.__data__,
                    index = assocIndexOf(data, key)

                if (index < 0) {
                    return false
                }
                var lastIndex = data.length - 1
                if (index == lastIndex) {
                    data.pop()
                } else {
                    splice.call(data, index, 1)
                }
                --this.size
                return true
            }

            module.exports = listCacheDelete

            /***/
        },

        /***/ b1HN: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            // ISC @ Julien Fontanet

            // ===================================================================

            var construct =
                typeof Reflect !== 'undefined' ? Reflect.construct : undefined
            var defineProperty = Object.defineProperty

            // -------------------------------------------------------------------

            var captureStackTrace = Error.captureStackTrace
            if (captureStackTrace === undefined) {
                captureStackTrace = function captureStackTrace(error) {
                    var container = new Error()

                    defineProperty(error, 'stack', {
                        configurable: true,
                        get: function getStack() {
                            var stack = container.stack

                            // Replace property with value for faster future accesses.
                            defineProperty(this, 'stack', {
                                configurable: true,
                                value: stack,
                                writable: true
                            })

                            return stack
                        },
                        set: function setStack(stack) {
                            defineProperty(error, 'stack', {
                                configurable: true,
                                value: stack,
                                writable: true
                            })
                        }
                    })
                }
            }

            // -------------------------------------------------------------------

            function BaseError(message) {
                if (message !== undefined) {
                    defineProperty(this, 'message', {
                        configurable: true,
                        value: message,
                        writable: true
                    })
                }

                var cname = this.constructor.name
                if (cname !== undefined && cname !== this.name) {
                    defineProperty(this, 'name', {
                        configurable: true,
                        value: cname,
                        writable: true
                    })
                }

                captureStackTrace(this, this.constructor)
            }

            BaseError.prototype = Object.create(Error.prototype, {
                // See: https://github.com/JsCommunity/make-error/issues/4
                constructor: {
                    configurable: true,
                    value: BaseError,
                    writable: true
                }
            })

            // -------------------------------------------------------------------

            // Sets the name of a function if possible (depends of the JS engine).
            var setFunctionName = (function() {
                function setFunctionName(fn, name) {
                    return defineProperty(fn, 'name', {
                        configurable: true,
                        value: name
                    })
                }
                try {
                    var f = function() {}
                    setFunctionName(f, 'foo')
                    if (f.name === 'foo') {
                        return setFunctionName
                    }
                } catch (_) {}
            })()

            // -------------------------------------------------------------------

            function makeError(constructor, super_) {
                if (super_ == null || super_ === Error) {
                    super_ = BaseError
                } else if (typeof super_ !== 'function') {
                    throw new TypeError('super_ should be a function')
                }

                var name
                if (typeof constructor === 'string') {
                    name = constructor
                    constructor =
                        construct !== undefined
                            ? function() {
                                  return construct(
                                      super_,
                                      arguments,
                                      this.constructor
                                  )
                              }
                            : function() {
                                  super_.apply(this, arguments)
                              }

                    // If the name can be set, do it once and for all.
                    if (setFunctionName !== undefined) {
                        setFunctionName(constructor, name)
                        name = undefined
                    }
                } else if (typeof constructor !== 'function') {
                    throw new TypeError(
                        'constructor should be either a string or a function'
                    )
                }

                // Also register the super constructor also as `constructor.super_` just
                // like Node's `util.inherits()`.
                //
                // eslint-disable-next-line dot-notation
                constructor.super_ = constructor['super'] = super_

                var properties = {
                    constructor: {
                        configurable: true,
                        value: constructor,
                        writable: true
                    }
                }

                // If the name could not be set on the constructor, set it on the
                // prototype.
                if (name !== undefined) {
                    properties.name = {
                        configurable: true,
                        value: name,
                        writable: true
                    }
                }
                constructor.prototype = Object.create(
                    super_.prototype,
                    properties
                )

                return constructor
            }
            exports = module.exports = makeError
            exports.BaseError = BaseError

            /***/
        },

        /***/ b1mx: /***/ function(module, exports, __webpack_require__) {
            var once = __webpack_require__('VmuJ')
            var eos = __webpack_require__('q1Jy')
            var fs = __webpack_require__('mw/K') // we only need fs to get the ReadStream and WriteStream prototypes

            var noop = function() {}
            var ancient = /^v?\.0/.test(process.version)

            var isFn = function(fn) {
                return typeof fn === 'function'
            }

            var isFS = function(stream) {
                if (!ancient) return false // newer node version do not need to care about fs is a special way
                if (!fs) return false // browser
                return (
                    (stream instanceof (fs.ReadStream || noop) ||
                        stream instanceof (fs.WriteStream || noop)) &&
                    isFn(stream.close)
                )
            }

            var isRequest = function(stream) {
                return stream.setHeader && isFn(stream.abort)
            }

            var destroyer = function(stream, reading, writing, callback) {
                callback = once(callback)

                var closed = false
                stream.on('close', function() {
                    closed = true
                })

                eos(stream, { readable: reading, writable: writing }, function(
                    err
                ) {
                    if (err) return callback(err)
                    closed = true
                    callback()
                })

                var destroyed = false
                return function(err) {
                    if (closed) return
                    if (destroyed) return
                    destroyed = true

                    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
                    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

                    if (isFn(stream.destroy)) return stream.destroy()

                    callback(err || new Error('stream was destroyed'))
                }
            }

            var call = function(fn) {
                fn()
            }

            var pipe = function(from, to) {
                return from.pipe(to)
            }

            var pump = function() {
                var streams = Array.prototype.slice.call(arguments)
                var callback =
                    (isFn(streams[streams.length - 1] || noop) &&
                        streams.pop()) ||
                    noop

                if (Array.isArray(streams[0])) streams = streams[0]
                if (streams.length < 2)
                    throw new Error('pump requires two streams per minimum')

                var error
                var destroys = streams.map(function(stream, i) {
                    var reading = i < streams.length - 1
                    var writing = i > 0
                    return destroyer(stream, reading, writing, function(err) {
                        if (!error) error = err
                        if (err) destroys.forEach(call)
                        if (reading) return
                        destroys.forEach(call)
                        callback(error)
                    })
                })

                return streams.reduce(pipe)
            }

            module.exports = pump

            /***/
        },

        /***/ b2z7: /***/ function(module, exports) {
            /** Used to match `RegExp` flags from their coerced string values. */
            var reFlags = /\w*$/

            /**
             * Creates a clone of `regexp`.
             *
             * @private
             * @param {Object} regexp The regexp to clone.
             * @returns {Object} Returns the cloned regexp.
             */
            function cloneRegExp(regexp) {
                var result = new regexp.constructor(
                    regexp.source,
                    reFlags.exec(regexp)
                )
                result.lastIndex = regexp.lastIndex
                return result
            }

            module.exports = cloneRegExp

            /***/
        },

        /***/ b80T: /***/ function(module, exports, __webpack_require__) {
            var baseTimes = __webpack_require__('UNi/'),
                isArguments = __webpack_require__('03A+'),
                isArray = __webpack_require__('Z0cm'),
                isBuffer = __webpack_require__('DSRE'),
                isIndex = __webpack_require__('wJg7'),
                isTypedArray = __webpack_require__('c6wG')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Creates an array of the enumerable property names of the array-like `value`.
             *
             * @private
             * @param {*} value The value to query.
             * @param {boolean} inherited Specify returning inherited property names.
             * @returns {Array} Returns the array of property names.
             */
            function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value),
                    isArg = !isArr && isArguments(value),
                    isBuff = !isArr && !isArg && isBuffer(value),
                    isType = !isArr && !isArg && !isBuff && isTypedArray(value),
                    skipIndexes = isArr || isArg || isBuff || isType,
                    result = skipIndexes ? baseTimes(value.length, String) : [],
                    length = result.length

                for (var key in value) {
                    if (
                        (inherited || hasOwnProperty.call(value, key)) &&
                        !(
                            skipIndexes &&
                            // Safari 9 has enumerable `arguments.length` in strict mode.
                            (key == 'length' ||
                                // Node.js 0.10 has enumerable non-index properties on buffers.
                                (isBuff &&
                                    (key == 'offset' || key == 'parent')) ||
                                // PhantomJS 2 has enumerable non-index properties on typed arrays.
                                (isType &&
                                    (key == 'buffer' ||
                                        key == 'byteLength' ||
                                        key == 'byteOffset')) ||
                                // Skip index properties.
                                isIndex(key, length))
                        )
                    ) {
                        result.push(key)
                    }
                }
                return result
            }

            module.exports = arrayLikeKeys

            /***/
        },

        /***/ b9eJ: /***/ function(module, exports, __webpack_require__) {
            const { getCurves } = __webpack_require__('PJMN')

            const { name: secp256k1 } = __webpack_require__('F/JS')

            const curves = new Set()

            if (getCurves().includes('prime256v1')) {
                curves.add('P-256')
            }

            if (getCurves().includes('secp256k1')) {
                curves.add(secp256k1)
            }

            if (getCurves().includes('secp384r1')) {
                curves.add('P-384')
            }

            if (getCurves().includes('secp521r1')) {
                curves.add('P-521')
            }

            module.exports = curves

            /***/
        },

        /***/ bUME: /***/ function(module, exports, __webpack_require__) {
            const {
                createCipheriv,
                createDecipheriv,
                getCiphers
            } = __webpack_require__('PJMN')

            const uint64be = __webpack_require__('PsWn')
            const timingSafeEqual = __webpack_require__('kuaU')
            const { KEYOBJECT } = __webpack_require__('ehsS')
            const { asInput } = __webpack_require__('1ALl')

            const checkInput = data => {
                if (data !== undefined && data.length % 8 !== 0) {
                    throw new Error('invalid data length')
                }
            }

            const IV = Buffer.alloc(8, 'a6', 'hex')

            const xor = (a, b) => {
                const len = Math.max(a.length, b.length)
                const result = Buffer.alloc(len)
                for (let idx = 0; len > idx; idx++) {
                    result[idx] = (a[idx] || 0) ^ (b[idx] || 0)
                }

                return result
            }

            const split = (input, size) => {
                const output = []
                for (let idx = 0; input.length > idx; idx += size) {
                    output.push(input.slice(idx, idx + size))
                }
                return output
            }

            const wrapKey = (size, { [KEYOBJECT]: keyObject }, payload) => {
                const key = asInput(keyObject, false)
                const iv = Buffer.alloc(16)
                let R = split(payload, 8)
                let A
                let B
                let count
                A = IV
                for (let jdx = 0; jdx < 6; jdx++) {
                    for (let idx = 0; R.length > idx; idx++) {
                        count = R.length * jdx + idx + 1
                        const cipher = createCipheriv(`aes${size}`, key, iv)
                        B = Buffer.concat([A, R[idx]])
                        B = cipher.update(B)

                        A = xor(B.slice(0, 8), uint64be(count))
                        R[idx] = B.slice(8, 16)
                    }
                }
                R = [A].concat(R)

                return { wrapped: Buffer.concat(R) }
            }

            const unwrapKey = (size, { [KEYOBJECT]: keyObject }, payload) => {
                const key = asInput(keyObject, false)
                checkInput(payload)

                const iv = Buffer.alloc(16)

                let R = split(payload, 8)
                let A
                let B
                let count
                A = R[0]
                R = R.slice(1)
                for (let jdx = 5; jdx >= 0; --jdx) {
                    for (let idx = R.length - 1; idx >= 0; --idx) {
                        count = R.length * jdx + idx + 1
                        B = xor(A, uint64be(count))
                        B = Buffer.concat([B, R[idx], iv])
                        const cipher = createDecipheriv(`aes${size}`, key, iv)
                        B = cipher.update(B)

                        A = B.slice(0, 8)
                        R[idx] = B.slice(8, 16)
                    }
                }

                if (!timingSafeEqual(IV, A)) {
                    throw new Error('unwrap failed')
                }

                return Buffer.concat(R)
            }

            module.exports = (JWA, JWK) => {
                ;['A128KW', 'A192KW', 'A256KW'].forEach(jwaAlg => {
                    const size = parseInt(jwaAlg.substr(1, 3), 10)
                    if (getCiphers().includes(`aes${size}`)) {
                        JWA.keyManagementEncrypt.set(
                            jwaAlg,
                            wrapKey.bind(undefined, size)
                        )
                        JWA.keyManagementDecrypt.set(
                            jwaAlg,
                            unwrapKey.bind(undefined, size)
                        )
                        JWK.oct.wrapKey[jwaAlg] = JWK.oct.unwrapKey[
                            jwaAlg
                        ] = key =>
                            (key.use === 'enc' || key.use === undefined) &&
                            key.length === size
                    }
                })
            }

            /***/
        },

        /***/ bzos: /***/ function(module, exports) {
            module.exports = require('url')

            /***/
        },

        /***/ 'c1/D': /***/ function(module, exports, __webpack_require__) {
            const { inherits } = __webpack_require__('jK02')

            const DEREncoder = __webpack_require__('ZUdF')

            function PEMEncoder(entity) {
                DEREncoder.call(this, entity)
                this.enc = 'pem'
            }
            inherits(PEMEncoder, DEREncoder)

            PEMEncoder.prototype.encode = function encode(data, options) {
                const buf = DEREncoder.prototype.encode.call(this, data)

                const p = buf.toString('base64')
                const out = [`-----BEGIN ${options.label}-----`]
                for (let i = 0; i < p.length; i += 64) {
                    out.push(p.slice(i, i + 64))
                }
                out.push(`-----END ${options.label}-----`)
                return out.join('\n')
            }

            module.exports = PEMEncoder

            /***/
        },

        /***/ c21q: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var Buffer = __webpack_require__('NkYg').Buffer
            // Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer

            // == Extend Node primitives to use iconv-lite =================================

            module.exports = function(iconv) {
                var original = undefined // Place to keep original methods.

                // Node authors rewrote Buffer internals to make it compatible with
                // Uint8Array and we cannot patch key functions since then.
                // Note: this does use older Buffer API on a purpose
                iconv.supportsNodeEncodingsExtension = !(
                    Buffer.from || new Buffer(0) instanceof Uint8Array
                )

                iconv.extendNodeEncodings = function extendNodeEncodings() {
                    if (original) return
                    original = {}

                    if (!iconv.supportsNodeEncodingsExtension) {
                        console.error(
                            "ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node"
                        )
                        console.error(
                            'See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility'
                        )
                        return
                    }

                    var nodeNativeEncodings = {
                        hex: true,
                        utf8: true,
                        'utf-8': true,
                        ascii: true,
                        binary: true,
                        base64: true,
                        ucs2: true,
                        'ucs-2': true,
                        utf16le: true,
                        'utf-16le': true
                    }

                    Buffer.isNativeEncoding = function(enc) {
                        return enc && nodeNativeEncodings[enc.toLowerCase()]
                    }

                    // -- SlowBuffer -----------------------------------------------------------
                    var SlowBuffer = __webpack_require__('NkYg').SlowBuffer

                    original.SlowBufferToString = SlowBuffer.prototype.toString
                    SlowBuffer.prototype.toString = function(
                        encoding,
                        start,
                        end
                    ) {
                        encoding = String(encoding || 'utf8').toLowerCase()

                        // Use native conversion when possible
                        if (Buffer.isNativeEncoding(encoding))
                            return original.SlowBufferToString.call(
                                this,
                                encoding,
                                start,
                                end
                            )

                        // Otherwise, use our decoding method.
                        if (typeof start == 'undefined') start = 0
                        if (typeof end == 'undefined') end = this.length
                        return iconv.decode(this.slice(start, end), encoding)
                    }

                    original.SlowBufferWrite = SlowBuffer.prototype.write
                    SlowBuffer.prototype.write = function(
                        string,
                        offset,
                        length,
                        encoding
                    ) {
                        // Support both (string, offset, length, encoding)
                        // and the legacy (string, encoding, offset, length)
                        if (isFinite(offset)) {
                            if (!isFinite(length)) {
                                encoding = length
                                length = undefined
                            }
                        } else {
                            // legacy
                            var swap = encoding
                            encoding = offset
                            offset = length
                            length = swap
                        }

                        offset = +offset || 0
                        var remaining = this.length - offset
                        if (!length) {
                            length = remaining
                        } else {
                            length = +length
                            if (length > remaining) {
                                length = remaining
                            }
                        }
                        encoding = String(encoding || 'utf8').toLowerCase()

                        // Use native conversion when possible
                        if (Buffer.isNativeEncoding(encoding))
                            return original.SlowBufferWrite.call(
                                this,
                                string,
                                offset,
                                length,
                                encoding
                            )

                        if (string.length > 0 && (length < 0 || offset < 0))
                            throw new RangeError(
                                'attempt to write beyond buffer bounds'
                            )

                        // Otherwise, use our encoding method.
                        var buf = iconv.encode(string, encoding)
                        if (buf.length < length) length = buf.length
                        buf.copy(this, offset, 0, length)
                        return length
                    }

                    // -- Buffer ---------------------------------------------------------------

                    original.BufferIsEncoding = Buffer.isEncoding
                    Buffer.isEncoding = function(encoding) {
                        return (
                            Buffer.isNativeEncoding(encoding) ||
                            iconv.encodingExists(encoding)
                        )
                    }

                    original.BufferByteLength = Buffer.byteLength
                    Buffer.byteLength = SlowBuffer.byteLength = function(
                        str,
                        encoding
                    ) {
                        encoding = String(encoding || 'utf8').toLowerCase()

                        // Use native conversion when possible
                        if (Buffer.isNativeEncoding(encoding))
                            return original.BufferByteLength.call(
                                this,
                                str,
                                encoding
                            )

                        // Slow, I know, but we don't have a better way yet.
                        return iconv.encode(str, encoding).length
                    }

                    original.BufferToString = Buffer.prototype.toString
                    Buffer.prototype.toString = function(encoding, start, end) {
                        encoding = String(encoding || 'utf8').toLowerCase()

                        // Use native conversion when possible
                        if (Buffer.isNativeEncoding(encoding))
                            return original.BufferToString.call(
                                this,
                                encoding,
                                start,
                                end
                            )

                        // Otherwise, use our decoding method.
                        if (typeof start == 'undefined') start = 0
                        if (typeof end == 'undefined') end = this.length
                        return iconv.decode(this.slice(start, end), encoding)
                    }

                    original.BufferWrite = Buffer.prototype.write
                    Buffer.prototype.write = function(
                        string,
                        offset,
                        length,
                        encoding
                    ) {
                        var _offset = offset,
                            _length = length,
                            _encoding = encoding
                        // Support both (string, offset, length, encoding)
                        // and the legacy (string, encoding, offset, length)
                        if (isFinite(offset)) {
                            if (!isFinite(length)) {
                                encoding = length
                                length = undefined
                            }
                        } else {
                            // legacy
                            var swap = encoding
                            encoding = offset
                            offset = length
                            length = swap
                        }

                        encoding = String(encoding || 'utf8').toLowerCase()

                        // Use native conversion when possible
                        if (Buffer.isNativeEncoding(encoding))
                            return original.BufferWrite.call(
                                this,
                                string,
                                _offset,
                                _length,
                                _encoding
                            )

                        offset = +offset || 0
                        var remaining = this.length - offset
                        if (!length) {
                            length = remaining
                        } else {
                            length = +length
                            if (length > remaining) {
                                length = remaining
                            }
                        }

                        if (string.length > 0 && (length < 0 || offset < 0))
                            throw new RangeError(
                                'attempt to write beyond buffer bounds'
                            )

                        // Otherwise, use our encoding method.
                        var buf = iconv.encode(string, encoding)
                        if (buf.length < length) length = buf.length
                        buf.copy(this, offset, 0, length)
                        return length

                        // TODO: Set _charsWritten.
                    }

                    // -- Readable -------------------------------------------------------------
                    if (iconv.supportsStreams) {
                        var Readable = __webpack_require__('msIP').Readable

                        original.ReadableSetEncoding =
                            Readable.prototype.setEncoding
                        Readable.prototype.setEncoding = function setEncoding(
                            enc,
                            options
                        ) {
                            // Use our own decoder, it has the same interface.
                            // We cannot use original function as it doesn't handle BOM-s.
                            this._readableState.decoder = iconv.getDecoder(
                                enc,
                                options
                            )
                            this._readableState.encoding = enc
                        }

                        Readable.prototype.collect = iconv._collect
                    }
                }

                // Remove iconv-lite Node primitive extensions.
                iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
                    if (!iconv.supportsNodeEncodingsExtension) return
                    if (!original)
                        throw new Error(
                            "require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called."
                        )

                    delete Buffer.isNativeEncoding

                    var SlowBuffer = __webpack_require__('NkYg').SlowBuffer

                    SlowBuffer.prototype.toString = original.SlowBufferToString
                    SlowBuffer.prototype.write = original.SlowBufferWrite

                    Buffer.isEncoding = original.BufferIsEncoding
                    Buffer.byteLength = original.BufferByteLength
                    Buffer.prototype.toString = original.BufferToString
                    Buffer.prototype.write = original.BufferWrite

                    if (iconv.supportsStreams) {
                        var Readable = __webpack_require__('msIP').Readable

                        Readable.prototype.setEncoding =
                            original.ReadableSetEncoding
                        delete Readable.prototype.collect
                    }

                    original = undefined
                }
            }

            /***/
        },

        /***/ c6wG: /***/ function(module, exports, __webpack_require__) {
            var baseIsTypedArray = __webpack_require__('dD9F'),
                baseUnary = __webpack_require__('sEf8'),
                nodeUtil = __webpack_require__('mdPL')

            /* Node.js helper references. */
            var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray

            /**
             * Checks if `value` is classified as a typed array.
             *
             * @static
             * @memberOf _
             * @since 3.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
             * @example
             *
             * _.isTypedArray(new Uint8Array);
             * // => true
             *
             * _.isTypedArray([]);
             * // => false
             */
            var isTypedArray = nodeIsTypedArray
                ? baseUnary(nodeIsTypedArray)
                : baseIsTypedArray

            module.exports = isTypedArray

            /***/
        },

        /***/ canG: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const errors = __webpack_require__('9Fi5')
            const asStream = __webpack_require__('kjw5')
            const asPromise = __webpack_require__('4UWp')
            const normalizeArguments = __webpack_require__('whhB')
            const merge = __webpack_require__('AW8e')
            const deepFreeze = __webpack_require__('z/H/')

            const getPromiseOrStream = options =>
                options.stream ? asStream(options) : asPromise(options)

            const aliases = ['get', 'post', 'put', 'patch', 'head', 'delete']

            const create = defaults => {
                defaults = merge({}, defaults)
                normalizeArguments.preNormalize(defaults.options)

                if (!defaults.handler) {
                    // This can't be getPromiseOrStream, because when merging
                    // the chain would stop at this point and no further handlers would be called.
                    defaults.handler = (options, next) => next(options)
                }

                function got(url, options) {
                    try {
                        return defaults.handler(
                            normalizeArguments(url, options, defaults),
                            getPromiseOrStream
                        )
                    } catch (error) {
                        if (options && options.stream) {
                            throw error
                        } else {
                            return Promise.reject(error)
                        }
                    }
                }

                got.create = create
                got.extend = options => {
                    let mutableDefaults
                    if (options && Reflect.has(options, 'mutableDefaults')) {
                        mutableDefaults = options.mutableDefaults
                        delete options.mutableDefaults
                    } else {
                        mutableDefaults = defaults.mutableDefaults
                    }

                    return create({
                        options: merge.options(defaults.options, options),
                        handler: defaults.handler,
                        mutableDefaults
                    })
                }

                got.mergeInstances = (...args) => create(merge.instances(args))

                got.stream = (url, options) =>
                    got(url, { ...options, stream: true })

                for (const method of aliases) {
                    got[method] = (url, options) =>
                        got(url, { ...options, method })
                    got.stream[method] = (url, options) =>
                        got.stream(url, { ...options, method })
                }

                Object.assign(got, { ...errors, mergeOptions: merge.options })
                Object.defineProperty(got, 'defaults', {
                    value: defaults.mutableDefaults
                        ? defaults
                        : deepFreeze(defaults),
                    writable: defaults.mutableDefaults,
                    configurable: defaults.mutableDefaults,
                    enumerable: true
                })

                return got
            }

            module.exports = create

            /***/
        },

        /***/ cfAG: /***/ function(module) {
            module.exports = JSON.parse(
                '[["8740",""],["8767",""],["87a1",""],["8840","",4,""],["88a1",""],["8940",""],["8943",""],["8946",""],["894c",""],["89a1",""],["89ab",""],["89b0",""],["89b5",""],["89c1",""],["89c5",""],["8a40",""],["8a43",""],["8a64",""],["8a76",""],["8aa1",""],["8aac",""],["8ab2",""],["8abb",""],["8ac9",""],["8ace",""],["8adf",""],["8af6",""],["8b40",""],["8b55",""],["8ba1",""],["8bde",""],["8c40",""],["8ca1",""],["8ca7",""],["8cc9",""],["8cce",""],["8ce6",""],["8d40",""],["8d42",""],["8da1",""],["8e40",""],["8ea1",""],["8f40",""],["8fa1",""],["9040",""],["90a1",""],["9140",""],["91a1",""],["9240",""],["92a1",""],["9340",""],["93a1",""],["9440",""],["94a1",""],["9540",""],["95a1",""],["9640",""],["96a1",""],["9740",""],["97a1",""],["9840",""],["98a1",""],["9940",""],["99a1",""],["9a40",""],["9aa1",""],["9b40",""],["9b62",""],["9ba1",""],["9c40",""],["9ca1",""],["9d40",""],["9da1",""],["9e40",""],["9ea1",""],["9ead",""],["9ec5",""],["9ef5",""],["9f40",""],["9f4f",""],["9fa1",""],["9fae",""],["9fb2",""],["9fc1",""],["9fc9",""],["9fdb",""],["9fe7",""],["9feb",""],["9ff0",""],["a040",""],["a055",""],["a058",""],["a05b",""],["a063",""],["a073",""],["a0a1",""],["a0a6",""],["a0ae",""],["a0b0",""],["a0d4",""],["a0e2",""],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,""],["c8a1",""],["c8cd",""],["c8f5",""],["f9fe",""],["fa40",""],["faa1",""],["fb40",""],["fba1",""],["fc40",""],["fca1",""],["fd40",""],["fda1",""],["fe40",""],["fea1",""]]'
            )

            /***/
        },

        /***/ 'cq/+': /***/ function(module, exports, __webpack_require__) {
            var createBaseFor = __webpack_require__('mc0g')

            /**
             * The base implementation of `baseForOwn` which iterates over `object`
             * properties returned by `keysFunc` and invokes `iteratee` for each property.
             * Iteratee functions may exit iteration early by explicitly returning `false`.
             *
             * @private
             * @param {Object} object The object to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @param {Function} keysFunc The function to get the keys of `object`.
             * @returns {Object} Returns `object`.
             */
            var baseFor = createBaseFor()

            module.exports = baseFor

            /***/
        },

        /***/ cvCv: /***/ function(module, exports) {
            /**
             * Creates a function that returns `value`.
             *
             * @static
             * @memberOf _
             * @since 2.4.0
             * @category Util
             * @param {*} value The value to return from the new function.
             * @returns {Function} Returns the new constant function.
             * @example
             *
             * var objects = _.times(2, _.constant({ 'a': 1 }));
             *
             * console.log(objects);
             * // => [{ 'a': 1 }, { 'a': 1 }]
             *
             * console.log(objects[0] === objects[1]);
             * // => true
             */
            function constant(value) {
                return function() {
                    return value
                }
            }

            module.exports = constant

            /***/
        },

        /***/ d4WF: /***/ function(module, exports, __webpack_require__) {
            const {
                createCipheriv,
                createDecipheriv,
                getCiphers
            } = __webpack_require__('PJMN')

            const uint64be = __webpack_require__('PsWn')
            const timingSafeEqual = __webpack_require__('kuaU')
            const { KEYOBJECT } = __webpack_require__('ehsS')
            const { JWEInvalid, JWEDecryptionFailed } = __webpack_require__(
                'yt7c'
            )

            const checkInput = function(size, iv, tag) {
                if (iv.length !== 16) {
                    throw new JWEInvalid('invalid iv')
                }
                if (arguments.length === 3) {
                    if (tag.length !== size / 8) {
                        throw new JWEInvalid('invalid tag')
                    }
                }
            }

            const encrypt = (
                size,
                sign,
                { [KEYOBJECT]: keyObject },
                cleartext,
                { iv, aad = Buffer.alloc(0) }
            ) => {
                const key = keyObject.export()
                checkInput(size, iv)

                const keySize = size / 8
                const encKey = key.slice(keySize)
                const cipher = createCipheriv(`aes-${size}-cbc`, encKey, iv)
                const ciphertext = Buffer.concat([
                    cipher.update(cleartext),
                    cipher.final()
                ])
                const macData = Buffer.concat([
                    aad,
                    iv,
                    ciphertext,
                    uint64be(aad.length * 8)
                ])

                const macKey = key.slice(0, keySize)
                const tag = sign({ [KEYOBJECT]: macKey }, macData).slice(
                    0,
                    keySize
                )

                return { ciphertext, tag }
            }

            const decrypt = (
                size,
                sign,
                { [KEYOBJECT]: keyObject },
                ciphertext,
                { iv, tag = Buffer.alloc(0), aad = Buffer.alloc(0) }
            ) => {
                checkInput(size, iv, tag)

                const keySize = size / 8
                const key = keyObject.export()
                const encKey = key.slice(keySize)
                const macKey = key.slice(0, keySize)

                const macData = Buffer.concat([
                    aad,
                    iv,
                    ciphertext,
                    uint64be(aad.length * 8)
                ])
                const expectedTag = sign(
                    { [KEYOBJECT]: macKey },
                    macData,
                    tag
                ).slice(0, keySize)
                const macCheckPassed = timingSafeEqual(tag, expectedTag)

                let cleartext
                try {
                    const cipher = createDecipheriv(
                        `aes-${size}-cbc`,
                        encKey,
                        iv
                    )
                    cleartext = Buffer.concat([
                        cipher.update(ciphertext),
                        cipher.final()
                    ])
                } catch (err) {}

                if (!cleartext || !macCheckPassed) {
                    throw new JWEDecryptionFailed()
                }

                return cleartext
            }

            module.exports = (JWA, JWK) => {
                ;['A128CBC-HS256', 'A192CBC-HS384', 'A256CBC-HS512'].forEach(
                    jwaAlg => {
                        const size = parseInt(jwaAlg.substr(1, 3), 10)
                        const sign = JWA.sign.get(`HS${size * 2}`)
                        if (getCiphers().includes(`aes-${size}-cbc`)) {
                            JWA.encrypt.set(
                                jwaAlg,
                                encrypt.bind(undefined, size, sign)
                            )
                            JWA.decrypt.set(
                                jwaAlg,
                                decrypt.bind(undefined, size, sign)
                            )
                            JWK.oct.encrypt[jwaAlg] = JWK.oct.decrypt[
                                jwaAlg
                            ] = key =>
                                (key.use === 'enc' || key.use === undefined) &&
                                key.length / 2 === size
                        }
                    }
                )
            }

            /***/
        },

        /***/ d8FT: /***/ function(module, exports, __webpack_require__) {
            var arrayMap = __webpack_require__('eUgh'),
                baseIteratee = __webpack_require__('ut/Y'),
                basePickBy = __webpack_require__('idmN'),
                getAllKeysIn = __webpack_require__('G6z8')

            /**
             * Creates an object composed of the `object` properties `predicate` returns
             * truthy for. The predicate is invoked with two arguments: (value, key).
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Object
             * @param {Object} object The source object.
             * @param {Function} [predicate=_.identity] The function invoked per property.
             * @returns {Object} Returns the new object.
             * @example
             *
             * var object = { 'a': 1, 'b': '2', 'c': 3 };
             *
             * _.pickBy(object, _.isNumber);
             * // => { 'a': 1, 'c': 3 }
             */
            function pickBy(object, predicate) {
                if (object == null) {
                    return {}
                }
                var props = arrayMap(getAllKeysIn(object), function(prop) {
                    return [prop]
                })
                predicate = baseIteratee(predicate)
                return basePickBy(object, props, function(value, path) {
                    return predicate(value, path[0])
                })
            }

            module.exports = pickBy

            /***/
        },

        /***/ dD9F: /***/ function(module, exports, __webpack_require__) {
            var baseGetTag = __webpack_require__('NykK'),
                isLength = __webpack_require__('shjB'),
                isObjectLike = __webpack_require__('ExA7')

            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]',
                arrayTag = '[object Array]',
                boolTag = '[object Boolean]',
                dateTag = '[object Date]',
                errorTag = '[object Error]',
                funcTag = '[object Function]',
                mapTag = '[object Map]',
                numberTag = '[object Number]',
                objectTag = '[object Object]',
                regexpTag = '[object RegExp]',
                setTag = '[object Set]',
                stringTag = '[object String]',
                weakMapTag = '[object WeakMap]'

            var arrayBufferTag = '[object ArrayBuffer]',
                dataViewTag = '[object DataView]',
                float32Tag = '[object Float32Array]',
                float64Tag = '[object Float64Array]',
                int8Tag = '[object Int8Array]',
                int16Tag = '[object Int16Array]',
                int32Tag = '[object Int32Array]',
                uint8Tag = '[object Uint8Array]',
                uint8ClampedTag = '[object Uint8ClampedArray]',
                uint16Tag = '[object Uint16Array]',
                uint32Tag = '[object Uint32Array]'

            /** Used to identify `toStringTag` values of typed arrays. */
            var typedArrayTags = {}
            typedArrayTags[float32Tag] = typedArrayTags[
                float64Tag
            ] = typedArrayTags[int8Tag] = typedArrayTags[
                int16Tag
            ] = typedArrayTags[int32Tag] = typedArrayTags[
                uint8Tag
            ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
                uint16Tag
            ] = typedArrayTags[uint32Tag] = true
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[
                arrayBufferTag
            ] = typedArrayTags[boolTag] = typedArrayTags[
                dataViewTag
            ] = typedArrayTags[dateTag] = typedArrayTags[
                errorTag
            ] = typedArrayTags[funcTag] = typedArrayTags[
                mapTag
            ] = typedArrayTags[numberTag] = typedArrayTags[
                objectTag
            ] = typedArrayTags[regexpTag] = typedArrayTags[
                setTag
            ] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false

            /**
             * The base implementation of `_.isTypedArray` without Node.js optimizations.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
             */
            function baseIsTypedArray(value) {
                return (
                    isObjectLike(value) &&
                    isLength(value.length) &&
                    !!typedArrayTags[baseGetTag(value)]
                )
            }

            module.exports = baseIsTypedArray

            /***/
        },

        /***/ dTAl: /***/ function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__('GoyQ')

            /** Built-in value references. */
            var objectCreate = Object.create

            /**
             * The base implementation of `_.create` without support for assigning
             * properties to the created object.
             *
             * @private
             * @param {Object} proto The object to inherit from.
             * @returns {Object} Returns the new object.
             */
            var baseCreate = (function() {
                function object() {}
                return function(proto) {
                    if (!isObject(proto)) {
                        return {}
                    }
                    if (objectCreate) {
                        return objectCreate(proto)
                    }
                    object.prototype = proto
                    var result = new object()
                    object.prototype = undefined
                    return result
                }
            })()

            module.exports = baseCreate

            /***/
        },

        /***/ dt0z: /***/ function(module, exports, __webpack_require__) {
            var baseToString = __webpack_require__('zoYe')

            /**
             * Converts `value` to a string. An empty string is returned for `null`
             * and `undefined` values. The sign of `-0` is preserved.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to convert.
             * @returns {string} Returns the converted string.
             * @example
             *
             * _.toString(null);
             * // => ''
             *
             * _.toString(-0);
             * // => '-0'
             *
             * _.toString([1, 2, 3]);
             * // => '1,2,3'
             */
            function toString(value) {
                return value == null ? '' : baseToString(value)
            }

            module.exports = toString

            /***/
        },

        /***/ e4Nc: /***/ function(module, exports, __webpack_require__) {
            var mapCacheClear = __webpack_require__('fGT3'),
                mapCacheDelete = __webpack_require__('k+1r'),
                mapCacheGet = __webpack_require__('JHgL'),
                mapCacheHas = __webpack_require__('pSRY'),
                mapCacheSet = __webpack_require__('H8j4')

            /**
             * Creates a map cache object to store key-value pairs.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function MapCache(entries) {
                var index = -1,
                    length = entries == null ? 0 : entries.length

                this.clear()
                while (++index < length) {
                    var entry = entries[index]
                    this.set(entry[0], entry[1])
                }
            }

            // Add methods to `MapCache`.
            MapCache.prototype.clear = mapCacheClear
            MapCache.prototype['delete'] = mapCacheDelete
            MapCache.prototype.get = mapCacheGet
            MapCache.prototype.has = mapCacheHas
            MapCache.prototype.set = mapCacheSet

            module.exports = MapCache

            /***/
        },

        /***/ e5cp: /***/ function(module, exports, __webpack_require__) {
            var Stack = __webpack_require__('fmRc'),
                equalArrays = __webpack_require__('or5M'),
                equalByTag = __webpack_require__('HDyB'),
                equalObjects = __webpack_require__('seXi'),
                getTag = __webpack_require__('QqLw'),
                isArray = __webpack_require__('Z0cm'),
                isBuffer = __webpack_require__('DSRE'),
                isTypedArray = __webpack_require__('c6wG')

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1

            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]',
                arrayTag = '[object Array]',
                objectTag = '[object Object]'

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * A specialized version of `baseIsEqual` for arrays and objects which performs
             * deep comparisons and tracks traversed objects enabling objects with circular
             * references to be compared.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
             * @param {Function} customizer The function to customize comparisons.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Object} [stack] Tracks traversed `object` and `other` objects.
             * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
             */
            function baseIsEqualDeep(
                object,
                other,
                bitmask,
                customizer,
                equalFunc,
                stack
            ) {
                var objIsArr = isArray(object),
                    othIsArr = isArray(other),
                    objTag = objIsArr ? arrayTag : getTag(object),
                    othTag = othIsArr ? arrayTag : getTag(other)

                objTag = objTag == argsTag ? objectTag : objTag
                othTag = othTag == argsTag ? objectTag : othTag

                var objIsObj = objTag == objectTag,
                    othIsObj = othTag == objectTag,
                    isSameTag = objTag == othTag

                if (isSameTag && isBuffer(object)) {
                    if (!isBuffer(other)) {
                        return false
                    }
                    objIsArr = true
                    objIsObj = false
                }
                if (isSameTag && !objIsObj) {
                    stack || (stack = new Stack())
                    return objIsArr || isTypedArray(object)
                        ? equalArrays(
                              object,
                              other,
                              bitmask,
                              customizer,
                              equalFunc,
                              stack
                          )
                        : equalByTag(
                              object,
                              other,
                              objTag,
                              bitmask,
                              customizer,
                              equalFunc,
                              stack
                          )
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                    var objIsWrapped =
                            objIsObj &&
                            hasOwnProperty.call(object, '__wrapped__'),
                        othIsWrapped =
                            othIsObj &&
                            hasOwnProperty.call(other, '__wrapped__')

                    if (objIsWrapped || othIsWrapped) {
                        var objUnwrapped = objIsWrapped
                                ? object.value()
                                : object,
                            othUnwrapped = othIsWrapped ? other.value() : other

                        stack || (stack = new Stack())
                        return equalFunc(
                            objUnwrapped,
                            othUnwrapped,
                            bitmask,
                            customizer,
                            stack
                        )
                    }
                }
                if (!isSameTag) {
                    return false
                }
                stack || (stack = new Stack())
                return equalObjects(
                    object,
                    other,
                    bitmask,
                    customizer,
                    equalFunc,
                    stack
                )
            }

            module.exports = baseIsEqualDeep

            /***/
        },

        /***/ eC53: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const EventEmitter = __webpack_require__('/0p4')
            const urlLib = __webpack_require__('bzos')
            const normalizeUrl = __webpack_require__('NCJl')
            const getStream = __webpack_require__('gK4g')
            const CachePolicy = __webpack_require__('lERV')
            const Response = __webpack_require__('O9zF')
            const lowercaseKeys = __webpack_require__('D5mk')
            const cloneResponse = __webpack_require__('21rS')
            const Keyv = __webpack_require__('mxNO')

            class CacheableRequest {
                constructor(request, cacheAdapter) {
                    if (typeof request !== 'function') {
                        throw new TypeError(
                            'Parameter `request` must be a function'
                        )
                    }

                    this.cache = new Keyv({
                        uri: typeof cacheAdapter === 'string' && cacheAdapter,
                        store: typeof cacheAdapter !== 'string' && cacheAdapter,
                        namespace: 'cacheable-request'
                    })

                    return this.createCacheableRequest(request)
                }

                createCacheableRequest(request) {
                    return (opts, cb) => {
                        let url
                        if (typeof opts === 'string') {
                            url = normalizeUrlObject(urlLib.parse(opts))
                            opts = {}
                        } else if (opts instanceof urlLib.URL) {
                            url = normalizeUrlObject(
                                urlLib.parse(opts.toString())
                            )
                            opts = {}
                        } else {
                            const [pathname, ...searchParts] = (
                                opts.path || ''
                            ).split('?')
                            const search =
                                searchParts.length > 0
                                    ? `?${searchParts.join('?')}`
                                    : ''
                            url = normalizeUrlObject({
                                ...opts,
                                pathname,
                                search
                            })
                        }

                        opts = {
                            headers: {},
                            method: 'GET',
                            cache: true,
                            strictTtl: false,
                            automaticFailover: false,
                            ...opts,
                            ...urlObjectToRequestOptions(url)
                        }
                        opts.headers = lowercaseKeys(opts.headers)

                        const ee = new EventEmitter()
                        const normalizedUrlString = normalizeUrl(
                            urlLib.format(url),
                            {
                                stripWWW: false,
                                removeTrailingSlash: false,
                                stripAuthentication: false
                            }
                        )
                        const key = `${opts.method}:${normalizedUrlString}`
                        let revalidate = false
                        let madeRequest = false

                        const makeRequest = opts => {
                            madeRequest = true
                            let requestErrored = false
                            let requestErrorCallback

                            const requestErrorPromise = new Promise(resolve => {
                                requestErrorCallback = () => {
                                    if (!requestErrored) {
                                        requestErrored = true
                                        resolve()
                                    }
                                }
                            })

                            const handler = response => {
                                if (revalidate && !opts.forceRefresh) {
                                    response.status = response.statusCode
                                    const revalidatedPolicy = CachePolicy.fromObject(
                                        revalidate.cachePolicy
                                    ).revalidatedPolicy(opts, response)
                                    if (!revalidatedPolicy.modified) {
                                        const headers = revalidatedPolicy.policy.responseHeaders()
                                        response = new Response(
                                            revalidate.statusCode,
                                            headers,
                                            revalidate.body,
                                            revalidate.url
                                        )
                                        response.cachePolicy =
                                            revalidatedPolicy.policy
                                        response.fromCache = true
                                    }
                                }

                                if (!response.fromCache) {
                                    response.cachePolicy = new CachePolicy(
                                        opts,
                                        response,
                                        opts
                                    )
                                    response.fromCache = false
                                }

                                let clonedResponse
                                if (
                                    opts.cache &&
                                    response.cachePolicy.storable()
                                ) {
                                    clonedResponse = cloneResponse(response)

                                    ;(async () => {
                                        try {
                                            const bodyPromise = getStream.buffer(
                                                response
                                            )

                                            await Promise.race([
                                                requestErrorPromise,
                                                new Promise(resolve =>
                                                    response.once(
                                                        'end',
                                                        resolve
                                                    )
                                                )
                                            ])

                                            if (requestErrored) {
                                                return
                                            }

                                            const body = await bodyPromise

                                            const value = {
                                                cachePolicy: response.cachePolicy.toObject(),
                                                url: response.url,
                                                statusCode: response.fromCache
                                                    ? revalidate.statusCode
                                                    : response.statusCode,
                                                body
                                            }

                                            let ttl = opts.strictTtl
                                                ? response.cachePolicy.timeToLive()
                                                : undefined
                                            if (opts.maxTtl) {
                                                ttl = ttl
                                                    ? Math.min(ttl, opts.maxTtl)
                                                    : opts.maxTtl
                                            }

                                            await this.cache.set(
                                                key,
                                                value,
                                                ttl
                                            )
                                        } catch (error) {
                                            ee.emit(
                                                'error',
                                                new CacheableRequest.CacheError(
                                                    error
                                                )
                                            )
                                        }
                                    })()
                                } else if (opts.cache && revalidate) {
                                    ;(async () => {
                                        try {
                                            await this.cache.delete(key)
                                        } catch (error) {
                                            ee.emit(
                                                'error',
                                                new CacheableRequest.CacheError(
                                                    error
                                                )
                                            )
                                        }
                                    })()
                                }

                                ee.emit('response', clonedResponse || response)
                                if (typeof cb === 'function') {
                                    cb(clonedResponse || response)
                                }
                            }

                            try {
                                const req = request(opts, handler)
                                req.once('error', requestErrorCallback)
                                req.once('abort', requestErrorCallback)
                                ee.emit('request', req)
                            } catch (error) {
                                ee.emit(
                                    'error',
                                    new CacheableRequest.RequestError(error)
                                )
                            }
                        }

                        ;(async () => {
                            const get = async opts => {
                                await Promise.resolve()

                                const cacheEntry = opts.cache
                                    ? await this.cache.get(key)
                                    : undefined
                                if (typeof cacheEntry === 'undefined') {
                                    return makeRequest(opts)
                                }

                                const policy = CachePolicy.fromObject(
                                    cacheEntry.cachePolicy
                                )
                                if (
                                    policy.satisfiesWithoutRevalidation(opts) &&
                                    !opts.forceRefresh
                                ) {
                                    const headers = policy.responseHeaders()
                                    const response = new Response(
                                        cacheEntry.statusCode,
                                        headers,
                                        cacheEntry.body,
                                        cacheEntry.url
                                    )
                                    response.cachePolicy = policy
                                    response.fromCache = true

                                    ee.emit('response', response)
                                    if (typeof cb === 'function') {
                                        cb(response)
                                    }
                                } else {
                                    revalidate = cacheEntry
                                    opts.headers = policy.revalidationHeaders(
                                        opts
                                    )
                                    makeRequest(opts)
                                }
                            }

                            const errorHandler = error =>
                                ee.emit(
                                    'error',
                                    new CacheableRequest.CacheError(error)
                                )
                            this.cache.once('error', errorHandler)
                            ee.on('response', () =>
                                this.cache.removeListener('error', errorHandler)
                            )

                            try {
                                await get(opts)
                            } catch (error) {
                                if (opts.automaticFailover && !madeRequest) {
                                    makeRequest(opts)
                                }

                                ee.emit(
                                    'error',
                                    new CacheableRequest.CacheError(error)
                                )
                            }
                        })()

                        return ee
                    }
                }
            }

            function urlObjectToRequestOptions(url) {
                const options = { ...url }
                options.path = `${url.pathname || '/'}${url.search || ''}`
                delete options.pathname
                delete options.search
                return options
            }

            function normalizeUrlObject(url) {
                // If url was parsed by url.parse or new URL:
                // - hostname will be set
                // - host will be hostname[:port]
                // - port will be set if it was explicit in the parsed string
                // Otherwise, url was from request options:
                // - hostname or host may be set
                // - host shall not have port encoded
                return {
                    protocol: url.protocol,
                    auth: url.auth,
                    hostname: url.hostname || url.host || 'localhost',
                    port: url.port,
                    pathname: url.pathname,
                    search: url.search
                }
            }

            CacheableRequest.RequestError = class extends Error {
                constructor(error) {
                    super(error.message)
                    this.name = 'RequestError'
                    Object.assign(this, error)
                }
            }

            CacheableRequest.CacheError = class extends Error {
                constructor(error) {
                    super(error.message)
                    this.name = 'CacheError'
                    Object.assign(this, error)
                }
            }

            module.exports = CacheableRequest

            /***/
        },

        /***/ eHfw: /***/ function(module, exports, __webpack_require__) {
            /* global BigInt */

            const { randomBytes } = __webpack_require__('PJMN')

            const base64url = __webpack_require__('Xab3')
            const errors = __webpack_require__('yt7c')

            const ZERO = BigInt(0)
            const ONE = BigInt(1)
            const TWO = BigInt(2)

            const toJWKParameter = n => {
                const hex = n.toString(16)
                return base64url.encodeBuffer(
                    Buffer.from(hex.length % 2 ? `0${hex}` : hex, 'hex')
                )
            }
            const fromBuffer = buf => BigInt(`0x${buf.toString('hex')}`)
            const bitLength = n => n.toString(2).length

            const eGcdX = (a, b) => {
                let x = ZERO
                let y = ONE
                let u = ONE
                let v = ZERO

                while (a !== ZERO) {
                    const q = b / a
                    const r = b % a
                    const m = x - u * q
                    const n = y - v * q
                    b = a
                    a = r
                    x = u
                    y = v
                    u = m
                    v = n
                }
                return x
            }

            const gcd = (a, b) => {
                let shift = ZERO
                while (!((a | b) & ONE)) {
                    a >>= ONE
                    b >>= ONE
                    shift++
                }
                while (!(a & ONE)) {
                    a >>= ONE
                }
                do {
                    while (!(b & ONE)) {
                        b >>= ONE
                    }
                    if (a > b) {
                        const x = a
                        a = b
                        b = x
                    }
                    b -= a
                } while (b)

                return a << shift
            }

            const modPow = (a, b, n) => {
                a = toZn(a, n)
                let result = ONE
                let x = a
                while (b > 0) {
                    var leastSignificantBit = b % TWO
                    b = b / TWO
                    if (leastSignificantBit === ONE) {
                        result = result * x
                        result = result % n
                    }
                    x = x * x
                    x = x % n
                }
                return result
            }

            const randBetween = (min, max) => {
                const interval = max - min
                const bitLen = bitLength(interval)
                let rnd
                do {
                    rnd = fromBuffer(randBits(bitLen))
                } while (rnd > interval)
                return rnd + min
            }

            const randBits = bitLength => {
                const byteLength = Math.ceil(bitLength / 8)
                const rndBytes = randomBytes(byteLength)
                // Fill with 0's the extra bits
                rndBytes[0] = rndBytes[0] & (2 ** (bitLength % 8) - 1)
                return rndBytes
            }

            const toZn = (a, n) => {
                a = a % n
                return a < 0 ? a + n : a
            }

            const odd = n => {
                let r = n
                while (r % TWO === ZERO) {
                    r = r / TWO
                }
                return r
            }

            // not sold on these values
            const maxCountWhileNoY = 30
            const maxCountWhileInot0 = 22

            const getPrimeFactors = (e, d, n) => {
                const r = odd(e * d - ONE)

                let countWhileNoY = 0
                let y
                do {
                    countWhileNoY++
                    if (countWhileNoY === maxCountWhileNoY) {
                        throw new errors.JWKImportFailed(
                            'failed to calculate missing primes'
                        )
                    }

                    let countWhileInot0 = 0
                    let i = modPow(randBetween(TWO, n), r, n)
                    let o = ZERO
                    while (i !== ONE) {
                        countWhileInot0++
                        if (countWhileInot0 === maxCountWhileInot0) {
                            throw new errors.JWKImportFailed(
                                'failed to calculate missing primes'
                            )
                        }
                        o = i
                        i = (i * i) % n
                    }
                    if (o !== n - ONE) {
                        y = o
                    }
                } while (!y)

                const p = gcd(y - ONE, n)
                const q = n / p

                return p > q ? { p, q } : { p: q, q: p }
            }

            module.exports = jwk => {
                const e = fromBuffer(base64url.decodeToBuffer(jwk.e))
                const d = fromBuffer(base64url.decodeToBuffer(jwk.d))
                const n = fromBuffer(base64url.decodeToBuffer(jwk.n))

                if (d >= n) {
                    throw new errors.JWKInvalid('invalid RSA private exponent')
                }

                const { p, q } = getPrimeFactors(e, d, n)
                const dp = d % (p - ONE)
                const dq = d % (q - ONE)
                const qi = toZn(eGcdX(toZn(q, p), p), p)

                return {
                    ...jwk,
                    p: toJWKParameter(p),
                    q: toJWKParameter(q),
                    dp: toJWKParameter(dp),
                    dq: toJWKParameter(dq),
                    qi: toJWKParameter(qi)
                }
            }

            /***/
        },

        /***/ eUgh: /***/ function(module, exports) {
            /**
             * A specialized version of `_.map` for arrays without support for iteratee
             * shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the new mapped array.
             */
            function arrayMap(array, iteratee) {
                var index = -1,
                    length = array == null ? 0 : array.length,
                    result = Array(length)

                while (++index < length) {
                    result[index] = iteratee(array[index], index, array)
                }
                return result
            }

            module.exports = arrayMap

            /***/
        },

        /***/ eUtF: /***/ function(module, exports, __webpack_require__) {
            module.exports =
                !__webpack_require__('jmDH') &&
                !__webpack_require__('KUxP')(function() {
                    return (
                        Object.defineProperty(
                            __webpack_require__('Hsns')('div'),
                            'a',
                            {
                                get: function() {
                                    return 7
                                }
                            }
                        ).a != 7
                    )
                })

            /***/
        },

        /***/ eaoh: /***/ function(module, exports) {
            module.exports = function(it) {
                if (typeof it != 'function')
                    throw TypeError(it + ' is not a function!')
                return it
            }

            /***/
        },

        /***/ ebwN: /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5'),
                root = __webpack_require__('Kz5y')

            /* Built-in method references that are verified to be native. */
            var Map = getNative(root, 'Map')

            module.exports = Map

            /***/
        },

        /***/ ecj1: /***/ function(module, exports, __webpack_require__) {
            const Issuer = __webpack_require__('A93I')
            const { OPError, RPError } = __webpack_require__('L71r')
            const Registry = __webpack_require__('0Aai')
            const Strategy = __webpack_require__('/co4')
            const TokenSet = __webpack_require__('IgmS')
            const { CLOCK_TOLERANCE, HTTP_OPTIONS } = __webpack_require__(
                'TJm8'
            )
            const generators = __webpack_require__('iAgo')
            const { setDefaults } = __webpack_require__('UwMm')

            module.exports = {
                Issuer,
                Registry,
                Strategy,
                TokenSet,
                errors: {
                    OPError,
                    RPError
                },
                custom: {
                    setHttpOptionsDefaults: setDefaults,
                    http_options: HTTP_OPTIONS,
                    clock_tolerance: CLOCK_TOLERANCE
                },
                generators
            }

            /***/
        },

        /***/ ehsS: /***/ function(module, exports) {
            module.exports.KEYOBJECT = Symbol('KEYOBJECT')
            module.exports.PRIVATE_MEMBERS = Symbol('PRIVATE_MEMBERS')
            module.exports.PUBLIC_MEMBERS = Symbol('PUBLIC_MEMBERS')
            module.exports.THUMBPRINT_MATERIAL = Symbol('THUMBPRINT_MATERIAL')
            module.exports.JWK_MEMBERS = Symbol('JWK_MEMBERS')
            module.exports.KEY_MANAGEMENT_ENCRYPT = Symbol(
                'KEY_MANAGEMENT_ENCRYPT'
            )
            module.exports.KEY_MANAGEMENT_DECRYPT = Symbol(
                'KEY_MANAGEMENT_DECRYPT'
            )

            const USES_MAPPING = {
                sig: new Set(['sign', 'verify']),
                enc: new Set([
                    'encrypt',
                    'decrypt',
                    'wrapKey',
                    'unwrapKey',
                    'deriveKey'
                ])
            }
            const OPS = new Set([...USES_MAPPING.sig, ...USES_MAPPING.enc])
            const USES = new Set(Object.keys(USES_MAPPING))

            module.exports.USES_MAPPING = USES_MAPPING
            module.exports.OPS = OPS
            module.exports.USES = USES

            /***/
        },

        /***/ ekgI: /***/ function(module, exports, __webpack_require__) {
            var nativeCreate = __webpack_require__('YESw')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Checks if a hash value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf Hash
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function hashHas(key) {
                var data = this.__data__
                return nativeCreate
                    ? data[key] !== undefined
                    : hasOwnProperty.call(data, key)
            }

            module.exports = hashHas

            /***/
        },

        /***/ f0Nx: /***/ function(module, exports) {
            const MAX_OCTET = 0x80
            const CLASS_UNIVERSAL = 0
            const PRIMITIVE_BIT = 0x20
            const TAG_SEQ = 0x10
            const TAG_INT = 0x02
            const ENCODED_TAG_SEQ =
                TAG_SEQ | PRIMITIVE_BIT | (CLASS_UNIVERSAL << 6)
            const ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6)

            const getParamSize = keySize =>
                ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1)

            const paramBytesForAlg = {
                ES256: getParamSize(256),
                ES256K: getParamSize(256),
                ES384: getParamSize(384),
                ES512: getParamSize(521)
            }

            const countPadding = (buf, start, stop) => {
                let padding = 0
                while (start + padding < stop && buf[start + padding] === 0) {
                    ++padding
                }

                const needsSign = buf[start + padding] >= MAX_OCTET
                if (needsSign) {
                    --padding
                }

                return padding
            }

            module.exports.derToJose = (signature, alg) => {
                if (!Buffer.isBuffer(signature)) {
                    throw new TypeError('ECDSA signature must be a Buffer')
                }

                if (!paramBytesForAlg[alg]) {
                    throw new Error(`Unknown algorithm "${alg}"`)
                }

                const paramBytes = paramBytesForAlg[alg]

                // the DER encoded param should at most be the param size, plus a padding
                // zero, since due to being a signed integer
                const maxEncodedParamLength = paramBytes + 1

                const inputLength = signature.length

                let offset = 0
                if (signature[offset++] !== ENCODED_TAG_SEQ) {
                    throw new Error('Could not find expected "seq"')
                }

                let seqLength = signature[offset++]
                if (seqLength === (MAX_OCTET | 1)) {
                    seqLength = signature[offset++]
                }

                if (inputLength - offset < seqLength) {
                    throw new Error(
                        `"seq" specified length of ${seqLength}", only ${inputLength -
                            offset}" remaining`
                    )
                }

                if (signature[offset++] !== ENCODED_TAG_INT) {
                    throw new Error('Could not find expected "int" for "r"')
                }

                const rLength = signature[offset++]

                if (inputLength - offset - 2 < rLength) {
                    throw new Error(
                        `"r" specified length of "${rLength}", only "${inputLength -
                            offset -
                            2}" available`
                    )
                }

                if (maxEncodedParamLength < rLength) {
                    throw new Error(
                        `"r" specified length of "${rLength}", max of "${maxEncodedParamLength}" is acceptable`
                    )
                }

                const rOffset = offset
                offset += rLength

                if (signature[offset++] !== ENCODED_TAG_INT) {
                    throw new Error('Could not find expected "int" for "s"')
                }

                const sLength = signature[offset++]

                if (inputLength - offset !== sLength) {
                    throw new Error(
                        `"s" specified length of "${sLength}", expected "${inputLength -
                            offset}"`
                    )
                }

                if (maxEncodedParamLength < sLength) {
                    throw new Error(
                        `"s" specified length of "${sLength}", max of "${maxEncodedParamLength}" is acceptable`
                    )
                }

                const sOffset = offset
                offset += sLength

                if (offset !== inputLength) {
                    throw new Error(
                        `Expected to consume entire buffer, but "${inputLength -
                            offset}" bytes remain`
                    )
                }

                const rPadding = paramBytes - rLength

                const sPadding = paramBytes - sLength

                const dst = Buffer.allocUnsafe(
                    rPadding + rLength + sPadding + sLength
                )

                for (offset = 0; offset < rPadding; ++offset) {
                    dst[offset] = 0
                }
                signature.copy(
                    dst,
                    offset,
                    rOffset + Math.max(-rPadding, 0),
                    rOffset + rLength
                )

                offset = paramBytes

                for (const o = offset; offset < o + sPadding; ++offset) {
                    dst[offset] = 0
                }
                signature.copy(
                    dst,
                    offset,
                    sOffset + Math.max(-sPadding, 0),
                    sOffset + sLength
                )

                return dst
            }

            module.exports.joseToDer = (signature, alg) => {
                if (!Buffer.isBuffer(signature)) {
                    throw new TypeError('ECDSA signature must be a Buffer')
                }

                if (!paramBytesForAlg[alg]) {
                    throw new TypeError(`Unknown algorithm "${alg}"`)
                }

                const paramBytes = paramBytesForAlg[alg]

                const signatureBytes = signature.length
                if (signatureBytes !== paramBytes * 2) {
                    throw new Error(
                        `"${alg}" signatures must be "${paramBytes *
                            2}" bytes, saw "${signatureBytes}"`
                    )
                }

                const rPadding = countPadding(signature, 0, paramBytes)
                const sPadding = countPadding(
                    signature,
                    paramBytes,
                    signature.length
                )
                const rLength = paramBytes - rPadding
                const sLength = paramBytes - sPadding

                const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength

                const shortLength = rsBytes < MAX_OCTET

                const dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes)

                let offset = 0
                dst[offset++] = ENCODED_TAG_SEQ
                if (shortLength) {
                    // Bit 8 has value "0"
                    // bits 7-1 give the length.
                    dst[offset++] = rsBytes
                } else {
                    // Bit 8 of first octet has value "1"
                    // bits 7-1 give the number of additional length octets.
                    dst[offset++] = MAX_OCTET | 1 // eslint-disable-line no-tabs
                    // length, base 256
                    dst[offset++] = rsBytes & 0xff
                }
                dst[offset++] = ENCODED_TAG_INT
                dst[offset++] = rLength
                if (rPadding < 0) {
                    dst[offset++] = 0
                    offset += signature.copy(dst, offset, 0, paramBytes)
                } else {
                    offset += signature.copy(dst, offset, rPadding, paramBytes)
                }
                dst[offset++] = ENCODED_TAG_INT
                dst[offset++] = sLength
                if (sPadding < 0) {
                    dst[offset++] = 0
                    signature.copy(dst, offset, paramBytes)
                } else {
                    signature.copy(dst, offset, paramBytes + sPadding)
                }

                return dst
            }

            /***/
        },

        /***/ fGT3: /***/ function(module, exports, __webpack_require__) {
            var Hash = __webpack_require__('4kuk'),
                ListCache = __webpack_require__('Xi7e'),
                Map = __webpack_require__('ebwN')

            /**
             * Removes all key-value entries from the map.
             *
             * @private
             * @name clear
             * @memberOf MapCache
             */
            function mapCacheClear() {
                this.size = 0
                this.__data__ = {
                    hash: new Hash(),
                    map: new (Map || ListCache)(),
                    string: new Hash()
                }
            }

            module.exports = mapCacheClear

            /***/
        },

        /***/ fL7X: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * http-errors
             * Copyright(c) 2014 Jonathan Ong
             * Copyright(c) 2016 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module dependencies.
             * @private
             */

            var deprecate = __webpack_require__('9RKe')('http-errors')
            var setPrototypeOf = __webpack_require__('3SI8')
            var statuses = __webpack_require__('T1JI')
            var inherits = __webpack_require__('vQrS')
            var toIdentifier = __webpack_require__('sYMc')

            /**
             * Module exports.
             * @public
             */

            module.exports = createError
            module.exports.HttpError = createHttpErrorConstructor()

            // Populate exports for all constructors
            populateConstructorExports(
                module.exports,
                statuses.codes,
                module.exports.HttpError
            )

            /**
             * Get the code class of a status code.
             * @private
             */

            function codeClass(status) {
                return Number(String(status).charAt(0) + '00')
            }

            /**
             * Create a new HTTP Error.
             *
             * @returns {Error}
             * @public
             */

            function createError() {
                // so much arity going on ~_~
                var err
                var msg
                var status = 500
                var props = {}
                for (var i = 0; i < arguments.length; i++) {
                    var arg = arguments[i]
                    if (arg instanceof Error) {
                        err = arg
                        status = err.status || err.statusCode || status
                        continue
                    }
                    switch (typeof arg) {
                        case 'string':
                            msg = arg
                            break
                        case 'number':
                            status = arg
                            if (i !== 0) {
                                deprecate(
                                    'non-first-argument status code; replace with createError(' +
                                        arg +
                                        ', ...)'
                                )
                            }
                            break
                        case 'object':
                            props = arg
                            break
                    }
                }

                if (
                    typeof status === 'number' &&
                    (status < 400 || status >= 600)
                ) {
                    deprecate(
                        'non-error status code; use only 4xx or 5xx status codes'
                    )
                }

                if (
                    typeof status !== 'number' ||
                    (!statuses[status] && (status < 400 || status >= 600))
                ) {
                    status = 500
                }

                // constructor
                var HttpError =
                    createError[status] || createError[codeClass(status)]

                if (!err) {
                    // create error
                    err = HttpError
                        ? new HttpError(msg)
                        : new Error(msg || statuses[status])
                    Error.captureStackTrace(err, createError)
                }

                if (
                    !HttpError ||
                    !(err instanceof HttpError) ||
                    err.status !== status
                ) {
                    // add properties to generic error
                    err.expose = status < 500
                    err.status = err.statusCode = status
                }

                for (var key in props) {
                    if (key !== 'status' && key !== 'statusCode') {
                        err[key] = props[key]
                    }
                }

                return err
            }

            /**
             * Create HTTP error abstract base class.
             * @private
             */

            function createHttpErrorConstructor() {
                function HttpError() {
                    throw new TypeError('cannot construct abstract class')
                }

                inherits(HttpError, Error)

                return HttpError
            }

            /**
             * Create a constructor for a client error.
             * @private
             */

            function createClientErrorConstructor(HttpError, name, code) {
                var className = name.match(/Error$/) ? name : name + 'Error'

                function ClientError(message) {
                    // create the error object
                    var msg = message != null ? message : statuses[code]
                    var err = new Error(msg)

                    // capture a stack trace to the construction point
                    Error.captureStackTrace(err, ClientError)

                    // adjust the [[Prototype]]
                    setPrototypeOf(err, ClientError.prototype)

                    // redefine the error message
                    Object.defineProperty(err, 'message', {
                        enumerable: true,
                        configurable: true,
                        value: msg,
                        writable: true
                    })

                    // redefine the error name
                    Object.defineProperty(err, 'name', {
                        enumerable: false,
                        configurable: true,
                        value: className,
                        writable: true
                    })

                    return err
                }

                inherits(ClientError, HttpError)
                nameFunc(ClientError, className)

                ClientError.prototype.status = code
                ClientError.prototype.statusCode = code
                ClientError.prototype.expose = true

                return ClientError
            }

            /**
             * Create a constructor for a server error.
             * @private
             */

            function createServerErrorConstructor(HttpError, name, code) {
                var className = name.match(/Error$/) ? name : name + 'Error'

                function ServerError(message) {
                    // create the error object
                    var msg = message != null ? message : statuses[code]
                    var err = new Error(msg)

                    // capture a stack trace to the construction point
                    Error.captureStackTrace(err, ServerError)

                    // adjust the [[Prototype]]
                    setPrototypeOf(err, ServerError.prototype)

                    // redefine the error message
                    Object.defineProperty(err, 'message', {
                        enumerable: true,
                        configurable: true,
                        value: msg,
                        writable: true
                    })

                    // redefine the error name
                    Object.defineProperty(err, 'name', {
                        enumerable: false,
                        configurable: true,
                        value: className,
                        writable: true
                    })

                    return err
                }

                inherits(ServerError, HttpError)
                nameFunc(ServerError, className)

                ServerError.prototype.status = code
                ServerError.prototype.statusCode = code
                ServerError.prototype.expose = false

                return ServerError
            }

            /**
             * Set the name of a function, if possible.
             * @private
             */

            function nameFunc(func, name) {
                var desc = Object.getOwnPropertyDescriptor(func, 'name')

                if (desc && desc.configurable) {
                    desc.value = name
                    Object.defineProperty(func, 'name', desc)
                }
            }

            /**
             * Populate the exports object with constructors for every error class.
             * @private
             */

            function populateConstructorExports(exports, codes, HttpError) {
                codes.forEach(function forEachCode(code) {
                    var CodeError
                    var name = toIdentifier(statuses[code])

                    switch (codeClass(code)) {
                        case 400:
                            CodeError = createClientErrorConstructor(
                                HttpError,
                                name,
                                code
                            )
                            break
                        case 500:
                            CodeError = createServerErrorConstructor(
                                HttpError,
                                name,
                                code
                            )
                            break
                    }

                    if (CodeError) {
                        // export the constructor
                        exports[code] = CodeError
                        exports[name] = CodeError
                    }
                })

                // backwards-compatibility
                exports["I'mateapot"] = deprecate.function(
                    exports.ImATeapot,
                    '"I\'mateapot"; use "ImATeapot" instead'
                )
            }

            /***/
        },

        /***/ fPfv: /***/ function(module) {
            module.exports = JSON.parse(
                '{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}'
            )

            /***/
        },

        /***/ 'fR/l': /***/ function(module, exports, __webpack_require__) {
            var arrayPush = __webpack_require__('CH3K'),
                isArray = __webpack_require__('Z0cm')

            /**
             * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
             * `keysFunc` and `symbolsFunc` to get the enumerable property names and
             * symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Function} keysFunc The function to get the keys of `object`.
             * @param {Function} symbolsFunc The function to get the symbols of `object`.
             * @returns {Array} Returns the array of property names and symbols.
             */
            function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object)
                return isArray(object)
                    ? result
                    : arrayPush(result, symbolsFunc(object))
            }

            module.exports = baseGetAllKeys

            /***/
        },

        /***/ faWz: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const is = __webpack_require__('6mOv')

            module.exports = body =>
                is.nodeStream(body) && is.function(body.getBoundary)

            /***/
        },

        /***/ fbmr: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * raw-body
             * Copyright(c) 2013-2014 Jonathan Ong
             * Copyright(c) 2014-2015 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module dependencies.
             * @private
             */

            var bytes = __webpack_require__('8kg+')
            var createError = __webpack_require__('fL7X')
            var iconv = __webpack_require__('rPnE')
            var unpipe = __webpack_require__('SmFm')

            /**
             * Module exports.
             * @public
             */

            module.exports = getRawBody

            /**
             * Module variables.
             * @private
             */

            var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /

            /**
             * Get the decoder for a given encoding.
             *
             * @param {string} encoding
             * @private
             */

            function getDecoder(encoding) {
                if (!encoding) return null

                try {
                    return iconv.getDecoder(encoding)
                } catch (e) {
                    // error getting decoder
                    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e

                    // the encoding was not found
                    throw createError(415, 'specified encoding unsupported', {
                        encoding: encoding,
                        type: 'encoding.unsupported'
                    })
                }
            }

            /**
             * Get the raw body of a stream (typically HTTP).
             *
             * @param {object} stream
             * @param {object|string|function} [options]
             * @param {function} [callback]
             * @public
             */

            function getRawBody(stream, options, callback) {
                var done = callback
                var opts = options || {}

                if (options === true || typeof options === 'string') {
                    // short cut for encoding
                    opts = {
                        encoding: options
                    }
                }

                if (typeof options === 'function') {
                    done = options
                    opts = {}
                }

                // validate callback is a function, if provided
                if (done !== undefined && typeof done !== 'function') {
                    throw new TypeError('argument callback must be a function')
                }

                // require the callback without promises
                if (!done && !global.Promise) {
                    throw new TypeError('argument callback is required')
                }

                // get encoding
                var encoding = opts.encoding !== true ? opts.encoding : 'utf-8'

                // convert the limit to an integer
                var limit = bytes.parse(opts.limit)

                // convert the expected length to an integer
                var length =
                    opts.length != null && !isNaN(opts.length)
                        ? parseInt(opts.length, 10)
                        : null

                if (done) {
                    // classic callback style
                    return readStream(stream, encoding, length, limit, done)
                }

                return new Promise(function executor(resolve, reject) {
                    readStream(stream, encoding, length, limit, function onRead(
                        err,
                        buf
                    ) {
                        if (err) return reject(err)
                        resolve(buf)
                    })
                })
            }

            /**
             * Halt a stream.
             *
             * @param {Object} stream
             * @private
             */

            function halt(stream) {
                // unpipe everything from the stream
                unpipe(stream)

                // pause stream
                if (typeof stream.pause === 'function') {
                    stream.pause()
                }
            }

            /**
             * Read the data from the stream.
             *
             * @param {object} stream
             * @param {string} encoding
             * @param {number} length
             * @param {number} limit
             * @param {function} callback
             * @public
             */

            function readStream(stream, encoding, length, limit, callback) {
                var complete = false
                var sync = true

                // check the length and limit options.
                // note: we intentionally leave the stream paused,
                // so users should handle the stream themselves.
                if (limit !== null && length !== null && length > limit) {
                    return done(
                        createError(413, 'request entity too large', {
                            expected: length,
                            length: length,
                            limit: limit,
                            type: 'entity.too.large'
                        })
                    )
                }

                // streams1: assert request encoding is buffer.
                // streams2+: assert the stream encoding is buffer.
                //   stream._decoder: streams1
                //   state.encoding: streams2
                //   state.decoder: streams2, specifically < 0.10.6
                var state = stream._readableState
                if (
                    stream._decoder ||
                    (state && (state.encoding || state.decoder))
                ) {
                    // developer error
                    return done(
                        createError(500, 'stream encoding should not be set', {
                            type: 'stream.encoding.set'
                        })
                    )
                }

                var received = 0
                var decoder

                try {
                    decoder = getDecoder(encoding)
                } catch (err) {
                    return done(err)
                }

                var buffer = decoder ? '' : []

                // attach listeners
                stream.on('aborted', onAborted)
                stream.on('close', cleanup)
                stream.on('data', onData)
                stream.on('end', onEnd)
                stream.on('error', onEnd)

                // mark sync section complete
                sync = false

                function done() {
                    var args = new Array(arguments.length)

                    // copy arguments
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i]
                    }

                    // mark complete
                    complete = true

                    if (sync) {
                        process.nextTick(invokeCallback)
                    } else {
                        invokeCallback()
                    }

                    function invokeCallback() {
                        cleanup()

                        if (args[0]) {
                            // halt the stream on error
                            halt(stream)
                        }

                        callback.apply(null, args)
                    }
                }

                function onAborted() {
                    if (complete) return

                    done(
                        createError(400, 'request aborted', {
                            code: 'ECONNABORTED',
                            expected: length,
                            length: length,
                            received: received,
                            type: 'request.aborted'
                        })
                    )
                }

                function onData(chunk) {
                    if (complete) return

                    received += chunk.length

                    if (limit !== null && received > limit) {
                        done(
                            createError(413, 'request entity too large', {
                                limit: limit,
                                received: received,
                                type: 'entity.too.large'
                            })
                        )
                    } else if (decoder) {
                        buffer += decoder.write(chunk)
                    } else {
                        buffer.push(chunk)
                    }
                }

                function onEnd(err) {
                    if (complete) return
                    if (err) return done(err)

                    if (length !== null && received !== length) {
                        done(
                            createError(
                                400,
                                'request size did not match content length',
                                {
                                    expected: length,
                                    length: length,
                                    received: received,
                                    type: 'request.size.invalid'
                                }
                            )
                        )
                    } else {
                        var string = decoder
                            ? buffer + (decoder.end() || '')
                            : Buffer.concat(buffer)
                        done(null, string)
                    }
                }

                function cleanup() {
                    buffer = null

                    stream.removeListener('aborted', onAborted)
                    stream.removeListener('data', onData)
                    stream.removeListener('end', onEnd)
                    stream.removeListener('error', onEnd)
                    stream.removeListener('close', cleanup)
                }
            }

            /***/
        },

        /***/ fmRc: /***/ function(module, exports, __webpack_require__) {
            var ListCache = __webpack_require__('Xi7e'),
                stackClear = __webpack_require__('77Zs'),
                stackDelete = __webpack_require__('L8xA'),
                stackGet = __webpack_require__('gCq4'),
                stackHas = __webpack_require__('VaNO'),
                stackSet = __webpack_require__('0Cz8')

            /**
             * Creates a stack cache object to store key-value pairs.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function Stack(entries) {
                var data = (this.__data__ = new ListCache(entries))
                this.size = data.size
            }

            // Add methods to `Stack`.
            Stack.prototype.clear = stackClear
            Stack.prototype['delete'] = stackDelete
            Stack.prototype.get = stackGet
            Stack.prototype.has = stackHas
            Stack.prototype.set = stackSet

            module.exports = Stack

            /***/
        },

        /***/ ftKO: /***/ function(module, exports) {
            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__'

            /**
             * Adds `value` to the array cache.
             *
             * @private
             * @name add
             * @memberOf SetCache
             * @alias push
             * @param {*} value The value to cache.
             * @returns {Object} Returns the cache instance.
             */
            function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED)
                return this
            }

            module.exports = setCacheAdd

            /***/
        },

        /***/ gAB1: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(timeout) {
                return new Promise(resolve => setTimeout(resolve, timeout))
            }

            /***/
        },

        /***/ gCq4: /***/ function(module, exports) {
            /**
             * Gets the stack value for `key`.
             *
             * @private
             * @name get
             * @memberOf Stack
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function stackGet(key) {
                return this.__data__.get(key)
            }

            module.exports = stackGet

            /***/
        },

        /***/ gFfm: /***/ function(module, exports) {
            /**
             * A specialized version of `_.forEach` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns `array`.
             */
            function arrayEach(array, iteratee) {
                var index = -1,
                    length = array == null ? 0 : array.length

                while (++index < length) {
                    if (iteratee(array[index], index, array) === false) {
                        break
                    }
                }
                return array
            }

            module.exports = arrayEach

            /***/
        },

        /***/ gK4g: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const pump = __webpack_require__('b1mx')
            const bufferStream = __webpack_require__('iGjV')

            class MaxBufferError extends Error {
                constructor() {
                    super('maxBuffer exceeded')
                    this.name = 'MaxBufferError'
                }
            }

            async function getStream(inputStream, options) {
                if (!inputStream) {
                    return Promise.reject(new Error('Expected a stream'))
                }

                options = {
                    maxBuffer: Infinity,
                    ...options
                }

                const { maxBuffer } = options

                let stream
                await new Promise((resolve, reject) => {
                    const rejectPromise = error => {
                        if (error) {
                            // A null check
                            error.bufferedData = stream.getBufferedValue()
                        }

                        reject(error)
                    }

                    stream = pump(inputStream, bufferStream(options), error => {
                        if (error) {
                            rejectPromise(error)
                            return
                        }

                        resolve()
                    })

                    stream.on('data', () => {
                        if (stream.getBufferedLength() > maxBuffer) {
                            rejectPromise(new MaxBufferError())
                        }
                    })
                })

                return stream.getBufferedValue()
            }

            module.exports = getStream
            // TODO: Remove this for the next major release
            module.exports.default = getStream
            module.exports.buffer = (stream, options) =>
                getStream(stream, { ...options, encoding: 'buffer' })
            module.exports.array = (stream, options) =>
                getStream(stream, { ...options, array: true })
            module.exports.MaxBufferError = MaxBufferError

            /***/
        },

        /***/ gKi1: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const cookie_1 = __webpack_require__('iVi/')
            /**
             * Parses the cookies from an API Route or from Pages and returns a key/value object containing all the cookies.
             * @param req Incoming HTTP request.
             */
            function parseCookies(req) {
                const { cookies } = req
                // For API Routes we don't need to parse the cookies.
                if (cookies) {
                    return cookies
                }
                // For pages we still need to parse the cookies.
                const cookie = req && req.headers && req.headers.cookie
                return cookie_1.parse(cookie || '')
            }
            exports.parseCookies = parseCookies
            /**
             * Based on the environment and the request we know if a secure cookie can be set.
             */
            function isSecureEnvironment(req) {
                if (!req || !req.headers || !req.headers.host) {
                    throw new Error(
                        'The "host" request header is not available'
                    )
                }
                if (false) {
                }
                const host =
                    (req.headers.host.indexOf(':') > -1 &&
                        req.headers.host.split(':')[0]) ||
                    req.headers.host
                if (['localhost', '127.0.0.1'].indexOf(host) > -1) {
                    return false
                }
                return true
            }
            /**
             * Serialize a cookie to a string.
             * @param cookie The cookie to serialize
             * @param secure Create a secure cookie.
             */
            function serializeCookie(cookie, secure) {
                return cookie_1.serialize(cookie.name, cookie.value, {
                    maxAge: cookie.maxAge,
                    expires: new Date(Date.now() + cookie.maxAge * 1000),
                    httpOnly: true,
                    secure,
                    path: cookie.path
                })
            }
            /**
             * Set one or more cookies.
             * @param res The HTTP response on which the cookie will be set.
             */
            function setCookies(req, res, cookies) {
                res.setHeader(
                    'Set-Cookie',
                    cookies.map(c =>
                        serializeCookie(c, isSecureEnvironment(req))
                    )
                )
            }
            exports.setCookies = setCookies
            /**
             * Set one or more cookies.
             * @param res The HTTP response on which the cookie will be set.
             */
            function setCookie(req, res, cookie) {
                res.setHeader(
                    'Set-Cookie',
                    serializeCookie(cookie, isSecureEnvironment(req))
                )
            }
            exports.setCookie = setCookie
            //# sourceMappingURL=cookies.js.map

            /***/
        },

        /***/ gLwZ: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
            module.exports = {
                '437': 'cp437',
                '737': 'cp737',
                '775': 'cp775',
                '850': 'cp850',
                '852': 'cp852',
                '855': 'cp855',
                '856': 'cp856',
                '857': 'cp857',
                '858': 'cp858',
                '860': 'cp860',
                '861': 'cp861',
                '862': 'cp862',
                '863': 'cp863',
                '864': 'cp864',
                '865': 'cp865',
                '866': 'cp866',
                '869': 'cp869',
                '874': 'windows874',
                '922': 'cp922',
                '1046': 'cp1046',
                '1124': 'cp1124',
                '1125': 'cp1125',
                '1129': 'cp1129',
                '1133': 'cp1133',
                '1161': 'cp1161',
                '1162': 'cp1162',
                '1163': 'cp1163',
                '1250': 'windows1250',
                '1251': 'windows1251',
                '1252': 'windows1252',
                '1253': 'windows1253',
                '1254': 'windows1254',
                '1255': 'windows1255',
                '1256': 'windows1256',
                '1257': 'windows1257',
                '1258': 'windows1258',
                '28591': 'iso88591',
                '28592': 'iso88592',
                '28593': 'iso88593',
                '28594': 'iso88594',
                '28595': 'iso88595',
                '28596': 'iso88596',
                '28597': 'iso88597',
                '28598': 'iso88598',
                '28599': 'iso88599',
                '28600': 'iso885910',
                '28601': 'iso885911',
                '28603': 'iso885913',
                '28604': 'iso885914',
                '28605': 'iso885915',
                '28606': 'iso885916',
                windows874: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                win874: 'windows874',
                cp874: 'windows874',
                windows1250: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                win1250: 'windows1250',
                cp1250: 'windows1250',
                windows1251: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                win1251: 'windows1251',
                cp1251: 'windows1251',
                windows1252: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                win1252: 'windows1252',
                cp1252: 'windows1252',
                windows1253: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                win1253: 'windows1253',
                cp1253: 'windows1253',
                windows1254: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                win1254: 'windows1254',
                cp1254: 'windows1254',
                windows1255: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                win1255: 'windows1255',
                cp1255: 'windows1255',
                windows1256: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                win1256: 'windows1256',
                cp1256: 'windows1256',
                windows1257: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                win1257: 'windows1257',
                cp1257: 'windows1257',
                windows1258: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                win1258: 'windows1258',
                cp1258: 'windows1258',
                iso88591: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28591: 'iso88591',
                iso88592: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28592: 'iso88592',
                iso88593: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28593: 'iso88593',
                iso88594: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28594: 'iso88594',
                iso88595: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28595: 'iso88595',
                iso88596: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28596: 'iso88596',
                iso88597: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28597: 'iso88597',
                iso88598: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28598: 'iso88598',
                iso88599: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28599: 'iso88599',
                iso885910: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28600: 'iso885910',
                iso885911: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28601: 'iso885911',
                iso885913: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28603: 'iso885913',
                iso885914: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28604: 'iso885914',
                iso885915: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28605: 'iso885915',
                iso885916: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                cp28606: 'iso885916',
                cp437: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm437: 'cp437',
                csibm437: 'cp437',
                cp737: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm737: 'cp737',
                csibm737: 'cp737',
                cp775: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm775: 'cp775',
                csibm775: 'cp775',
                cp850: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm850: 'cp850',
                csibm850: 'cp850',
                cp852: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm852: 'cp852',
                csibm852: 'cp852',
                cp855: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm855: 'cp855',
                csibm855: 'cp855',
                cp856: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm856: 'cp856',
                csibm856: 'cp856',
                cp857: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm857: 'cp857',
                csibm857: 'cp857',
                cp858: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm858: 'cp858',
                csibm858: 'cp858',
                cp860: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm860: 'cp860',
                csibm860: 'cp860',
                cp861: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm861: 'cp861',
                csibm861: 'cp861',
                cp862: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm862: 'cp862',
                csibm862: 'cp862',
                cp863: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm863: 'cp863',
                csibm863: 'cp863',
                cp864: {
                    type: '_sbcs',
                    chars:
                        '\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !"#$&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'
                },
                ibm864: 'cp864',
                csibm864: 'cp864',
                cp865: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm865: 'cp865',
                csibm865: 'cp865',
                cp866: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm866: 'cp866',
                csibm866: 'cp866',
                cp869: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm869: 'cp869',
                csibm869: 'cp869',
                cp922: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm922: 'cp922',
                csibm922: 'cp922',
                cp1046: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm1046: 'cp1046',
                csibm1046: 'cp1046',
                cp1124: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm1124: 'cp1124',
                csibm1124: 'cp1124',
                cp1125: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm1125: 'cp1125',
                csibm1125: 'cp1125',
                cp1129: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm1129: 'cp1129',
                csibm1129: 'cp1129',
                cp1133: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm1133: 'cp1133',
                csibm1133: 'cp1133',
                cp1161: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm1161: 'cp1161',
                csibm1161: 'cp1161',
                cp1162: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm1162: 'cp1162',
                csibm1162: 'cp1162',
                cp1163: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ibm1163: 'cp1163',
                csibm1163: 'cp1163',
                maccroatian: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                maccyrillic: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                macgreek: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                maciceland: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                macroman: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                macromania: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                macthai: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                macturkish: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                macukraine: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                koi8r: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                koi8u: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                koi8ru: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                koi8t: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                armscii8: {
                    type: '_sbcs',
                    chars:
                        ')(.,-'
                },
                rk1048: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                tcvn: {
                    type: '_sbcs',
                    chars:
                        '\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'
                },
                georgianacademy: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                georgianps: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                pt154: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                viscii: {
                    type: '_sbcs',
                    chars:
                        '\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'
                },
                iso646cn: {
                    type: '_sbcs',
                    chars:
                        '\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !"#%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}'
                },
                iso646jp: {
                    type: '_sbcs',
                    chars:
                        '\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}'
                },
                hproman8: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                macintosh: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                ascii: {
                    type: '_sbcs',
                    chars:
                        ''
                },
                tis620: {
                    type: '_sbcs',
                    chars:
                        ''
                }
            }

            /***/
        },

        /***/ gXwc: /***/ function(module, exports, __webpack_require__) {
            /* global BigInt */
            const { EOL } = __webpack_require__('jle/')

            const { name: secp256k1 } = __webpack_require__('F/JS')
            const errors = __webpack_require__('yt7c')

            const { createPublicKey } = __webpack_require__('1ALl')
            const base64url = __webpack_require__('Xab3')
            const asn1 = __webpack_require__('u88T')
            const computePrimes = __webpack_require__('eHfw')
            const { OKP_CURVES, EC_CURVES } = __webpack_require__('N+nT')

            const oidHexToCurve = new Map([
                ['06082a8648ce3d030107', 'P-256'],
                ['06052b8104000a', secp256k1],
                ['06052b81040022', 'P-384'],
                ['06052b81040023', 'P-521']
            ])
            const EC_KEY_OID = '1.2.840.10045.2.1'.split('.')
            const crvToOid = new Map([
                ['P-256', '1.2.840.10045.3.1.7'.split('.')],
                [secp256k1, '1.3.132.0.10'.split('.')],
                ['P-384', '1.3.132.0.34'.split('.')],
                ['P-521', '1.3.132.0.35'.split('.')]
            ])
            const crvToOidBuf = new Map([
                ['P-256', Buffer.from('06082a8648ce3d030107', 'hex')],
                [secp256k1, Buffer.from('06052b8104000a', 'hex')],
                ['P-384', Buffer.from('06052b81040022', 'hex')],
                ['P-521', Buffer.from('06052b81040023', 'hex')]
            ])

            const formatPem = (base64pem, descriptor) =>
                `-----BEGIN ${descriptor} KEY-----${EOL}${base64pem
                    .match(/.{1,64}/g)
                    .join(EOL)}${EOL}-----END ${descriptor} KEY-----`

            const okpToJWK = {
                private(crv, keyObject) {
                    const der = keyObject.export({
                        type: 'pkcs8',
                        format: 'der'
                    })
                    const OneAsymmetricKey = asn1.get('OneAsymmetricKey')
                    const {
                        privateKey: { privateKey: d }
                    } = OneAsymmetricKey.decode(der)

                    return {
                        ...okpToJWK.public(crv, createPublicKey(keyObject)),
                        d: base64url.encodeBuffer(d)
                    }
                },
                public(crv, keyObject) {
                    const der = keyObject.export({
                        type: 'spki',
                        format: 'der'
                    })

                    const PublicKeyInfo = asn1.get('PublicKeyInfo')

                    const {
                        publicKey: { data: x }
                    } = PublicKeyInfo.decode(der)

                    return {
                        kty: 'OKP',
                        crv,
                        x: base64url.encodeBuffer(x)
                    }
                }
            }

            const keyObjectToJWK = {
                rsa: {
                    private(keyObject) {
                        const der = keyObject.export({
                            type: 'pkcs8',
                            format: 'der'
                        })

                        const PrivateKeyInfo = asn1.get('PrivateKeyInfo')
                        const RSAPrivateKey = asn1.get('RSAPrivateKey')

                        const { privateKey } = PrivateKeyInfo.decode(der)
                        const {
                            version,
                            n,
                            e,
                            d,
                            p,
                            q,
                            dp,
                            dq,
                            qi
                        } = RSAPrivateKey.decode(privateKey)

                        if (version !== 'two-prime') {
                            throw new errors.JOSENotSupported(
                                'Private RSA keys with more than two primes are not supported'
                            )
                        }

                        return {
                            kty: 'RSA',
                            n: base64url.encodeBigInt(n),
                            e: base64url.encodeBigInt(e),
                            d: base64url.encodeBigInt(d),
                            p: base64url.encodeBigInt(p),
                            q: base64url.encodeBigInt(q),
                            dp: base64url.encodeBigInt(dp),
                            dq: base64url.encodeBigInt(dq),
                            qi: base64url.encodeBigInt(qi)
                        }
                    },
                    public(keyObject) {
                        const der = keyObject.export({
                            type: 'spki',
                            format: 'der'
                        })

                        const PublicKeyInfo = asn1.get('PublicKeyInfo')
                        const RSAPublicKey = asn1.get('RSAPublicKey')

                        const {
                            publicKey: { data: publicKey }
                        } = PublicKeyInfo.decode(der)
                        const { n, e } = RSAPublicKey.decode(publicKey)

                        return {
                            kty: 'RSA',
                            n: base64url.encodeBigInt(n),
                            e: base64url.encodeBigInt(e)
                        }
                    }
                },
                ec: {
                    private(keyObject) {
                        const der = keyObject.export({
                            type: 'pkcs8',
                            format: 'der'
                        })

                        const PrivateKeyInfo = asn1.get('PrivateKeyInfo')
                        const ECPrivateKey = asn1.get('ECPrivateKey')

                        const {
                            privateKey,
                            algorithm: { parameters: curveOid }
                        } = PrivateKeyInfo.decode(der)
                        const crv = oidHexToCurve.get(curveOid.toString('hex'))
                        const {
                            privateKey: d,
                            publicKey: { data: publicKey }
                        } = ECPrivateKey.decode(privateKey)

                        const x = publicKey.slice(
                            1,
                            (publicKey.length - 1) / 2 + 1
                        )
                        const y = publicKey.slice(
                            (publicKey.length - 1) / 2 + 1
                        )

                        return {
                            kty: 'EC',
                            crv,
                            d: base64url.encodeBuffer(d),
                            x: base64url.encodeBuffer(x),
                            y: base64url.encodeBuffer(y)
                        }
                    },
                    public(keyObject) {
                        const der = keyObject.export({
                            type: 'spki',
                            format: 'der'
                        })

                        const PublicKeyInfo = asn1.get('PublicKeyInfo')

                        const {
                            publicKey: { data: publicKey },
                            algorithm: { parameters: curveOid }
                        } = PublicKeyInfo.decode(der)
                        const crv = oidHexToCurve.get(curveOid.toString('hex'))

                        const x = publicKey.slice(
                            1,
                            (publicKey.length - 1) / 2 + 1
                        )
                        const y = publicKey.slice(
                            (publicKey.length - 1) / 2 + 1
                        )

                        return {
                            kty: 'EC',
                            crv,
                            x: base64url.encodeBuffer(x),
                            y: base64url.encodeBuffer(y)
                        }
                    }
                },
                ed25519: {
                    private(keyObject) {
                        return okpToJWK.private('Ed25519', keyObject)
                    },
                    public(keyObject) {
                        return okpToJWK.public('Ed25519', keyObject)
                    }
                },
                ed448: {
                    private(keyObject) {
                        return okpToJWK.private('Ed448', keyObject)
                    },
                    public(keyObject) {
                        return okpToJWK.public('Ed448', keyObject)
                    }
                },
                x25519: {
                    private(keyObject) {
                        return okpToJWK.private('X25519', keyObject)
                    },
                    public(keyObject) {
                        return okpToJWK.public('X25519', keyObject)
                    }
                },
                x448: {
                    private(keyObject) {
                        return okpToJWK.private('X448', keyObject)
                    },
                    public(keyObject) {
                        return okpToJWK.public('X448', keyObject)
                    }
                }
            }

            module.exports.keyObjectToJWK = keyObject => {
                if (keyObject.type === 'private') {
                    return keyObjectToJWK[keyObject.asymmetricKeyType].private(
                        keyObject
                    )
                }

                return keyObjectToJWK[keyObject.asymmetricKeyType].public(
                    keyObject
                )
            }

            const concatEcPublicKey = (x, y) => ({
                unused: 0,
                data: Buffer.concat([
                    Buffer.alloc(1, 4),
                    base64url.decodeToBuffer(x),
                    base64url.decodeToBuffer(y)
                ])
            })

            const okpCrvToOid = crv => {
                switch (crv) {
                    case 'X25519':
                        return '1.3.101.110'.split('.')
                    case 'X448':
                        return '1.3.101.111'.split('.')
                    case 'Ed25519':
                        return '1.3.101.112'.split('.')
                    case 'Ed448':
                        return '1.3.101.113'.split('.')
                }
            }

            const jwkToPem = {
                RSA: {
                    private(jwk, { calculateMissingRSAPrimes }) {
                        const RSAPrivateKey = asn1.get('RSAPrivateKey')

                        if ('oth' in jwk) {
                            throw new errors.JOSENotSupported(
                                'Private RSA keys with more than two primes are not supported'
                            )
                        }

                        if (jwk.p || jwk.q || jwk.dp || jwk.dq || jwk.qi) {
                            if (
                                !(jwk.p && jwk.q && jwk.dp && jwk.dq && jwk.qi)
                            ) {
                                throw new errors.JWKInvalid(
                                    'all other private key parameters must be present when any one of them is present'
                                )
                            }
                        } else if (calculateMissingRSAPrimes) {
                            jwk = computePrimes(jwk)
                        } else if (!calculateMissingRSAPrimes) {
                            throw new errors.JOSENotSupported(
                                'importing private RSA keys without all other private key parameters is not enabled, see documentation and its advisory on how and when its ok to enable it'
                            )
                        }

                        return RSAPrivateKey.encode(
                            {
                                version: 0,
                                n: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.n)
                                        .toString('hex')}`
                                ),
                                e: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.e)
                                        .toString('hex')}`
                                ),
                                d: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.d)
                                        .toString('hex')}`
                                ),
                                p: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.p)
                                        .toString('hex')}`
                                ),
                                q: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.q)
                                        .toString('hex')}`
                                ),
                                dp: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.dp)
                                        .toString('hex')}`
                                ),
                                dq: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.dq)
                                        .toString('hex')}`
                                ),
                                qi: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.qi)
                                        .toString('hex')}`
                                )
                            },
                            'pem',
                            { label: 'RSA PRIVATE KEY' }
                        )
                    },
                    public(jwk) {
                        const RSAPublicKey = asn1.get('RSAPublicKey')

                        return RSAPublicKey.encode(
                            {
                                version: 0,
                                n: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.n)
                                        .toString('hex')}`
                                ),
                                e: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.e)
                                        .toString('hex')}`
                                )
                            },
                            'pem',
                            { label: 'RSA PUBLIC KEY' }
                        )
                    }
                },
                EC: {
                    private(jwk) {
                        const ECPrivateKey = asn1.get('ECPrivateKey')

                        return ECPrivateKey.encode(
                            {
                                version: 1,
                                privateKey: base64url.decodeToBuffer(jwk.d),
                                parameters: {
                                    type: 'namedCurve',
                                    value: crvToOid.get(jwk.crv)
                                },
                                publicKey: concatEcPublicKey(jwk.x, jwk.y)
                            },
                            'pem',
                            { label: 'EC PRIVATE KEY' }
                        )
                    },
                    public(jwk) {
                        const PublicKeyInfo = asn1.get('PublicKeyInfo')

                        return PublicKeyInfo.encode(
                            {
                                algorithm: {
                                    algorithm: EC_KEY_OID,
                                    parameters: crvToOidBuf.get(jwk.crv)
                                },
                                publicKey: concatEcPublicKey(jwk.x, jwk.y)
                            },
                            'pem',
                            { label: 'PUBLIC KEY' }
                        )
                    }
                },
                OKP: {
                    private(jwk) {
                        const OneAsymmetricKey = asn1.get('OneAsymmetricKey')

                        const b64 = OneAsymmetricKey.encode(
                            {
                                version: 0,
                                privateKey: {
                                    privateKey: base64url.decodeToBuffer(jwk.d)
                                },
                                algorithm: { algorithm: okpCrvToOid(jwk.crv) }
                            },
                            'der'
                        )

                        // TODO: WHYYY? https://github.com/indutny/asn1.js/issues/110
                        b64.write('04', 12, 1, 'hex')

                        return formatPem(b64.toString('base64'), 'PRIVATE')
                    },
                    public(jwk) {
                        const PublicKeyInfo = asn1.get('PublicKeyInfo')

                        return PublicKeyInfo.encode(
                            {
                                algorithm: { algorithm: okpCrvToOid(jwk.crv) },
                                publicKey: {
                                    unused: 0,
                                    data: base64url.decodeToBuffer(jwk.x)
                                }
                            },
                            'pem',
                            { label: 'PUBLIC KEY' }
                        )
                    }
                }
            }

            module.exports.jwkToPem = (
                jwk,
                { calculateMissingRSAPrimes = false } = {}
            ) => {
                switch (jwk.kty) {
                    case 'EC':
                        if (!EC_CURVES.has(jwk.crv)) {
                            throw new errors.JOSENotSupported(
                                `unsupported EC key curve: ${jwk.crv}`
                            )
                        }
                        break
                    case 'OKP':
                        if (!OKP_CURVES.has(jwk.crv)) {
                            throw new errors.JOSENotSupported(
                                `unsupported OKP key curve: ${jwk.crv}`
                            )
                        }
                        break
                    case 'RSA':
                        break
                    default:
                        throw new errors.JOSENotSupported(
                            `unsupported key type: ${jwk.kty}`
                        )
                }

                if (jwk.d) {
                    return jwkToPem[jwk.kty].private(jwk, {
                        calculateMissingRSAPrimes
                    })
                }

                return jwkToPem[jwk.kty].public(jwk)
            }

            /***/
        },

        /***/ gdNv: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            exports = module.exports = {
                array: Array.prototype,
                buffer: Buffer && Buffer.prototype, // $lab:coverage:ignore$
                date: Date.prototype,
                error: Error.prototype,
                generic: Object.prototype,
                map: Map.prototype,
                promise: Promise.prototype,
                regex: RegExp.prototype,
                set: Set.prototype,
                weakMap: WeakMap.prototype,
                weakSet: WeakSet.prototype
            }

            internals.typeMap = new Map([
                ['[object Error]', exports.error],
                ['[object Map]', exports.map],
                ['[object Promise]', exports.promise],
                ['[object Set]', exports.set],
                ['[object WeakMap]', exports.weakMap],
                ['[object WeakSet]', exports.weakSet]
            ])

            exports.getInternalProto = function(obj) {
                if (Array.isArray(obj)) {
                    return exports.array
                }

                if (Buffer && obj instanceof Buffer) {
                    // $lab:coverage:ignore$
                    return exports.buffer
                }

                if (obj instanceof Date) {
                    return exports.date
                }

                if (obj instanceof RegExp) {
                    return exports.regex
                }

                if (obj instanceof Error) {
                    return exports.error
                }

                const objName = Object.prototype.toString.call(obj)
                return internals.typeMap.get(objName) || exports.generic
            }

            /***/
        },

        /***/ gt9x: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            class Session {
                constructor(user, createdAt) {
                    this.user = user
                    if (createdAt) {
                        this.createdAt = createdAt
                    } else {
                        this.createdAt = Date.now()
                    }
                }
            }
            exports.default = Session
            //# sourceMappingURL=session.js.map

            /***/
        },

        /***/ 'h+i2': /***/ function(module, exports, __webpack_require__) {
            module.exports = {
                der: __webpack_require__('1Gj5')
            }

            /***/
        },

        /***/ hHSr: /***/ function(module) {
            module.exports = JSON.parse(
                '[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93]]'
            )

            /***/
        },

        /***/ heNW: /***/ function(module, exports) {
            /**
             * A faster alternative to `Function#apply`, this function invokes `func`
             * with the `this` binding of `thisArg` and the arguments of `args`.
             *
             * @private
             * @param {Function} func The function to invoke.
             * @param {*} thisArg The `this` binding of `func`.
             * @param {Array} args The arguments to invoke `func` with.
             * @returns {*} Returns the result of `func`.
             */
            function apply(func, thisArg, args) {
                switch (args.length) {
                    case 0:
                        return func.call(thisArg)
                    case 1:
                        return func.call(thisArg, args[0])
                    case 2:
                        return func.call(thisArg, args[0], args[1])
                    case 3:
                        return func.call(thisArg, args[0], args[1], args[2])
                }
                return func.apply(thisArg, args)
            }

            module.exports = apply

            /***/
        },

        /***/ hfKm: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('RU/L')

            /***/
        },

        /***/ hgQt: /***/ function(module, exports, __webpack_require__) {
            var baseHasIn = __webpack_require__('Juji'),
                hasPath = __webpack_require__('4sDh')

            /**
             * Checks if `path` is a direct or inherited property of `object`.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Object
             * @param {Object} object The object to query.
             * @param {Array|string} path The path to check.
             * @returns {boolean} Returns `true` if `path` exists, else `false`.
             * @example
             *
             * var object = _.create({ 'a': _.create({ 'b': 2 }) });
             *
             * _.hasIn(object, 'a');
             * // => true
             *
             * _.hasIn(object, 'a.b');
             * // => true
             *
             * _.hasIn(object, ['a', 'b']);
             * // => true
             *
             * _.hasIn(object, 'b');
             * // => false
             */
            function hasIn(object, path) {
                return object != null && hasPath(object, path, baseHasIn)
            }

            module.exports = hasIn

            /***/
        },

        /***/ hk9D: /***/ function(module, exports, __webpack_require__) {
            const {
                publicEncrypt,
                privateDecrypt,
                constants
            } = __webpack_require__('PJMN')

            const { oaepHashSupported } = __webpack_require__('pDDt')
            const { KEYOBJECT } = __webpack_require__('ehsS')
            const { asInput } = __webpack_require__('1ALl')

            const resolvePadding = alg => {
                switch (alg) {
                    case 'RSA-OAEP':
                    case 'RSA-OAEP-256':
                    case 'RSA-OAEP-384':
                    case 'RSA-OAEP-512':
                        return constants.RSA_PKCS1_OAEP_PADDING
                    case 'RSA1_5':
                        return constants.RSA_PKCS1_PADDING
                }
            }

            const resolveOaepHash = alg => {
                switch (alg) {
                    case 'RSA-OAEP':
                        return 'sha1'
                    case 'RSA-OAEP-256':
                        return 'sha256'
                    case 'RSA-OAEP-384':
                        return 'sha384'
                    case 'RSA-OAEP-512':
                        return 'sha512'
                    default:
                        return undefined
                }
            }

            const wrapKey = (
                padding,
                oaepHash,
                { [KEYOBJECT]: keyObject },
                payload
            ) => {
                const key = asInput(keyObject, true)
                return {
                    wrapped: publicEncrypt({ key, oaepHash, padding }, payload)
                }
            }

            const unwrapKey = (
                padding,
                oaepHash,
                { [KEYOBJECT]: keyObject },
                payload
            ) => {
                const key = asInput(keyObject, false)
                return privateDecrypt({ key, oaepHash, padding }, payload)
            }

            const LENGTHS = {
                RSA1_5: 0,
                'RSA-OAEP': 592,
                'RSA-OAEP-256': 784,
                'RSA-OAEP-384': 1040,
                'RSA-OAEP-512': 1296
            }

            module.exports = (JWA, JWK) => {
                const algs = ['RSA-OAEP', 'RSA1_5']

                if (oaepHashSupported) {
                    algs.splice(
                        1,
                        0,
                        'RSA-OAEP-256',
                        'RSA-OAEP-384',
                        'RSA-OAEP-512'
                    )
                }

                algs.forEach(jwaAlg => {
                    const padding = resolvePadding(jwaAlg)
                    const oaepHash = resolveOaepHash(jwaAlg)
                    JWA.keyManagementEncrypt.set(
                        jwaAlg,
                        wrapKey.bind(undefined, padding, oaepHash)
                    )
                    JWA.keyManagementDecrypt.set(
                        jwaAlg,
                        unwrapKey.bind(undefined, padding, oaepHash)
                    )
                    JWK.RSA.wrapKey[jwaAlg] = key =>
                        (key.use === 'enc' || key.use === undefined) &&
                        key.length >= LENGTHS[jwaAlg]
                    JWK.RSA.unwrapKey[jwaAlg] = key =>
                        key.private &&
                        (key.use === 'enc' || key.use === undefined) &&
                        key.length >= LENGTHS[jwaAlg]
                })
            }

            /***/
        },

        /***/ hnhG: /***/ function(module, exports, __webpack_require__) {
            const { createSign, createVerify, constants } = __webpack_require__(
                'PJMN'
            )

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const resolveNodeAlg = __webpack_require__('uGJc')
            const { asInput } = __webpack_require__('1ALl')

            const sign = (nodeAlg, { [KEYOBJECT]: keyObject }, payload) => {
                const key = asInput(keyObject, false)
                return createSign(nodeAlg)
                    .update(payload)
                    .sign({
                        key,
                        padding: constants.RSA_PKCS1_PSS_PADDING,
                        saltLength: constants.RSA_PSS_SALTLEN_DIGEST
                    })
            }

            const verify = (
                nodeAlg,
                { [KEYOBJECT]: keyObject },
                payload,
                signature
            ) => {
                const key = asInput(keyObject, true)
                return createVerify(nodeAlg)
                    .update(payload)
                    .verify(
                        {
                            key,
                            padding: constants.RSA_PKCS1_PSS_PADDING,
                            saltLength: constants.RSA_PSS_SALTLEN_DIGEST
                        },
                        signature
                    )
            }

            const LENGTHS = {
                PS256: 528,
                PS384: 784,
                PS512: 1040
            }

            module.exports = (JWA, JWK) => {
                ;['PS256', 'PS384', 'PS512'].forEach(jwaAlg => {
                    const nodeAlg = resolveNodeAlg(jwaAlg)
                    JWA.sign.set(jwaAlg, sign.bind(undefined, nodeAlg))
                    JWA.verify.set(jwaAlg, verify.bind(undefined, nodeAlg))
                    JWK.RSA.sign[jwaAlg] = key =>
                        key.private && JWK.RSA.verify[jwaAlg](key)
                    JWK.RSA.verify[jwaAlg] = key =>
                        (key.use === 'sig' || key.use === undefined) &&
                        key.length >= LENGTHS[jwaAlg]
                })
            }

            /***/
        },

        /***/ hpEj: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(promise) {
                return !!promise && typeof promise.then === 'function'
            }

            /***/
        },

        /***/ htIY: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const AggregateError = __webpack_require__('xh2E')
            const PCancelable = __webpack_require__('ijcl')

            const pSome = (iterable, options) =>
                new PCancelable((resolve, reject, onCancel) => {
                    options = {
                        filter: () => true,
                        ...options
                    }

                    if (!Number.isFinite(options.count)) {
                        throw new TypeError(
                            `Expected a finite number, got ${typeof options.count}`
                        )
                    }

                    const values = []
                    const errors = []
                    let elementCount = 0
                    let maxErrors = -options.count + 1
                    let maxFiltered = -options.count + 1
                    let isDone = false

                    const completed = new Set()
                    const cancelPendingIfDone = () => {
                        if (!isDone) {
                            return
                        }

                        for (const promise of iterable) {
                            if (
                                !completed.has(promise) &&
                                typeof promise.cancel === 'function'
                            ) {
                                promise.cancel()
                            }
                        }
                    }

                    onCancel(() => {
                        isDone = true
                        cancelPendingIfDone()
                    })

                    const fulfilled = value => {
                        if (isDone) {
                            return
                        }

                        if (!options.filter(value)) {
                            if (--maxFiltered === 0) {
                                isDone = true
                                reject(
                                    new RangeError(
                                        'Not enough values pass the `filter` option'
                                    )
                                )
                            }

                            return
                        }

                        values.push(value)

                        if (--options.count === 0) {
                            isDone = true
                            resolve(values)
                        }
                    }

                    const rejected = error => {
                        if (isDone) {
                            return
                        }

                        errors.push(error)

                        if (--maxErrors === 0) {
                            isDone = true
                            reject(new AggregateError(errors))
                        }
                    }

                    for (const element of iterable) {
                        maxErrors++
                        maxFiltered++
                        elementCount++

                        ;(async () => {
                            try {
                                const value = await Promise.resolve(element)
                                fulfilled(value)
                            } catch (error) {
                                rejected(error)
                            }

                            completed.add(element)
                            cancelPendingIfDone()
                        })()
                    }

                    if (options.count > elementCount) {
                        throw new RangeError(
                            `Expected input to contain at least ${options.count} items, but contains ${elementCount} items`
                        )
                    }
                })

            module.exports = pSome
            // TODO: Remove this for the next major release
            module.exports.default = pSome

            module.exports.AggregateError = AggregateError

            /***/
        },

        /***/ htfN: /***/ function(module) {
            module.exports = JSON.parse(
                '[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]'
            )

            /***/
        },

        /***/ hypo: /***/ function(module, exports, __webpack_require__) {
            var defineProperty = __webpack_require__('O0oS')

            /**
             * The base implementation of `assignValue` and `assignMergeValue` without
             * value checks.
             *
             * @private
             * @param {Object} object The object to modify.
             * @param {string} key The key of the property to assign.
             * @param {*} value The value to assign.
             */
            function baseAssignValue(object, key, value) {
                if (key == '__proto__' && defineProperty) {
                    defineProperty(object, key, {
                        configurable: true,
                        enumerable: true,
                        value: value,
                        writable: true
                    })
                } else {
                    object[key] = value
                }
            }

            module.exports = baseAssignValue

            /***/
        },

        /***/ i8G8: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(method) {
                if (method._hoekOnce) {
                    return method
                }

                let once = false
                const wrapped = function(...args) {
                    if (!once) {
                        once = true
                        method(...args)
                    }
                }

                wrapped._hoekOnce = true
                return wrapped
            }

            /***/
        },

        /***/ iAgo: /***/ function(module, exports, __webpack_require__) {
            const { createHash, randomBytes } = __webpack_require__('PJMN')

            const { encode: base64url } = __webpack_require__('+00W')

            const random = (bytes = 32) => base64url(randomBytes(bytes))

            module.exports = {
                random,
                state: random,
                nonce: random,
                codeVerifier: random,
                codeChallenge: codeVerifier =>
                    base64url(
                        createHash('sha256')
                            .update(codeVerifier)
                            .digest()
                    )
            }

            /***/
        },

        /***/ iGjV: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { PassThrough: PassThroughStream } = __webpack_require__(
                'msIP'
            )

            module.exports = options => {
                options = { ...options }

                const { array } = options
                let { encoding } = options
                const isBuffer = encoding === 'buffer'
                let objectMode = false

                if (array) {
                    objectMode = !(encoding || isBuffer)
                } else {
                    encoding = encoding || 'utf8'
                }

                if (isBuffer) {
                    encoding = null
                }

                const stream = new PassThroughStream({ objectMode })

                if (encoding) {
                    stream.setEncoding(encoding)
                }

                let length = 0
                const chunks = []

                stream.on('data', chunk => {
                    chunks.push(chunk)

                    if (objectMode) {
                        length = chunks.length
                    } else {
                        length += chunk.length
                    }
                })

                stream.getBufferedValue = () => {
                    if (array) {
                        return chunks
                    }

                    return isBuffer
                        ? Buffer.concat(chunks, length)
                        : chunks.join('')
                }

                stream.getBufferedLength = () => length

                return stream
            }

            /***/
        },

        /***/ 'iVi/': /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * cookie
             * Copyright(c) 2012-2014 Roman Shtylman
             * Copyright(c) 2015 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module exports.
             * @public
             */

            exports.parse = parse
            exports.serialize = serialize

            /**
             * Module variables.
             * @private
             */

            var decode = decodeURIComponent
            var encode = encodeURIComponent
            var pairSplitRegExp = /; */

            /**
             * RegExp to match field-content in RFC 7230 sec 3.2
             *
             * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
             * field-vchar   = VCHAR / obs-text
             * obs-text      = %x80-FF
             */

            var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/

            /**
             * Parse a cookie header.
             *
             * Parse the given cookie header string into an object
             * The object has the various cookies as keys(names) => values
             *
             * @param {string} str
             * @param {object} [options]
             * @return {object}
             * @public
             */

            function parse(str, options) {
                if (typeof str !== 'string') {
                    throw new TypeError('argument str must be a string')
                }

                var obj = {}
                var opt = options || {}
                var pairs = str.split(pairSplitRegExp)
                var dec = opt.decode || decode

                for (var i = 0; i < pairs.length; i++) {
                    var pair = pairs[i]
                    var eq_idx = pair.indexOf('=')

                    // skip things that don't look like key=value
                    if (eq_idx < 0) {
                        continue
                    }

                    var key = pair.substr(0, eq_idx).trim()
                    var val = pair.substr(++eq_idx, pair.length).trim()

                    // quoted values
                    if ('"' == val[0]) {
                        val = val.slice(1, -1)
                    }

                    // only assign once
                    if (undefined == obj[key]) {
                        obj[key] = tryDecode(val, dec)
                    }
                }

                return obj
            }

            /**
             * Serialize data into a cookie header.
             *
             * Serialize the a name value pair into a cookie string suitable for
             * http headers. An optional options object specified cookie parameters.
             *
             * serialize('foo', 'bar', { httpOnly: true })
             *   => "foo=bar; httpOnly"
             *
             * @param {string} name
             * @param {string} val
             * @param {object} [options]
             * @return {string}
             * @public
             */

            function serialize(name, val, options) {
                var opt = options || {}
                var enc = opt.encode || encode

                if (typeof enc !== 'function') {
                    throw new TypeError('option encode is invalid')
                }

                if (!fieldContentRegExp.test(name)) {
                    throw new TypeError('argument name is invalid')
                }

                var value = enc(val)

                if (value && !fieldContentRegExp.test(value)) {
                    throw new TypeError('argument val is invalid')
                }

                var str = name + '=' + value

                if (null != opt.maxAge) {
                    var maxAge = opt.maxAge - 0
                    if (isNaN(maxAge))
                        throw new Error('maxAge should be a Number')
                    str += '; Max-Age=' + Math.floor(maxAge)
                }

                if (opt.domain) {
                    if (!fieldContentRegExp.test(opt.domain)) {
                        throw new TypeError('option domain is invalid')
                    }

                    str += '; Domain=' + opt.domain
                }

                if (opt.path) {
                    if (!fieldContentRegExp.test(opt.path)) {
                        throw new TypeError('option path is invalid')
                    }

                    str += '; Path=' + opt.path
                }

                if (opt.expires) {
                    if (typeof opt.expires.toUTCString !== 'function') {
                        throw new TypeError('option expires is invalid')
                    }

                    str += '; Expires=' + opt.expires.toUTCString()
                }

                if (opt.httpOnly) {
                    str += '; HttpOnly'
                }

                if (opt.secure) {
                    str += '; Secure'
                }

                if (opt.sameSite) {
                    var sameSite =
                        typeof opt.sameSite === 'string'
                            ? opt.sameSite.toLowerCase()
                            : opt.sameSite

                    switch (sameSite) {
                        case true:
                            str += '; SameSite=Strict'
                            break
                        case 'lax':
                            str += '; SameSite=Lax'
                            break
                        case 'strict':
                            str += '; SameSite=Strict'
                            break
                        case 'none':
                            str += '; SameSite=None'
                            break
                        default:
                            throw new TypeError('option sameSite is invalid')
                    }
                }

                return str
            }

            /**
             * Try decoding a string using a decoding function.
             *
             * @param {string} str
             * @param {function} decode
             * @private
             */

            function tryDecode(str, decode) {
                try {
                    return decode(str)
                } catch (e) {
                    return str
                }
            }

            /***/
        },

        /***/ idmN: /***/ function(module, exports, __webpack_require__) {
            var baseGet = __webpack_require__('ZWtO'),
                baseSet = __webpack_require__('FZoo'),
                castPath = __webpack_require__('4uTw')

            /**
             * The base implementation of  `_.pickBy` without support for iteratee shorthands.
             *
             * @private
             * @param {Object} object The source object.
             * @param {string[]} paths The property paths to pick.
             * @param {Function} predicate The function invoked per property.
             * @returns {Object} Returns the new object.
             */
            function basePickBy(object, paths, predicate) {
                var index = -1,
                    length = paths.length,
                    result = {}

                while (++index < length) {
                    var path = paths[index],
                        value = baseGet(object, path)

                    if (predicate(value, path)) {
                        baseSet(result, castPath(path, object), value)
                    }
                }
                return result
            }

            module.exports = basePickBy

            /***/
        },

        /***/ ieHi: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Crypto = __webpack_require__('PJMN')

            const Boom = __webpack_require__('U3sn')

            const internals = {}

            // Generate a cryptographically strong pseudo-random data

            exports.randomString = function(size) {
                const buffer = exports.randomBits((size + 1) * 6)
                const string = buffer
                    .toString('base64')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/\=/g, '')
                return string.slice(0, size)
            }

            // Return a random string of digits

            exports.randomDigits = function(size) {
                const digits = []

                let buffer = internals.random(size * 2) // Provision twice the amount of bytes needed to increase chance of single pass
                let pos = 0

                while (digits.length < size) {
                    if (pos >= buffer.length) {
                        buffer = internals.random(size * 2)
                        pos = 0
                    }

                    if (buffer[pos] < 250) {
                        digits.push(buffer[pos] % 10)
                    }

                    ++pos
                }

                return digits.join('')
            }

            // Generate a buffer of random bits

            exports.randomBits = function(bits) {
                if (!bits || bits < 0) {
                    throw Boom.internal('Invalid random bits count')
                }

                const bytes = Math.ceil(bits / 8)
                return internals.random(bytes)
            }

            exports.fixedTimeComparison = function(a, b) {
                try {
                    return Crypto.timingSafeEqual(
                        Buffer.from(a),
                        Buffer.from(b)
                    )
                } catch (err) {
                    return false
                }
            }

            internals.random = function(bytes) {
                try {
                    return Crypto.randomBytes(bytes)
                } catch (err) {
                    throw Boom.internal(
                        'Failed generating random bits: ' + err.message
                    )
                }
            }

            /***/
        },

        /***/ ijcl: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            class CancelError extends Error {
                constructor(reason) {
                    super(reason || 'Promise was canceled')
                    this.name = 'CancelError'
                }

                get isCanceled() {
                    return true
                }
            }

            class PCancelable {
                static fn(userFn) {
                    return (...arguments_) => {
                        return new PCancelable((resolve, reject, onCancel) => {
                            arguments_.push(onCancel)
                            // eslint-disable-next-line promise/prefer-await-to-then
                            userFn(...arguments_).then(resolve, reject)
                        })
                    }
                }

                constructor(executor) {
                    this._cancelHandlers = []
                    this._isPending = true
                    this._isCanceled = false
                    this._rejectOnCancel = true

                    this._promise = new Promise((resolve, reject) => {
                        this._reject = reject

                        const onResolve = value => {
                            this._isPending = false
                            resolve(value)
                        }

                        const onReject = error => {
                            this._isPending = false
                            reject(error)
                        }

                        const onCancel = handler => {
                            if (!this._isPending) {
                                throw new Error(
                                    'The `onCancel` handler was attached after the promise settled.'
                                )
                            }

                            this._cancelHandlers.push(handler)
                        }

                        Object.defineProperties(onCancel, {
                            shouldReject: {
                                get: () => this._rejectOnCancel,
                                set: boolean => {
                                    this._rejectOnCancel = boolean
                                }
                            }
                        })

                        return executor(onResolve, onReject, onCancel)
                    })
                }

                then(onFulfilled, onRejected) {
                    // eslint-disable-next-line promise/prefer-await-to-then
                    return this._promise.then(onFulfilled, onRejected)
                }

                catch(onRejected) {
                    return this._promise.catch(onRejected)
                }

                finally(onFinally) {
                    return this._promise.finally(onFinally)
                }

                cancel(reason) {
                    if (!this._isPending || this._isCanceled) {
                        return
                    }

                    if (this._cancelHandlers.length > 0) {
                        try {
                            for (const handler of this._cancelHandlers) {
                                handler()
                            }
                        } catch (error) {
                            this._reject(error)
                        }
                    }

                    this._isCanceled = true
                    if (this._rejectOnCancel) {
                        this._reject(new CancelError(reason))
                    }
                }

                get isCanceled() {
                    return this._isCanceled
                }
            }

            Object.setPrototypeOf(PCancelable.prototype, Promise.prototype)

            module.exports = PCancelable
            module.exports.CancelError = CancelError

            /***/
        },

        /***/ itsj: /***/ function(module, exports) {
            /**
             * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
             *
             * @private
             * @param {Object} object The object to query.
             * @param {string} key The key of the property to get.
             * @returns {*} Returns the property value.
             */
            function safeGet(object, key) {
                if (
                    key === 'constructor' &&
                    typeof object[key] === 'function'
                ) {
                    return
                }

                if (key == '__proto__') {
                    return
                }

                return object[key]
            }

            module.exports = safeGet

            /***/
        },

        /***/ j0Yl: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const deferToConnect = __webpack_require__('xZ+y')

            module.exports = request => {
                const timings = {
                    start: Date.now(),
                    socket: null,
                    lookup: null,
                    connect: null,
                    upload: null,
                    response: null,
                    end: null,
                    error: null,
                    phases: {
                        wait: null,
                        dns: null,
                        tcp: null,
                        request: null,
                        firstByte: null,
                        download: null,
                        total: null
                    }
                }

                const handleError = origin => {
                    const emit = origin.emit.bind(origin)
                    origin.emit = (event, ...args) => {
                        // Catches the `error` event
                        if (event === 'error') {
                            timings.error = Date.now()
                            timings.phases.total = timings.error - timings.start

                            origin.emit = emit
                        }

                        // Saves the original behavior
                        return emit(event, ...args)
                    }
                }

                let uploadFinished = false
                const onUpload = () => {
                    timings.upload = Date.now()
                    timings.phases.request = timings.upload - timings.connect
                }

                handleError(request)

                request.once('socket', socket => {
                    timings.socket = Date.now()
                    timings.phases.wait = timings.socket - timings.start

                    const lookupListener = () => {
                        timings.lookup = Date.now()
                        timings.phases.dns = timings.lookup - timings.socket
                    }

                    socket.once('lookup', lookupListener)

                    deferToConnect(socket, () => {
                        timings.connect = Date.now()

                        if (timings.lookup === null) {
                            socket.removeListener('lookup', lookupListener)
                            timings.lookup = timings.connect
                            timings.phases.dns = timings.lookup - timings.socket
                        }

                        timings.phases.tcp = timings.connect - timings.lookup

                        if (uploadFinished && !timings.upload) {
                            onUpload()
                        }
                    })
                })

                request.once('finish', () => {
                    uploadFinished = true

                    if (timings.connect) {
                        onUpload()
                    }
                })

                request.once('response', response => {
                    timings.response = Date.now()
                    timings.phases.firstByte = timings.response - timings.upload

                    handleError(response)

                    response.once('end', () => {
                        timings.end = Date.now()
                        timings.phases.download = timings.end - timings.response
                        timings.phases.total = timings.end - timings.start
                    })
                })

                return timings
            }

            /***/
        },

        /***/ jK02: /***/ function(module, exports) {
            module.exports = require('util')

            /***/
        },

        /***/ jUDV: /***/ function(module, exports, __webpack_require__) {
            const { inherits } = __webpack_require__('jK02')
            const encoders = __webpack_require__('E8LI')
            const decoders = __webpack_require__('zspo')

            module.exports.define = function define(name, body) {
                return new Entity(name, body)
            }

            function Entity(name, body) {
                this.name = name
                this.body = body

                this.decoders = {}
                this.encoders = {}
            }

            Entity.prototype._createNamed = function createNamed(Base) {
                const name = this.name

                function Generated(entity) {
                    this._initNamed(entity, name)
                }
                inherits(Generated, Base)
                Generated.prototype._initNamed = function _initNamed(
                    entity,
                    name
                ) {
                    Base.call(this, entity, name)
                }

                return new Generated(this)
            }

            Entity.prototype._getDecoder = function _getDecoder(enc) {
                enc = enc || 'der'
                // Lazily create decoder
                if (!Object.prototype.hasOwnProperty.call(this.decoders, enc)) {
                    this.decoders[enc] = this._createNamed(decoders[enc])
                }
                return this.decoders[enc]
            }

            Entity.prototype.decode = function decode(data, enc, options) {
                return this._getDecoder(enc).decode(data, options)
            }

            Entity.prototype._getEncoder = function _getEncoder(enc) {
                enc = enc || 'der'
                // Lazily create encoder
                if (!Object.prototype.hasOwnProperty.call(this.encoders, enc)) {
                    this.encoders[enc] = this._createNamed(encoders[enc])
                }
                return this.encoders[enc]
            }

            Entity.prototype.encode = function encode(
                data,
                enc,
                /* internal */ reporter
            ) {
                return this._getEncoder(enc).encode(data, reporter)
            }

            /***/
        },

        /***/ jeLo: /***/ function(module, exports, __webpack_require__) {
            var copyObject = __webpack_require__('juv8'),
                keysIn = __webpack_require__('mTTR')

            /**
             * Converts `value` to a plain object flattening inherited enumerable string
             * keyed properties of `value` to own properties of the plain object.
             *
             * @static
             * @memberOf _
             * @since 3.0.0
             * @category Lang
             * @param {*} value The value to convert.
             * @returns {Object} Returns the converted plain object.
             * @example
             *
             * function Foo() {
             *   this.b = 2;
             * }
             *
             * Foo.prototype.c = 3;
             *
             * _.assign({ 'a': 1 }, new Foo);
             * // => { 'a': 1, 'b': 2 }
             *
             * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
             * // => { 'a': 1, 'b': 2, 'c': 3 }
             */
            function toPlainObject(value) {
                return copyObject(value, keysIn(value))
            }

            module.exports = toPlainObject

            /***/
        },

        /***/ 'jle/': /***/ function(module, exports) {
            module.exports = require('os')

            /***/
        },

        /***/ jmDH: /***/ function(module, exports, __webpack_require__) {
            // Thank's IE8 for his funny defineProperty
            module.exports = !__webpack_require__('KUxP')(function() {
                return (
                    Object.defineProperty({}, 'a', {
                        get: function() {
                            return 7
                        }
                    }).a != 7
                )
            })

            /***/
        },

        /***/ juv8: /***/ function(module, exports, __webpack_require__) {
            var assignValue = __webpack_require__('MrPd'),
                baseAssignValue = __webpack_require__('hypo')

            /**
             * Copies properties of `source` to `object`.
             *
             * @private
             * @param {Object} source The object to copy properties from.
             * @param {Array} props The property identifiers to copy.
             * @param {Object} [object={}] The object to copy properties to.
             * @param {Function} [customizer] The function to customize copied values.
             * @returns {Object} Returns `object`.
             */
            function copyObject(source, props, object, customizer) {
                var isNew = !object
                object || (object = {})

                var index = -1,
                    length = props.length

                while (++index < length) {
                    var key = props[index]

                    var newValue = customizer
                        ? customizer(
                              object[key],
                              source[key],
                              key,
                              object,
                              source
                          )
                        : undefined

                    if (newValue === undefined) {
                        newValue = source[key]
                    }
                    if (isNew) {
                        baseAssignValue(object, key, newValue)
                    } else {
                        assignValue(object, key, newValue)
                    }
                }
                return object
            }

            module.exports = copyObject

            /***/
        },

        /***/ 'k+0e': /***/ function(module, exports, __webpack_require__) {
            const { strict: assert } = __webpack_require__('Qs3B')

            const { Reporter } = __webpack_require__('1WHo')
            const { DecoderBuffer, EncoderBuffer } = __webpack_require__('Z9M3')

            // Supported tags
            const tags = [
                'seq',
                'seqof',
                'set',
                'setof',
                'objid',
                'bool',
                'gentime',
                'utctime',
                'null_',
                'enum',
                'int',
                'objDesc',
                'bitstr',
                'bmpstr',
                'charstr',
                'genstr',
                'graphstr',
                'ia5str',
                'iso646str',
                'numstr',
                'octstr',
                'printstr',
                't61str',
                'unistr',
                'utf8str',
                'videostr'
            ]

            // Public methods list
            const methods = [
                'key',
                'obj',
                'use',
                'optional',
                'explicit',
                'implicit',
                'def',
                'choice',
                'any',
                'contains'
            ].concat(tags)

            // Overrided methods list
            const overrided = [
                '_peekTag',
                '_decodeTag',
                '_use',
                '_decodeStr',
                '_decodeObjid',
                '_decodeTime',
                '_decodeNull',
                '_decodeInt',
                '_decodeBool',
                '_decodeList',

                '_encodeComposite',
                '_encodeStr',
                '_encodeObjid',
                '_encodeTime',
                '_encodeNull',
                '_encodeInt',
                '_encodeBool'
            ]

            function Node(enc, parent, name) {
                const state = {}
                this._baseState = state

                state.name = name
                state.enc = enc

                state.parent = parent || null
                state.children = null

                // State
                state.tag = null
                state.args = null
                state.reverseArgs = null
                state.choice = null
                state.optional = false
                state.any = false
                state.obj = false
                state.use = null
                state.useDecoder = null
                state.key = null
                state.default = null
                state.explicit = null
                state.implicit = null
                state.contains = null

                // Should create new instance on each method
                if (!state.parent) {
                    state.children = []
                    this._wrap()
                }
            }

            const stateProps = [
                'enc',
                'parent',
                'children',
                'tag',
                'args',
                'reverseArgs',
                'choice',
                'optional',
                'any',
                'obj',
                'use',
                'alteredUse',
                'key',
                'default',
                'explicit',
                'implicit',
                'contains'
            ]

            Node.prototype.clone = function clone() {
                const state = this._baseState
                const cstate = {}
                stateProps.forEach(function(prop) {
                    cstate[prop] = state[prop]
                })
                const res = new this.constructor(cstate.parent)
                res._baseState = cstate
                return res
            }

            Node.prototype._wrap = function wrap() {
                const state = this._baseState
                methods.forEach(function(method) {
                    this[method] = function _wrappedMethod() {
                        const clone = new this.constructor(this)
                        state.children.push(clone)
                        return clone[method].apply(clone, arguments)
                    }
                }, this)
            }

            Node.prototype._init = function init(body) {
                const state = this._baseState

                assert(state.parent === null)
                body.call(this)

                // Filter children
                state.children = state.children.filter(function(child) {
                    return child._baseState.parent === this
                }, this)
                assert.equal(
                    state.children.length,
                    1,
                    'Root node can have only one child'
                )
            }

            Node.prototype._useArgs = function useArgs(args) {
                const state = this._baseState

                // Filter children and args
                const children = args.filter(function(arg) {
                    return arg instanceof this.constructor
                }, this)
                args = args.filter(function(arg) {
                    return !(arg instanceof this.constructor)
                }, this)

                if (children.length !== 0) {
                    assert(state.children === null)
                    state.children = children

                    // Replace parent to maintain backward link
                    children.forEach(function(child) {
                        child._baseState.parent = this
                    }, this)
                }
                if (args.length !== 0) {
                    assert(state.args === null)
                    state.args = args
                    state.reverseArgs = args.map(function(arg) {
                        if (
                            typeof arg !== 'object' ||
                            arg.constructor !== Object
                        ) {
                            return arg
                        }

                        const res = {}
                        Object.keys(arg).forEach(function(key) {
                            if (key == (key | 0)) {
                                key |= 0
                            } // eslint-disable-line eqeqeq
                            const value = arg[key]
                            res[value] = key
                        })
                        return res
                    })
                }
            }

            //
            // Overrided methods
            //

            overrided.forEach(function(method) {
                Node.prototype[method] = function _overrided() {
                    const state = this._baseState
                    throw new Error(
                        `${method} not implemented for encoding: ${state.enc}`
                    )
                }
            })

            //
            // Public methods
            //

            tags.forEach(function(tag) {
                Node.prototype[tag] = function _tagMethod() {
                    const state = this._baseState
                    const args = Array.prototype.slice.call(arguments)

                    assert(state.tag === null)
                    state.tag = tag

                    this._useArgs(args)

                    return this
                }
            })

            Node.prototype.use = function use(item) {
                assert(item)
                const state = this._baseState

                assert(state.use === null)
                state.use = item

                return this
            }

            Node.prototype.optional = function optional() {
                const state = this._baseState

                state.optional = true

                return this
            }

            Node.prototype.def = function def(val) {
                const state = this._baseState

                assert(state.default === null)
                state.default = val
                state.optional = true

                return this
            }

            Node.prototype.explicit = function explicit(num) {
                const state = this._baseState

                assert(state.explicit === null && state.implicit === null)
                state.explicit = num

                return this
            }

            Node.prototype.implicit = function implicit(num) {
                const state = this._baseState

                assert(state.explicit === null && state.implicit === null)
                state.implicit = num

                return this
            }

            Node.prototype.obj = function obj() {
                const state = this._baseState
                const args = Array.prototype.slice.call(arguments)

                state.obj = true

                if (args.length !== 0) {
                    this._useArgs(args)
                }

                return this
            }

            Node.prototype.key = function key(newKey) {
                const state = this._baseState

                assert(state.key === null)
                state.key = newKey

                return this
            }

            Node.prototype.any = function any() {
                const state = this._baseState

                state.any = true

                return this
            }

            Node.prototype.choice = function choice(obj) {
                const state = this._baseState

                assert(state.choice === null)
                state.choice = obj
                this._useArgs(
                    Object.keys(obj).map(function(key) {
                        return obj[key]
                    })
                )

                return this
            }

            Node.prototype.contains = function contains(item) {
                const state = this._baseState

                assert(state.use === null)
                state.contains = item

                return this
            }

            //
            // Decoding
            //

            Node.prototype._decode = function decode(input, options) {
                const state = this._baseState

                // Decode root node
                if (state.parent === null) {
                    return input.wrapResult(
                        state.children[0]._decode(input, options)
                    )
                }

                let result = state.default
                let present = true

                let prevKey = null
                if (state.key !== null) {
                    prevKey = input.enterKey(state.key)
                }

                // Check if tag is there
                if (state.optional) {
                    let tag = null
                    if (state.explicit !== null) {
                        tag = state.explicit
                    } else if (state.implicit !== null) {
                        tag = state.implicit
                    } else if (state.tag !== null) {
                        tag = state.tag
                    }

                    if (tag === null && !state.any) {
                        // Trial and Error
                        const save = input.save()
                        try {
                            if (state.choice === null) {
                                this._decodeGeneric(state.tag, input, options)
                            } else {
                                this._decodeChoice(input, options)
                            }
                            present = true
                        } catch (e) {
                            present = false
                        }
                        input.restore(save)
                    } else {
                        present = this._peekTag(input, tag, state.any)

                        if (input.isError(present)) {
                            return present
                        }
                    }
                }

                // Push object on stack
                let prevObj
                if (state.obj && present) {
                    prevObj = input.enterObject()
                }

                if (present) {
                    // Unwrap explicit values
                    if (state.explicit !== null) {
                        const explicit = this._decodeTag(input, state.explicit)
                        if (input.isError(explicit)) {
                            return explicit
                        }
                        input = explicit
                    }

                    const start = input.offset

                    // Unwrap implicit and normal values
                    if (state.use === null && state.choice === null) {
                        let save
                        if (state.any) {
                            save = input.save()
                        }
                        const body = this._decodeTag(
                            input,
                            state.implicit !== null
                                ? state.implicit
                                : state.tag,
                            state.any
                        )
                        if (input.isError(body)) {
                            return body
                        }

                        if (state.any) {
                            result = input.raw(save)
                        } else {
                            input = body
                        }
                    }

                    if (options && options.track && state.tag !== null) {
                        options.track(
                            input.path(),
                            start,
                            input.length,
                            'tagged'
                        )
                    }

                    if (options && options.track && state.tag !== null) {
                        options.track(
                            input.path(),
                            input.offset,
                            input.length,
                            'content'
                        )
                    }

                    // Select proper method for tag
                    if (state.any) {
                        // no-op
                    } else if (state.choice === null) {
                        result = this._decodeGeneric(state.tag, input, options)
                    } else {
                        result = this._decodeChoice(input, options)
                    }

                    if (input.isError(result)) {
                        return result
                    }

                    // Decode children
                    if (
                        !state.any &&
                        state.choice === null &&
                        state.children !== null
                    ) {
                        state.children.forEach(function decodeChildren(child) {
                            // NOTE: We are ignoring errors here, to let parser continue with other
                            // parts of encoded data
                            child._decode(input, options)
                        })
                    }

                    // Decode contained/encoded by schema, only in bit or octet strings
                    if (
                        state.contains &&
                        (state.tag === 'octstr' || state.tag === 'bitstr')
                    ) {
                        const data = new DecoderBuffer(result)
                        result = this._getUse(
                            state.contains,
                            input._reporterState.obj
                        )._decode(data, options)
                    }
                }

                // Pop object
                if (state.obj && present) {
                    result = input.leaveObject(prevObj)
                }

                // Set key
                if (
                    state.key !== null &&
                    (result !== null || present === true)
                ) {
                    input.leaveKey(prevKey, state.key, result)
                } else if (prevKey !== null) {
                    input.exitKey(prevKey)
                }

                return result
            }

            Node.prototype._decodeGeneric = function decodeGeneric(
                tag,
                input,
                options
            ) {
                const state = this._baseState

                if (tag === 'seq' || tag === 'set') {
                    return null
                }
                if (tag === 'seqof' || tag === 'setof') {
                    return this._decodeList(input, tag, state.args[0], options)
                } else if (/str$/.test(tag)) {
                    return this._decodeStr(input, tag, options)
                } else if (tag === 'objid' && state.args) {
                    return this._decodeObjid(
                        input,
                        state.args[0],
                        state.args[1],
                        options
                    )
                } else if (tag === 'objid') {
                    return this._decodeObjid(input, null, null, options)
                } else if (tag === 'gentime' || tag === 'utctime') {
                    return this._decodeTime(input, tag, options)
                } else if (tag === 'null_') {
                    return this._decodeNull(input, options)
                } else if (tag === 'bool') {
                    return this._decodeBool(input, options)
                } else if (tag === 'objDesc') {
                    return this._decodeStr(input, tag, options)
                } else if (tag === 'int' || tag === 'enum') {
                    return this._decodeInt(
                        input,
                        state.args && state.args[0],
                        options
                    )
                }

                if (state.use !== null) {
                    return this._getUse(
                        state.use,
                        input._reporterState.obj
                    )._decode(input, options)
                } else {
                    return input.error(`unknown tag: ${tag}`)
                }
            }

            Node.prototype._getUse = function _getUse(entity, obj) {
                const state = this._baseState
                // Create altered use decoder if implicit is set
                state.useDecoder = this._use(entity, obj)
                assert(state.useDecoder._baseState.parent === null)
                state.useDecoder = state.useDecoder._baseState.children[0]
                if (state.implicit !== state.useDecoder._baseState.implicit) {
                    state.useDecoder = state.useDecoder.clone()
                    state.useDecoder._baseState.implicit = state.implicit
                }
                return state.useDecoder
            }

            Node.prototype._decodeChoice = function decodeChoice(
                input,
                options
            ) {
                const state = this._baseState
                let result = null
                let match = false

                Object.keys(state.choice).some(function(key) {
                    const save = input.save()
                    const node = state.choice[key]
                    try {
                        const value = node._decode(input, options)
                        if (input.isError(value)) {
                            return false
                        }

                        result = { type: key, value: value }
                        match = true
                    } catch (e) {
                        input.restore(save)
                        return false
                    }
                    return true
                }, this)

                if (!match) {
                    return input.error('Choice not matched')
                }

                return result
            }

            //
            // Encoding
            //

            Node.prototype._createEncoderBuffer = function createEncoderBuffer(
                data
            ) {
                return new EncoderBuffer(data, this.reporter)
            }

            Node.prototype._encode = function encode(data, reporter, parent) {
                const state = this._baseState
                if (state.default !== null && state.default === data) {
                    return
                }

                const result = this._encodeValue(data, reporter, parent)
                if (result === undefined) {
                    return
                }

                if (this._skipDefault(result, reporter, parent)) {
                    return
                }

                return result
            }

            Node.prototype._encodeValue = function encode(
                data,
                reporter,
                parent
            ) {
                const state = this._baseState

                // Decode root node
                if (state.parent === null) {
                    return state.children[0]._encode(
                        data,
                        reporter || new Reporter()
                    )
                }

                let result = null

                // Set reporter to share it with a child class
                this.reporter = reporter

                // Check if data is there
                if (state.optional && data === undefined) {
                    if (state.default !== null) {
                        data = state.default
                    } else {
                        return
                    }
                }

                // Encode children first
                let content = null
                let primitive = false
                if (state.any) {
                    // Anything that was given is translated to buffer
                    result = this._createEncoderBuffer(data)
                } else if (state.choice) {
                    result = this._encodeChoice(data, reporter)
                } else if (state.contains) {
                    content = this._getUse(state.contains, parent)._encode(
                        data,
                        reporter
                    )
                    primitive = true
                } else if (state.children) {
                    content = state.children
                        .map(function(child) {
                            if (child._baseState.tag === 'null_') {
                                return child._encode(null, reporter, data)
                            }

                            if (child._baseState.key === null) {
                                return reporter.error('Child should have a key')
                            }
                            const prevKey = reporter.enterKey(
                                child._baseState.key
                            )

                            if (typeof data !== 'object') {
                                return reporter.error(
                                    'Child expected, but input is not object'
                                )
                            }

                            const res = child._encode(
                                data[child._baseState.key],
                                reporter,
                                data
                            )
                            reporter.leaveKey(prevKey)

                            return res
                        }, this)
                        .filter(function(child) {
                            return child
                        })
                    content = this._createEncoderBuffer(content)
                } else {
                    if (state.tag === 'seqof' || state.tag === 'setof') {
                        if (!(state.args && state.args.length === 1)) {
                            return reporter.error(
                                `Too many args for: ${state.tag}`
                            )
                        }

                        if (!Array.isArray(data)) {
                            return reporter.error(
                                'seqof/setof, but data is not Array'
                            )
                        }

                        const child = this.clone()
                        child._baseState.implicit = null
                        content = this._createEncoderBuffer(
                            data.map(function(item) {
                                const state = this._baseState

                                return this._getUse(
                                    state.args[0],
                                    data
                                )._encode(item, reporter)
                            }, child)
                        )
                    } else if (state.use !== null) {
                        result = this._getUse(state.use, parent)._encode(
                            data,
                            reporter
                        )
                    } else {
                        content = this._encodePrimitive(state.tag, data)
                        primitive = true
                    }
                }

                // Encode data itself
                if (!state.any && state.choice === null) {
                    const tag =
                        state.implicit !== null ? state.implicit : state.tag
                    const cls =
                        state.implicit === null ? 'universal' : 'context'

                    if (tag === null) {
                        if (state.use === null) {
                            reporter.error(
                                'Tag could be omitted only for .use()'
                            )
                        }
                    } else {
                        if (state.use === null) {
                            result = this._encodeComposite(
                                tag,
                                primitive,
                                cls,
                                content
                            )
                        }
                    }
                }

                // Wrap in explicit
                if (state.explicit !== null) {
                    result = this._encodeComposite(
                        state.explicit,
                        false,
                        'context',
                        result
                    )
                }

                return result
            }

            Node.prototype._encodeChoice = function encodeChoice(
                data,
                reporter
            ) {
                const state = this._baseState

                const node = state.choice[data.type]
                if (!node) {
                    assert(
                        false,
                        `${data.type} not found in ${JSON.stringify(
                            Object.keys(state.choice)
                        )}`
                    )
                }
                return node._encode(data.value, reporter)
            }

            Node.prototype._encodePrimitive = function encodePrimitive(
                tag,
                data
            ) {
                const state = this._baseState

                if (/str$/.test(tag)) {
                    return this._encodeStr(data, tag)
                } else if (tag === 'objid' && state.args) {
                    return this._encodeObjid(
                        data,
                        state.reverseArgs[0],
                        state.args[1]
                    )
                } else if (tag === 'objid') {
                    return this._encodeObjid(data, null, null)
                } else if (tag === 'gentime' || tag === 'utctime') {
                    return this._encodeTime(data, tag)
                } else if (tag === 'null_') {
                    return this._encodeNull()
                } else if (tag === 'int' || tag === 'enum') {
                    return this._encodeInt(
                        data,
                        state.args && state.reverseArgs[0]
                    )
                } else if (tag === 'bool') {
                    return this._encodeBool(data)
                } else if (tag === 'objDesc') {
                    return this._encodeStr(data, tag)
                } else {
                    throw new Error(`Unsupported tag: ${tag}`)
                }
            }

            Node.prototype._isNumstr = function isNumstr(str) {
                return /^[0-9 ]*$/.test(str)
            }

            Node.prototype._isPrintstr = function isPrintstr(str) {
                return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str)
            }

            module.exports = Node

            /***/
        },

        /***/ 'k+1r': /***/ function(module, exports, __webpack_require__) {
            var getMapData = __webpack_require__('QkVE')

            /**
             * Removes `key` and its value from the map.
             *
             * @private
             * @name delete
             * @memberOf MapCache
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function mapCacheDelete(key) {
                var result = getMapData(this, key)['delete'](key)
                this.size -= result ? 1 : 0
                return result
            }

            module.exports = mapCacheDelete

            /***/
        },

        /***/ k9s9: /***/ function(module, exports) {
            module.exports = function() {
                this.seq().obj(this.key('n').int(), this.key('e').int())
            }

            /***/
        },

        /***/ 'kF1/': /***/ function(module, exports) {
            module.exports = a => !!a && a.constructor === Object

            /***/
        },

        /***/ kMlu: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var Buffer = __webpack_require__('xZGU').Buffer

            // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
            // Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
            // To save memory and loading time, we read table files only when requested.

            exports._dbcs = DBCSCodec

            var UNASSIGNED = -1,
                GB18030_CODE = -2,
                SEQ_START = -10,
                NODE_START = -1000,
                UNASSIGNED_NODE = new Array(0x100),
                DEF_CHAR = -1

            for (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED

            // Class DBCSCodec reads and initializes mapping tables.
            function DBCSCodec(codecOptions, iconv) {
                this.encodingName = codecOptions.encodingName
                if (!codecOptions)
                    throw new Error('DBCS codec is called without the data.')
                if (!codecOptions.table)
                    throw new Error(
                        "Encoding '" + this.encodingName + "' has no data."
                    )

                // Load tables.
                var mappingTable = codecOptions.table()

                // Decode tables: MBCS -> Unicode.

                // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
                // Trie root is decodeTables[0].
                // Values: >=  0 -> unicode character code. can be > 0xFFFF
                //         == UNASSIGNED -> unknown/unassigned sequence.
                //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
                //         <= NODE_START -> index of the next node in our trie to process next byte.
                //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
                this.decodeTables = []
                this.decodeTables[0] = UNASSIGNED_NODE.slice(0) // Create root node.

                // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here.
                this.decodeTableSeq = []

                // Actual mapping tables consist of chunks. Use them to fill up decode tables.
                for (var i = 0; i < mappingTable.length; i++)
                    this._addDecodeChunk(mappingTable[i])

                this.defaultCharUnicode = iconv.defaultCharUnicode

                // Encode tables: Unicode -> DBCS.

                // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
                // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
                // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
                //         == UNASSIGNED -> no conversion found. Output a default char.
                //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
                this.encodeTable = []

                // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
                // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
                // means end of sequence (needed when one sequence is a strict subsequence of another).
                // Objects are kept separately from encodeTable to increase performance.
                this.encodeTableSeq = []

                // Some chars can be decoded, but need not be encoded.
                var skipEncodeChars = {}
                if (codecOptions.encodeSkipVals)
                    for (
                        var i = 0;
                        i < codecOptions.encodeSkipVals.length;
                        i++
                    ) {
                        var val = codecOptions.encodeSkipVals[i]
                        if (typeof val === 'number') skipEncodeChars[val] = true
                        else
                            for (var j = val.from; j <= val.to; j++)
                                skipEncodeChars[j] = true
                    }

                // Use decode trie to recursively fill out encode tables.
                this._fillEncodeTable(0, 0, skipEncodeChars)

                // Add more encoding pairs when needed.
                if (codecOptions.encodeAdd) {
                    for (var uChar in codecOptions.encodeAdd)
                        if (
                            Object.prototype.hasOwnProperty.call(
                                codecOptions.encodeAdd,
                                uChar
                            )
                        )
                            this._setEncodeChar(
                                uChar.charCodeAt(0),
                                codecOptions.encodeAdd[uChar]
                            )
                }

                this.defCharSB = this.encodeTable[0][
                    iconv.defaultCharSingleByte.charCodeAt(0)
                ]
                if (this.defCharSB === UNASSIGNED)
                    this.defCharSB = this.encodeTable[0]['?']
                if (this.defCharSB === UNASSIGNED)
                    this.defCharSB = '?'.charCodeAt(0)

                // Load & create GB18030 tables when needed.
                if (typeof codecOptions.gb18030 === 'function') {
                    this.gb18030 = codecOptions.gb18030() // Load GB18030 ranges.

                    // Add GB18030 decode tables.
                    var thirdByteNodeIdx = this.decodeTables.length
                    var thirdByteNode = (this.decodeTables[
                        thirdByteNodeIdx
                    ] = UNASSIGNED_NODE.slice(0))

                    var fourthByteNodeIdx = this.decodeTables.length
                    var fourthByteNode = (this.decodeTables[
                        fourthByteNodeIdx
                    ] = UNASSIGNED_NODE.slice(0))

                    for (var i = 0x81; i <= 0xfe; i++) {
                        var secondByteNodeIdx =
                            NODE_START - this.decodeTables[0][i]
                        var secondByteNode = this.decodeTables[
                            secondByteNodeIdx
                        ]
                        for (var j = 0x30; j <= 0x39; j++)
                            secondByteNode[j] = NODE_START - thirdByteNodeIdx
                    }
                    for (var i = 0x81; i <= 0xfe; i++)
                        thirdByteNode[i] = NODE_START - fourthByteNodeIdx
                    for (var i = 0x30; i <= 0x39; i++)
                        fourthByteNode[i] = GB18030_CODE
                }
            }

            DBCSCodec.prototype.encoder = DBCSEncoder
            DBCSCodec.prototype.decoder = DBCSDecoder

            // Decoder helpers
            DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
                var bytes = []
                for (; addr > 0; addr >>= 8) bytes.push(addr & 0xff)
                if (bytes.length == 0) bytes.push(0)

                var node = this.decodeTables[0]
                for (var i = bytes.length - 1; i > 0; i--) {
                    // Traverse nodes deeper into the trie.
                    var val = node[bytes[i]]

                    if (val == UNASSIGNED) {
                        // Create new node.
                        node[bytes[i]] = NODE_START - this.decodeTables.length
                        this.decodeTables.push(
                            (node = UNASSIGNED_NODE.slice(0))
                        )
                    } else if (val <= NODE_START) {
                        // Existing node.
                        node = this.decodeTables[NODE_START - val]
                    } else
                        throw new Error(
                            'Overwrite byte in ' +
                                this.encodingName +
                                ', addr: ' +
                                addr.toString(16)
                        )
                }
                return node
            }

            DBCSCodec.prototype._addDecodeChunk = function(chunk) {
                // First element of chunk is the hex mbcs code where we start.
                var curAddr = parseInt(chunk[0], 16)

                // Choose the decoding node where we'll write our chars.
                var writeTable = this._getDecodeTrieNode(curAddr)
                curAddr = curAddr & 0xff

                // Write all other elements of the chunk to the table.
                for (var k = 1; k < chunk.length; k++) {
                    var part = chunk[k]
                    if (typeof part === 'string') {
                        // String, write as-is.
                        for (var l = 0; l < part.length; ) {
                            var code = part.charCodeAt(l++)
                            if (0xd800 <= code && code < 0xdc00) {
                                // Decode surrogate
                                var codeTrail = part.charCodeAt(l++)
                                if (0xdc00 <= codeTrail && codeTrail < 0xe000)
                                    writeTable[curAddr++] =
                                        0x10000 +
                                        (code - 0xd800) * 0x400 +
                                        (codeTrail - 0xdc00)
                                else
                                    throw new Error(
                                        'Incorrect surrogate pair in ' +
                                            this.encodingName +
                                            ' at chunk ' +
                                            chunk[0]
                                    )
                            } else if (0x0ff0 < code && code <= 0x0fff) {
                                // Character sequence (our own encoding used)
                                var len = 0xfff - code + 2
                                var seq = []
                                for (var m = 0; m < len; m++)
                                    seq.push(part.charCodeAt(l++)) // Simple variation: don't support surrogates or subsequences in seq.

                                writeTable[curAddr++] =
                                    SEQ_START - this.decodeTableSeq.length
                                this.decodeTableSeq.push(seq)
                            } else writeTable[curAddr++] = code // Basic char
                        }
                    } else if (typeof part === 'number') {
                        // Integer, meaning increasing sequence starting with prev character.
                        var charCode = writeTable[curAddr - 1] + 1
                        for (var l = 0; l < part; l++)
                            writeTable[curAddr++] = charCode++
                    } else
                        throw new Error(
                            "Incorrect type '" +
                                typeof part +
                                "' given in " +
                                this.encodingName +
                                ' at chunk ' +
                                chunk[0]
                        )
                }
                if (curAddr > 0xff)
                    throw new Error(
                        'Incorrect chunk in ' +
                            this.encodingName +
                            ' at addr ' +
                            chunk[0] +
                            ': too long' +
                            curAddr
                    )
            }

            // Encoder helpers
            DBCSCodec.prototype._getEncodeBucket = function(uCode) {
                var high = uCode >> 8 // This could be > 0xFF because of astral characters.
                if (this.encodeTable[high] === undefined)
                    this.encodeTable[high] = UNASSIGNED_NODE.slice(0) // Create bucket on demand.
                return this.encodeTable[high]
            }

            DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
                var bucket = this._getEncodeBucket(uCode)
                var low = uCode & 0xff
                if (bucket[low] <= SEQ_START)
                    this.encodeTableSeq[SEQ_START - bucket[low]][
                        DEF_CHAR
                    ] = dbcsCode
                // There's already a sequence, set a single-char subsequence of it.
                else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode
            }

            DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
                // Get the root of character tree according to first character of the sequence.
                var uCode = seq[0]
                var bucket = this._getEncodeBucket(uCode)
                var low = uCode & 0xff

                var node
                if (bucket[low] <= SEQ_START) {
                    // There's already a sequence with  - use it.
                    node = this.encodeTableSeq[SEQ_START - bucket[low]]
                } else {
                    // There was no sequence object - allocate a new one.
                    node = {}
                    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low] // If a char was set before - make it a single-char subsequence.
                    bucket[low] = SEQ_START - this.encodeTableSeq.length
                    this.encodeTableSeq.push(node)
                }

                // Traverse the character tree, allocating new nodes as needed.
                for (var j = 1; j < seq.length - 1; j++) {
                    var oldVal = node[uCode]
                    if (typeof oldVal === 'object') node = oldVal
                    else {
                        node = node[uCode] = {}
                        if (oldVal !== undefined) node[DEF_CHAR] = oldVal
                    }
                }

                // Set the leaf to given dbcsCode.
                uCode = seq[seq.length - 1]
                node[uCode] = dbcsCode
            }

            DBCSCodec.prototype._fillEncodeTable = function(
                nodeIdx,
                prefix,
                skipEncodeChars
            ) {
                var node = this.decodeTables[nodeIdx]
                for (var i = 0; i < 0x100; i++) {
                    var uCode = node[i]
                    var mbCode = prefix + i
                    if (skipEncodeChars[mbCode]) continue

                    if (uCode >= 0) this._setEncodeChar(uCode, mbCode)
                    else if (uCode <= NODE_START)
                        this._fillEncodeTable(
                            NODE_START - uCode,
                            mbCode << 8,
                            skipEncodeChars
                        )
                    else if (uCode <= SEQ_START)
                        this._setEncodeSequence(
                            this.decodeTableSeq[SEQ_START - uCode],
                            mbCode
                        )
                }
            }

            // == Encoder ==================================================================

            function DBCSEncoder(options, codec) {
                // Encoder state
                this.leadSurrogate = -1
                this.seqObj = undefined

                // Static data
                this.encodeTable = codec.encodeTable
                this.encodeTableSeq = codec.encodeTableSeq
                this.defaultCharSingleByte = codec.defCharSB
                this.gb18030 = codec.gb18030
            }

            DBCSEncoder.prototype.write = function(str) {
                var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
                    leadSurrogate = this.leadSurrogate,
                    seqObj = this.seqObj,
                    nextChar = -1,
                    i = 0,
                    j = 0

                while (true) {
                    // 0. Get next character.
                    if (nextChar === -1) {
                        if (i == str.length) break
                        var uCode = str.charCodeAt(i++)
                    } else {
                        var uCode = nextChar
                        nextChar = -1
                    }

                    // 1. Handle surrogates.
                    if (0xd800 <= uCode && uCode < 0xe000) {
                        // Char is one of surrogates.
                        if (uCode < 0xdc00) {
                            // We've got lead surrogate.
                            if (leadSurrogate === -1) {
                                leadSurrogate = uCode
                                continue
                            } else {
                                leadSurrogate = uCode
                                // Double lead surrogate found.
                                uCode = UNASSIGNED
                            }
                        } else {
                            // We've got trail surrogate.
                            if (leadSurrogate !== -1) {
                                uCode =
                                    0x10000 +
                                    (leadSurrogate - 0xd800) * 0x400 +
                                    (uCode - 0xdc00)
                                leadSurrogate = -1
                            } else {
                                // Incomplete surrogate pair - only trail surrogate found.
                                uCode = UNASSIGNED
                            }
                        }
                    } else if (leadSurrogate !== -1) {
                        // Incomplete surrogate pair - only lead surrogate found.
                        nextChar = uCode
                        uCode = UNASSIGNED // Write an error, then current char.
                        leadSurrogate = -1
                    }

                    // 2. Convert uCode character.
                    var dbcsCode = UNASSIGNED
                    if (seqObj !== undefined && uCode != UNASSIGNED) {
                        // We are in the middle of the sequence
                        var resCode = seqObj[uCode]
                        if (typeof resCode === 'object') {
                            // Sequence continues.
                            seqObj = resCode
                            continue
                        } else if (typeof resCode == 'number') {
                            // Sequence finished. Write it.
                            dbcsCode = resCode
                        } else if (resCode == undefined) {
                            // Current character is not part of the sequence.

                            // Try default character for this sequence
                            resCode = seqObj[DEF_CHAR]
                            if (resCode !== undefined) {
                                dbcsCode = resCode // Found. Write it.
                                nextChar = uCode // Current character will be written too in the next iteration.
                            } else {
                                // TODO: What if we have no default? (resCode == undefined)
                                // Then, we should write first char of the sequence as-is and try the rest recursively.
                                // Didn't do it for now because no encoding has this situation yet.
                                // Currently, just skip the sequence and write current char.
                            }
                        }
                        seqObj = undefined
                    } else if (uCode >= 0) {
                        // Regular character
                        var subtable = this.encodeTable[uCode >> 8]
                        if (subtable !== undefined)
                            dbcsCode = subtable[uCode & 0xff]

                        if (dbcsCode <= SEQ_START) {
                            // Sequence start
                            seqObj = this.encodeTableSeq[SEQ_START - dbcsCode]
                            continue
                        }

                        if (dbcsCode == UNASSIGNED && this.gb18030) {
                            // Use GB18030 algorithm to find character(s) to write.
                            var idx = findIdx(this.gb18030.uChars, uCode)
                            if (idx != -1) {
                                var dbcsCode =
                                    this.gb18030.gbChars[idx] +
                                    (uCode - this.gb18030.uChars[idx])
                                newBuf[j++] =
                                    0x81 + Math.floor(dbcsCode / 12600)
                                dbcsCode = dbcsCode % 12600
                                newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260)
                                dbcsCode = dbcsCode % 1260
                                newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10)
                                dbcsCode = dbcsCode % 10
                                newBuf[j++] = 0x30 + dbcsCode
                                continue
                            }
                        }
                    }

                    // 3. Write dbcsCode character.
                    if (dbcsCode === UNASSIGNED)
                        dbcsCode = this.defaultCharSingleByte

                    if (dbcsCode < 0x100) {
                        newBuf[j++] = dbcsCode
                    } else if (dbcsCode < 0x10000) {
                        newBuf[j++] = dbcsCode >> 8 // high byte
                        newBuf[j++] = dbcsCode & 0xff // low byte
                    } else {
                        newBuf[j++] = dbcsCode >> 16
                        newBuf[j++] = (dbcsCode >> 8) & 0xff
                        newBuf[j++] = dbcsCode & 0xff
                    }
                }

                this.seqObj = seqObj
                this.leadSurrogate = leadSurrogate
                return newBuf.slice(0, j)
            }

            DBCSEncoder.prototype.end = function() {
                if (this.leadSurrogate === -1 && this.seqObj === undefined)
                    return // All clean. Most often case.

                var newBuf = Buffer.alloc(10),
                    j = 0

                if (this.seqObj) {
                    // We're in the sequence.
                    var dbcsCode = this.seqObj[DEF_CHAR]
                    if (dbcsCode !== undefined) {
                        // Write beginning of the sequence.
                        if (dbcsCode < 0x100) {
                            newBuf[j++] = dbcsCode
                        } else {
                            newBuf[j++] = dbcsCode >> 8 // high byte
                            newBuf[j++] = dbcsCode & 0xff // low byte
                        }
                    } else {
                        // See todo above.
                    }
                    this.seqObj = undefined
                }

                if (this.leadSurrogate !== -1) {
                    // Incomplete surrogate pair - only lead surrogate found.
                    newBuf[j++] = this.defaultCharSingleByte
                    this.leadSurrogate = -1
                }

                return newBuf.slice(0, j)
            }

            // Export for testing
            DBCSEncoder.prototype.findIdx = findIdx

            // == Decoder ==================================================================

            function DBCSDecoder(options, codec) {
                // Decoder state
                this.nodeIdx = 0
                this.prevBuf = Buffer.alloc(0)

                // Static data
                this.decodeTables = codec.decodeTables
                this.decodeTableSeq = codec.decodeTableSeq
                this.defaultCharUnicode = codec.defaultCharUnicode
                this.gb18030 = codec.gb18030
            }

            DBCSDecoder.prototype.write = function(buf) {
                var newBuf = Buffer.alloc(buf.length * 2),
                    nodeIdx = this.nodeIdx,
                    prevBuf = this.prevBuf,
                    prevBufOffset = this.prevBuf.length,
                    seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
                    uCode

                if (prevBufOffset > 0)
                    // Make prev buf overlap a little to make it easier to slice later.
                    prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)])

                for (var i = 0, j = 0; i < buf.length; i++) {
                    var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset]

                    // Lookup in current trie node.
                    var uCode = this.decodeTables[nodeIdx][curByte]

                    if (uCode >= 0) {
                        // Normal character, just use it.
                    } else if (uCode === UNASSIGNED) {
                        // Unknown char.
                        // TODO: Callback with seq.
                        //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
                        i = seqStart // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
                        uCode = this.defaultCharUnicode.charCodeAt(0)
                    } else if (uCode === GB18030_CODE) {
                        var curSeq =
                            seqStart >= 0
                                ? buf.slice(seqStart, i + 1)
                                : prevBuf.slice(
                                      seqStart + prevBufOffset,
                                      i + 1 + prevBufOffset
                                  )
                        var ptr =
                            (curSeq[0] - 0x81) * 12600 +
                            (curSeq[1] - 0x30) * 1260 +
                            (curSeq[2] - 0x81) * 10 +
                            (curSeq[3] - 0x30)
                        var idx = findIdx(this.gb18030.gbChars, ptr)
                        uCode =
                            this.gb18030.uChars[idx] +
                            ptr -
                            this.gb18030.gbChars[idx]
                    } else if (uCode <= NODE_START) {
                        // Go to next trie node.
                        nodeIdx = NODE_START - uCode
                        continue
                    } else if (uCode <= SEQ_START) {
                        // Output a sequence of chars.
                        var seq = this.decodeTableSeq[SEQ_START - uCode]
                        for (var k = 0; k < seq.length - 1; k++) {
                            uCode = seq[k]
                            newBuf[j++] = uCode & 0xff
                            newBuf[j++] = uCode >> 8
                        }
                        uCode = seq[seq.length - 1]
                    } else
                        throw new Error(
                            'iconv-lite internal error: invalid decoding table value ' +
                                uCode +
                                ' at ' +
                                nodeIdx +
                                '/' +
                                curByte
                        )

                    // Write the character to buffer, handling higher planes using surrogate pair.
                    if (uCode > 0xffff) {
                        uCode -= 0x10000
                        var uCodeLead = 0xd800 + Math.floor(uCode / 0x400)
                        newBuf[j++] = uCodeLead & 0xff
                        newBuf[j++] = uCodeLead >> 8

                        uCode = 0xdc00 + (uCode % 0x400)
                    }
                    newBuf[j++] = uCode & 0xff
                    newBuf[j++] = uCode >> 8

                    // Reset trie node.
                    nodeIdx = 0
                    seqStart = i + 1
                }

                this.nodeIdx = nodeIdx
                this.prevBuf =
                    seqStart >= 0
                        ? buf.slice(seqStart)
                        : prevBuf.slice(seqStart + prevBufOffset)
                return newBuf.slice(0, j).toString('ucs2')
            }

            DBCSDecoder.prototype.end = function() {
                var ret = ''

                // Try to parse all remaining chars.
                while (this.prevBuf.length > 0) {
                    // Skip 1 character in the buffer.
                    ret += this.defaultCharUnicode
                    var buf = this.prevBuf.slice(1)

                    // Parse remaining as usual.
                    this.prevBuf = Buffer.alloc(0)
                    this.nodeIdx = 0
                    if (buf.length > 0) ret += this.write(buf)
                }

                this.nodeIdx = 0
                return ret
            }

            // Binary search for GB18030. Returns largest i such that table[i] <= val.
            function findIdx(table, val) {
                if (table[0] > val) return -1

                var l = 0,
                    r = table.length
                while (l < r - 1) {
                    // always table[l] <= val < table[r]
                    var mid = l + Math.floor((r - l + 1) / 2)
                    if (table[mid] <= val) l = mid
                    else r = mid
                }
                return l
            }

            /***/
        },

        /***/ kZLX: /***/ function(module, exports, __webpack_require__) {
            const { createHash } = __webpack_require__('PJMN')
            const ecdhComputeSecret = __webpack_require__('RFts')

            const concat = (key, length, value) => {
                const iterations = Math.ceil(length / 32)
                let res

                for (let iter = 1; iter <= iterations; iter++) {
                    const buf = Buffer.allocUnsafe(
                        4 + key.length + value.length
                    )
                    buf.writeUInt32BE(iter, 0)
                    key.copy(buf, 4)
                    value.copy(buf, 4 + key.length)
                    if (!res) {
                        res = createHash('sha256')
                            .update(buf)
                            .digest()
                    } else {
                        res = Buffer.concat([
                            res,
                            createHash('sha256')
                                .update(buf)
                                .digest()
                        ])
                    }
                }

                return res.slice(0, length)
            }

            const uint32be = (value, buf = Buffer.allocUnsafe(4)) => {
                buf.writeUInt32BE(value)
                return buf
            }

            const lengthAndInput = input =>
                Buffer.concat([uint32be(input.length), input])

            module.exports = (
                alg,
                keyLen,
                privKey,
                pubKey,
                { apu = Buffer.alloc(0), apv = Buffer.alloc(0) } = {},
                computeSecret = ecdhComputeSecret
            ) => {
                const value = Buffer.concat([
                    lengthAndInput(Buffer.from(alg)),
                    lengthAndInput(apu),
                    lengthAndInput(apv),
                    uint32be(keyLen)
                ])

                const sharedSecret = computeSecret(privKey, pubKey)
                return concat(sharedSecret, keyLen / 8, value)
            }

            /***/
        },

        /***/ kekF: /***/ function(module, exports) {
            /**
             * Creates a unary function that invokes `func` with its argument transformed.
             *
             * @private
             * @param {Function} func The function to wrap.
             * @param {Function} transform The argument transform.
             * @returns {Function} Returns the new function.
             */
            function overArg(func, transform) {
                return function(arg) {
                    return func(transform(arg))
                }
            }

            module.exports = overArg

            /***/
        },

        /***/ kjw5: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { PassThrough } = __webpack_require__('msIP')
            const duplexer3 = __webpack_require__('U064')
            const requestAsEventEmitter = __webpack_require__('y/nk')
            const { HTTPError, ReadError } = __webpack_require__('9Fi5')

            module.exports = options => {
                const input = new PassThrough()
                const output = new PassThrough()
                const proxy = duplexer3(input, output)
                const piped = new Set()
                let isFinished = false

                options.retry.retries = () => 0

                if (options.body) {
                    proxy.write = () => {
                        throw new Error(
                            "Got's stream is not writable when the `body` option is used"
                        )
                    }
                }

                const emitter = requestAsEventEmitter(options, input)

                // Cancels the request
                proxy._destroy = emitter.abort

                emitter.on('response', response => {
                    const { statusCode } = response

                    response.on('error', error => {
                        proxy.emit('error', new ReadError(error, options))
                    })

                    if (
                        options.throwHttpErrors &&
                        statusCode !== 304 &&
                        (statusCode < 200 || statusCode > 299)
                    ) {
                        proxy.emit(
                            'error',
                            new HTTPError(response, options),
                            null,
                            response
                        )
                        return
                    }

                    isFinished = true

                    response.pipe(output)

                    for (const destination of piped) {
                        if (destination.headersSent) {
                            continue
                        }

                        for (const [key, value] of Object.entries(
                            response.headers
                        )) {
                            // Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.
                            // It's not possible to decompress already decompressed data, is it?
                            const allowed = options.decompress
                                ? key !== 'content-encoding'
                                : true
                            if (allowed) {
                                destination.setHeader(key, value)
                            }
                        }

                        destination.statusCode = response.statusCode
                    }

                    proxy.emit('response', response)
                })

                ;[
                    'error',
                    'request',
                    'redirect',
                    'uploadProgress',
                    'downloadProgress'
                ].forEach(event =>
                    emitter.on(event, (...args) => proxy.emit(event, ...args))
                )

                const pipe = proxy.pipe.bind(proxy)
                const unpipe = proxy.unpipe.bind(proxy)
                proxy.pipe = (destination, options) => {
                    if (isFinished) {
                        throw new Error(
                            'Failed to pipe. The response has been emitted already.'
                        )
                    }

                    const result = pipe(destination, options)

                    if (Reflect.has(destination, 'setHeader')) {
                        piped.add(destination)
                    }

                    return result
                }

                proxy.unpipe = stream => {
                    piped.delete(stream)
                    return unpipe(stream)
                }

                return proxy
            }

            /***/
        },

        /***/ kl4A: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function() {}

            /***/
        },

        /***/ kuaU: /***/ function(module, exports, __webpack_require__) {
            const { timingSafeEqual: TSE } = __webpack_require__('PJMN')

            const paddedBuffer = (input, length) => {
                if (input.length === length) {
                    return input
                }

                const buffer = Buffer.alloc(length)
                input.copy(buffer)
                return buffer
            }

            const timingSafeEqual = (a, b) => {
                const length = Math.max(a.length, b.length)
                return TSE(paddedBuffer(a, length), paddedBuffer(b, length))
            }

            module.exports = timingSafeEqual

            /***/
        },

        /***/ l3Iq: /***/ function(module, exports, __webpack_require__) {
            const base64url = __webpack_require__('Xab3')
            const isDisjoint = __webpack_require__('KQbz')
            const isObject = __webpack_require__('kF1/')
            const deepClone = __webpack_require__('O9d4')
            const { JWSInvalid } = __webpack_require__('yt7c')
            const { sign } = __webpack_require__('FUB/')
            const getKey = __webpack_require__('oGTz')

            const serializers = __webpack_require__('SwXk')

            const PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT')

            class Sign {
                constructor(payload) {
                    if (typeof payload === 'string') {
                        payload = base64url.encode(payload)
                    } else if (Buffer.isBuffer(payload)) {
                        payload = base64url.encodeBuffer(payload)
                        this._binary = true
                    } else if (isObject(payload)) {
                        payload = base64url.JSON.encode(payload)
                    } else {
                        throw new TypeError(
                            'payload argument must be a Buffer, string or an object'
                        )
                    }

                    this._payload = payload
                    this._recipients = []
                }

                /*
                 * @public
                 */
                recipient(key, protectedHeader, unprotectedHeader) {
                    key = getKey(key)

                    if (
                        protectedHeader !== undefined &&
                        !isObject(protectedHeader)
                    ) {
                        throw new TypeError(
                            'protectedHeader argument must be a plain object when provided'
                        )
                    }

                    if (
                        unprotectedHeader !== undefined &&
                        !isObject(unprotectedHeader)
                    ) {
                        throw new TypeError(
                            'unprotectedHeader argument must be a plain object when provided'
                        )
                    }

                    if (!isDisjoint(protectedHeader, unprotectedHeader)) {
                        throw new JWSInvalid(
                            'JWS Protected and JWS Unprotected Header Parameter names must be disjoint'
                        )
                    }

                    this._recipients.push({
                        key,
                        protectedHeader: protectedHeader
                            ? deepClone(protectedHeader)
                            : undefined,
                        unprotectedHeader: unprotectedHeader
                            ? deepClone(unprotectedHeader)
                            : undefined
                    })

                    return this
                }

                /*
                 * @private
                 */
                [PROCESS_RECIPIENT](recipient) {
                    const {
                        key,
                        protectedHeader,
                        unprotectedHeader
                    } = recipient

                    if (key.use === 'enc') {
                        throw new TypeError(
                            'a key with "use":"enc" is not usable for signing'
                        )
                    }

                    const joseHeader = {
                        protected: protectedHeader || {},
                        unprotected: unprotectedHeader || {}
                    }

                    let alg =
                        joseHeader.protected.alg || joseHeader.unprotected.alg

                    if (!alg) {
                        alg = key.alg || [...key.algorithms('sign')][0]
                        if (recipient.protectedHeader) {
                            joseHeader.protected.alg = recipient.protectedHeader.alg = alg
                        } else {
                            joseHeader.protected = recipient.protectedHeader = {
                                alg
                            }
                        }
                    }

                    if (!alg) {
                        throw new JWSInvalid(
                            'could not resolve a usable "alg" for a recipient'
                        )
                    }

                    recipient.header = unprotectedHeader
                    recipient.protected = Object.keys(joseHeader.protected)
                        .length
                        ? base64url.JSON.encode(joseHeader.protected)
                        : ''

                    let toBeSigned
                    if (
                        joseHeader.protected.crit &&
                        joseHeader.protected.crit.includes('b64')
                    ) {
                        if (
                            this._b64 !== undefined &&
                            this._b64 !== joseHeader.protected.b64
                        ) {
                            throw new JWSInvalid(
                                'the "b64" Header Parameter value MUST be the same for all recipients'
                            )
                        } else {
                            this._b64 = joseHeader.protected.b64
                        }

                        if (!joseHeader.protected.b64) {
                            if (this._binary) {
                                this._payload = base64url.decodeToBuffer(
                                    this._payload
                                )
                            } else {
                                this._payload = base64url.decode(this._payload)
                            }
                        }

                        toBeSigned = Buffer.concat([
                            Buffer.from(recipient.protected || ''),
                            Buffer.from('.'),
                            Buffer.isBuffer(this._payload)
                                ? this._payload
                                : Buffer.from(this._payload)
                        ])
                    } else {
                        toBeSigned = `${recipient.protected || ''}.${
                            this._payload
                        }`
                    }

                    recipient.signature = base64url.encodeBuffer(
                        sign(alg, key, toBeSigned)
                    )
                }

                /*
                 * @public
                 */
                sign(serialization) {
                    const serializer = serializers[serialization]
                    if (!serializer) {
                        throw new TypeError(
                            'serialization must be one of "compact", "flattened", "general"'
                        )
                    }

                    if (!this._recipients.length) {
                        throw new JWSInvalid('missing recipients')
                    }

                    serializer.validate(this, this._recipients)

                    for (const recipient of this._recipients) {
                        this[PROCESS_RECIPIENT](recipient)
                    }

                    return serializer(this._payload, this._recipients)
                }
            }

            module.exports = Sign

            /***/
        },

        /***/ lA9T: /***/ function(module, exports, __webpack_require__) {
            const Key = __webpack_require__('//Cd')
            const None = __webpack_require__('qSBP')
            const importKey = __webpack_require__('GhER')
            const generate = __webpack_require__('LDEB')

            module.exports = {
                ...generate,
                asKey: importKey,
                isKey: input => input instanceof Key,
                None
            }

            /* deprecated */
            Object.defineProperty(module.exports, 'importKey', {
                value: importKey.deprecated,
                enumerable: false
            })

            /***/
        },

        /***/ lERV: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // rfc7231 6.1
            const statusCodeCacheableByDefault = [
                200,
                203,
                204,
                206,
                300,
                301,
                404,
                405,
                410,
                414,
                501
            ]

            // This implementation does not understand partial responses (206)
            const understoodStatuses = [
                200,
                203,
                204,
                300,
                301,
                302,
                303,
                307,
                308,
                404,
                405,
                410,
                414,
                501
            ]

            const hopByHopHeaders = {
                date: true, // included, because we add Age update Date
                connection: true,
                'keep-alive': true,
                'proxy-authenticate': true,
                'proxy-authorization': true,
                te: true,
                trailer: true,
                'transfer-encoding': true,
                upgrade: true
            }
            const excludedFromRevalidationUpdate = {
                // Since the old body is reused, it doesn't make sense to change properties of the body
                'content-length': true,
                'content-encoding': true,
                'transfer-encoding': true,
                'content-range': true
            }

            function parseCacheControl(header) {
                const cc = {}
                if (!header) return cc

                // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),
                // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale
                const parts = header.trim().split(/\s*,\s*/) // TODO: lame parsing
                for (const part of parts) {
                    const [k, v] = part.split(/\s*=\s*/, 2)
                    cc[k] = v === undefined ? true : v.replace(/^"|"$/g, '') // TODO: lame unquoting
                }

                return cc
            }

            function formatCacheControl(cc) {
                let parts = []
                for (const k in cc) {
                    const v = cc[k]
                    parts.push(v === true ? k : k + '=' + v)
                }
                if (!parts.length) {
                    return undefined
                }
                return parts.join(', ')
            }

            module.exports = class CachePolicy {
                constructor(
                    req,
                    res,
                    {
                        shared,
                        cacheHeuristic,
                        immutableMinTimeToLive,
                        ignoreCargoCult,
                        trustServerDate,
                        _fromObject
                    } = {}
                ) {
                    if (_fromObject) {
                        this._fromObject(_fromObject)
                        return
                    }

                    if (!res || !res.headers) {
                        throw Error('Response headers missing')
                    }
                    this._assertRequestHasHeaders(req)

                    this._responseTime = this.now()
                    this._isShared = shared !== false
                    this._trustServerDate =
                        undefined !== trustServerDate ? trustServerDate : true
                    this._cacheHeuristic =
                        undefined !== cacheHeuristic ? cacheHeuristic : 0.1 // 10% matches IE
                    this._immutableMinTtl =
                        undefined !== immutableMinTimeToLive
                            ? immutableMinTimeToLive
                            : 24 * 3600 * 1000

                    this._status = 'status' in res ? res.status : 200
                    this._resHeaders = res.headers
                    this._rescc = parseCacheControl(
                        res.headers['cache-control']
                    )
                    this._method = 'method' in req ? req.method : 'GET'
                    this._url = req.url
                    this._host = req.headers.host
                    this._noAuthorization = !req.headers.authorization
                    this._reqHeaders = res.headers.vary ? req.headers : null // Don't keep all request headers if they won't be used
                    this._reqcc = parseCacheControl(
                        req.headers['cache-control']
                    )

                    // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,
                    // so there's no point stricly adhering to the blindly copy&pasted directives.
                    if (
                        ignoreCargoCult &&
                        'pre-check' in this._rescc &&
                        'post-check' in this._rescc
                    ) {
                        delete this._rescc['pre-check']
                        delete this._rescc['post-check']
                        delete this._rescc['no-cache']
                        delete this._rescc['no-store']
                        delete this._rescc['must-revalidate']
                        this._resHeaders = Object.assign({}, this._resHeaders, {
                            'cache-control': formatCacheControl(this._rescc)
                        })
                        delete this._resHeaders.expires
                        delete this._resHeaders.pragma
                    }

                    // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive
                    // as having the same effect as if "Cache-Control: no-cache" were present (see Section 5.2.1).
                    if (
                        res.headers['cache-control'] == null &&
                        /no-cache/.test(res.headers.pragma)
                    ) {
                        this._rescc['no-cache'] = true
                    }
                }

                now() {
                    return Date.now()
                }

                storable() {
                    // The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.
                    return !!(
                        !this._reqcc['no-store'] &&
                        // A cache MUST NOT store a response to any request, unless:
                        // The request method is understood by the cache and defined as being cacheable, and
                        ('GET' === this._method ||
                            'HEAD' === this._method ||
                            ('POST' === this._method &&
                                this._hasExplicitExpiration())) &&
                        // the response status code is understood by the cache, and
                        understoodStatuses.indexOf(this._status) !== -1 &&
                        // the "no-store" cache directive does not appear in request or response header fields, and
                        !this._rescc['no-store'] &&
                        // the "private" response directive does not appear in the response, if the cache is shared, and
                        (!this._isShared || !this._rescc.private) &&
                        // the Authorization header field does not appear in the request, if the cache is shared,
                        (!this._isShared ||
                            this._noAuthorization ||
                            this._allowsStoringAuthenticated()) &&
                        // the response either:
                        // contains an Expires header field, or
                        (this._resHeaders.expires ||
                            // contains a max-age response directive, or
                            // contains a s-maxage response directive and the cache is shared, or
                            // contains a public response directive.
                            this._rescc['max-age'] ||
                            (this._isShared && this._rescc['s-maxage']) ||
                            this._rescc.public ||
                            // has a status code that is defined as cacheable by default
                            statusCodeCacheableByDefault.indexOf(
                                this._status
                            ) !== -1)
                    )
                }

                _hasExplicitExpiration() {
                    // 4.2.1 Calculating Freshness Lifetime
                    return (
                        (this._isShared && this._rescc['s-maxage']) ||
                        this._rescc['max-age'] ||
                        this._resHeaders.expires
                    )
                }

                _assertRequestHasHeaders(req) {
                    if (!req || !req.headers) {
                        throw Error('Request headers missing')
                    }
                }

                satisfiesWithoutRevalidation(req) {
                    this._assertRequestHasHeaders(req)

                    // When presented with a request, a cache MUST NOT reuse a stored response, unless:
                    // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,
                    // unless the stored response is successfully validated (Section 4.3), and
                    const requestCC = parseCacheControl(
                        req.headers['cache-control']
                    )
                    if (
                        requestCC['no-cache'] ||
                        /no-cache/.test(req.headers.pragma)
                    ) {
                        return false
                    }

                    if (
                        requestCC['max-age'] &&
                        this.age() > requestCC['max-age']
                    ) {
                        return false
                    }

                    if (
                        requestCC['min-fresh'] &&
                        this.timeToLive() < 1000 * requestCC['min-fresh']
                    ) {
                        return false
                    }

                    // the stored response is either:
                    // fresh, or allowed to be served stale
                    if (this.stale()) {
                        const allowsStale =
                            requestCC['max-stale'] &&
                            !this._rescc['must-revalidate'] &&
                            (true === requestCC['max-stale'] ||
                                requestCC['max-stale'] >
                                    this.age() - this.maxAge())
                        if (!allowsStale) {
                            return false
                        }
                    }

                    return this._requestMatches(req, false)
                }

                _requestMatches(req, allowHeadMethod) {
                    // The presented effective request URI and that of the stored response match, and
                    return (
                        (!this._url || this._url === req.url) &&
                        this._host === req.headers.host &&
                        // the request method associated with the stored response allows it to be used for the presented request, and
                        (!req.method ||
                            this._method === req.method ||
                            (allowHeadMethod && 'HEAD' === req.method)) &&
                        // selecting header fields nominated by the stored response (if any) match those presented, and
                        this._varyMatches(req)
                    )
                }

                _allowsStoringAuthenticated() {
                    //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.
                    return (
                        this._rescc['must-revalidate'] ||
                        this._rescc.public ||
                        this._rescc['s-maxage']
                    )
                }

                _varyMatches(req) {
                    if (!this._resHeaders.vary) {
                        return true
                    }

                    // A Vary header field-value of "*" always fails to match
                    if (this._resHeaders.vary === '*') {
                        return false
                    }

                    const fields = this._resHeaders.vary
                        .trim()
                        .toLowerCase()
                        .split(/\s*,\s*/)
                    for (const name of fields) {
                        if (req.headers[name] !== this._reqHeaders[name])
                            return false
                    }
                    return true
                }

                _copyWithoutHopByHopHeaders(inHeaders) {
                    const headers = {}
                    for (const name in inHeaders) {
                        if (hopByHopHeaders[name]) continue
                        headers[name] = inHeaders[name]
                    }
                    // 9.1.  Connection
                    if (inHeaders.connection) {
                        const tokens = inHeaders.connection
                            .trim()
                            .split(/\s*,\s*/)
                        for (const name of tokens) {
                            delete headers[name]
                        }
                    }
                    if (headers.warning) {
                        const warnings = headers.warning
                            .split(/,/)
                            .filter(warning => {
                                return !/^\s*1[0-9][0-9]/.test(warning)
                            })
                        if (!warnings.length) {
                            delete headers.warning
                        } else {
                            headers.warning = warnings.join(',').trim()
                        }
                    }
                    return headers
                }

                responseHeaders() {
                    const headers = this._copyWithoutHopByHopHeaders(
                        this._resHeaders
                    )
                    const age = this.age()

                    // A cache SHOULD generate 113 warning if it heuristically chose a freshness
                    // lifetime greater than 24 hours and the response's age is greater than 24 hours.
                    if (
                        age > 3600 * 24 &&
                        !this._hasExplicitExpiration() &&
                        this.maxAge() > 3600 * 24
                    ) {
                        headers.warning =
                            (headers.warning ? `${headers.warning}, ` : '') +
                            '113 - "rfc7234 5.5.4"'
                    }
                    headers.age = `${Math.round(age)}`
                    headers.date = new Date(this.now()).toUTCString()
                    return headers
                }

                /**
                 * Value of the Date response header or current time if Date was demed invalid
                 * @return timestamp
                 */
                date() {
                    if (this._trustServerDate) {
                        return this._serverDate()
                    }
                    return this._responseTime
                }

                _serverDate() {
                    const serverDate = Date.parse(this._resHeaders.date)
                    if (isFinite(serverDate)) {
                        const maxClockDrift = 8 * 3600 * 1000
                        const clockDrift = Math.abs(
                            this._responseTime - serverDate
                        )
                        if (clockDrift < maxClockDrift) {
                            return serverDate
                        }
                    }
                    return this._responseTime
                }

                /**
                 * Value of the Age header, in seconds, updated for the current time.
                 * May be fractional.
                 *
                 * @return Number
                 */
                age() {
                    let age = Math.max(
                        0,
                        (this._responseTime - this.date()) / 1000
                    )
                    if (this._resHeaders.age) {
                        let ageValue = this._ageValue()
                        if (ageValue > age) age = ageValue
                    }

                    const residentTime =
                        (this.now() - this._responseTime) / 1000
                    return age + residentTime
                }

                _ageValue() {
                    const ageValue = parseInt(this._resHeaders.age)
                    return isFinite(ageValue) ? ageValue : 0
                }

                /**
                 * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
                 *
                 * For an up-to-date value, see `timeToLive()`.
                 *
                 * @return Number
                 */
                maxAge() {
                    if (!this.storable() || this._rescc['no-cache']) {
                        return 0
                    }

                    // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default
                    // so this implementation requires explicit opt-in via public header
                    if (
                        this._isShared &&
                        this._resHeaders['set-cookie'] &&
                            !this._rescc.public &&
                            !this._rescc.immutable
                    ) {
                        return 0
                    }

                    if (this._resHeaders.vary === '*') {
                        return 0
                    }

                    if (this._isShared) {
                        if (this._rescc['proxy-revalidate']) {
                            return 0
                        }
                        // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.
                        if (this._rescc['s-maxage']) {
                            return parseInt(this._rescc['s-maxage'], 10)
                        }
                    }

                    // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.
                    if (this._rescc['max-age']) {
                        return parseInt(this._rescc['max-age'], 10)
                    }

                    const defaultMinTtl = this._rescc.immutable
                        ? this._immutableMinTtl
                        : 0

                    const serverDate = this._serverDate()
                    if (this._resHeaders.expires) {
                        const expires = Date.parse(this._resHeaders.expires)
                        // A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
                        if (Number.isNaN(expires) || expires < serverDate) {
                            return 0
                        }
                        return Math.max(
                            defaultMinTtl,
                            (expires - serverDate) / 1000
                        )
                    }

                    if (this._resHeaders['last-modified']) {
                        const lastModified = Date.parse(
                            this._resHeaders['last-modified']
                        )
                        if (
                            isFinite(lastModified) &&
                            serverDate > lastModified
                        ) {
                            return Math.max(
                                defaultMinTtl,
                                ((serverDate - lastModified) / 1000) *
                                    this._cacheHeuristic
                            )
                        }
                    }

                    return defaultMinTtl
                }

                timeToLive() {
                    return Math.max(0, this.maxAge() - this.age()) * 1000
                }

                stale() {
                    return this.maxAge() <= this.age()
                }

                static fromObject(obj) {
                    return new this(undefined, undefined, { _fromObject: obj })
                }

                _fromObject(obj) {
                    if (this._responseTime) throw Error('Reinitialized')
                    if (!obj || obj.v !== 1)
                        throw Error('Invalid serialization')

                    this._responseTime = obj.t
                    this._isShared = obj.sh
                    this._cacheHeuristic = obj.ch
                    this._immutableMinTtl =
                        obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000
                    this._status = obj.st
                    this._resHeaders = obj.resh
                    this._rescc = obj.rescc
                    this._method = obj.m
                    this._url = obj.u
                    this._host = obj.h
                    this._noAuthorization = obj.a
                    this._reqHeaders = obj.reqh
                    this._reqcc = obj.reqcc
                }

                toObject() {
                    return {
                        v: 1,
                        t: this._responseTime,
                        sh: this._isShared,
                        ch: this._cacheHeuristic,
                        imm: this._immutableMinTtl,
                        st: this._status,
                        resh: this._resHeaders,
                        rescc: this._rescc,
                        m: this._method,
                        u: this._url,
                        h: this._host,
                        a: this._noAuthorization,
                        reqh: this._reqHeaders,
                        reqcc: this._reqcc
                    }
                }

                /**
                 * Headers for sending to the origin server to revalidate stale response.
                 * Allows server to return 304 to allow reuse of the previous response.
                 *
                 * Hop by hop headers are always stripped.
                 * Revalidation headers may be added or removed, depending on request.
                 */
                revalidationHeaders(incomingReq) {
                    this._assertRequestHasHeaders(incomingReq)
                    const headers = this._copyWithoutHopByHopHeaders(
                        incomingReq.headers
                    )

                    // This implementation does not understand range requests
                    delete headers['if-range']

                    if (
                        !this._requestMatches(incomingReq, true) ||
                        !this.storable()
                    ) {
                        // revalidation allowed via HEAD
                        // not for the same resource, or wasn't allowed to be cached anyway
                        delete headers['if-none-match']
                        delete headers['if-modified-since']
                        return headers
                    }

                    /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */
                    if (this._resHeaders.etag) {
                        headers['if-none-match'] = headers['if-none-match']
                            ? `${headers['if-none-match']}, ${this._resHeaders.etag}`
                            : this._resHeaders.etag
                    }

                    // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.
                    const forbidsWeakValidators =
                        headers['accept-ranges'] ||
                        headers['if-match'] ||
                        headers['if-unmodified-since'] ||
                        (this._method && this._method != 'GET')

                    /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
        Note: This implementation does not understand partial responses (206) */
                    if (forbidsWeakValidators) {
                        delete headers['if-modified-since']

                        if (headers['if-none-match']) {
                            const etags = headers['if-none-match']
                                .split(/,/)
                                .filter(etag => {
                                    return !/^\s*W\//.test(etag)
                                })
                            if (!etags.length) {
                                delete headers['if-none-match']
                            } else {
                                headers['if-none-match'] = etags
                                    .join(',')
                                    .trim()
                            }
                        }
                    } else if (
                        this._resHeaders['last-modified'] &&
                        !headers['if-modified-since']
                    ) {
                        headers['if-modified-since'] = this._resHeaders[
                            'last-modified'
                        ]
                    }

                    return headers
                }

                /**
                 * Creates new CachePolicy with information combined from the previews response,
                 * and the new revalidation response.
                 *
                 * Returns {policy, modified} where modified is a boolean indicating
                 * whether the response body has been modified, and old cached body can't be used.
                 *
                 * @return {Object} {policy: CachePolicy, modified: Boolean}
                 */
                revalidatedPolicy(request, response) {
                    this._assertRequestHasHeaders(request)
                    if (!response || !response.headers) {
                        throw Error('Response headers missing')
                    }

                    // These aren't going to be supported exactly, since one CachePolicy object
                    // doesn't know about all the other cached objects.
                    let matches = false
                    if (
                        response.status !== undefined &&
                        response.status != 304
                    ) {
                        matches = false
                    } else if (
                        response.headers.etag &&
                        !/^\s*W\//.test(response.headers.etag)
                    ) {
                        // "All of the stored responses with the same strong validator are selected.
                        // If none of the stored responses contain the same strong validator,
                        // then the cache MUST NOT use the new response to update any stored responses."
                        matches =
                            this._resHeaders.etag &&
                            this._resHeaders.etag.replace(/^\s*W\//, '') ===
                                response.headers.etag
                    } else if (this._resHeaders.etag && response.headers.etag) {
                        // "If the new response contains a weak validator and that validator corresponds
                        // to one of the cache's stored responses,
                        // then the most recent of those matching stored responses is selected for update."
                        matches =
                            this._resHeaders.etag.replace(/^\s*W\//, '') ===
                            response.headers.etag.replace(/^\s*W\//, '')
                    } else if (this._resHeaders['last-modified']) {
                        matches =
                            this._resHeaders['last-modified'] ===
                            response.headers['last-modified']
                    } else {
                        // If the new response does not include any form of validator (such as in the case where
                        // a client generates an If-Modified-Since request from a source other than the Last-Modified
                        // response header field), and there is only one stored response, and that stored response also
                        // lacks a validator, then that stored response is selected for update.
                        if (
                            !this._resHeaders.etag &&
                            !this._resHeaders['last-modified'] &&
                            !response.headers.etag &&
                            !response.headers['last-modified']
                        ) {
                            matches = true
                        }
                    }

                    if (!matches) {
                        return {
                            policy: new this.constructor(request, response),
                            // Client receiving 304 without body, even if it's invalid/mismatched has no option
                            // but to reuse a cached body. We don't have a good way to tell clients to do
                            // error recovery in such case.
                            modified: response.status != 304,
                            matches: false
                        }
                    }

                    // use other header fields provided in the 304 (Not Modified) response to replace all instances
                    // of the corresponding header fields in the stored response.
                    const headers = {}
                    for (const k in this._resHeaders) {
                        headers[k] =
                            k in response.headers &&
                            !excludedFromRevalidationUpdate[k]
                                ? response.headers[k]
                                : this._resHeaders[k]
                    }

                    const newResponse = Object.assign({}, response, {
                        status: this._status,
                        method: this._method,
                        headers
                    })
                    return {
                        policy: new this.constructor(request, newResponse, {
                            shared: this._isShared,
                            cacheHeuristic: this._cacheHeuristic,
                            immutableMinTimeToLive: this._immutableMinTtl,
                            trustServerDate: this._trustServerDate
                        }),
                        modified: false,
                        matches: true
                    }
                }
            }

            /***/
        },

        /***/ lLtp: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // Update this array if you add/rename/remove files in this directory.
            // We support Browserify by skipping automatic module discovery and requiring modules directly.
            var modules = [
                __webpack_require__('01QI'),
                __webpack_require__('pY1j'),
                __webpack_require__('xkKp'),
                __webpack_require__('a9ph'),
                __webpack_require__('PQ6H'),
                __webpack_require__('gLwZ'),
                __webpack_require__('kMlu'),
                __webpack_require__('HEcb')
            ]

            // Put all encoding/alias/codec definitions to single object and export it.
            for (var i = 0; i < modules.length; i++) {
                var module = modules[i]
                for (var enc in module)
                    if (Object.prototype.hasOwnProperty.call(module, enc))
                        exports[enc] = module[enc]
            }

            /***/
        },

        /***/ lN8I: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const pSome = __webpack_require__('htIY')
            const PCancelable = __webpack_require__('ijcl')

            const pAny = (iterable, options) => {
                const anyCancelable = pSome(iterable, { ...options, count: 1 })

                return PCancelable.fn(async onCancel => {
                    onCancel(() => {
                        anyCancelable.cancel()
                    })

                    const [value] = await anyCancelable
                    return value
                })()
            }

            module.exports = pAny
            // TODO: Remove this for the next major release
            module.exports.default = pAny

            module.exports.AggregateError = pSome.AggregateError

            /***/
        },

        /***/ lPSh: /***/ function(module) {
            module.exports = JSON.parse(
                '[["0","\\u0000",128],["a1","",62],["8140","",9,""],["8180",""],["81b8",""],["81c8",""],["81da",""],["81f0",""],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]'
            )

            /***/
        },

        /***/ lSCD: /***/ function(module, exports, __webpack_require__) {
            var baseGetTag = __webpack_require__('NykK'),
                isObject = __webpack_require__('GoyQ')

            /** `Object#toString` result references. */
            var asyncTag = '[object AsyncFunction]',
                funcTag = '[object Function]',
                genTag = '[object GeneratorFunction]',
                proxyTag = '[object Proxy]'

            /**
             * Checks if `value` is classified as a `Function` object.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a function, else `false`.
             * @example
             *
             * _.isFunction(_);
             * // => true
             *
             * _.isFunction(/abc/);
             * // => false
             */
            function isFunction(value) {
                if (!isObject(value)) {
                    return false
                }
                // The use of `Object#toString` avoids issues with the `typeof` operator
                // in Safari 9 which returns 'object' for typed arrays and other constructors.
                var tag = baseGetTag(value)
                return (
                    tag == funcTag ||
                    tag == genTag ||
                    tag == asyncTag ||
                    tag == proxyTag
                )
            }

            module.exports = isFunction

            /***/
        },

        /***/ la6v: /***/ function(module, exports, __webpack_require__) {
            var baseRest = __webpack_require__('EA7m'),
                eq = __webpack_require__('ljhN'),
                isIterateeCall = __webpack_require__('mv/X'),
                keysIn = __webpack_require__('mTTR')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Assigns own and inherited enumerable string keyed properties of source
             * objects to the destination object for all destination properties that
             * resolve to `undefined`. Source objects are applied from left to right.
             * Once a property is set, additional values of the same property are ignored.
             *
             * **Note:** This method mutates `object`.
             *
             * @static
             * @since 0.1.0
             * @memberOf _
             * @category Object
             * @param {Object} object The destination object.
             * @param {...Object} [sources] The source objects.
             * @returns {Object} Returns `object`.
             * @see _.defaultsDeep
             * @example
             *
             * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
             * // => { 'a': 1, 'b': 2 }
             */
            var defaults = baseRest(function(object, sources) {
                object = Object(object)

                var index = -1
                var length = sources.length
                var guard = length > 2 ? sources[2] : undefined

                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    length = 1
                }

                while (++index < length) {
                    var source = sources[index]
                    var props = keysIn(source)
                    var propsIndex = -1
                    var propsLength = props.length

                    while (++propsIndex < propsLength) {
                        var key = props[propsIndex]
                        var value = object[key]

                        if (
                            value === undefined ||
                            (eq(value, objectProto[key]) &&
                                !hasOwnProperty.call(object, key))
                        ) {
                            object[key] = source[key]
                        }
                    }
                }

                return object
            })

            module.exports = defaults

            /***/
        },

        /***/ ljhN: /***/ function(module, exports) {
            /**
             * Performs a
             * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
             * comparison between two values to determine if they are equivalent.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to compare.
             * @param {*} other The other value to compare.
             * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
             * @example
             *
             * var object = { 'a': 1 };
             * var other = { 'a': 1 };
             *
             * _.eq(object, object);
             * // => true
             *
             * _.eq(object, other);
             * // => false
             *
             * _.eq('a', 'a');
             * // => true
             *
             * _.eq('a', Object('a'));
             * // => false
             *
             * _.eq(NaN, NaN);
             * // => true
             */
            function eq(value, other) {
                return value === other || (value !== value && other !== other)
            }

            module.exports = eq

            /***/
        },

        /***/ 'lm/5': /***/ function(module, exports, __webpack_require__) {
            var Stack = __webpack_require__('fmRc'),
                baseIsEqual = __webpack_require__('wF/u')

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1,
                COMPARE_UNORDERED_FLAG = 2

            /**
             * The base implementation of `_.isMatch` without support for iteratee shorthands.
             *
             * @private
             * @param {Object} object The object to inspect.
             * @param {Object} source The object of property values to match.
             * @param {Array} matchData The property names, values, and compare flags to match.
             * @param {Function} [customizer] The function to customize comparisons.
             * @returns {boolean} Returns `true` if `object` is a match, else `false`.
             */
            function baseIsMatch(object, source, matchData, customizer) {
                var index = matchData.length,
                    length = index,
                    noCustomizer = !customizer

                if (object == null) {
                    return !length
                }
                object = Object(object)
                while (index--) {
                    var data = matchData[index]
                    if (
                        noCustomizer && data[2]
                            ? data[1] !== object[data[0]]
                            : !(data[0] in object)
                    ) {
                        return false
                    }
                }
                while (++index < length) {
                    data = matchData[index]
                    var key = data[0],
                        objValue = object[key],
                        srcValue = data[1]

                    if (noCustomizer && data[2]) {
                        if (objValue === undefined && !(key in object)) {
                            return false
                        }
                    } else {
                        var stack = new Stack()
                        if (customizer) {
                            var result = customizer(
                                objValue,
                                srcValue,
                                key,
                                object,
                                source,
                                stack
                            )
                        }
                        if (
                            !(result === undefined
                                ? baseIsEqual(
                                      srcValue,
                                      objValue,
                                      COMPARE_PARTIAL_FLAG |
                                          COMPARE_UNORDERED_FLAG,
                                      customizer,
                                      stack
                                  )
                                : result)
                        ) {
                            return false
                        }
                    }
                }
                return true
            }

            module.exports = baseIsMatch

            /***/
        },

        /***/ m2VO: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const cookies_1 = __webpack_require__('gKi1')
            function createLogoutUrl(settings) {
                return (
                    `https://${settings.domain}/v2/logout?` +
                    `client_id=${settings.clientId}` +
                    `&returnTo=${encodeURIComponent(
                        settings.postLogoutRedirectUri
                    )}`
                )
            }
            function logoutHandler(settings, sessionSettings) {
                return (req, res) =>
                    tslib_1.__awaiter(this, void 0, void 0, function*() {
                        if (!res) {
                            throw new Error('Response is not available')
                        }
                        // Remove the cookies
                        cookies_1.setCookies(req, res, [
                            {
                                name: 'a0:state',
                                value: '',
                                maxAge: -1
                            },
                            {
                                name: sessionSettings.cookieName,
                                value: '',
                                maxAge: -1,
                                path: sessionSettings.cookiePath
                            }
                        ])
                        // Redirect to the logout endpoint.
                        res.writeHead(302, {
                            Location: createLogoutUrl(settings)
                        })
                        res.end()
                    })
            }
            exports.default = logoutHandler
            //# sourceMappingURL=logout.js.map

            /***/
        },

        /***/ mRrf: /***/ function(module, exports) {
            const isNotString = val =>
                typeof val !== 'string' || val.length === 0

            module.exports.isNotString = isNotString
            module.exports.isString = function isString(
                Err,
                value,
                label,
                claim,
                required = false
            ) {
                if (required && value === undefined) {
                    throw new Err(`${label} is missing`, claim, 'missing')
                }

                if (value !== undefined && isNotString(value)) {
                    throw new Err(`${label} must be a string`, claim, 'invalid')
                }
            }

            /***/
        },

        /***/ mTTR: /***/ function(module, exports, __webpack_require__) {
            var arrayLikeKeys = __webpack_require__('b80T'),
                baseKeysIn = __webpack_require__('QcOe'),
                isArrayLike = __webpack_require__('MMmD')

            /**
             * Creates an array of the own and inherited enumerable property names of `object`.
             *
             * **Note:** Non-object values are coerced to objects.
             *
             * @static
             * @memberOf _
             * @since 3.0.0
             * @category Object
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             * @example
             *
             * function Foo() {
             *   this.a = 1;
             *   this.b = 2;
             * }
             *
             * Foo.prototype.c = 3;
             *
             * _.keysIn(new Foo);
             * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
             */
            function keysIn(object) {
                return isArrayLike(object)
                    ? arrayLikeKeys(object, true)
                    : baseKeysIn(object)
            }

            module.exports = keysIn

            /***/
        },

        /***/ mc0g: /***/ function(module, exports) {
            /**
             * Creates a base function for methods like `_.forIn` and `_.forOwn`.
             *
             * @private
             * @param {boolean} [fromRight] Specify iterating from right to left.
             * @returns {Function} Returns the new base function.
             */
            function createBaseFor(fromRight) {
                return function(object, iteratee, keysFunc) {
                    var index = -1,
                        iterable = Object(object),
                        props = keysFunc(object),
                        length = props.length

                    while (length--) {
                        var key = props[fromRight ? length : ++index]
                        if (iteratee(iterable[key], key, iterable) === false) {
                            break
                        }
                    }
                    return object
                }
            }

            module.exports = createBaseFor

            /***/
        },

        /***/ mdPL: /***/ function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */ ;(function(module) {
                var freeGlobal = __webpack_require__('WFqU')

                /** Detect free variable `exports`. */
                var freeExports =
                    true && exports && !exports.nodeType && exports

                /** Detect free variable `module`. */
                var freeModule =
                    freeExports &&
                    typeof module == 'object' &&
                    module &&
                    !module.nodeType &&
                    module

                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports =
                    freeModule && freeModule.exports === freeExports

                /** Detect free variable `process` from Node.js. */
                var freeProcess = moduleExports && freeGlobal.process

                /** Used to access faster Node.js helpers. */
                var nodeUtil = (function() {
                    try {
                        // Use `util.types` for Node.js 10+.
                        var types =
                            freeModule &&
                            freeModule.require &&
                            freeModule.require('util').types

                        if (types) {
                            return types
                        }

                        // Legacy `process.binding('util')` for Node.js < 10.
                        return (
                            freeProcess &&
                            freeProcess.binding &&
                            freeProcess.binding('util')
                        )
                    } catch (e) {}
                })()

                module.exports = nodeUtil

                /* WEBPACK VAR INJECTION */
            }.call(this, __webpack_require__('YuTi')(module)))

            /***/
        },

        /***/ mmuM: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Assert = __webpack_require__('GlC0')

            const internals = {}

            module.exports = function(obj, chain, options) {
                if (chain === false || chain === null || chain === undefined) {
                    return obj
                }

                options = options || {}
                if (typeof options === 'string') {
                    options = { separator: options }
                }

                const isChainArray = Array.isArray(chain)

                Assert(
                    !isChainArray || !options.separator,
                    'Separator option no valid for array-based chain'
                )

                const path = isChainArray
                    ? chain
                    : chain.split(options.separator || '.')
                let ref = obj
                for (let i = 0; i < path.length; ++i) {
                    let key = path[i]
                    const type = options.iterables && internals.iterables(ref)

                    if (Array.isArray(ref) || type === 'set') {
                        const number = Number(key)
                        if (Number.isInteger(number)) {
                            key = number < 0 ? ref.length + number : number
                        }
                    }

                    if (
                        !ref ||
                        (typeof ref === 'function' &&
                            options.functions === false) || // Defaults to true
                        (!type && ref[key] === undefined)
                    ) {
                        Assert(
                            !options.strict || i + 1 === path.length,
                            'Missing segment',
                            key,
                            'in reach path ',
                            chain
                        )
                        Assert(
                            typeof ref === 'object' ||
                                options.functions === true ||
                                typeof ref !== 'function',
                            'Invalid segment',
                            key,
                            'in reach path ',
                            chain
                        )
                        ref = options.default
                        break
                    }

                    if (!type) {
                        ref = ref[key]
                    } else if (type === 'set') {
                        ref = [...ref][key]
                    } else {
                        // type === 'map'
                        ref = ref.get(key)
                    }
                }

                return ref
            }

            internals.iterables = function(ref) {
                if (ref instanceof Set) {
                    return 'set'
                }

                if (ref instanceof Map) {
                    return 'map'
                }
            }

            /***/
        },

        /***/ msIP: /***/ function(module, exports) {
            module.exports = require('stream')

            /***/
        },

        /***/ 'mv/X': /***/ function(module, exports, __webpack_require__) {
            var eq = __webpack_require__('ljhN'),
                isArrayLike = __webpack_require__('MMmD'),
                isIndex = __webpack_require__('wJg7'),
                isObject = __webpack_require__('GoyQ')

            /**
             * Checks if the given arguments are from an iteratee call.
             *
             * @private
             * @param {*} value The potential iteratee value argument.
             * @param {*} index The potential iteratee index or key argument.
             * @param {*} object The potential iteratee object argument.
             * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
             *  else `false`.
             */
            function isIterateeCall(value, index, object) {
                if (!isObject(object)) {
                    return false
                }
                var type = typeof index
                if (
                    type == 'number'
                        ? isArrayLike(object) && isIndex(index, object.length)
                        : type == 'string' && index in object
                ) {
                    return eq(object[index], value)
                }
                return false
            }

            module.exports = isIterateeCall

            /***/
        },

        /***/ 'mw/K': /***/ function(module, exports) {
            module.exports = require('fs')

            /***/
        },

        /***/ mwIZ: /***/ function(module, exports, __webpack_require__) {
            var baseGet = __webpack_require__('ZWtO')

            /**
             * Gets the value at `path` of `object`. If the resolved value is
             * `undefined`, the `defaultValue` is returned in its place.
             *
             * @static
             * @memberOf _
             * @since 3.7.0
             * @category Object
             * @param {Object} object The object to query.
             * @param {Array|string} path The path of the property to get.
             * @param {*} [defaultValue] The value returned for `undefined` resolved values.
             * @returns {*} Returns the resolved value.
             * @example
             *
             * var object = { 'a': [{ 'b': { 'c': 3 } }] };
             *
             * _.get(object, 'a[0].b.c');
             * // => 3
             *
             * _.get(object, ['a', '0', 'b', 'c']);
             * // => 3
             *
             * _.get(object, 'a.b.c', 'default');
             * // => 'default'
             */
            function get(object, path, defaultValue) {
                var result = object == null ? undefined : baseGet(object, path)
                return result === undefined ? defaultValue : result
            }

            module.exports = get

            /***/
        },

        /***/ mxNO: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const EventEmitter = __webpack_require__('/0p4')
            const JSONB = __webpack_require__('F/5w')

            const loadStore = opts => {
                const adapters = {
                    redis: '@keyv/redis',
                    mongodb: '@keyv/mongo',
                    mongo: '@keyv/mongo',
                    sqlite: '@keyv/sqlite',
                    postgresql: '@keyv/postgres',
                    postgres: '@keyv/postgres',
                    mysql: '@keyv/mysql'
                }
                if (opts.adapter || opts.uri) {
                    const adapter = opts.adapter || /^[^:]*/.exec(opts.uri)[0]
                    return new (__webpack_require__('qIYm')(adapters[adapter]))(
                        opts
                    )
                }
                return new Map()
            }

            class Keyv extends EventEmitter {
                constructor(uri, opts) {
                    super()
                    this.opts = Object.assign(
                        {
                            namespace: 'keyv',
                            serialize: JSONB.stringify,
                            deserialize: JSONB.parse
                        },
                        typeof uri === 'string' ? { uri } : uri,
                        opts
                    )

                    if (!this.opts.store) {
                        const adapterOpts = Object.assign({}, this.opts)
                        this.opts.store = loadStore(adapterOpts)
                    }

                    if (typeof this.opts.store.on === 'function') {
                        this.opts.store.on('error', err =>
                            this.emit('error', err)
                        )
                    }

                    this.opts.store.namespace = this.opts.namespace
                }

                _getKeyPrefix(key) {
                    return `${this.opts.namespace}:${key}`
                }

                get(key) {
                    key = this._getKeyPrefix(key)
                    const store = this.opts.store
                    return Promise.resolve()
                        .then(() => store.get(key))
                        .then(data => {
                            data =
                                typeof data === 'string'
                                    ? this.opts.deserialize(data)
                                    : data
                            if (data === undefined) {
                                return undefined
                            }
                            if (
                                typeof data.expires === 'number' &&
                                Date.now() > data.expires
                            ) {
                                this.delete(key)
                                return undefined
                            }
                            return data.value
                        })
                }

                set(key, value, ttl) {
                    key = this._getKeyPrefix(key)
                    if (typeof ttl === 'undefined') {
                        ttl = this.opts.ttl
                    }
                    if (ttl === 0) {
                        ttl = undefined
                    }
                    const store = this.opts.store

                    return Promise.resolve()
                        .then(() => {
                            const expires =
                                typeof ttl === 'number'
                                    ? Date.now() + ttl
                                    : null
                            value = { value, expires }
                            return store.set(
                                key,
                                this.opts.serialize(value),
                                ttl
                            )
                        })
                        .then(() => true)
                }

                delete(key) {
                    key = this._getKeyPrefix(key)
                    const store = this.opts.store
                    return Promise.resolve().then(() => store.delete(key))
                }

                clear() {
                    const store = this.opts.store
                    return Promise.resolve().then(() => store.clear())
                }
            }

            module.exports = Keyv

            /***/
        },

        /***/ n8pu: /***/ function(module, exports, __webpack_require__) {
            const { improvedDH } = __webpack_require__('pDDt')
            const { KEYOBJECT } = __webpack_require__('ehsS')
            const { generateSync } = __webpack_require__('LDEB')
            const { name: secp256k1 } = __webpack_require__('F/JS')
            const { ECDH_DERIVE_LENGTHS } = __webpack_require__('N+nT')

            const derive = __webpack_require__('kZLX')

            const wrapKey = (wrap, derive, key, payload) => {
                const epk = generateSync(key.kty, key.crv)

                const derivedKey = derive(epk, key, payload)

                const result = wrap({ [KEYOBJECT]: derivedKey }, payload)
                result.header = result.header || {}
                Object.assign(result.header, {
                    epk: { kty: key.kty, crv: key.crv, x: epk.x, y: epk.y }
                })

                return result
            }

            const unwrapKey = (unwrap, derive, key, payload, header) => {
                const { epk } = header
                const derivedKey = derive(key, epk, header)

                return unwrap({ [KEYOBJECT]: derivedKey }, payload, header)
            }

            module.exports = (JWA, JWK) => {
                ;['ECDH-ES+A128KW', 'ECDH-ES+A192KW', 'ECDH-ES+A256KW'].forEach(
                    jwaAlg => {
                        const kw = jwaAlg.substr(-6)
                        const kwWrap = JWA.keyManagementEncrypt.get(kw)
                        const kwUnwrap = JWA.keyManagementDecrypt.get(kw)
                        const keylen = parseInt(jwaAlg.substr(9, 3), 10)
                        ECDH_DERIVE_LENGTHS.set(jwaAlg, keylen)

                        if (kwWrap && kwUnwrap) {
                            JWA.keyManagementEncrypt.set(
                                jwaAlg,
                                wrapKey.bind(
                                    undefined,
                                    kwWrap,
                                    derive.bind(undefined, jwaAlg, keylen)
                                )
                            )
                            JWA.keyManagementDecrypt.set(
                                jwaAlg,
                                unwrapKey.bind(
                                    undefined,
                                    kwUnwrap,
                                    derive.bind(undefined, jwaAlg, keylen)
                                )
                            )
                            JWK.EC.deriveKey[jwaAlg] = key =>
                                (key.use === 'enc' || key.use === undefined) &&
                                key.crv !== secp256k1

                            if (improvedDH) {
                                JWK.OKP.deriveKey[jwaAlg] = key =>
                                    (key.use === 'enc' ||
                                        key.use === undefined) &&
                                    key.keyObject.asymmetricKeyType.startsWith(
                                        'x'
                                    )
                            }
                        }
                    }
                )
            }
            module.exports.wrapKey = wrapKey
            module.exports.unwrapKey = unwrapKey

            /***/
        },

        /***/ nK8a: /***/ function(module) {
            module.exports = JSON.parse(
                '{"name":"openid-client","version":"3.13.0","description":"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs","keywords":["auth","authentication","basic","certified","client","connect","dynamic","electron","hybrid","identity","implicit","oauth","oauth2","oidc","openid","passport","relying party","strategy"],"homepage":"https://github.com/panva/node-openid-client","repository":"panva/node-openid-client","license":"MIT","author":"Filip Skokan <panva.ip@gmail.com>","files":["lib","types/index.d.ts"],"funding":"https://github.com/sponsors/panva","main":"lib/index.js","types":"types/index.d.ts","scripts":{"coverage":"nyc mocha test/**/*.test.js","lint":"eslint lib test && dtslint types","lint-fix":"eslint lib test --fix","test":"mocha test/**/*.test.js"},"dependencies":{"@types/got":"^9.6.9","base64url":"^3.0.1","got":"^9.6.0","jose":"^1.23.0","lodash":"^4.17.15","lru-cache":"^5.1.1","make-error":"^1.3.5","object-hash":"^2.0.1","oidc-token-hash":"^5.0.0","p-any":"^2.1.0"},"devDependencies":{"@commitlint/cli":"^8.3.4","@commitlint/config-conventional":"^8.3.4","@types/passport":"^1.0.2","chai":"^4.2.0","dtslint":"^2.0.5","eslint":"^6.8.0","eslint-config-airbnb-base":"^14.0.0","eslint-plugin-import":"^2.19.1","husky":"^4.0.0","mocha":"^7.0.0","nock":"^11.7.1","nyc":"^15.0.0","readable-mock-req":"^0.2.2","sinon":"^8.0.4","timekeeper":"^2.2.0"},"engines":{"node":"^10.13.0 || >=12.0.0"},"commitlint":{"extends":["@commitlint/config-conventional"]},"husky":{"hooks":{"commit-msg":"commitlint -E HUSKY_GIT_PARAMS"}},"nyc":{"reporter":["lcov","text-summary"]}}'
            )

            /***/
        },

        /***/ nmnc: /***/ function(module, exports, __webpack_require__) {
            var root = __webpack_require__('Kz5y')

            /** Built-in value references. */
            var Symbol = root.Symbol

            module.exports = Symbol

            /***/
        },

        /***/ 'o/Eg': /***/ function(module, exports) {
            module.exports = (AlgorithmIdentifier, PrivateKey) =>
                function() {
                    this.seq().obj(
                        this.key('version').int(),
                        this.key('algorithm').use(AlgorithmIdentifier),
                        this.key('privateKey').use(PrivateKey)
                    )
                }

            /***/
        },

        /***/ o156: /***/ function(module, exports) {
            const minute = 60
            const hour = minute * 60
            const day = hour * 24
            const week = day * 7
            const year = day * 365.25

            const REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i

            module.exports = str => {
                const matched = REGEX.exec(str)

                if (!matched) {
                    throw new TypeError(`invalid time period format ("${str}")`)
                }

                const value = parseFloat(matched[1])
                const unit = matched[2].toLowerCase()

                switch (unit) {
                    case 'sec':
                    case 'secs':
                    case 'second':
                    case 'seconds':
                    case 's':
                        return Math.round(value)
                    case 'minute':
                    case 'minutes':
                    case 'min':
                    case 'mins':
                    case 'm':
                        return Math.round(value * minute)
                    case 'hour':
                    case 'hours':
                    case 'hr':
                    case 'hrs':
                    case 'h':
                        return Math.round(value * hour)
                    case 'day':
                    case 'days':
                    case 'd':
                        return Math.round(value * day)
                    case 'week':
                    case 'weeks':
                    case 'w':
                        return Math.round(value * week)
                    case 'year':
                    case 'years':
                    case 'yr':
                    case 'yrs':
                    case 'y':
                        return Math.round(value * year)
                }
            }

            /***/
        },

        /***/ 'oCl/': /***/ function(module, exports, __webpack_require__) {
            var arrayPush = __webpack_require__('CH3K'),
                getPrototype = __webpack_require__('LcsW'),
                getSymbols = __webpack_require__('MvSz'),
                stubArray = __webpack_require__('0ycA')

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeGetSymbols = Object.getOwnPropertySymbols

            /**
             * Creates an array of the own and inherited enumerable symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of symbols.
             */
            var getSymbolsIn = !nativeGetSymbols
                ? stubArray
                : function(object) {
                      var result = []
                      while (object) {
                          arrayPush(result, getSymbols(object))
                          object = getPrototype(object)
                      }
                      return result
                  }

            module.exports = getSymbolsIn

            /***/
        },

        /***/ oGTz: /***/ function(module, exports, __webpack_require__) {
            const errors = __webpack_require__('yt7c')
            const Key = __webpack_require__('//Cd')
            const importKey = __webpack_require__('GhER')
            const { KeyStore } = __webpack_require__('aIoy')

            module.exports = (input, keyStoreAllowed = false) => {
                if (input instanceof Key) {
                    return input
                }

                if (input instanceof KeyStore) {
                    if (!keyStoreAllowed) {
                        throw new TypeError(
                            'key argument for this operation must not be a JWKS.KeyStore instance'
                        )
                    }

                    return input
                }

                try {
                    return importKey(input)
                } catch (err) {
                    if (
                        err instanceof errors.JOSEError &&
                        !(err instanceof errors.JWKImportFailed)
                    ) {
                        throw err
                    }

                    let msg
                    if (keyStoreAllowed) {
                        msg =
                            'key must be an instance of a key instantiated by JWK.asKey, a valid JWK.asKey input, or a JWKS.KeyStore instance'
                    } else {
                        msg =
                            'key must be an instance of a key instantiated by JWK.asKey, or a valid JWK.asKey input'
                    }

                    throw new TypeError(msg)
                }
            }

            /***/
        },

        /***/ oKwy: /***/ function(module, exports) {
            /** Error message constants. */
            var FUNC_ERROR_TEXT = 'Expected a function'

            /**
             * Creates a function that negates the result of the predicate `func`. The
             * `func` predicate is invoked with the `this` binding and arguments of the
             * created function.
             *
             * @static
             * @memberOf _
             * @since 3.0.0
             * @category Function
             * @param {Function} predicate The predicate to negate.
             * @returns {Function} Returns the new negated function.
             * @example
             *
             * function isEven(n) {
             *   return n % 2 == 0;
             * }
             *
             * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
             * // => [1, 3, 5]
             */
            function negate(predicate) {
                if (typeof predicate != 'function') {
                    throw new TypeError(FUNC_ERROR_TEXT)
                }
                return function() {
                    var args = arguments
                    switch (args.length) {
                        case 0:
                            return !predicate.call(this)
                        case 1:
                            return !predicate.call(this, args[0])
                        case 2:
                            return !predicate.call(this, args[0], args[1])
                        case 3:
                            return !predicate.call(
                                this,
                                args[0],
                                args[1],
                                args[2]
                            )
                    }
                    return !predicate.apply(this, args)
                }
            }

            module.exports = negate

            /***/
        },

        /***/ or5M: /***/ function(module, exports, __webpack_require__) {
            var SetCache = __webpack_require__('1hJj'),
                arraySome = __webpack_require__('QoRX'),
                cacheHas = __webpack_require__('xYSL')

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1,
                COMPARE_UNORDERED_FLAG = 2

            /**
             * A specialized version of `baseIsEqualDeep` for arrays with support for
             * partial deep comparisons.
             *
             * @private
             * @param {Array} array The array to compare.
             * @param {Array} other The other array to compare.
             * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
             * @param {Function} customizer The function to customize comparisons.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Object} stack Tracks traversed `array` and `other` objects.
             * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
             */
            function equalArrays(
                array,
                other,
                bitmask,
                customizer,
                equalFunc,
                stack
            ) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                    arrLength = array.length,
                    othLength = other.length

                if (
                    arrLength != othLength &&
                    !(isPartial && othLength > arrLength)
                ) {
                    return false
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(array)
                if (stacked && stack.get(other)) {
                    return stacked == other
                }
                var index = -1,
                    result = true,
                    seen =
                        bitmask & COMPARE_UNORDERED_FLAG
                            ? new SetCache()
                            : undefined

                stack.set(array, other)
                stack.set(other, array)

                // Ignore non-index properties.
                while (++index < arrLength) {
                    var arrValue = array[index],
                        othValue = other[index]

                    if (customizer) {
                        var compared = isPartial
                            ? customizer(
                                  othValue,
                                  arrValue,
                                  index,
                                  other,
                                  array,
                                  stack
                              )
                            : customizer(
                                  arrValue,
                                  othValue,
                                  index,
                                  array,
                                  other,
                                  stack
                              )
                    }
                    if (compared !== undefined) {
                        if (compared) {
                            continue
                        }
                        result = false
                        break
                    }
                    // Recursively compare arrays (susceptible to call stack limits).
                    if (seen) {
                        if (
                            !arraySome(other, function(othValue, othIndex) {
                                if (
                                    !cacheHas(seen, othIndex) &&
                                    (arrValue === othValue ||
                                        equalFunc(
                                            arrValue,
                                            othValue,
                                            bitmask,
                                            customizer,
                                            stack
                                        ))
                                ) {
                                    return seen.push(othIndex)
                                }
                            })
                        ) {
                            result = false
                            break
                        }
                    } else if (
                        !(
                            arrValue === othValue ||
                            equalFunc(
                                arrValue,
                                othValue,
                                bitmask,
                                customizer,
                                stack
                            )
                        )
                    ) {
                        result = false
                        break
                    }
                }
                stack['delete'](array)
                stack['delete'](other)
                return result
            }

            module.exports = equalArrays

            /***/
        },

        /***/ 'otv/': /***/ function(module, exports, __webpack_require__) {
            var Symbol = __webpack_require__('nmnc')

            /** Used to convert symbols to primitives and strings. */
            var symbolProto = Symbol ? Symbol.prototype : undefined,
                symbolValueOf = symbolProto ? symbolProto.valueOf : undefined

            /**
             * Creates a clone of the `symbol` object.
             *
             * @private
             * @param {Object} symbol The symbol object to clone.
             * @returns {Object} Returns the cloned symbol object.
             */
            function cloneSymbol(symbol) {
                return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
            }

            module.exports = cloneSymbol

            /***/
        },

        /***/ oyvS: /***/ function(module, exports) {
            module.exports = require('path')

            /***/
        },

        /***/ pBmY: /***/ function(module, exports) {
            module.exports = AlgorithmIdentifier =>
                function() {
                    this.seq().obj(
                        this.key('algorithm').use(AlgorithmIdentifier),
                        this.key('publicKey').bitstr()
                    )
                }

            /***/
        },

        /***/ pDDt: /***/ function(module, exports, __webpack_require__) {
            const {
                diffieHellman,
                KeyObject,
                sign,
                verify
            } = __webpack_require__('PJMN')

            const [major, minor] = process.version
                .substr(1)
                .split('.')
                .map(x => parseInt(x, 10))

            module.exports = {
                oaepHashSupported: major > 12 || (major === 12 && minor >= 9),
                keyObjectSupported: !!KeyObject && major >= 12,
                edDSASupported: !!sign && !!verify,
                dsaEncodingSupported:
                    major > 13 ||
                    (major === 13 && minor >= 2) ||
                    (major === 12 && minor >= 16),
                improvedDH: !!diffieHellman
            }

            /***/
        },

        /***/ pFRH: /***/ function(module, exports, __webpack_require__) {
            var constant = __webpack_require__('cvCv'),
                defineProperty = __webpack_require__('O0oS'),
                identity = __webpack_require__('zZ0H')

            /**
             * The base implementation of `setToString` without support for hot loop shorting.
             *
             * @private
             * @param {Function} func The function to modify.
             * @param {Function} string The `toString` result.
             * @returns {Function} Returns `func`.
             */
            var baseSetToString = !defineProperty
                ? identity
                : function(func, string) {
                      return defineProperty(func, 'toString', {
                          configurable: true,
                          enumerable: false,
                          value: constant(string),
                          writable: true
                      })
                  }

            module.exports = baseSetToString

            /***/
        },

        /***/ pSRY: /***/ function(module, exports, __webpack_require__) {
            var getMapData = __webpack_require__('QkVE')

            /**
             * Checks if a map value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf MapCache
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function mapCacheHas(key) {
                return getMapData(this, key).has(key)
            }

            module.exports = mapCacheHas

            /***/
        },

        /***/ pY1j: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var Buffer = __webpack_require__('xZGU').Buffer

            // Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

            // == UTF16-BE codec. ==========================================================

            exports.utf16be = Utf16BECodec
            function Utf16BECodec() {}

            Utf16BECodec.prototype.encoder = Utf16BEEncoder
            Utf16BECodec.prototype.decoder = Utf16BEDecoder
            Utf16BECodec.prototype.bomAware = true

            // -- Encoding

            function Utf16BEEncoder() {}

            Utf16BEEncoder.prototype.write = function(str) {
                var buf = Buffer.from(str, 'ucs2')
                for (var i = 0; i < buf.length; i += 2) {
                    var tmp = buf[i]
                    buf[i] = buf[i + 1]
                    buf[i + 1] = tmp
                }
                return buf
            }

            Utf16BEEncoder.prototype.end = function() {}

            // -- Decoding

            function Utf16BEDecoder() {
                this.overflowByte = -1
            }

            Utf16BEDecoder.prototype.write = function(buf) {
                if (buf.length == 0) return ''

                var buf2 = Buffer.alloc(buf.length + 1),
                    i = 0,
                    j = 0

                if (this.overflowByte !== -1) {
                    buf2[0] = buf[0]
                    buf2[1] = this.overflowByte
                    i = 1
                    j = 2
                }

                for (; i < buf.length - 1; i += 2, j += 2) {
                    buf2[j] = buf[i + 1]
                    buf2[j + 1] = buf[i]
                }

                this.overflowByte =
                    i == buf.length - 1 ? buf[buf.length - 1] : -1

                return buf2.slice(0, j).toString('ucs2')
            }

            Utf16BEDecoder.prototype.end = function() {}

            // == UTF-16 codec =============================================================
            // Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
            // Defaults to UTF-16LE, as it's prevalent and default in Node.
            // http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
            // Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

            // Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

            exports.utf16 = Utf16Codec
            function Utf16Codec(codecOptions, iconv) {
                this.iconv = iconv
            }

            Utf16Codec.prototype.encoder = Utf16Encoder
            Utf16Codec.prototype.decoder = Utf16Decoder

            // -- Encoding (pass-through)

            function Utf16Encoder(options, codec) {
                options = options || {}
                if (options.addBOM === undefined) options.addBOM = true
                this.encoder = codec.iconv.getEncoder('utf-16le', options)
            }

            Utf16Encoder.prototype.write = function(str) {
                return this.encoder.write(str)
            }

            Utf16Encoder.prototype.end = function() {
                return this.encoder.end()
            }

            // -- Decoding

            function Utf16Decoder(options, codec) {
                this.decoder = null
                this.initialBytes = []
                this.initialBytesLen = 0

                this.options = options || {}
                this.iconv = codec.iconv
            }

            Utf16Decoder.prototype.write = function(buf) {
                if (!this.decoder) {
                    // Codec is not chosen yet. Accumulate initial bytes.
                    this.initialBytes.push(buf)
                    this.initialBytesLen += buf.length

                    if (this.initialBytesLen < 16)
                        // We need more bytes to use space heuristic (see below)
                        return ''

                    // We have enough bytes -> detect endianness.
                    var buf = Buffer.concat(this.initialBytes),
                        encoding = detectEncoding(
                            buf,
                            this.options.defaultEncoding
                        )
                    this.decoder = this.iconv.getDecoder(encoding, this.options)
                    this.initialBytes.length = this.initialBytesLen = 0
                }

                return this.decoder.write(buf)
            }

            Utf16Decoder.prototype.end = function() {
                if (!this.decoder) {
                    var buf = Buffer.concat(this.initialBytes),
                        encoding = detectEncoding(
                            buf,
                            this.options.defaultEncoding
                        )
                    this.decoder = this.iconv.getDecoder(encoding, this.options)

                    var res = this.decoder.write(buf),
                        trail = this.decoder.end()

                    return trail ? res + trail : res
                }
                return this.decoder.end()
            }

            function detectEncoding(buf, defaultEncoding) {
                var enc = defaultEncoding || 'utf-16le'

                if (buf.length >= 2) {
                    // Check BOM.
                    if (buf[0] == 0xfe && buf[1] == 0xff)
                        // UTF-16BE BOM
                        enc = 'utf-16be'
                    else if (buf[0] == 0xff && buf[1] == 0xfe)
                        // UTF-16LE BOM
                        enc = 'utf-16le'
                    else {
                        // No BOM found. Try to deduce encoding from initial content.
                        // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
                        // So, we count ASCII as if it was LE or BE, and decide from that.
                        var asciiCharsLE = 0,
                            asciiCharsBE = 0, // Counts of chars in both positions
                            _len = Math.min(buf.length - (buf.length % 2), 64) // Len is always even.

                        for (var i = 0; i < _len; i += 2) {
                            if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++
                            if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++
                        }

                        if (asciiCharsBE > asciiCharsLE) enc = 'utf-16be'
                        else if (asciiCharsBE < asciiCharsLE) enc = 'utf-16le'
                    }
                }

                return enc
            }

            /***/
        },

        /***/ q1Jy: /***/ function(module, exports, __webpack_require__) {
            var once = __webpack_require__('VmuJ')

            var noop = function() {}

            var isRequest = function(stream) {
                return stream.setHeader && typeof stream.abort === 'function'
            }

            var isChildProcess = function(stream) {
                return (
                    stream.stdio &&
                    Array.isArray(stream.stdio) &&
                    stream.stdio.length === 3
                )
            }

            var eos = function(stream, opts, callback) {
                if (typeof opts === 'function') return eos(stream, null, opts)
                if (!opts) opts = {}

                callback = once(callback || noop)

                var ws = stream._writableState
                var rs = stream._readableState
                var readable =
                    opts.readable ||
                    (opts.readable !== false && stream.readable)
                var writable =
                    opts.writable ||
                    (opts.writable !== false && stream.writable)
                var cancelled = false

                var onlegacyfinish = function() {
                    if (!stream.writable) onfinish()
                }

                var onfinish = function() {
                    writable = false
                    if (!readable) callback.call(stream)
                }

                var onend = function() {
                    readable = false
                    if (!writable) callback.call(stream)
                }

                var onexit = function(exitCode) {
                    callback.call(
                        stream,
                        exitCode
                            ? new Error('exited with error code: ' + exitCode)
                            : null
                    )
                }

                var onerror = function(err) {
                    callback.call(stream, err)
                }

                var onclose = function() {
                    process.nextTick(onclosenexttick)
                }

                var onclosenexttick = function() {
                    if (cancelled) return
                    if (readable && !(rs && rs.ended && !rs.destroyed))
                        return callback.call(
                            stream,
                            new Error('premature close')
                        )
                    if (writable && !(ws && ws.ended && !ws.destroyed))
                        return callback.call(
                            stream,
                            new Error('premature close')
                        )
                }

                var onrequest = function() {
                    stream.req.on('finish', onfinish)
                }

                if (isRequest(stream)) {
                    stream.on('complete', onfinish)
                    stream.on('abort', onclose)
                    if (stream.req) onrequest()
                    else stream.on('request', onrequest)
                } else if (writable && !ws) {
                    // legacy streams
                    stream.on('end', onlegacyfinish)
                    stream.on('close', onlegacyfinish)
                }

                if (isChildProcess(stream)) stream.on('exit', onexit)

                stream.on('end', onend)
                stream.on('finish', onfinish)
                if (opts.error !== false) stream.on('error', onerror)
                stream.on('close', onclose)

                return function() {
                    cancelled = true
                    stream.removeListener('complete', onfinish)
                    stream.removeListener('abort', onclose)
                    stream.removeListener('request', onrequest)
                    if (stream.req)
                        stream.req.removeListener('finish', onfinish)
                    stream.removeListener('end', onlegacyfinish)
                    stream.removeListener('close', onlegacyfinish)
                    stream.removeListener('finish', onfinish)
                    stream.removeListener('exit', onexit)
                    stream.removeListener('end', onend)
                    stream.removeListener('error', onerror)
                    stream.removeListener('close', onclose)
                }
            }

            module.exports = eos

            /***/
        },

        /***/ q2Us: /***/ function(module, exports, __webpack_require__) {
            const { pbkdf2Sync: pbkdf2, randomBytes } = __webpack_require__(
                'PJMN'
            )

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const base64url = __webpack_require__('Xab3')

            const SALT_LENGTH = 16
            const NULL_BUFFER = Buffer.alloc(1, 0)

            const concatSalt = (alg, p2s) => {
                return Buffer.concat([
                    Buffer.from(alg, 'utf8'),
                    NULL_BUFFER,
                    p2s
                ])
            }

            const wrapKey = (
                keylen,
                sha,
                concat,
                wrap,
                { [KEYOBJECT]: keyObject },
                payload
            ) => {
                // Note that if password-based encryption is used for multiple
                // recipients, it is expected that each recipient use different values
                // for the PBES2 parameters "p2s" and "p2c".
                // here we generate p2c between 2048 and 4096 and random p2s
                const p2c = Math.floor(Math.random() * 2049 + 2048)
                const p2s = randomBytes(SALT_LENGTH)
                const salt = concat(p2s)

                const derivedKey = pbkdf2(
                    keyObject.export(),
                    salt,
                    p2c,
                    keylen,
                    sha
                )

                const result = wrap({ [KEYOBJECT]: derivedKey }, payload)
                result.header = result.header || {}
                Object.assign(result.header, {
                    p2c,
                    p2s: base64url.encodeBuffer(p2s)
                })

                return result
            }

            const unwrapKey = (
                keylen,
                sha,
                concat,
                unwrap,
                { [KEYOBJECT]: keyObject },
                payload,
                header
            ) => {
                const { p2s, p2c } = header
                const salt = concat(p2s)
                const derivedKey = pbkdf2(
                    keyObject.export(),
                    salt,
                    p2c,
                    keylen,
                    sha
                )
                return unwrap({ [KEYOBJECT]: derivedKey }, payload, header)
            }

            module.exports = (JWA, JWK) => {
                ;[
                    'PBES2-HS256+A128KW',
                    'PBES2-HS384+A192KW',
                    'PBES2-HS512+A256KW'
                ].forEach(jwaAlg => {
                    const kw = jwaAlg.substr(-6)
                    const kwWrap = JWA.keyManagementEncrypt.get(kw)
                    const kwUnwrap = JWA.keyManagementDecrypt.get(kw)
                    const keylen = parseInt(jwaAlg.substr(13, 3), 10) / 8
                    const sha = `sha${jwaAlg.substr(8, 3)}`

                    if (kwWrap && kwUnwrap) {
                        JWA.keyManagementEncrypt.set(
                            jwaAlg,
                            wrapKey.bind(
                                undefined,
                                keylen,
                                sha,
                                concatSalt.bind(undefined, jwaAlg),
                                kwWrap
                            )
                        )
                        JWA.keyManagementDecrypt.set(
                            jwaAlg,
                            unwrapKey.bind(
                                undefined,
                                keylen,
                                sha,
                                concatSalt.bind(undefined, jwaAlg),
                                kwUnwrap
                            )
                        )
                        JWK.oct.deriveKey[jwaAlg] = key =>
                            key.use === 'enc' || key.use === undefined
                    }
                })
            }

            /***/
        },

        /***/ qIYm: /***/ function(module, exports) {
            function webpackEmptyContext(req) {
                var e = new Error("Cannot find module '" + req + "'")
                e.code = 'MODULE_NOT_FOUND'
                throw e
            }
            webpackEmptyContext.keys = function() {
                return []
            }
            webpackEmptyContext.resolve = webpackEmptyContext
            module.exports = webpackEmptyContext
            webpackEmptyContext.id = 'qIYm'

            /***/
        },

        /***/ qQzh: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const iron_1 = tslib_1.__importDefault(__webpack_require__('ClL1'))
            const session_1 = tslib_1.__importDefault(
                __webpack_require__('gt9x')
            )
            const cookies_1 = __webpack_require__('gKi1')
            class CookieSessionStore {
                constructor(settings) {
                    this.settings = settings
                }
                /**
                 * Read the session from the cookie.
                 * @param req HTTP request
                 */
                read(req) {
                    return tslib_1.__awaiter(this, void 0, void 0, function*() {
                        const { cookieSecret, cookieName } = this.settings
                        const cookies = cookies_1.parseCookies(req)
                        const cookie = cookies[cookieName]
                        if (!cookie || cookie.length === 0) {
                            return null
                        }
                        const unsealed = yield iron_1.default.unseal(
                            cookies[cookieName],
                            cookieSecret,
                            iron_1.default.defaults
                        )
                        if (!unsealed) {
                            return null
                        }
                        return unsealed
                    })
                }
                /**
                 * Write the session to the cookie.
                 * @param req HTTP request
                 */
                save(req, res, session) {
                    return tslib_1.__awaiter(this, void 0, void 0, function*() {
                        const {
                            cookieSecret,
                            cookieName,
                            cookiePath,
                            cookieLifetime
                        } = this.settings
                        const {
                            idToken,
                            accessToken,
                            refreshToken,
                            user,
                            createdAt
                        } = session
                        const persistedSession = new session_1.default(
                            user,
                            createdAt
                        )
                        if (this.settings.storeIdToken && idToken) {
                            persistedSession.idToken = idToken
                        }
                        if (this.settings.storeAccessToken && accessToken) {
                            persistedSession.accessToken = accessToken
                        }
                        if (this.settings.storeRefreshToken && refreshToken) {
                            persistedSession.refreshToken = refreshToken
                        }
                        const encryptedSession = yield iron_1.default.seal(
                            persistedSession,
                            cookieSecret,
                            iron_1.default.defaults
                        )
                        cookies_1.setCookie(req, res, {
                            name: cookieName,
                            value: encryptedSession,
                            path: cookiePath,
                            maxAge: cookieLifetime
                        })
                    })
                }
            }
            exports.default = CookieSessionStore
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ qSBP: /***/ function(module, exports, __webpack_require__) {
            const { inspect } = __webpack_require__('jK02')

            const Key = __webpack_require__('//Cd')

            class NoneKey extends Key {
                constructor() {
                    super({ type: 'unsecured' }, { alg: 'none' })
                    Object.defineProperties(this, {
                        kid: { value: undefined },
                        thumbprint: { value: undefined },
                        toJWK: { value: undefined },
                        toPEM: { value: undefined }
                    })
                }

                /* c8 ignore next 3 */
                [inspect.custom]() {
                    return 'None {}'
                }

                algorithms(operation) {
                    switch (operation) {
                        case 'sign':
                        case 'verify':
                        case undefined:
                            return new Set(['none'])
                        default:
                            return new Set()
                    }
                }
            }

            module.exports = new NoneKey({ type: 'unsecured' }, { alg: 'none' })

            /***/
        },

        /***/ qXE0: /***/ function(module, exports, __webpack_require__) {
            const verify = __webpack_require__('BOd6')

            module.exports = {
                IdToken: {
                    verify: (token, key, options) =>
                        verify(token, key, { ...options, profile: 'id_token' })
                },
                LogoutToken: {
                    verify: (token, key, options) =>
                        verify(token, key, {
                            ...options,
                            profile: 'logout_token'
                        })
                },
                AccessToken: {
                    verify: (token, key, options) =>
                        verify(token, key, { ...options, profile: 'at+JWT' })
                }
            }

            /***/
        },

        /***/ qZTm: /***/ function(module, exports, __webpack_require__) {
            var baseGetAllKeys = __webpack_require__('fR/l'),
                getSymbols = __webpack_require__('MvSz'),
                keys = __webpack_require__('7GkX')

            /**
             * Creates an array of own enumerable property names and symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names and symbols.
             */
            function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols)
            }

            module.exports = getAllKeys

            /***/
        },

        /***/ qnp3: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Types = __webpack_require__('gdNv')
            const Utils = __webpack_require__('O0PD')

            const internals = {
                needsProtoHack: new Set([
                    Types.set,
                    Types.map,
                    Types.weakSet,
                    Types.weakMap
                ])
            }

            module.exports = internals.clone = function(
                obj,
                options = {},
                _seen = null
            ) {
                if (typeof obj !== 'object' || obj === null) {
                    return obj
                }

                let clone = internals.clone
                let seen = _seen

                if (options.shallow) {
                    if (options.shallow !== true) {
                        return internals.cloneWithShallow(obj, options)
                    }

                    clone = value => value
                } else {
                    seen = seen || new Map()

                    const lookup = seen.get(obj)
                    if (lookup) {
                        return lookup
                    }
                }

                // Built-in object types

                const baseProto = Types.getInternalProto(obj)
                if (baseProto === Types.buffer) {
                    return Buffer && Buffer.from(obj) // $lab:coverage:ignore$
                }

                if (baseProto === Types.date) {
                    return new Date(obj.getTime())
                }

                if (baseProto === Types.regex) {
                    return new RegExp(obj)
                }

                // Generic objects

                const newObj = internals.base(obj, baseProto, options)
                if (newObj === obj) {
                    return obj
                }

                if (seen) {
                    seen.set(obj, newObj) // Set seen, since obj could recurse
                }

                if (baseProto === Types.set) {
                    for (const value of obj) {
                        newObj.add(clone(value, options, seen))
                    }
                } else if (baseProto === Types.map) {
                    for (const [key, value] of obj) {
                        newObj.set(key, clone(value, options, seen))
                    }
                }

                const keys = Utils.keys(obj, options)
                for (const key of keys) {
                    if (key === '__proto__') {
                        continue
                    }

                    if (baseProto === Types.array && key === 'length') {
                        newObj.length = obj.length
                        continue
                    }

                    const descriptor = Object.getOwnPropertyDescriptor(obj, key)
                    if (descriptor) {
                        if (descriptor.get || descriptor.set) {
                            Object.defineProperty(newObj, key, descriptor)
                        } else if (descriptor.enumerable) {
                            newObj[key] = clone(obj[key], options, seen)
                        } else {
                            Object.defineProperty(newObj, key, {
                                enumerable: false,
                                writable: true,
                                configurable: true,
                                value: clone(obj[key], options, seen)
                            })
                        }
                    } else {
                        Object.defineProperty(newObj, key, {
                            enumerable: true,
                            writable: true,
                            configurable: true,
                            value: clone(obj[key], options, seen)
                        })
                    }
                }

                return newObj
            }

            internals.cloneWithShallow = function(source, options) {
                const keys = options.shallow
                options = Object.assign({}, options)
                options.shallow = false

                const storage = Utils.store(source, keys) // Move shallow copy items to storage
                const copy = internals.clone(source, options) // Deep copy the rest
                Utils.restore(copy, source, storage) // Shallow copy the stored items and restore
                return copy
            }

            internals.base = function(obj, baseProto, options) {
                if (baseProto === Types.array) {
                    return []
                }

                if (options.prototype === false) {
                    // Defaults to true
                    if (internals.needsProtoHack.has(baseProto)) {
                        return new baseProto.constructor()
                    }

                    return {}
                }

                const proto = Object.getPrototypeOf(obj)
                if (proto && proto.isImmutable) {
                    return obj
                }

                if (internals.needsProtoHack.has(baseProto)) {
                    const newObj = new proto.constructor()
                    if (proto !== baseProto) {
                        Object.setPrototypeOf(newObj, proto)
                    }

                    return newObj
                }

                return Object.create(proto)
            }

            /***/
        },

        /***/ qsvm: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // We define these manually to ensure they're always copied
            // even if they would move up the prototype chain
            // https://nodejs.org/api/http.html#http_class_http_incomingmessage
            const knownProps = [
                'destroy',
                'setTimeout',
                'socket',
                'headers',
                'trailers',
                'rawHeaders',
                'statusCode',
                'httpVersion',
                'httpVersionMinor',
                'httpVersionMajor',
                'rawTrailers',
                'statusMessage'
            ]

            module.exports = (fromStream, toStream) => {
                const fromProps = new Set(
                    Object.keys(fromStream).concat(knownProps)
                )

                for (const prop of fromProps) {
                    // Don't overwrite existing properties
                    if (prop in toStream) {
                        continue
                    }

                    toStream[prop] =
                        typeof fromStream[prop] === 'function'
                            ? fromStream[prop].bind(fromStream)
                            : fromStream[prop]
                }
            }

            /***/
        },

        /***/ qwdb: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            function initAuth0(settings) {
                const isBrowser = typeof window !== 'undefined' || false
                if (isBrowser) {
                    return __webpack_require__('6gLP').default(settings)
                }
                return __webpack_require__('+du+').default(settings)
            }
            exports.initAuth0 = initAuth0
            /**
             * @deprecated useAuth0 has been deprecated in favor of initAuth0
             */
            exports.useAuth0 = initAuth0
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ rEGp: /***/ function(module, exports) {
            /**
             * Converts `set` to an array of its values.
             *
             * @private
             * @param {Object} set The set to convert.
             * @returns {Array} Returns the values.
             */
            function setToArray(set) {
                var index = -1,
                    result = Array(set.size)

                set.forEach(function(value) {
                    result[++index] = value
                })
                return result
            }

            module.exports = setToArray

            /***/
        },

        /***/ rMgD: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = internals.Bench = class {
                constructor() {
                    this.ts = 0
                    this.reset()
                }

                reset() {
                    this.ts = internals.Bench.now()
                }

                elapsed() {
                    return internals.Bench.now() - this.ts
                }

                static now() {
                    const ts = process.hrtime()
                    return ts[0] * 1e3 + ts[1] / 1e6
                }
            }

            /***/
        },

        /***/ rPnE: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // Some environments don't have global Buffer (e.g. React Native).
            // Solution would be installing npm modules "buffer" and "stream" explicitly.
            var Buffer = __webpack_require__('xZGU').Buffer

            var bomHandling = __webpack_require__('uCqB'),
                iconv = module.exports

            // All codecs and aliases are kept here, keyed by encoding name/alias.
            // They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
            iconv.encodings = null

            // Characters emitted in case of error.
            iconv.defaultCharUnicode = ''
            iconv.defaultCharSingleByte = '?'

            // Public API.
            iconv.encode = function encode(str, encoding, options) {
                str = '' + (str || '') // Ensure string.

                var encoder = iconv.getEncoder(encoding, options)

                var res = encoder.write(str)
                var trail = encoder.end()

                return trail && trail.length > 0
                    ? Buffer.concat([res, trail])
                    : res
            }

            iconv.decode = function decode(buf, encoding, options) {
                if (typeof buf === 'string') {
                    if (!iconv.skipDecodeWarning) {
                        console.error(
                            'Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding'
                        )
                        iconv.skipDecodeWarning = true
                    }

                    buf = Buffer.from('' + (buf || ''), 'binary') // Ensure buffer.
                }

                var decoder = iconv.getDecoder(encoding, options)

                var res = decoder.write(buf)
                var trail = decoder.end()

                return trail ? res + trail : res
            }

            iconv.encodingExists = function encodingExists(enc) {
                try {
                    iconv.getCodec(enc)
                    return true
                } catch (e) {
                    return false
                }
            }

            // Legacy aliases to convert functions
            iconv.toEncoding = iconv.encode
            iconv.fromEncoding = iconv.decode

            // Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
            iconv._codecDataCache = {}
            iconv.getCodec = function getCodec(encoding) {
                if (!iconv.encodings)
                    iconv.encodings = __webpack_require__('lLtp') // Lazy load all encoding definitions.

                // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
                var enc = iconv._canonicalizeEncoding(encoding)

                // Traverse iconv.encodings to find actual codec.
                var codecOptions = {}
                while (true) {
                    var codec = iconv._codecDataCache[enc]
                    if (codec) return codec

                    var codecDef = iconv.encodings[enc]

                    switch (typeof codecDef) {
                        case 'string': // Direct alias to other encoding.
                            enc = codecDef
                            break

                        case 'object': // Alias with options. Can be layered.
                            for (var key in codecDef)
                                codecOptions[key] = codecDef[key]

                            if (!codecOptions.encodingName)
                                codecOptions.encodingName = enc

                            enc = codecDef.type
                            break

                        case 'function': // Codec itself.
                            if (!codecOptions.encodingName)
                                codecOptions.encodingName = enc

                            // The codec function must load all tables and return object with .encoder and .decoder methods.
                            // It'll be called only once (for each different options object).
                            codec = new codecDef(codecOptions, iconv)

                            iconv._codecDataCache[
                                codecOptions.encodingName
                            ] = codec // Save it to be reused later.
                            return codec

                        default:
                            throw new Error(
                                "Encoding not recognized: '" +
                                    encoding +
                                    "' (searched as: '" +
                                    enc +
                                    "')"
                            )
                    }
                }
            }

            iconv._canonicalizeEncoding = function(encoding) {
                // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
                return ('' + encoding)
                    .toLowerCase()
                    .replace(/:\d{4}$|[^0-9a-z]/g, '')
            }

            iconv.getEncoder = function getEncoder(encoding, options) {
                var codec = iconv.getCodec(encoding),
                    encoder = new codec.encoder(options, codec)

                if (codec.bomAware && options && options.addBOM)
                    encoder = new bomHandling.PrependBOM(encoder, options)

                return encoder
            }

            iconv.getDecoder = function getDecoder(encoding, options) {
                var codec = iconv.getCodec(encoding),
                    decoder = new codec.decoder(options, codec)

                if (codec.bomAware && !(options && options.stripBOM === false))
                    decoder = new bomHandling.StripBOM(decoder, options)

                return decoder
            }

            // Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
            var nodeVer =
                typeof process !== 'undefined' &&
                process.versions &&
                process.versions.node
            if (nodeVer) {
                // Load streaming support in Node v0.10+
                var nodeVerArr = nodeVer.split('.').map(Number)
                if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
                    __webpack_require__('JwZZ')(iconv)
                }

                // Load Node primitive extensions.
                __webpack_require__('c21q')(iconv)
            }

            if (false) {
            }

            /***/
        },

        /***/ rr1i: /***/ function(module, exports) {
            module.exports = function(bitmap, value) {
                return {
                    enumerable: !(bitmap & 1),
                    configurable: !(bitmap & 2),
                    writable: !(bitmap & 4),
                    value: value
                }
            }

            /***/
        },

        /***/ s8OG: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = internals.flatten = function(array, target) {
                const result = target || []

                for (let i = 0; i < array.length; ++i) {
                    if (Array.isArray(array[i])) {
                        internals.flatten(array[i], result)
                    } else {
                        result.push(array[i])
                    }
                }

                return result
            }

            /***/
        },

        /***/ sEf8: /***/ function(module, exports) {
            /**
             * The base implementation of `_.unary` without support for storing metadata.
             *
             * @private
             * @param {Function} func The function to cap arguments for.
             * @returns {Function} Returns the new capped function.
             */
            function baseUnary(func) {
                return function(value) {
                    return func(value)
                }
            }

            module.exports = baseUnary

            /***/
        },

        /***/ 'sR+5': /***/ function(module, exports, __webpack_require__) {
            const Sign = __webpack_require__('l3Iq')
            const { verify } = __webpack_require__('ZXG7')

            const single = (
                serialization,
                payload,
                key,
                protectedHeader,
                unprotectedHeader
            ) => {
                return new Sign(payload)
                    .recipient(key, protectedHeader, unprotectedHeader)
                    .sign(serialization)
            }

            module.exports.Sign = Sign
            module.exports.sign = single.bind(undefined, 'compact')
            module.exports.sign.flattened = single.bind(undefined, 'flattened')
            module.exports.sign.general = single.bind(undefined, 'general')

            module.exports.verify = verify

            /***/
        },

        /***/ sYMc: /***/ function(module, exports) {
            /*!
             * toidentifier
             * Copyright(c) 2016 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module exports.
             * @public
             */

            module.exports = toIdentifier

            /**
             * Trasform the given string into a JavaScript identifier
             *
             * @param {string} str
             * @returns {string}
             * @public
             */

            function toIdentifier(str) {
                return str
                    .split(' ')
                    .map(function(token) {
                        return token.slice(0, 1).toUpperCase() + token.slice(1)
                    })
                    .join('')
                    .replace(/[^ _0-9a-z]/gi, '')
            }

            /***/
        },

        /***/ seXi: /***/ function(module, exports, __webpack_require__) {
            var getAllKeys = __webpack_require__('qZTm')

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * A specialized version of `baseIsEqualDeep` for objects with support for
             * partial deep comparisons.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
             * @param {Function} customizer The function to customize comparisons.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Object} stack Tracks traversed `object` and `other` objects.
             * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
             */
            function equalObjects(
                object,
                other,
                bitmask,
                customizer,
                equalFunc,
                stack
            ) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                    objProps = getAllKeys(object),
                    objLength = objProps.length,
                    othProps = getAllKeys(other),
                    othLength = othProps.length

                if (objLength != othLength && !isPartial) {
                    return false
                }
                var index = objLength
                while (index--) {
                    var key = objProps[index]
                    if (
                        !(isPartial
                            ? key in other
                            : hasOwnProperty.call(other, key))
                    ) {
                        return false
                    }
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object)
                if (stacked && stack.get(other)) {
                    return stacked == other
                }
                var result = true
                stack.set(object, other)
                stack.set(other, object)

                var skipCtor = isPartial
                while (++index < objLength) {
                    key = objProps[index]
                    var objValue = object[key],
                        othValue = other[key]

                    if (customizer) {
                        var compared = isPartial
                            ? customizer(
                                  othValue,
                                  objValue,
                                  key,
                                  other,
                                  object,
                                  stack
                              )
                            : customizer(
                                  objValue,
                                  othValue,
                                  key,
                                  object,
                                  other,
                                  stack
                              )
                    }
                    // Recursively compare objects (susceptible to call stack limits).
                    if (
                        !(compared === undefined
                            ? objValue === othValue ||
                              equalFunc(
                                  objValue,
                                  othValue,
                                  bitmask,
                                  customizer,
                                  stack
                              )
                            : compared)
                    ) {
                        result = false
                        break
                    }
                    skipCtor || (skipCtor = key == 'constructor')
                }
                if (result && !skipCtor) {
                    var objCtor = object.constructor,
                        othCtor = other.constructor

                    // Non `Object` object instances with different constructors are not equal.
                    if (
                        objCtor != othCtor &&
                        'constructor' in object && 'constructor' in other &&
                        !(
                            typeof objCtor == 'function' &&
                            objCtor instanceof objCtor &&
                            typeof othCtor == 'function' &&
                            othCtor instanceof othCtor
                        )
                    ) {
                        result = false
                    }
                }
                stack['delete'](object)
                stack['delete'](other)
                return result
            }

            module.exports = equalObjects

            /***/
        },

        /***/ shjB: /***/ function(module, exports) {
            /** Used as references for various `Number` constants. */
            var MAX_SAFE_INTEGER = 9007199254740991

            /**
             * Checks if `value` is a valid array-like length.
             *
             * **Note:** This method is loosely based on
             * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
             * @example
             *
             * _.isLength(3);
             * // => true
             *
             * _.isLength(Number.MIN_VALUE);
             * // => false
             *
             * _.isLength(Infinity);
             * // => false
             *
             * _.isLength('3');
             * // => false
             */
            function isLength(value) {
                return (
                    typeof value == 'number' &&
                    value > -1 &&
                    value % 1 == 0 &&
                    value <= MAX_SAFE_INTEGER
                )
            }

            module.exports = isLength

            /***/
        },

        /***/ sv2S: /***/ function(module) {
            module.exports = JSON.parse(
                '[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]'
            )

            /***/
        },

        /***/ t2Dn: /***/ function(module, exports, __webpack_require__) {
            var baseAssignValue = __webpack_require__('hypo'),
                eq = __webpack_require__('ljhN')

            /**
             * This function is like `assignValue` except that it doesn't assign
             * `undefined` values.
             *
             * @private
             * @param {Object} object The object to modify.
             * @param {string} key The key of the property to assign.
             * @param {*} value The value to assign.
             */
            function assignMergeValue(object, key, value) {
                if (
                    (value !== undefined && !eq(object[key], value)) ||
                    (value === undefined && !(key in object))
                ) {
                    baseAssignValue(object, key, value)
                }
            }

            module.exports = assignMergeValue

            /***/
        },

        /***/ 'tA+R': /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * content-type
             * Copyright(c) 2015 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
             *
             * parameter     = token "=" ( token / quoted-string )
             * token         = 1*tchar
             * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
             *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
             *               / DIGIT / ALPHA
             *               ; any VCHAR, except delimiters
             * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
             * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
             * obs-text      = %x80-FF
             * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
             */
            var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g
            var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/
            var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

            /**
             * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
             *
             * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
             * obs-text    = %x80-FF
             */
            var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g

            /**
             * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
             */
            var QUOTE_REGEXP = /([\\"])/g

            /**
             * RegExp to match type in RFC 7231 sec 3.1.1.1
             *
             * media-type = type "/" subtype
             * type       = token
             * subtype    = token
             */
            var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

            /**
             * Module exports.
             * @public
             */

            exports.format = format
            exports.parse = parse

            /**
             * Format object to media type.
             *
             * @param {object} obj
             * @return {string}
             * @public
             */

            function format(obj) {
                if (!obj || typeof obj !== 'object') {
                    throw new TypeError('argument obj is required')
                }

                var parameters = obj.parameters
                var type = obj.type

                if (!type || !TYPE_REGEXP.test(type)) {
                    throw new TypeError('invalid type')
                }

                var string = type

                // append parameters
                if (parameters && typeof parameters === 'object') {
                    var param
                    var params = Object.keys(parameters).sort()

                    for (var i = 0; i < params.length; i++) {
                        param = params[i]

                        if (!TOKEN_REGEXP.test(param)) {
                            throw new TypeError('invalid parameter name')
                        }

                        string +=
                            '; ' + param + '=' + qstring(parameters[param])
                    }
                }

                return string
            }

            /**
             * Parse media type to object.
             *
             * @param {string|object} string
             * @return {Object}
             * @public
             */

            function parse(string) {
                if (!string) {
                    throw new TypeError('argument string is required')
                }

                // support req/res-like objects as argument
                var header =
                    typeof string === 'object' ? getcontenttype(string) : string

                if (typeof header !== 'string') {
                    throw new TypeError(
                        'argument string is required to be a string'
                    )
                }

                var index = header.indexOf(';')
                var type =
                    index !== -1
                        ? header.substr(0, index).trim()
                        : header.trim()

                if (!TYPE_REGEXP.test(type)) {
                    throw new TypeError('invalid media type')
                }

                var obj = new ContentType(type.toLowerCase())

                // parse parameters
                if (index !== -1) {
                    var key
                    var match
                    var value

                    PARAM_REGEXP.lastIndex = index

                    while ((match = PARAM_REGEXP.exec(header))) {
                        if (match.index !== index) {
                            throw new TypeError('invalid parameter format')
                        }

                        index += match[0].length
                        key = match[1].toLowerCase()
                        value = match[2]

                        if (value[0] === '"') {
                            // remove quotes and escapes
                            value = value
                                .substr(1, value.length - 2)
                                .replace(QESC_REGEXP, '$1')
                        }

                        obj.parameters[key] = value
                    }

                    if (index !== header.length) {
                        throw new TypeError('invalid parameter format')
                    }
                }

                return obj
            }

            /**
             * Get content-type from req/res objects.
             *
             * @param {object}
             * @return {Object}
             * @private
             */

            function getcontenttype(obj) {
                var header

                if (typeof obj.getHeader === 'function') {
                    // res-like
                    header = obj.getHeader('content-type')
                } else if (typeof obj.headers === 'object') {
                    // req-like
                    header = obj.headers && obj.headers['content-type']
                }

                if (typeof header !== 'string') {
                    throw new TypeError(
                        'content-type header is missing from object'
                    )
                }

                return header
            }

            /**
             * Quote a string if necessary.
             *
             * @param {string} val
             * @return {string}
             * @private
             */

            function qstring(val) {
                var str = String(val)

                // no need to quote tokens
                if (TOKEN_REGEXP.test(str)) {
                    return str
                }

                if (str.length > 0 && !TEXT_REGEXP.test(str)) {
                    throw new TypeError('invalid parameter value')
                }

                return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
            }

            /**
             * Class to represent a content type.
             * @private
             */
            function ContentType(type) {
                this.parameters = Object.create(null)
                this.type = type
            }

            /***/
        },

        /***/ tCGZ: /***/ function(module) {
            module.exports = JSON.parse(
                '{"name":"got","version":"9.6.0","description":"Simplified HTTP requests","license":"MIT","repository":"sindresorhus/got","main":"source","engines":{"node":">=8.6"},"scripts":{"test":"xo && nyc ava","release":"np"},"files":["source"],"keywords":["http","https","get","got","url","uri","request","util","utility","simple","curl","wget","fetch","net","network","electron"],"dependencies":{"@sindresorhus/is":"^0.14.0","@szmarczak/http-timer":"^1.1.2","cacheable-request":"^6.0.0","decompress-response":"^3.3.0","duplexer3":"^0.1.4","get-stream":"^4.1.0","lowercase-keys":"^1.0.1","mimic-response":"^1.0.1","p-cancelable":"^1.0.0","to-readable-stream":"^1.0.0","url-parse-lax":"^3.0.0"},"devDependencies":{"ava":"^1.1.0","coveralls":"^3.0.0","delay":"^4.1.0","form-data":"^2.3.3","get-port":"^4.0.0","np":"^3.1.0","nyc":"^13.1.0","p-event":"^2.1.0","pem":"^1.13.2","proxyquire":"^2.0.1","sinon":"^7.2.2","slow-stream":"0.0.4","tempfile":"^2.0.0","tempy":"^0.2.1","tough-cookie":"^3.0.0","xo":"^0.24.0"},"ava":{"concurrency":4},"browser":{"decompress-response":false,"electron":false}}'
            )

            /***/
        },

        /***/ tMB7: /***/ function(module, exports, __webpack_require__) {
            var assocIndexOf = __webpack_require__('y1pI')

            /**
             * Gets the list cache value for `key`.
             *
             * @private
             * @name get
             * @memberOf ListCache
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function listCacheGet(key) {
                var data = this.__data__,
                    index = assocIndexOf(data, key)

                return index < 0 ? undefined : data[index][1]
            }

            module.exports = listCacheGet

            /***/
        },

        /***/ tYgP: /***/ function(module) {
            module.exports = JSON.parse(
                '{"100":"Continue","101":"Switching Protocols","102":"Processing","103":"Early Hints","200":"OK","201":"Created","202":"Accepted","203":"Non-Authoritative Information","204":"No Content","205":"Reset Content","206":"Partial Content","207":"Multi-Status","208":"Already Reported","226":"IM Used","300":"Multiple Choices","301":"Moved Permanently","302":"Found","303":"See Other","304":"Not Modified","305":"Use Proxy","306":"(Unused)","307":"Temporary Redirect","308":"Permanent Redirect","400":"Bad Request","401":"Unauthorized","402":"Payment Required","403":"Forbidden","404":"Not Found","405":"Method Not Allowed","406":"Not Acceptable","407":"Proxy Authentication Required","408":"Request Timeout","409":"Conflict","410":"Gone","411":"Length Required","412":"Precondition Failed","413":"Payload Too Large","414":"URI Too Long","415":"Unsupported Media Type","416":"Range Not Satisfiable","417":"Expectation Failed","418":"I\'m a teapot","421":"Misdirected Request","422":"Unprocessable Entity","423":"Locked","424":"Failed Dependency","425":"Unordered Collection","426":"Upgrade Required","428":"Precondition Required","429":"Too Many Requests","431":"Request Header Fields Too Large","451":"Unavailable For Legal Reasons","500":"Internal Server Error","501":"Not Implemented","502":"Bad Gateway","503":"Service Unavailable","504":"Gateway Timeout","505":"HTTP Version Not Supported","506":"Variant Also Negotiates","507":"Insufficient Storage","508":"Loop Detected","509":"Bandwidth Limit Exceeded","510":"Not Extended","511":"Network Authentication Required"}'
            )

            /***/
        },

        /***/ tadb: /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5'),
                root = __webpack_require__('Kz5y')

            /* Built-in method references that are verified to be native. */
            var DataView = getNative(root, 'DataView')

            module.exports = DataView

            /***/
        },

        /***/ tlh6: /***/ function(module, exports) {
            module.exports = require('string_decoder')

            /***/
        },

        /***/ u88T: /***/ function(module, exports, __webpack_require__) {
            const asn1 = __webpack_require__('9ny7')

            const types = new Map()

            const AlgorithmIdentifier = asn1.define(
                'AlgorithmIdentifier',
                __webpack_require__('yAVD')
            )
            types.set('AlgorithmIdentifier', AlgorithmIdentifier)

            const ECPrivateKey = asn1.define(
                'ECPrivateKey',
                __webpack_require__('HKOu')
            )
            types.set('ECPrivateKey', ECPrivateKey)

            const PrivateKeyInfo = asn1.define(
                'PrivateKeyInfo',
                __webpack_require__('wEzw')(AlgorithmIdentifier)
            )
            types.set('PrivateKeyInfo', PrivateKeyInfo)

            const PublicKeyInfo = asn1.define(
                'PublicKeyInfo',
                __webpack_require__('pBmY')(AlgorithmIdentifier)
            )
            types.set('PublicKeyInfo', PublicKeyInfo)

            const PrivateKey = asn1.define(
                'PrivateKey',
                __webpack_require__('YFSu')
            )
            types.set('PrivateKey', PrivateKey)

            const OneAsymmetricKey = asn1.define(
                'OneAsymmetricKey',
                __webpack_require__('o/Eg')(AlgorithmIdentifier, PrivateKey)
            )
            types.set('OneAsymmetricKey', OneAsymmetricKey)

            const RSAPrivateKey = asn1.define(
                'RSAPrivateKey',
                __webpack_require__('Ra3S')
            )
            types.set('RSAPrivateKey', RSAPrivateKey)

            const RSAPublicKey = asn1.define(
                'RSAPublicKey',
                __webpack_require__('k9s9')
            )
            types.set('RSAPublicKey', RSAPublicKey)

            const OID = asn1.define('OID', function() {
                return this.objid()
            })
            types.set('OID', OID)

            module.exports = types

            /***/
        },

        /***/ u8Dt: /***/ function(module, exports, __webpack_require__) {
            var nativeCreate = __webpack_require__('YESw')

            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__'

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Gets the hash value for `key`.
             *
             * @private
             * @name get
             * @memberOf Hash
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function hashGet(key) {
                var data = this.__data__
                if (nativeCreate) {
                    var result = data[key]
                    return result === HASH_UNDEFINED ? undefined : result
                }
                return hasOwnProperty.call(data, key) ? data[key] : undefined
            }

            module.exports = hashGet

            /***/
        },

        /***/ uCqB: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var BOMChar = '\uFEFF'

            exports.PrependBOM = PrependBOMWrapper
            function PrependBOMWrapper(encoder, options) {
                this.encoder = encoder
                this.addBOM = true
            }

            PrependBOMWrapper.prototype.write = function(str) {
                if (this.addBOM) {
                    str = BOMChar + str
                    this.addBOM = false
                }

                return this.encoder.write(str)
            }

            PrependBOMWrapper.prototype.end = function() {
                return this.encoder.end()
            }

            //------------------------------------------------------------------------------

            exports.StripBOM = StripBOMWrapper
            function StripBOMWrapper(decoder, options) {
                this.decoder = decoder
                this.pass = false
                this.options = options || {}
            }

            StripBOMWrapper.prototype.write = function(buf) {
                var res = this.decoder.write(buf)
                if (this.pass || !res) return res

                if (res[0] === BOMChar) {
                    res = res.slice(1)
                    if (typeof this.options.stripBOM === 'function')
                        this.options.stripBOM()
                }

                this.pass = true
                return res
            }

            StripBOMWrapper.prototype.end = function() {
                return this.decoder.end()
            }

            /***/
        },

        /***/ uGJc: /***/ function(module, exports) {
            module.exports = alg => `sha${alg.substr(2, 3)}`

            /***/
        },

        /***/ uWJx: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(array1, array2, options = {}) {
                if (!array1 || !array2) {
                    return options.first ? null : []
                }

                const common = []
                const hash = Array.isArray(array1) ? new Set(array1) : array1
                const found = new Set()
                for (const value of array2) {
                    if (internals.has(hash, value) && !found.has(value)) {
                        if (options.first) {
                            return value
                        }

                        common.push(value)
                        found.add(value)
                    }
                }

                return options.first ? null : common
            }

            internals.has = function(ref, key) {
                if (typeof ref.has === 'function') {
                    return ref.has(key)
                }

                return ref[key] !== undefined
            }

            /***/
        },

        /***/ ud21: /***/ function(module, exports) {
            if (typeof Object.create === 'function') {
                // implementation from standard node.js 'util' module
                module.exports = function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor
                    ctor.prototype = Object.create(superCtor.prototype, {
                        constructor: {
                            value: ctor,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    })
                }
            } else {
                // old school shim for old browsers
                module.exports = function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor
                    var TempCtor = function() {}
                    TempCtor.prototype = superCtor.prototype
                    ctor.prototype = new TempCtor()
                    ctor.prototype.constructor = ctor
                }
            }

            /***/
        },

        /***/ ugmf: /***/ function(module, exports) {
            module.exports = require('tls')

            /***/
        },

        /***/ uk5n: /***/ function(module, exports, __webpack_require__) {
            const { createHash } = __webpack_require__('PJMN')

            const base64url = __webpack_require__('Xab3')

            const x5t = (hash, cert) =>
                base64url.encodeBuffer(
                    createHash(hash)
                        .update(Buffer.from(cert, 'base64'))
                        .digest()
                )

            module.exports.kid = components =>
                base64url.encodeBuffer(
                    createHash('sha256')
                        .update(JSON.stringify(components))
                        .digest()
                )
            module.exports.x5t = x5t.bind(undefined, 'sha1')
            module.exports['x5t#S256'] = x5t.bind(undefined, 'sha256')

            /***/
        },

        /***/ urXW: /***/ function(module, exports, __webpack_require__) {
            const { JOSECritNotUnderstood, JWSInvalid } = __webpack_require__(
                'yt7c'
            )

            const DEFINED = new Set([
                'alg',
                'jku',
                'jwk',
                'kid',
                'x5u',
                'x5c',
                'x5t',
                'x5t#S256',
                'typ',
                'cty',
                'crit',
                'enc',
                'zip',
                'epk',
                'apu',
                'apv',
                'iv',
                'tag',
                'p2s',
                'p2c'
            ])

            module.exports = function validateCrit(
                Err,
                protectedHeader,
                unprotectedHeader,
                understood
            ) {
                if (protectedHeader && 'crit' in protectedHeader) {
                    if (
                        !Array.isArray(protectedHeader.crit) ||
                        protectedHeader.crit.length === 0 ||
                        protectedHeader.crit.some(
                            s => typeof s !== 'string' || !s
                        )
                    ) {
                        throw new Err(
                            '"crit" Header Parameter MUST be an array of non-empty strings when present'
                        )
                    }
                    const whitelisted = new Set(understood)
                    const combined = {
                        ...protectedHeader,
                        ...unprotectedHeader
                    }
                    protectedHeader.crit.forEach(parameter => {
                        if (DEFINED.has(parameter)) {
                            throw new Err(
                                `The critical list contains a non-extension Header Parameter ${parameter}`
                            )
                        }
                        if (!whitelisted.has(parameter)) {
                            throw new JOSECritNotUnderstood(
                                `critical "${parameter}" is not understood`
                            )
                        }
                        if (parameter === 'b64') {
                            if (!('b64' in protectedHeader)) {
                                throw new JWSInvalid(
                                    '"b64" critical parameter must be integrity protected'
                                )
                            }
                            if (typeof protectedHeader.b64 !== 'boolean') {
                                throw new JWSInvalid(
                                    '"b64" critical parameter must be a boolean'
                                )
                            }
                        } else if (!(parameter in combined)) {
                            throw new Err(
                                `critical parameter "${parameter}" is missing`
                            )
                        }
                    })
                }
                if (unprotectedHeader && 'crit' in unprotectedHeader) {
                    throw new Err(
                        '"crit" Header Parameter MUST be integrity protected when present'
                    )
                }
            }

            /***/
        },

        /***/ 'ut/Y': /***/ function(module, exports, __webpack_require__) {
            var baseMatches = __webpack_require__('ZCpW'),
                baseMatchesProperty = __webpack_require__('GDhZ'),
                identity = __webpack_require__('zZ0H'),
                isArray = __webpack_require__('Z0cm'),
                property = __webpack_require__('+c4W')

            /**
             * The base implementation of `_.iteratee`.
             *
             * @private
             * @param {*} [value=_.identity] The value to convert to an iteratee.
             * @returns {Function} Returns the iteratee.
             */
            function baseIteratee(value) {
                // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                if (typeof value == 'function') {
                    return value
                }
                if (value == null) {
                    return identity
                }
                if (typeof value == 'object') {
                    return isArray(value)
                        ? baseMatchesProperty(value[0], value[1])
                        : baseMatches(value)
                }
                return property(value)
            }

            module.exports = baseIteratee

            /***/
        },

        /***/ vC2k: /***/ function(module, exports, __webpack_require__) {
            const {
                generateKeyPairSync,
                generateKeyPair: async
            } = __webpack_require__('PJMN')
            const { promisify } = __webpack_require__('jK02')

            const {
                THUMBPRINT_MATERIAL,
                JWK_MEMBERS,
                PUBLIC_MEMBERS,
                PRIVATE_MEMBERS,
                KEY_MANAGEMENT_DECRYPT,
                KEY_MANAGEMENT_ENCRYPT
            } = __webpack_require__('ehsS')
            const { OKP_CURVES } = __webpack_require__('N+nT')
            const { edDSASupported } = __webpack_require__('pDDt')
            const errors = __webpack_require__('yt7c')

            const Key = __webpack_require__('//Cd')

            const generateKeyPair = promisify(async)

            const OKP_PUBLIC = new Set(['crv', 'x'])
            Object.freeze(OKP_PUBLIC)
            const OKP_PRIVATE = new Set([...OKP_PUBLIC, 'd'])
            Object.freeze(OKP_PRIVATE)

            // Octet string key pairs Key Type
            class OKPKey extends Key {
                constructor(...args) {
                    super(...args)

                    Object.defineProperties(this, {
                        kty: {
                            value: 'OKP',
                            enumerable: true
                        }
                    })
                    this[JWK_MEMBERS]()
                }

                static get [PUBLIC_MEMBERS]() {
                    return OKP_PUBLIC
                }

                static get [PRIVATE_MEMBERS]() {
                    return OKP_PRIVATE
                }

                // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special
                // JSON.stringify handling in V8
                [THUMBPRINT_MATERIAL]() {
                    return { crv: this.crv, kty: 'OKP', x: this.x }
                }

                [KEY_MANAGEMENT_ENCRYPT]() {
                    return this.algorithms('deriveKey')
                }

                [KEY_MANAGEMENT_DECRYPT]() {
                    if (this.public) {
                        return new Set()
                    }
                    return this.algorithms('deriveKey')
                }

                static async generate(crv = 'Ed25519', privat = true) {
                    if (!edDSASupported) {
                        throw new errors.JOSENotSupported(
                            'OKP keys are not supported in your Node.js runtime version'
                        )
                    }

                    if (!OKP_CURVES.has(crv)) {
                        throw new errors.JOSENotSupported(
                            `unsupported OKP key curve: ${crv}`
                        )
                    }

                    const { privateKey, publicKey } = await generateKeyPair(
                        crv.toLowerCase()
                    )

                    return privat ? privateKey : publicKey
                }

                static generateSync(crv = 'Ed25519', privat = true) {
                    if (!edDSASupported) {
                        throw new errors.JOSENotSupported(
                            'OKP keys are not supported in your Node.js runtime version'
                        )
                    }

                    if (!OKP_CURVES.has(crv)) {
                        throw new errors.JOSENotSupported(
                            `unsupported OKP key curve: ${crv}`
                        )
                    }

                    const { privateKey, publicKey } = generateKeyPairSync(
                        crv.toLowerCase()
                    )

                    return privat ? privateKey : publicKey
                }
            }

            module.exports = OKPKey

            /***/
        },

        /***/ vQrS: /***/ function(module, exports, __webpack_require__) {
            try {
                var util = __webpack_require__('jK02')
                if (typeof util.inherits !== 'function') throw ''
                module.exports = util.inherits
            } catch (e) {
                module.exports = __webpack_require__('ud21')
            }

            /***/
        },

        /***/ vUsp: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            function padString(input) {
                var segmentLength = 4
                var stringLength = input.length
                var diff = stringLength % segmentLength
                if (!diff) {
                    return input
                }
                var position = stringLength
                var padLength = segmentLength - diff
                var paddedStringLength = stringLength + padLength
                var buffer = Buffer.alloc(paddedStringLength)
                buffer.write(input)
                while (padLength--) {
                    buffer.write('=', position++)
                }
                return buffer.toString()
            }
            exports.default = padString

            /***/
        },

        /***/ vv4h: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var __importDefault =
                (this && this.__importDefault) ||
                function(mod) {
                    return mod && mod.__esModule ? mod : { default: mod }
                }
            Object.defineProperty(exports, '__esModule', { value: true })
            const fs_1 = __importDefault(__webpack_require__('mw/K'))
            const path_1 = __webpack_require__('oyvS')
            const util_1 = __webpack_require__('jK02')
            const constants_1 = __webpack_require__('w7wo')
            const normalize_page_path_1 = __webpack_require__('w0zM')
            const readFile = util_1.promisify(fs_1.default.readFile)
            function pageNotFoundError(page) {
                const err = new Error(`Cannot find module for page: ${page}`)
                err.code = 'ENOENT'
                return err
            }
            exports.pageNotFoundError = pageNotFoundError
            function getPagePath(page, distDir, serverless, dev) {
                const serverBuildPath = path_1.join(
                    distDir,
                    serverless && !dev
                        ? constants_1.SERVERLESS_DIRECTORY
                        : constants_1.SERVER_DIRECTORY
                )
                const pagesManifest = __webpack_require__('PJv+')(
                    path_1.join(serverBuildPath, constants_1.PAGES_MANIFEST)
                )
                try {
                    page = normalize_page_path_1.normalizePagePath(page)
                    page = page === '/' ? '/index' : page
                } catch (err) {
                    // tslint:disable-next-line
                    console.error(err)
                    throw pageNotFoundError(page)
                }
                if (!pagesManifest[page]) {
                    const cleanedPage = page.replace(/\/index$/, '') || '/'
                    if (!pagesManifest[cleanedPage]) {
                        throw pageNotFoundError(page)
                    } else {
                        page = cleanedPage
                    }
                }
                return path_1.join(serverBuildPath, pagesManifest[page])
            }
            exports.getPagePath = getPagePath
            function requirePage(page, distDir, serverless) {
                const pagePath = getPagePath(page, distDir, serverless)
                if (pagePath.endsWith('.html')) {
                    return readFile(pagePath, 'utf8')
                }
                return __webpack_require__('PJv+')(pagePath)
            }
            exports.requirePage = requirePage

            /***/
        },

        /***/ 'w/wX': /***/ function(module, exports, __webpack_require__) {
            var getTag = __webpack_require__('QqLw'),
                isObjectLike = __webpack_require__('ExA7')

            /** `Object#toString` result references. */
            var setTag = '[object Set]'

            /**
             * The base implementation of `_.isSet` without Node.js optimizations.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a set, else `false`.
             */
            function baseIsSet(value) {
                return isObjectLike(value) && getTag(value) == setTag
            }

            module.exports = baseIsSet

            /***/
        },

        /***/ w0zM: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const path_1 = __webpack_require__('oyvS')
            function normalizePagePath(page) {
                // If the page is `/` we need to append `/index`, otherwise the returned directory root will be bundles instead of pages
                if (page === '/') {
                    page = '/index'
                }
                // Resolve on anything that doesn't start with `/`
                if (page[0] !== '/') {
                    page = `/${page}`
                }
                // Throw when using ../ etc in the pathname
                const resolvedPage = path_1.posix.normalize(page)
                if (page !== resolvedPage) {
                    throw new Error('Requested and resolved page mismatch')
                }
                return page
            }
            exports.normalizePagePath = normalizePagePath

            /***/
        },

        /***/ w7wo: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$defineProperty = __webpack_require__('hfKm')

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            exports.PHASE_EXPORT = 'phase-export'
            exports.PHASE_PRODUCTION_BUILD = 'phase-production-build'
            exports.PHASE_PRODUCTION_SERVER = 'phase-production-server'
            exports.PHASE_DEVELOPMENT_SERVER = 'phase-development-server'
            exports.PAGES_MANIFEST = 'pages-manifest.json'
            exports.BUILD_MANIFEST = 'build-manifest.json'
            exports.PRERENDER_MANIFEST = 'prerender-manifest.json'
            exports.ROUTES_MANIFEST = 'routes-manifest.json'
            exports.REACT_LOADABLE_MANIFEST = 'react-loadable-manifest.json'
            exports.SERVER_DIRECTORY = 'server'
            exports.SERVERLESS_DIRECTORY = 'serverless'
            exports.CONFIG_FILE = 'next.config.js'
            exports.BUILD_ID_FILE = 'BUILD_ID'
            exports.BLOCKED_PAGES = ['/_document', '/_app']
            exports.CLIENT_PUBLIC_FILES_PATH = 'public'
            exports.CLIENT_STATIC_FILES_PATH = 'static'
            exports.CLIENT_STATIC_FILES_RUNTIME = 'runtime'
            exports.CLIENT_STATIC_FILES_RUNTIME_PATH = `${exports.CLIENT_STATIC_FILES_PATH}/${exports.CLIENT_STATIC_FILES_RUNTIME}` // static/runtime/main.js

            exports.CLIENT_STATIC_FILES_RUNTIME_MAIN = `${exports.CLIENT_STATIC_FILES_RUNTIME_PATH}/main.js` // static/runtime/amp.js

            exports.CLIENT_STATIC_FILES_RUNTIME_AMP = `${exports.CLIENT_STATIC_FILES_RUNTIME_PATH}/amp.js` // static/runtime/webpack.js

            exports.CLIENT_STATIC_FILES_RUNTIME_WEBPACK = `${exports.CLIENT_STATIC_FILES_RUNTIME_PATH}/webpack.js` // static/runtime/polyfills.js

            exports.CLIENT_STATIC_FILES_RUNTIME_POLYFILLS = `${exports.CLIENT_STATIC_FILES_RUNTIME_PATH}/polyfills.js` // matches static/<buildid>/pages/<page>.js

            exports.IS_BUNDLED_PAGE_REGEX = /^static[/\\][^/\\]+[/\\]pages.*\.js$/ // matches static/<buildid>/pages/:page*.js

            exports.ROUTE_NAME_REGEX = /^static[/\\][^/\\]+[/\\]pages[/\\](.*)\.js$/
            exports.SERVERLESS_ROUTE_NAME_REGEX = /^pages[/\\](.*)\.js$/
            exports.DEFAULT_REDIRECT_STATUS = 307

            /***/
        },

        /***/ w8yO: /***/ function(module, exports) {
            const sign = () => Buffer.from('')
            const verify = (key, payload, signature) => !signature.length

            module.exports = (JWA, JWK) => {
                JWA.sign.set('none', sign)
                JWA.verify.set('none', verify)
            }

            /***/
        },

        /***/ wEzw: /***/ function(module, exports) {
            module.exports = AlgorithmIdentifier =>
                function() {
                    this.seq().obj(
                        this.key('version').int(),
                        this.key('algorithm').use(AlgorithmIdentifier),
                        this.key('privateKey').octstr()
                    )
                }

            /***/
        },

        /***/ 'wF/u': /***/ function(module, exports, __webpack_require__) {
            var baseIsEqualDeep = __webpack_require__('e5cp'),
                isObjectLike = __webpack_require__('ExA7')

            /**
             * The base implementation of `_.isEqual` which supports partial comparisons
             * and tracks traversed objects.
             *
             * @private
             * @param {*} value The value to compare.
             * @param {*} other The other value to compare.
             * @param {boolean} bitmask The bitmask flags.
             *  1 - Unordered comparison
             *  2 - Partial comparison
             * @param {Function} [customizer] The function to customize comparisons.
             * @param {Object} [stack] Tracks traversed `value` and `other` objects.
             * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
             */
            function baseIsEqual(value, other, bitmask, customizer, stack) {
                if (value === other) {
                    return true
                }
                if (
                    value == null ||
                    other == null ||
                    (!isObjectLike(value) && !isObjectLike(other))
                ) {
                    return value !== value && other !== other
                }
                return baseIsEqualDeep(
                    value,
                    other,
                    bitmask,
                    customizer,
                    baseIsEqual,
                    stack
                )
            }

            module.exports = baseIsEqual

            /***/
        },

        /***/ wJg7: /***/ function(module, exports) {
            /** Used as references for various `Number` constants. */
            var MAX_SAFE_INTEGER = 9007199254740991

            /** Used to detect unsigned integer values. */
            var reIsUint = /^(?:0|[1-9]\d*)$/

            /**
             * Checks if `value` is a valid array-like index.
             *
             * @private
             * @param {*} value The value to check.
             * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
             * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
             */
            function isIndex(value, length) {
                var type = typeof value
                length = length == null ? MAX_SAFE_INTEGER : length

                return (
                    !!length &&
                    (type == 'number' ||
                        (type != 'symbol' && reIsUint.test(value))) &&
                    value > -1 && value % 1 == 0 && value < length
                )
            }

            module.exports = isIndex

            /***/
        },

        /***/ wclG: /***/ function(module, exports, __webpack_require__) {
            var baseSetToString = __webpack_require__('pFRH'),
                shortOut = __webpack_require__('88Gu')

            /**
             * Sets the `toString` method of `func` to return `string`.
             *
             * @private
             * @param {Function} func The function to modify.
             * @param {Function} string The `toString` result.
             * @returns {Function} Returns `func`.
             */
            var setToString = shortOut(baseSetToString)

            module.exports = setToString

            /***/
        },

        /***/ whhB: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { URL, URLSearchParams } = __webpack_require__('bzos') // TODO: Use the `URL` global when targeting Node.js 10
            const urlLib = __webpack_require__('bzos')
            const is = __webpack_require__('6mOv')
            const urlParseLax = __webpack_require__('9l6Z')
            const lowercaseKeys = __webpack_require__('y1+z')
            const urlToOptions = __webpack_require__('NHoT')
            const isFormData = __webpack_require__('faWz')
            const merge = __webpack_require__('AW8e')
            const knownHookEvents = __webpack_require__('JlL/')

            const retryAfterStatusCodes = new Set([413, 429, 503])

            // `preNormalize` handles static options (e.g. headers).
            // For example, when you create a custom instance and make a request
            // with no static changes, they won't be normalized again.
            //
            // `normalize` operates on dynamic options - they cannot be saved.
            // For example, `body` is everytime different per request.
            // When it's done normalizing the new options, it performs merge()
            // on the prenormalized options and the normalized ones.

            const preNormalize = (options, defaults) => {
                if (is.nullOrUndefined(options.headers)) {
                    options.headers = {}
                } else {
                    options.headers = lowercaseKeys(options.headers)
                }

                if (
                    options.baseUrl &&
                    !options.baseUrl.toString().endsWith('/')
                ) {
                    options.baseUrl += '/'
                }

                if (options.stream) {
                    options.json = false
                }

                if (is.nullOrUndefined(options.hooks)) {
                    options.hooks = {}
                } else if (!is.object(options.hooks)) {
                    throw new TypeError(
                        `Parameter \`hooks\` must be an object, not ${is(
                            options.hooks
                        )}`
                    )
                }

                for (const event of knownHookEvents) {
                    if (is.nullOrUndefined(options.hooks[event])) {
                        if (defaults) {
                            options.hooks[event] = [...defaults.hooks[event]]
                        } else {
                            options.hooks[event] = []
                        }
                    }
                }

                if (is.number(options.timeout)) {
                    options.gotTimeout = { request: options.timeout }
                } else if (is.object(options.timeout)) {
                    options.gotTimeout = options.timeout
                }

                delete options.timeout

                const { retry } = options
                options.retry = {
                    retries: 0,
                    methods: [],
                    statusCodes: [],
                    errorCodes: []
                }

                if (is.nonEmptyObject(defaults) && retry !== false) {
                    options.retry = { ...defaults.retry }
                }

                if (retry !== false) {
                    if (is.number(retry)) {
                        options.retry.retries = retry
                    } else {
                        options.retry = { ...options.retry, ...retry }
                    }
                }

                if (options.gotTimeout) {
                    options.retry.maxRetryAfter = Math.min(
                        ...[
                            options.gotTimeout.request,
                            options.gotTimeout.connection
                        ].filter(n => !is.nullOrUndefined(n))
                    )
                }

                if (is.array(options.retry.methods)) {
                    options.retry.methods = new Set(
                        options.retry.methods.map(method =>
                            method.toUpperCase()
                        )
                    )
                }

                if (is.array(options.retry.statusCodes)) {
                    options.retry.statusCodes = new Set(
                        options.retry.statusCodes
                    )
                }

                if (is.array(options.retry.errorCodes)) {
                    options.retry.errorCodes = new Set(options.retry.errorCodes)
                }

                return options
            }

            const normalize = (url, options, defaults) => {
                if (is.plainObject(url)) {
                    options = { ...url, ...options }
                    url = options.url || {}
                    delete options.url
                }

                if (defaults) {
                    options = merge(
                        {},
                        defaults.options,
                        options ? preNormalize(options, defaults.options) : {}
                    )
                } else {
                    options = merge({}, preNormalize(options))
                }

                if (!is.string(url) && !is.object(url)) {
                    throw new TypeError(
                        `Parameter \`url\` must be a string or object, not ${is(
                            url
                        )}`
                    )
                }

                if (is.string(url)) {
                    if (options.baseUrl) {
                        if (url.toString().startsWith('/')) {
                            url = url.toString().slice(1)
                        }

                        url = urlToOptions(new URL(url, options.baseUrl))
                    } else {
                        url = url.replace(/^unix:/, 'http://$&')
                        url = urlParseLax(url)
                    }
                } else if (is(url) === 'URL') {
                    url = urlToOptions(url)
                }

                // Override both null/undefined with default protocol
                options = merge(
                    { path: '' },
                    url,
                    { protocol: url.protocol || 'https:' },
                    options
                )

                for (const hook of options.hooks.init) {
                    const called = hook(options)

                    if (is.promise(called)) {
                        throw new TypeError(
                            'The `init` hook must be a synchronous function'
                        )
                    }
                }

                const { baseUrl } = options
                Object.defineProperty(options, 'baseUrl', {
                    set: () => {
                        throw new Error(
                            'Failed to set baseUrl. Options are normalized already.'
                        )
                    },
                    get: () => baseUrl
                })

                const { query } = options
                if (
                    is.nonEmptyString(query) ||
                    is.nonEmptyObject(query) ||
                    query instanceof URLSearchParams
                ) {
                    if (!is.string(query)) {
                        options.query = new URLSearchParams(query).toString()
                    }

                    options.path = `${options.path.split('?')[0]}?${
                        options.query
                    }`
                    delete options.query
                }

                if (options.hostname === 'unix') {
                    const matches = /(.+?):(.+)/.exec(options.path)

                    if (matches) {
                        const [, socketPath, path] = matches
                        options = {
                            ...options,
                            socketPath,
                            path,
                            host: null
                        }
                    }
                }

                const { headers } = options
                for (const [key, value] of Object.entries(headers)) {
                    if (is.nullOrUndefined(value)) {
                        delete headers[key]
                    }
                }

                if (options.json && is.undefined(headers.accept)) {
                    headers.accept = 'application/json'
                }

                if (
                    options.decompress &&
                    is.undefined(headers['accept-encoding'])
                ) {
                    headers['accept-encoding'] = 'gzip, deflate'
                }

                const { body } = options
                if (is.nullOrUndefined(body)) {
                    options.method = options.method
                        ? options.method.toUpperCase()
                        : 'GET'
                } else {
                    const isObject =
                        is.object(body) &&
                        !is.buffer(body) &&
                        !is.nodeStream(body)
                    if (
                        !is.nodeStream(body) &&
                        !is.string(body) &&
                        !is.buffer(body) &&
                        !(options.form || options.json)
                    ) {
                        throw new TypeError(
                            'The `body` option must be a stream.Readable, string or Buffer'
                        )
                    }

                    if (options.json && !(isObject || is.array(body))) {
                        throw new TypeError(
                            'The `body` option must be an Object or Array when the `json` option is used'
                        )
                    }

                    if (options.form && !isObject) {
                        throw new TypeError(
                            'The `body` option must be an Object when the `form` option is used'
                        )
                    }

                    if (isFormData(body)) {
                        // Special case for https://github.com/form-data/form-data
                        headers['content-type'] =
                            headers['content-type'] ||
                            `multipart/form-data; boundary=${body.getBoundary()}`
                    } else if (options.form) {
                        headers['content-type'] =
                            headers['content-type'] ||
                            'application/x-www-form-urlencoded'
                        options.body = new URLSearchParams(body).toString()
                    } else if (options.json) {
                        headers['content-type'] =
                            headers['content-type'] || 'application/json'
                        options.body = JSON.stringify(body)
                    }

                    options.method = options.method
                        ? options.method.toUpperCase()
                        : 'POST'
                }

                if (!is.function(options.retry.retries)) {
                    const { retries } = options.retry

                    options.retry.retries = (iteration, error) => {
                        if (iteration > retries) {
                            return 0
                        }

                        if (
                            (!error ||
                                !options.retry.errorCodes.has(error.code)) &&
                            (!options.retry.methods.has(error.method) ||
                                !options.retry.statusCodes.has(
                                    error.statusCode
                                ))
                        ) {
                            return 0
                        }

                        if (
                            Reflect.has(error, 'headers') &&
                            Reflect.has(error.headers, 'retry-after') &&
                            retryAfterStatusCodes.has(error.statusCode)
                        ) {
                            let after = Number(error.headers['retry-after'])
                            if (is.nan(after)) {
                                after =
                                    Date.parse(error.headers['retry-after']) -
                                    Date.now()
                            } else {
                                after *= 1000
                            }

                            if (after > options.retry.maxRetryAfter) {
                                return 0
                            }

                            return after
                        }

                        if (error.statusCode === 413) {
                            return 0
                        }

                        const noise = Math.random() * 100
                        return 2 ** (iteration - 1) * 1000 + noise
                    }
                }

                return options
            }

            const reNormalize = options =>
                normalize(urlLib.format(options), options)

            module.exports = normalize
            module.exports.preNormalize = preNormalize
            module.exports.reNormalize = reNormalize

            /***/
        },

        /***/ wrZu: /***/ function(module, exports, __webpack_require__) {
            var cloneArrayBuffer = __webpack_require__('+K+b'),
                cloneDataView = __webpack_require__('XYm9'),
                cloneRegExp = __webpack_require__('b2z7'),
                cloneSymbol = __webpack_require__('otv/'),
                cloneTypedArray = __webpack_require__('yP5f')

            /** `Object#toString` result references. */
            var boolTag = '[object Boolean]',
                dateTag = '[object Date]',
                mapTag = '[object Map]',
                numberTag = '[object Number]',
                regexpTag = '[object RegExp]',
                setTag = '[object Set]',
                stringTag = '[object String]',
                symbolTag = '[object Symbol]'

            var arrayBufferTag = '[object ArrayBuffer]',
                dataViewTag = '[object DataView]',
                float32Tag = '[object Float32Array]',
                float64Tag = '[object Float64Array]',
                int8Tag = '[object Int8Array]',
                int16Tag = '[object Int16Array]',
                int32Tag = '[object Int32Array]',
                uint8Tag = '[object Uint8Array]',
                uint8ClampedTag = '[object Uint8ClampedArray]',
                uint16Tag = '[object Uint16Array]',
                uint32Tag = '[object Uint32Array]'

            /**
             * Initializes an object clone based on its `toStringTag`.
             *
             * **Note:** This function only supports cloning values with tags of
             * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
             *
             * @private
             * @param {Object} object The object to clone.
             * @param {string} tag The `toStringTag` of the object to clone.
             * @param {boolean} [isDeep] Specify a deep clone.
             * @returns {Object} Returns the initialized clone.
             */
            function initCloneByTag(object, tag, isDeep) {
                var Ctor = object.constructor
                switch (tag) {
                    case arrayBufferTag:
                        return cloneArrayBuffer(object)

                    case boolTag:
                    case dateTag:
                        return new Ctor(+object)

                    case dataViewTag:
                        return cloneDataView(object, isDeep)

                    case float32Tag:
                    case float64Tag:
                    case int8Tag:
                    case int16Tag:
                    case int32Tag:
                    case uint8Tag:
                    case uint8ClampedTag:
                    case uint16Tag:
                    case uint32Tag:
                        return cloneTypedArray(object, isDeep)

                    case mapTag:
                        return new Ctor()

                    case numberTag:
                    case stringTag:
                        return new Ctor(object)

                    case regexpTag:
                        return cloneRegExp(object)

                    case setTag:
                        return new Ctor()

                    case symbolTag:
                        return cloneSymbol(object)
                }
            }

            module.exports = initCloneByTag

            /***/
        },

        /***/ xYSL: /***/ function(module, exports) {
            /**
             * Checks if a `cache` value for `key` exists.
             *
             * @private
             * @param {Object} cache The cache to query.
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function cacheHas(cache, key) {
                return cache.has(key)
            }

            module.exports = cacheHas

            /***/
        },

        /***/ 'xZ+y': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tls_1 = __webpack_require__('ugmf')
            const deferToConnect = (socket, fn) => {
                let listeners
                if (typeof fn === 'function') {
                    const connect = fn
                    listeners = { connect }
                } else {
                    listeners = fn
                }
                const hasConnectListener =
                    typeof listeners.connect === 'function'
                const hasSecureConnectListener =
                    typeof listeners.secureConnect === 'function'
                const hasCloseListener = typeof listeners.close === 'function'
                const onConnect = () => {
                    if (hasConnectListener) {
                        listeners.connect()
                    }
                    if (
                        socket instanceof tls_1.TLSSocket &&
                        hasSecureConnectListener
                    ) {
                        if (socket.authorized) {
                            listeners.secureConnect()
                        } else if (!socket.authorizationError) {
                            socket.once(
                                'secureConnect',
                                listeners.secureConnect
                            )
                        }
                    }
                    if (hasCloseListener) {
                        socket.once('close', listeners.close)
                    }
                }
                if (socket.writable && !socket.connecting) {
                    onConnect()
                } else if (socket.connecting) {
                    socket.once('connect', onConnect)
                } else if (socket.destroyed && hasCloseListener) {
                    listeners.close(socket._hadError)
                }
            }
            exports.default = deferToConnect
            // For CommonJS default export support
            module.exports = deferToConnect
            module.exports.default = deferToConnect

            /***/
        },

        /***/ xZGU: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /* eslint-disable node/no-deprecated-api */

            var buffer = __webpack_require__('NkYg')
            var Buffer = buffer.Buffer

            var safer = {}

            var key

            for (key in buffer) {
                if (!buffer.hasOwnProperty(key)) continue
                if (key === 'SlowBuffer' || key === 'Buffer') continue
                safer[key] = buffer[key]
            }

            var Safer = (safer.Buffer = {})
            for (key in Buffer) {
                if (!Buffer.hasOwnProperty(key)) continue
                if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
                Safer[key] = Buffer[key]
            }

            safer.Buffer.prototype = Buffer.prototype

            if (!Safer.from || Safer.from === Uint8Array.from) {
                Safer.from = function(value, encodingOrOffset, length) {
                    if (typeof value === 'number') {
                        throw new TypeError(
                            'The "value" argument must not be of type number. Received type ' +
                                typeof value
                        )
                    }
                    if (value && typeof value.length === 'undefined') {
                        throw new TypeError(
                            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
                                typeof value
                        )
                    }
                    return Buffer(value, encodingOrOffset, length)
                }
            }

            if (!Safer.alloc) {
                Safer.alloc = function(size, fill, encoding) {
                    if (typeof size !== 'number') {
                        throw new TypeError(
                            'The "size" argument must be of type number. Received type ' +
                                typeof size
                        )
                    }
                    if (size < 0 || size >= 2 * (1 << 30)) {
                        throw new RangeError(
                            'The value "' +
                                size +
                                '" is invalid for option "size"'
                        )
                    }
                    var buf = Buffer(size)
                    if (!fill || fill.length === 0) {
                        buf.fill(0)
                    } else if (typeof encoding === 'string') {
                        buf.fill(fill, encoding)
                    } else {
                        buf.fill(fill)
                    }
                    return buf
                }
            }

            if (!safer.kStringMaxLength) {
                try {
                    safer.kStringMaxLength = process.binding(
                        'buffer'
                    ).kStringMaxLength
                } catch (e) {
                    // we can't determine kStringMaxLength in environments where process.binding
                    // is unsupported, so let's not set it
                }
            }

            if (!safer.constants) {
                safer.constants = {
                    MAX_LENGTH: safer.kMaxLength
                }
                if (safer.kStringMaxLength) {
                    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
                }
            }

            module.exports = safer

            /***/
        },

        /***/ xZSz: /***/ function(module, exports, __webpack_require__) {
            module.exports = {
                JWE: __webpack_require__('9AeD'),
                JWK: __webpack_require__('lA9T'),
                JWKS: __webpack_require__('WPgm'),
                JWS: __webpack_require__('sR+5'),
                JWT: __webpack_require__('zKJz'),
                errors: __webpack_require__('yt7c')
            }

            /***/
        },

        /***/ xfr8: /***/ function(module, exports, __webpack_require__) {
            const generateIV = __webpack_require__('X3uD')
            const base64url = __webpack_require__('Xab3')

            module.exports = (JWA, JWK) => {
                ;['A128GCMKW', 'A192GCMKW', 'A256GCMKW'].forEach(jwaAlg => {
                    const encAlg = jwaAlg.substr(0, 7)
                    const size = parseInt(jwaAlg.substr(1, 3), 10)
                    const encrypt = JWA.encrypt.get(encAlg)
                    const decrypt = JWA.decrypt.get(encAlg)

                    if (encrypt && decrypt) {
                        JWA.keyManagementEncrypt.set(jwaAlg, (key, payload) => {
                            const iv = generateIV(jwaAlg)
                            const { ciphertext, tag } = encrypt(key, payload, {
                                iv
                            })
                            return {
                                wrapped: ciphertext,
                                header: {
                                    tag: base64url.encodeBuffer(tag),
                                    iv: base64url.encodeBuffer(iv)
                                }
                            }
                        })
                        JWA.keyManagementDecrypt.set(jwaAlg, decrypt)
                        JWK.oct.wrapKey[jwaAlg] = JWK.oct.unwrapKey[
                            jwaAlg
                        ] = key =>
                            (key.use === 'enc' || key.use === undefined) &&
                            key.length === size
                    }
                })
            }

            /***/
        },

        /***/ xh2E: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const indentString = __webpack_require__('S6im')
            const cleanStack = __webpack_require__('9rVn')

            const cleanInternalStack = stack =>
                stack.replace(
                    /\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g,
                    ''
                )

            class AggregateError extends Error {
                constructor(errors) {
                    if (!Array.isArray(errors)) {
                        throw new TypeError(
                            `Expected input to be an Array, got ${typeof errors}`
                        )
                    }

                    errors = [...errors].map(error => {
                        if (error instanceof Error) {
                            return error
                        }

                        if (error !== null && typeof error === 'object') {
                            // Handle plain error objects with message property and/or possibly other metadata
                            return Object.assign(
                                new Error(error.message),
                                error
                            )
                        }

                        return new Error(error)
                    })

                    let message = errors
                        .map(error => {
                            // The `stack` property is not standardized, so we can't assume it exists
                            return typeof error.stack === 'string'
                                ? cleanInternalStack(cleanStack(error.stack))
                                : String(error)
                        })
                        .join('\n')
                    message = '\n' + indentString(message, 4)
                    super(message)

                    this.name = 'AggregateError'

                    Object.defineProperty(this, '_errors', { value: errors })
                }

                *[Symbol.iterator]() {
                    for (const error of this._errors) {
                        yield error
                    }
                }
            }

            module.exports = AggregateError

            /***/
        },

        /***/ xkKp: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var Buffer = __webpack_require__('xZGU').Buffer

            // UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
            // See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

            exports.utf7 = Utf7Codec
            exports.unicode11utf7 = 'utf7' // Alias UNICODE-1-1-UTF-7
            function Utf7Codec(codecOptions, iconv) {
                this.iconv = iconv
            }

            Utf7Codec.prototype.encoder = Utf7Encoder
            Utf7Codec.prototype.decoder = Utf7Decoder
            Utf7Codec.prototype.bomAware = true

            // -- Encoding

            var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g

            function Utf7Encoder(options, codec) {
                this.iconv = codec.iconv
            }

            Utf7Encoder.prototype.write = function(str) {
                // Naive implementation.
                // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
                return Buffer.from(
                    str.replace(
                        nonDirectChars,
                        function(chunk) {
                            return (
                                '+' +
                                (chunk === '+'
                                    ? ''
                                    : this.iconv
                                          .encode(chunk, 'utf16-be')
                                          .toString('base64')
                                          .replace(/=+$/, '')) +
                                '-'
                            )
                        }.bind(this)
                    )
                )
            }

            Utf7Encoder.prototype.end = function() {}

            // -- Decoding

            function Utf7Decoder(options, codec) {
                this.iconv = codec.iconv
                this.inBase64 = false
                this.base64Accum = ''
            }

            var base64Regex = /[A-Za-z0-9\/+]/
            var base64Chars = []
            for (var i = 0; i < 256; i++)
                base64Chars[i] = base64Regex.test(String.fromCharCode(i))

            var plusChar = '+'.charCodeAt(0),
                minusChar = '-'.charCodeAt(0),
                andChar = '&'.charCodeAt(0)

            Utf7Decoder.prototype.write = function(buf) {
                var res = '',
                    lastI = 0,
                    inBase64 = this.inBase64,
                    base64Accum = this.base64Accum

                // The decoder is more involved as we must handle chunks in stream.

                for (var i = 0; i < buf.length; i++) {
                    if (!inBase64) {
                        // We're in direct mode.
                        // Write direct chars until '+'
                        if (buf[i] == plusChar) {
                            res += this.iconv.decode(
                                buf.slice(lastI, i),
                                'ascii'
                            ) // Write direct chars.
                            lastI = i + 1
                            inBase64 = true
                        }
                    } else {
                        // We decode base64.
                        if (!base64Chars[buf[i]]) {
                            // Base64 ended.
                            if (i == lastI && buf[i] == minusChar) {
                                // "+-" -> "+"
                                res += '+'
                            } else {
                                var b64str =
                                    base64Accum + buf.slice(lastI, i).toString()
                                res += this.iconv.decode(
                                    Buffer.from(b64str, 'base64'),
                                    'utf16-be'
                                )
                            }

                            if (buf[i] != minusChar)
                                // Minus is absorbed after base64.
                                i--

                            lastI = i + 1
                            inBase64 = false
                            base64Accum = ''
                        }
                    }
                }

                if (!inBase64) {
                    res += this.iconv.decode(buf.slice(lastI), 'ascii') // Write direct chars.
                } else {
                    var b64str = base64Accum + buf.slice(lastI).toString()

                    var canBeDecoded = b64str.length - (b64str.length % 8) // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
                    base64Accum = b64str.slice(canBeDecoded) // The rest will be decoded in future.
                    b64str = b64str.slice(0, canBeDecoded)

                    res += this.iconv.decode(
                        Buffer.from(b64str, 'base64'),
                        'utf16-be'
                    )
                }

                this.inBase64 = inBase64
                this.base64Accum = base64Accum

                return res
            }

            Utf7Decoder.prototype.end = function() {
                var res = ''
                if (this.inBase64 && this.base64Accum.length > 0)
                    res = this.iconv.decode(
                        Buffer.from(this.base64Accum, 'base64'),
                        'utf16-be'
                    )

                this.inBase64 = false
                this.base64Accum = ''
                return res
            }

            // UTF-7-IMAP codec.
            // RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
            // Differences:
            //  * Base64 part is started by "&" instead of "+"
            //  * Direct characters are 0x20-0x7E, except "&" (0x26)
            //  * In Base64, "," is used instead of "/"
            //  * Base64 must not be used to represent direct characters.
            //  * No implicit shift back from Base64 (should always end with '-')
            //  * String must end in non-shifted position.
            //  * "-&" while in base64 is not allowed.

            exports.utf7imap = Utf7IMAPCodec
            function Utf7IMAPCodec(codecOptions, iconv) {
                this.iconv = iconv
            }

            Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder
            Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder
            Utf7IMAPCodec.prototype.bomAware = true

            // -- Encoding

            function Utf7IMAPEncoder(options, codec) {
                this.iconv = codec.iconv
                this.inBase64 = false
                this.base64Accum = Buffer.alloc(6)
                this.base64AccumIdx = 0
            }

            Utf7IMAPEncoder.prototype.write = function(str) {
                var inBase64 = this.inBase64,
                    base64Accum = this.base64Accum,
                    base64AccumIdx = this.base64AccumIdx,
                    buf = Buffer.alloc(str.length * 5 + 10),
                    bufIdx = 0

                for (var i = 0; i < str.length; i++) {
                    var uChar = str.charCodeAt(i)
                    if (0x20 <= uChar && uChar <= 0x7e) {
                        // Direct character or '&'.
                        if (inBase64) {
                            if (base64AccumIdx > 0) {
                                bufIdx += buf.write(
                                    base64Accum
                                        .slice(0, base64AccumIdx)
                                        .toString('base64')
                                        .replace(/\//g, ',')
                                        .replace(/=+$/, ''),
                                    bufIdx
                                )
                                base64AccumIdx = 0
                            }

                            buf[bufIdx++] = minusChar // Write '-', then go to direct mode.
                            inBase64 = false
                        }

                        if (!inBase64) {
                            buf[bufIdx++] = uChar // Write direct character

                            if (uChar === andChar)
                                // Ampersand -> '&-'
                                buf[bufIdx++] = minusChar
                        }
                    } else {
                        // Non-direct character
                        if (!inBase64) {
                            buf[bufIdx++] = andChar // Write '&', then go to base64 mode.
                            inBase64 = true
                        }
                        if (inBase64) {
                            base64Accum[base64AccumIdx++] = uChar >> 8
                            base64Accum[base64AccumIdx++] = uChar & 0xff

                            if (base64AccumIdx == base64Accum.length) {
                                bufIdx += buf.write(
                                    base64Accum
                                        .toString('base64')
                                        .replace(/\//g, ','),
                                    bufIdx
                                )
                                base64AccumIdx = 0
                            }
                        }
                    }
                }

                this.inBase64 = inBase64
                this.base64AccumIdx = base64AccumIdx

                return buf.slice(0, bufIdx)
            }

            Utf7IMAPEncoder.prototype.end = function() {
                var buf = Buffer.alloc(10),
                    bufIdx = 0
                if (this.inBase64) {
                    if (this.base64AccumIdx > 0) {
                        bufIdx += buf.write(
                            this.base64Accum
                                .slice(0, this.base64AccumIdx)
                                .toString('base64')
                                .replace(/\//g, ',')
                                .replace(/=+$/, ''),
                            bufIdx
                        )
                        this.base64AccumIdx = 0
                    }

                    buf[bufIdx++] = minusChar // Write '-', then go to direct mode.
                    this.inBase64 = false
                }

                return buf.slice(0, bufIdx)
            }

            // -- Decoding

            function Utf7IMAPDecoder(options, codec) {
                this.iconv = codec.iconv
                this.inBase64 = false
                this.base64Accum = ''
            }

            var base64IMAPChars = base64Chars.slice()
            base64IMAPChars[','.charCodeAt(0)] = true

            Utf7IMAPDecoder.prototype.write = function(buf) {
                var res = '',
                    lastI = 0,
                    inBase64 = this.inBase64,
                    base64Accum = this.base64Accum

                // The decoder is more involved as we must handle chunks in stream.
                // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

                for (var i = 0; i < buf.length; i++) {
                    if (!inBase64) {
                        // We're in direct mode.
                        // Write direct chars until '&'
                        if (buf[i] == andChar) {
                            res += this.iconv.decode(
                                buf.slice(lastI, i),
                                'ascii'
                            ) // Write direct chars.
                            lastI = i + 1
                            inBase64 = true
                        }
                    } else {
                        // We decode base64.
                        if (!base64IMAPChars[buf[i]]) {
                            // Base64 ended.
                            if (i == lastI && buf[i] == minusChar) {
                                // "&-" -> "&"
                                res += '&'
                            } else {
                                var b64str =
                                    base64Accum +
                                    buf
                                        .slice(lastI, i)
                                        .toString()
                                        .replace(/,/g, '/')
                                res += this.iconv.decode(
                                    Buffer.from(b64str, 'base64'),
                                    'utf16-be'
                                )
                            }

                            if (buf[i] != minusChar)
                                // Minus may be absorbed after base64.
                                i--

                            lastI = i + 1
                            inBase64 = false
                            base64Accum = ''
                        }
                    }
                }

                if (!inBase64) {
                    res += this.iconv.decode(buf.slice(lastI), 'ascii') // Write direct chars.
                } else {
                    var b64str =
                        base64Accum +
                        buf
                            .slice(lastI)
                            .toString()
                            .replace(/,/g, '/')

                    var canBeDecoded = b64str.length - (b64str.length % 8) // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
                    base64Accum = b64str.slice(canBeDecoded) // The rest will be decoded in future.
                    b64str = b64str.slice(0, canBeDecoded)

                    res += this.iconv.decode(
                        Buffer.from(b64str, 'base64'),
                        'utf16-be'
                    )
                }

                this.inBase64 = inBase64
                this.base64Accum = base64Accum

                return res
            }

            Utf7IMAPDecoder.prototype.end = function() {
                var res = ''
                if (this.inBase64 && this.base64Accum.length > 0)
                    res = this.iconv.decode(
                        Buffer.from(this.base64Accum, 'base64'),
                        'utf16-be'
                    )

                this.inBase64 = false
                this.base64Accum = ''
                return res
            }

            /***/
        },

        /***/ 'y/nk': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { URL } = __webpack_require__('bzos') // TODO: Use the `URL` global when targeting Node.js 10
            const util = __webpack_require__('jK02')
            const EventEmitter = __webpack_require__('/0p4')
            const http = __webpack_require__('KEll')
            const https = __webpack_require__('7WL4')
            const urlLib = __webpack_require__('bzos')
            const CacheableRequest = __webpack_require__('eC53')
            const toReadableStream = __webpack_require__('MrQC')
            const is = __webpack_require__('6mOv')
            const timer = __webpack_require__('j0Yl')
            const timedOut = __webpack_require__('2IvE')
            const getBodySize = __webpack_require__('10GS')
            const getResponse = __webpack_require__('zFNg')
            const progress = __webpack_require__('K0QS')
            const {
                CacheError,
                UnsupportedProtocolError,
                MaxRedirectsError,
                RequestError,
                TimeoutError
            } = __webpack_require__('9Fi5')
            const urlToOptions = __webpack_require__('NHoT')

            const getMethodRedirectCodes = new Set([
                300,
                301,
                302,
                303,
                304,
                305,
                307,
                308
            ])
            const allMethodRedirectCodes = new Set([300, 303, 307, 308])

            module.exports = (options, input) => {
                const emitter = new EventEmitter()
                const redirects = []
                let currentRequest
                let requestUrl
                let redirectString
                let uploadBodySize
                let retryCount = 0
                let shouldAbort = false

                const setCookie = options.cookieJar
                    ? util.promisify(
                          options.cookieJar.setCookie.bind(options.cookieJar)
                      )
                    : null
                const getCookieString = options.cookieJar
                    ? util.promisify(
                          options.cookieJar.getCookieString.bind(
                              options.cookieJar
                          )
                      )
                    : null
                const agents = is.object(options.agent) ? options.agent : null

                const emitError = async error => {
                    try {
                        for (const hook of options.hooks.beforeError) {
                            // eslint-disable-next-line no-await-in-loop
                            error = await hook(error)
                        }

                        emitter.emit('error', error)
                    } catch (error2) {
                        emitter.emit('error', error2)
                    }
                }

                const get = async options => {
                    const currentUrl = redirectString || requestUrl

                    if (
                        options.protocol !== 'http:' &&
                        options.protocol !== 'https:'
                    ) {
                        throw new UnsupportedProtocolError(options)
                    }

                    decodeURI(currentUrl)

                    let fn
                    if (is.function(options.request)) {
                        fn = { request: options.request }
                    } else {
                        fn = options.protocol === 'https:' ? https : http
                    }

                    if (agents) {
                        const protocolName =
                            options.protocol === 'https:' ? 'https' : 'http'
                        options.agent = agents[protocolName] || options.agent
                    }

                    /* istanbul ignore next: electron.net is broken */
                    if (options.useElectronNet && process.versions.electron) {
                        const r = { x: __webpack_require__('/SMw') }[
                            'yx'.slice(1)
                        ] // Trick webpack
                        const electron = r('electron')
                        fn = electron.net || electron.remote.net
                    }

                    if (options.cookieJar) {
                        const cookieString = await getCookieString(
                            currentUrl,
                            {}
                        )

                        if (is.nonEmptyString(cookieString)) {
                            options.headers.cookie = cookieString
                        }
                    }

                    let timings
                    const handleResponse = async response => {
                        try {
                            /* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */
                            if (options.useElectronNet) {
                                response = new Proxy(response, {
                                    get: (target, name) => {
                                        if (
                                            name === 'trailers' ||
                                            name === 'rawTrailers'
                                        ) {
                                            return []
                                        }

                                        const value = target[name]
                                        return is.function(value)
                                            ? value.bind(target)
                                            : value
                                    }
                                })
                            }

                            const { statusCode } = response
                            response.url = currentUrl
                            response.requestUrl = requestUrl
                            response.retryCount = retryCount
                            response.timings = timings
                            response.redirectUrls = redirects
                            response.request = {
                                gotOptions: options
                            }

                            const rawCookies = response.headers['set-cookie']
                            if (options.cookieJar && rawCookies) {
                                await Promise.all(
                                    rawCookies.map(rawCookie =>
                                        setCookie(rawCookie, response.url)
                                    )
                                )
                            }

                            if (
                                options.followRedirect &&
                                'location' in response.headers
                            ) {
                                if (
                                    allMethodRedirectCodes.has(statusCode) ||
                                    (getMethodRedirectCodes.has(statusCode) &&
                                        (options.method === 'GET' ||
                                            options.method === 'HEAD'))
                                ) {
                                    response.resume() // We're being redirected, we don't care about the response.

                                    if (statusCode === 303) {
                                        // Server responded with "see other", indicating that the resource exists at another location,
                                        // and the client should request it from that location via GET or HEAD.
                                        options.method = 'GET'
                                    }

                                    if (redirects.length >= 10) {
                                        throw new MaxRedirectsError(
                                            statusCode,
                                            redirects,
                                            options
                                        )
                                    }

                                    // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604
                                    const redirectBuffer = Buffer.from(
                                        response.headers.location,
                                        'binary'
                                    ).toString()
                                    const redirectURL = new URL(
                                        redirectBuffer,
                                        currentUrl
                                    )
                                    redirectString = redirectURL.toString()

                                    redirects.push(redirectString)

                                    const redirectOptions = {
                                        ...options,
                                        ...urlToOptions(redirectURL)
                                    }

                                    for (const hook of options.hooks
                                        .beforeRedirect) {
                                        // eslint-disable-next-line no-await-in-loop
                                        await hook(redirectOptions)
                                    }

                                    emitter.emit(
                                        'redirect',
                                        response,
                                        redirectOptions
                                    )

                                    await get(redirectOptions)
                                    return
                                }
                            }

                            getResponse(response, options, emitter)
                        } catch (error) {
                            emitError(error)
                        }
                    }

                    const handleRequest = request => {
                        if (shouldAbort) {
                            request.once('error', () => {})
                            request.abort()
                            return
                        }

                        currentRequest = request

                        request.once('error', error => {
                            if (request.aborted) {
                                return
                            }

                            if (error instanceof timedOut.TimeoutError) {
                                error = new TimeoutError(error, options)
                            } else {
                                error = new RequestError(error, options)
                            }

                            if (emitter.retry(error) === false) {
                                emitError(error)
                            }
                        })

                        timings = timer(request)

                        progress.upload(request, emitter, uploadBodySize)

                        if (options.gotTimeout) {
                            timedOut(request, options.gotTimeout, options)
                        }

                        emitter.emit('request', request)

                        const uploadComplete = () => {
                            request.emit('upload-complete')
                        }

                        try {
                            if (is.nodeStream(options.body)) {
                                options.body.once('end', uploadComplete)
                                options.body.pipe(request)
                                options.body = undefined
                            } else if (options.body) {
                                request.end(options.body, uploadComplete)
                            } else if (
                                input &&
                                (options.method === 'POST' ||
                                    options.method === 'PUT' ||
                                    options.method === 'PATCH')
                            ) {
                                input.once('end', uploadComplete)
                                input.pipe(request)
                            } else {
                                request.end(uploadComplete)
                            }
                        } catch (error) {
                            emitError(new RequestError(error, options))
                        }
                    }

                    if (options.cache) {
                        const cacheableRequest = new CacheableRequest(
                            fn.request,
                            options.cache
                        )
                        const cacheRequest = cacheableRequest(
                            options,
                            handleResponse
                        )

                        cacheRequest.once('error', error => {
                            if (
                                error instanceof CacheableRequest.RequestError
                            ) {
                                emitError(new RequestError(error, options))
                            } else {
                                emitError(new CacheError(error, options))
                            }
                        })

                        cacheRequest.once('request', handleRequest)
                    } else {
                        // Catches errors thrown by calling fn.request(...)
                        try {
                            handleRequest(fn.request(options, handleResponse))
                        } catch (error) {
                            emitError(new RequestError(error, options))
                        }
                    }
                }

                emitter.retry = error => {
                    let backoff

                    try {
                        backoff = options.retry.retries(++retryCount, error)
                    } catch (error2) {
                        emitError(error2)
                        return
                    }

                    if (backoff) {
                        const retry = async options => {
                            try {
                                for (const hook of options.hooks.beforeRetry) {
                                    // eslint-disable-next-line no-await-in-loop
                                    await hook(options, error, retryCount)
                                }

                                await get(options)
                            } catch (error) {
                                emitError(error)
                            }
                        }

                        setTimeout(retry, backoff, {
                            ...options,
                            forceRefresh: true
                        })
                        return true
                    }

                    return false
                }

                emitter.abort = () => {
                    if (currentRequest) {
                        currentRequest.once('error', () => {})
                        currentRequest.abort()
                    } else {
                        shouldAbort = true
                    }
                }

                setImmediate(async () => {
                    try {
                        // Convert buffer to stream to receive upload progress events (#322)
                        const { body } = options
                        if (is.buffer(body)) {
                            options.body = toReadableStream(body)
                            uploadBodySize = body.length
                        } else {
                            uploadBodySize = await getBodySize(options)
                        }

                        if (
                            is.undefined(options.headers['content-length']) &&
                            is.undefined(options.headers['transfer-encoding'])
                        ) {
                            if (
                                (uploadBodySize > 0 ||
                                    options.method === 'PUT') &&
                                !is.null(uploadBodySize)
                            ) {
                                options.headers[
                                    'content-length'
                                ] = uploadBodySize
                            }
                        }

                        for (const hook of options.hooks.beforeRequest) {
                            // eslint-disable-next-line no-await-in-loop
                            await hook(options)
                        }

                        requestUrl =
                            options.href ||
                            new URL(
                                options.path,
                                urlLib.format(options)
                            ).toString()

                        await get(options)
                    } catch (error) {
                        emitError(error)
                    }
                })

                return emitter
            }

            /***/
        },

        /***/ 'y1+z': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = function(obj) {
                var ret = {}
                var keys = Object.keys(Object(obj))

                for (var i = 0; i < keys.length; i++) {
                    ret[keys[i].toLowerCase()] = obj[keys[i]]
                }

                return ret
            }

            /***/
        },

        /***/ y1pI: /***/ function(module, exports, __webpack_require__) {
            var eq = __webpack_require__('ljhN')

            /**
             * Gets the index at which the `key` is found in `array` of key-value pairs.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {*} key The key to search for.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function assocIndexOf(array, key) {
                var length = array.length
                while (length--) {
                    if (eq(array[length][0], key)) {
                        return length
                    }
                }
                return -1
            }

            module.exports = assocIndexOf

            /***/
        },

        /***/ yAVD: /***/ function(module, exports) {
            module.exports = function() {
                this.seq().obj(
                    this.key('algorithm').objid(),
                    this.key('parameters')
                        .optional()
                        .any()
                )
            }

            /***/
        },

        /***/ yGk4: /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5'),
                root = __webpack_require__('Kz5y')

            /* Built-in method references that are verified to be native. */
            var Set = getNative(root, 'Set')

            module.exports = Set

            /***/
        },

        /***/ yHx3: /***/ function(module, exports) {
            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Initializes an array clone.
             *
             * @private
             * @param {Array} array The array to clone.
             * @returns {Array} Returns the initialized clone.
             */
            function initCloneArray(array) {
                var length = array.length,
                    result = new array.constructor(length)

                // Add properties assigned by `RegExp#exec`.
                if (
                    length &&
                    typeof array[0] == 'string' &&
                    hasOwnProperty.call(array, 'index')
                ) {
                    result.index = array.index
                    result.input = array.input
                }
                return result
            }

            module.exports = initCloneArray

            /***/
        },

        /***/ yP5f: /***/ function(module, exports, __webpack_require__) {
            var cloneArrayBuffer = __webpack_require__('+K+b')

            /**
             * Creates a clone of `typedArray`.
             *
             * @private
             * @param {Object} typedArray The typed array to clone.
             * @param {boolean} [isDeep] Specify a deep clone.
             * @returns {Object} Returns the cloned typed array.
             */
            function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep
                    ? cloneArrayBuffer(typedArray.buffer)
                    : typedArray.buffer
                return new typedArray.constructor(
                    buffer,
                    typedArray.byteOffset,
                    typedArray.length
                )
            }

            module.exports = cloneTypedArray

            /***/
        },

        /***/ yt7c: /***/ function(module, exports) {
            const CODES = {
                JOSEAlgNotWhitelisted: 'ERR_JOSE_ALG_NOT_WHITELISTED',
                JOSECritNotUnderstood: 'ERR_JOSE_CRIT_NOT_UNDERSTOOD',
                JOSEInvalidEncoding: 'ERR_JOSE_INVALID_ENCODING',
                JOSEMultiError: 'ERR_JOSE_MULTIPLE_ERRORS',
                JOSENotSupported: 'ERR_JOSE_NOT_SUPPORTED',
                JWEDecryptionFailed: 'ERR_JWE_DECRYPTION_FAILED',
                JWEInvalid: 'ERR_JWE_INVALID',
                JWKImportFailed: 'ERR_JWK_IMPORT_FAILED',
                JWKInvalid: 'ERR_JWK_INVALID',
                JWKKeySupport: 'ERR_JWK_KEY_SUPPORT',
                JWKSNoMatchingKey: 'ERR_JWKS_NO_MATCHING_KEY',
                JWSInvalid: 'ERR_JWS_INVALID',
                JWSVerificationFailed: 'ERR_JWS_VERIFICATION_FAILED',
                JWTClaimInvalid: 'ERR_JWT_CLAIM_INVALID',
                JWTExpired: 'ERR_JWT_EXPIRED',
                JWTMalformed: 'ERR_JWT_MALFORMED'
            }

            const DEFAULT_MESSAGES = {
                JWEDecryptionFailed: 'decryption operation failed',
                JWEInvalid: 'JWE invalid',
                JWKSNoMatchingKey: 'no matching key found in the KeyStore',
                JWSInvalid: 'JWS invalid',
                JWSVerificationFailed: 'signature verification failed'
            }

            class JOSEError extends Error {
                constructor(message) {
                    super(message)
                    if (message === undefined) {
                        this.message = DEFAULT_MESSAGES[this.constructor.name]
                    }
                    this.name = this.constructor.name
                    this.code = CODES[this.constructor.name]
                    Error.captureStackTrace(this, this.constructor)
                }
            }

            const isMulti = e => e instanceof JOSEMultiError
            class JOSEMultiError extends JOSEError {
                constructor(errors) {
                    super()
                    let i
                    while ((i = errors.findIndex(isMulti)) && i !== -1) {
                        errors.splice(i, 1, ...errors[i])
                    }
                    Object.defineProperty(this, 'errors', { value: errors })
                }

                *[Symbol.iterator]() {
                    for (const error of this.errors) {
                        yield error
                    }
                }
            }
            module.exports.JOSEError = JOSEError

            module.exports.JOSEAlgNotWhitelisted = class JOSEAlgNotWhitelisted extends JOSEError {}
            module.exports.JOSECritNotUnderstood = class JOSECritNotUnderstood extends JOSEError {}
            module.exports.JOSEInvalidEncoding = class JOSEInvalidEncoding extends JOSEError {}
            module.exports.JOSEMultiError = JOSEMultiError
            module.exports.JOSENotSupported = class JOSENotSupported extends JOSEError {}

            module.exports.JWEDecryptionFailed = class JWEDecryptionFailed extends JOSEError {}
            module.exports.JWEInvalid = class JWEInvalid extends JOSEError {}

            module.exports.JWKImportFailed = class JWKImportFailed extends JOSEError {}
            module.exports.JWKInvalid = class JWKInvalid extends JOSEError {}
            module.exports.JWKKeySupport = class JWKKeySupport extends JOSEError {}

            module.exports.JWKSNoMatchingKey = class JWKSNoMatchingKey extends JOSEError {}

            module.exports.JWSInvalid = class JWSInvalid extends JOSEError {}
            module.exports.JWSVerificationFailed = class JWSVerificationFailed extends JOSEError {}

            class JWTClaimInvalid extends JOSEError {
                constructor(
                    message,
                    claim = 'unspecified',
                    reason = 'unspecified'
                ) {
                    super(message)
                    this.claim = claim
                    this.reason = reason
                }
            }
            module.exports.JWTClaimInvalid = JWTClaimInvalid
            module.exports.JWTExpired = class JWTExpired extends JWTClaimInvalid {}
            module.exports.JWTMalformed = class JWTMalformed extends JOSEError {}

            /***/
        },

        /***/ 'z/H/': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const is = __webpack_require__('6mOv')

            module.exports = function deepFreeze(object) {
                for (const [key, value] of Object.entries(object)) {
                    if (is.plainObject(value) || is.array(value)) {
                        deepFreeze(object[key])
                    }
                }

                return Object.freeze(object)
            }

            /***/
        },

        /***/ zCb7: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(input) {
                if (!input) {
                    return ''
                }

                const lessThan = 0x3c
                const greaterThan = 0x3e
                const andSymbol = 0x26
                const lineSeperator = 0x2028

                // replace method
                let charCode
                return input.replace(/[<>&\u2028\u2029]/g, match => {
                    charCode = match.charCodeAt(0)

                    if (charCode === lessThan) {
                        return '\\u003c'
                    }

                    if (charCode === greaterThan) {
                        return '\\u003e'
                    }

                    if (charCode === andSymbol) {
                        return '\\u0026'
                    }

                    if (charCode === lineSeperator) {
                        return '\\u2028'
                    }

                    return '\\u2029'
                })
            }

            /***/
        },

        /***/ zEVN: /***/ function(module, exports, __webpack_require__) {
            var baseIsMap = __webpack_require__('Gi0A'),
                baseUnary = __webpack_require__('sEf8'),
                nodeUtil = __webpack_require__('mdPL')

            /* Node.js helper references. */
            var nodeIsMap = nodeUtil && nodeUtil.isMap

            /**
             * Checks if `value` is classified as a `Map` object.
             *
             * @static
             * @memberOf _
             * @since 4.3.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a map, else `false`.
             * @example
             *
             * _.isMap(new Map);
             * // => true
             *
             * _.isMap(new WeakMap);
             * // => false
             */
            var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap

            module.exports = isMap

            /***/
        },

        /***/ zFNg: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const decompressResponse = __webpack_require__('YNnK')
            const is = __webpack_require__('6mOv')
            const mimicResponse = __webpack_require__('qsvm')
            const progress = __webpack_require__('K0QS')

            module.exports = (response, options, emitter) => {
                const downloadBodySize =
                    Number(response.headers['content-length']) || null

                const progressStream = progress.download(
                    response,
                    emitter,
                    downloadBodySize
                )

                mimicResponse(response, progressStream)

                const newResponse =
                    options.decompress === true &&
                    is.function(decompressResponse) &&
                    options.method !== 'HEAD'
                        ? decompressResponse(progressStream)
                        : progressStream

                if (
                    !options.decompress &&
                    ['gzip', 'deflate'].includes(
                        response.headers['content-encoding']
                    )
                ) {
                    options.encoding = null
                }

                emitter.emit('response', newResponse)

                emitter.emit('downloadProgress', {
                    percent: 0,
                    transferred: 0,
                    total: downloadBodySize
                })

                response.pipe(progressStream)
            }

            /***/
        },

        /***/ zKJz: /***/ function(module, exports, __webpack_require__) {
            const decode = __webpack_require__('7o4N')
            const sign = __webpack_require__('6I+L')
            const verify = __webpack_require__('BOd6')
            const profiles = __webpack_require__('qXE0')

            module.exports = {
                decode,
                sign,
                verify,
                ...profiles
            }

            /***/
        },

        /***/ zOht: /***/ function(module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_ARRAY__,
                __WEBPACK_AMD_DEFINE_RESULT__ /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
            /* global global, define, System, Reflect, Promise */
            var __extends
            var __assign
            var __rest
            var __decorate
            var __param
            var __metadata
            var __awaiter
            var __generator
            var __exportStar
            var __values
            var __read
            var __spread
            var __spreadArrays
            var __await
            var __asyncGenerator
            var __asyncDelegator
            var __asyncValues
            var __makeTemplateObject
            var __importStar
            var __importDefault
            ;(function(factory) {
                var root =
                    typeof global === 'object'
                        ? global
                        : typeof self === 'object'
                        ? self
                        : typeof this === 'object'
                        ? this
                        : {}
                if (true) {
                    !((__WEBPACK_AMD_DEFINE_ARRAY__ = [exports]),
                    (__WEBPACK_AMD_DEFINE_RESULT__ = function(exports) {
                        factory(createExporter(root, createExporter(exports)))
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                        (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
                } else {
                }
                function createExporter(exports, previous) {
                    if (exports !== root) {
                        if (typeof Object.create === 'function') {
                            Object.defineProperty(exports, '__esModule', {
                                value: true
                            })
                        } else {
                            exports.__esModule = true
                        }
                    }
                    return function(id, v) {
                        return (exports[id] = previous ? previous(id, v) : v)
                    }
                }
            })(function(exporter) {
                var extendStatics =
                    Object.setPrototypeOf ||
                    ({ __proto__: [] } instanceof Array &&
                        function(d, b) {
                            d.__proto__ = b
                        }) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                    }

                __extends = function(d, b) {
                    extendStatics(d, b)
                    function __() {
                        this.constructor = d
                    }
                    d.prototype =
                        b === null
                            ? Object.create(b)
                            : ((__.prototype = b.prototype), new __())
                }

                __assign =
                    Object.assign ||
                    function(t) {
                        for (var s, i = 1, n = arguments.length; i < n; i++) {
                            s = arguments[i]
                            for (var p in s)
                                if (Object.prototype.hasOwnProperty.call(s, p))
                                    t[p] = s[p]
                        }
                        return t
                    }

                __rest = function(s, e) {
                    var t = {}
                    for (var p in s)
                        if (
                            Object.prototype.hasOwnProperty.call(s, p) &&
                            e.indexOf(p) < 0
                        )
                            t[p] = s[p]
                    if (
                        s != null &&
                        typeof Object.getOwnPropertySymbols === 'function'
                    )
                        for (
                            var i = 0, p = Object.getOwnPropertySymbols(s);
                            i < p.length;
                            i++
                        ) {
                            if (
                                e.indexOf(p[i]) < 0 &&
                                Object.prototype.propertyIsEnumerable.call(
                                    s,
                                    p[i]
                                )
                            )
                                t[p[i]] = s[p[i]]
                        }
                    return t
                }

                __decorate = function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r =
                            c < 3
                                ? target
                                : desc === null
                                ? (desc = Object.getOwnPropertyDescriptor(
                                      target,
                                      key
                                  ))
                                : desc,
                        d
                    if (
                        typeof Reflect === 'object' &&
                        typeof Reflect.decorate === 'function'
                    )
                        r = Reflect.decorate(decorators, target, key, desc)
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i]))
                                r =
                                    (c < 3
                                        ? d(r)
                                        : c > 3
                                        ? d(target, key, r)
                                        : d(target, key)) || r
                    return (
                        c > 3 && r && Object.defineProperty(target, key, r), r
                    )
                }

                __param = function(paramIndex, decorator) {
                    return function(target, key) {
                        decorator(target, key, paramIndex)
                    }
                }

                __metadata = function(metadataKey, metadataValue) {
                    if (
                        typeof Reflect === 'object' &&
                        typeof Reflect.metadata === 'function'
                    )
                        return Reflect.metadata(metadataKey, metadataValue)
                }

                __awaiter = function(thisArg, _arguments, P, generator) {
                    return new (P || (P = Promise))(function(resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value))
                            } catch (e) {
                                reject(e)
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value))
                            } catch (e) {
                                reject(e)
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : new P(function(resolve) {
                                      resolve(result.value)
                                  }).then(fulfilled, rejected)
                        }
                        step(
                            (generator = generator.apply(
                                thisArg,
                                _arguments || []
                            )).next()
                        )
                    })
                }

                __generator = function(thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function() {
                                if (t[0] & 1) throw t[1]
                                return t[1]
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g
                    return (
                        (g = {
                            next: verb(0),
                            throw: verb(1),
                            return: verb(2)
                        }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function() {
                                return this
                            }),
                        g
                    )
                    function verb(n) {
                        return function(v) {
                            return step([n, v])
                        }
                    }
                    function step(op) {
                        if (f)
                            throw new TypeError(
                                'Generator is already executing.'
                            )
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] ||
                                                  ((t = y['return']) &&
                                                      t.call(y),
                                                  0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t
                                if (((y = 0), t)) op = [op[0] & 2, t.value]
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op
                                        break
                                    case 4:
                                        _.label++
                                        return { value: op[1], done: false }
                                    case 5:
                                        _.label++
                                        y = op[1]
                                        op = [0]
                                        continue
                                    case 7:
                                        op = _.ops.pop()
                                        _.trys.pop()
                                        continue
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t =
                                                t.length > 0 &&
                                                t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0
                                            continue
                                        }
                                        if (
                                            op[0] === 3 &&
                                            (!t ||
                                                (op[1] > t[0] && op[1] < t[3]))
                                        ) {
                                            _.label = op[1]
                                            break
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1]
                                            t = op
                                            break
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2]
                                            _.ops.push(op)
                                            break
                                        }
                                        if (t[2]) _.ops.pop()
                                        _.trys.pop()
                                        continue
                                }
                                op = body.call(thisArg, _)
                            } catch (e) {
                                op = [6, e]
                                y = 0
                            } finally {
                                f = t = 0
                            }
                        if (op[0] & 5) throw op[1]
                        return { value: op[0] ? op[1] : void 0, done: true }
                    }
                }

                __exportStar = function(m, exports) {
                    for (var p in m)
                        if (!exports.hasOwnProperty(p)) exports[p] = m[p]
                }

                __values = function(o) {
                    var m = typeof Symbol === 'function' && o[Symbol.iterator],
                        i = 0
                    if (m) return m.call(o)
                    return {
                        next: function() {
                            if (o && i >= o.length) o = void 0
                            return { value: o && o[i++], done: !o }
                        }
                    }
                }

                __read = function(o, n) {
                    var m = typeof Symbol === 'function' && o[Symbol.iterator]
                    if (!m) return o
                    var i = m.call(o),
                        r,
                        ar = [],
                        e
                    try {
                        while (
                            (n === void 0 || n-- > 0) &&
                            !(r = i.next()).done
                        )
                            ar.push(r.value)
                    } catch (error) {
                        e = { error: error }
                    } finally {
                        try {
                            if (r && !r.done && (m = i['return'])) m.call(i)
                        } finally {
                            if (e) throw e.error
                        }
                    }
                    return ar
                }

                __spread = function() {
                    for (var ar = [], i = 0; i < arguments.length; i++)
                        ar = ar.concat(__read(arguments[i]))
                    return ar
                }

                __spreadArrays = function() {
                    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
                        s += arguments[i].length
                    for (var r = Array(s), k = 0, i = 0; i < il; i++)
                        for (
                            var a = arguments[i], j = 0, jl = a.length;
                            j < jl;
                            j++, k++
                        )
                            r[k] = a[j]
                    return r
                }

                __await = function(v) {
                    return this instanceof __await
                        ? ((this.v = v), this)
                        : new __await(v)
                }

                __asyncGenerator = function(thisArg, _arguments, generator) {
                    if (!Symbol.asyncIterator)
                        throw new TypeError(
                            'Symbol.asyncIterator is not defined.'
                        )
                    var g = generator.apply(thisArg, _arguments || []),
                        i,
                        q = []
                    return (
                        (i = {}),
                        verb('next'),
                        verb('throw'),
                        verb('return'),
                        (i[Symbol.asyncIterator] = function() {
                            return this
                        }),
                        i
                    )
                    function verb(n) {
                        if (g[n])
                            i[n] = function(v) {
                                return new Promise(function(a, b) {
                                    q.push([n, v, a, b]) > 1 || resume(n, v)
                                })
                            }
                    }
                    function resume(n, v) {
                        try {
                            step(g[n](v))
                        } catch (e) {
                            settle(q[0][3], e)
                        }
                    }
                    function step(r) {
                        r.value instanceof __await
                            ? Promise.resolve(r.value.v).then(fulfill, reject)
                            : settle(q[0][2], r)
                    }
                    function fulfill(value) {
                        resume('next', value)
                    }
                    function reject(value) {
                        resume('throw', value)
                    }
                    function settle(f, v) {
                        if ((f(v), q.shift(), q.length))
                            resume(q[0][0], q[0][1])
                    }
                }

                __asyncDelegator = function(o) {
                    var i, p
                    return (
                        (i = {}),
                        verb('next'),
                        verb('throw', function(e) {
                            throw e
                        }),
                        verb('return'),
                        (i[Symbol.iterator] = function() {
                            return this
                        }),
                        i
                    )
                    function verb(n, f) {
                        i[n] = o[n]
                            ? function(v) {
                                  return (p = !p)
                                      ? {
                                            value: __await(o[n](v)),
                                            done: n === 'return'
                                        }
                                      : f
                                      ? f(v)
                                      : v
                              }
                            : f
                    }
                }

                __asyncValues = function(o) {
                    if (!Symbol.asyncIterator)
                        throw new TypeError(
                            'Symbol.asyncIterator is not defined.'
                        )
                    var m = o[Symbol.asyncIterator],
                        i
                    return m
                        ? m.call(o)
                        : ((o =
                              typeof __values === 'function'
                                  ? __values(o)
                                  : o[Symbol.iterator]()),
                          (i = {}),
                          verb('next'),
                          verb('throw'),
                          verb('return'),
                          (i[Symbol.asyncIterator] = function() {
                              return this
                          }),
                          i)
                    function verb(n) {
                        i[n] =
                            o[n] &&
                            function(v) {
                                return new Promise(function(resolve, reject) {
                                    ;(v = o[n](v)),
                                        settle(resolve, reject, v.done, v.value)
                                })
                            }
                    }
                    function settle(resolve, reject, d, v) {
                        Promise.resolve(v).then(function(v) {
                            resolve({ value: v, done: d })
                        }, reject)
                    }
                }

                __makeTemplateObject = function(cooked, raw) {
                    if (Object.defineProperty) {
                        Object.defineProperty(cooked, 'raw', { value: raw })
                    } else {
                        cooked.raw = raw
                    }
                    return cooked
                }

                __importStar = function(mod) {
                    if (mod && mod.__esModule) return mod
                    var result = {}
                    if (mod != null)
                        for (var k in mod)
                            if (Object.hasOwnProperty.call(mod, k))
                                result[k] = mod[k]
                    result['default'] = mod
                    return result
                }

                __importDefault = function(mod) {
                    return mod && mod.__esModule ? mod : { default: mod }
                }

                exporter('__extends', __extends)
                exporter('__assign', __assign)
                exporter('__rest', __rest)
                exporter('__decorate', __decorate)
                exporter('__param', __param)
                exporter('__metadata', __metadata)
                exporter('__awaiter', __awaiter)
                exporter('__generator', __generator)
                exporter('__exportStar', __exportStar)
                exporter('__values', __values)
                exporter('__read', __read)
                exporter('__spread', __spread)
                exporter('__spreadArrays', __spreadArrays)
                exporter('__await', __await)
                exporter('__asyncGenerator', __asyncGenerator)
                exporter('__asyncDelegator', __asyncDelegator)
                exporter('__asyncValues', __asyncValues)
                exporter('__makeTemplateObject', __makeTemplateObject)
                exporter('__importStar', __importStar)
                exporter('__importDefault', __importDefault)
            })

            /***/
        },

        /***/ zZ0H: /***/ function(module, exports) {
            /**
             * This method returns the first argument it receives.
             *
             * @static
             * @since 0.1.0
             * @memberOf _
             * @category Util
             * @param {*} value Any value.
             * @returns {*} Returns `value`.
             * @example
             *
             * var object = { 'a': 1 };
             *
             * console.log(_.identity(object) === object);
             * // => true
             */
            function identity(value) {
                return value
            }

            module.exports = identity

            /***/
        },

        /***/ zoYe: /***/ function(module, exports, __webpack_require__) {
            var Symbol = __webpack_require__('nmnc'),
                arrayMap = __webpack_require__('eUgh'),
                isArray = __webpack_require__('Z0cm'),
                isSymbol = __webpack_require__('/9aa')

            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0

            /** Used to convert symbols to primitives and strings. */
            var symbolProto = Symbol ? Symbol.prototype : undefined,
                symbolToString = symbolProto ? symbolProto.toString : undefined

            /**
             * The base implementation of `_.toString` which doesn't convert nullish
             * values to empty strings.
             *
             * @private
             * @param {*} value The value to process.
             * @returns {string} Returns the string.
             */
            function baseToString(value) {
                // Exit early for strings to avoid a performance hit in some environments.
                if (typeof value == 'string') {
                    return value
                }
                if (isArray(value)) {
                    // Recursively convert values (susceptible to call stack limits).
                    return arrayMap(value, baseToString) + ''
                }
                if (isSymbol(value)) {
                    return symbolToString ? symbolToString.call(value) : ''
                }
                var result = value + ''
                return result == '0' && 1 / value == -INFINITY ? '-0' : result
            }

            module.exports = baseToString

            /***/
        },

        /***/ zosA: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(string) {
                // Escape ^$.*+-?=!:|\/()[]{},

                return string.replace(
                    /[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,
                    '\\$&'
                )
            }

            /***/
        },

        /***/ zspo: /***/ function(module, exports, __webpack_require__) {
            module.exports = {
                der: __webpack_require__('R7nf'),
                pem: __webpack_require__('QQHG')
            }

            /***/
        }

        /******/
    }
)
