module.exports = /******/ (function(modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/ var installedModules = {} // The require function
    /******/
    /******/ /******/ function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/ if (installedModules[moduleId]) {
            /******/ return installedModules[moduleId].exports
            /******/
        } // Create a new module (and put it into the cache)
        /******/ /******/ var module = (installedModules[moduleId] = {
            /******/ i: moduleId,
            /******/ l: false,
            /******/ exports: {}
            /******/
        }) // Execute the module function
        /******/
        /******/ /******/ var threw = true
        /******/ try {
            /******/ modules[moduleId].call(
                module.exports,
                module,
                module.exports,
                __webpack_require__
            )
            /******/ threw = false
            /******/
        } finally {
            /******/ if (threw) delete installedModules[moduleId]
            /******/
        } // Flag the module as loaded
        /******/
        /******/ /******/ module.l = true // Return the exports of the module
        /******/
        /******/ /******/ return module.exports
        /******/
    } // expose the modules object (__webpack_modules__)
    /******/
    /******/
    /******/ /******/ __webpack_require__.m = modules // expose the module cache
    /******/
    /******/ /******/ __webpack_require__.c = installedModules // define getter function for harmony exports
    /******/
    /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
        /******/ if (!__webpack_require__.o(exports, name)) {
            /******/ Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            })
            /******/
        }
        /******/
    } // define __esModule on exports
    /******/
    /******/ /******/ __webpack_require__.r = function(exports) {
        /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
            })
            /******/
        }
        /******/ Object.defineProperty(exports, '__esModule', { value: true })
        /******/
    } // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
    /******/
    /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
        value,
        mode
    ) {
        /******/ if (mode & 1) value = __webpack_require__(value)
        /******/ if (mode & 8) return value
        /******/ if (
            mode & 4 &&
            typeof value === 'object' &&
            value &&
            value.__esModule
        )
            return value
        /******/ var ns = Object.create(null)
        /******/ __webpack_require__.r(ns)
        /******/ Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
        })
        /******/ if (mode & 2 && typeof value != 'string')
            for (var key in value)
                __webpack_require__.d(
                    ns,
                    key,
                    function(key) {
                        return value[key]
                    }.bind(null, key)
                )
        /******/ return ns
        /******/
    } // getDefaultExport function for compatibility with non-harmony modules
    /******/
    /******/ /******/ __webpack_require__.n = function(module) {
        /******/ var getter =
            module && module.__esModule
                ? /******/ function getDefault() {
                      return module['default']
                  }
                : /******/ function getModuleExports() {
                      return module
                  }
        /******/ __webpack_require__.d(getter, 'a', getter)
        /******/ return getter
        /******/
    } // Object.prototype.hasOwnProperty.call
    /******/
    /******/ /******/ __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property)
    } // __webpack_public_path__
    /******/
    /******/ /******/ __webpack_require__.p = '' // Load entry module and return exports
    /******/
    /******/
    /******/ /******/ return __webpack_require__(
        (__webpack_require__.s = 'q9pr')
    )
    /******/
})(
    /************************************************************************/
    /******/ {
        /***/ '+00W': /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('RF0s').default
            module.exports.default = module.exports

            /***/
        },

        /***/ '+6XX': /***/ function(module, exports, __webpack_require__) {
            var assocIndexOf = __webpack_require__('y1pI')

            /**
             * Checks if a list cache value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf ListCache
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1
            }

            module.exports = listCacheHas

            /***/
        },

        /***/ '+K+b': /***/ function(module, exports, __webpack_require__) {
            var Uint8Array = __webpack_require__('JHRd')

            /**
             * Creates a clone of `arrayBuffer`.
             *
             * @private
             * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
             * @returns {ArrayBuffer} Returns the cloned array buffer.
             */
            function cloneArrayBuffer(arrayBuffer) {
                var result = new arrayBuffer.constructor(arrayBuffer.byteLength)
                new Uint8Array(result).set(new Uint8Array(arrayBuffer))
                return result
            }

            module.exports = cloneArrayBuffer

            /***/
        },

        /***/ '+Qka': /***/ function(module, exports, __webpack_require__) {
            var Stack = __webpack_require__('fmRc'),
                assignMergeValue = __webpack_require__('t2Dn'),
                baseFor = __webpack_require__('cq/+'),
                baseMergeDeep = __webpack_require__('T1AV'),
                isObject = __webpack_require__('GoyQ'),
                keysIn = __webpack_require__('mTTR'),
                safeGet = __webpack_require__('itsj')

            /**
             * The base implementation of `_.merge` without support for multiple sources.
             *
             * @private
             * @param {Object} object The destination object.
             * @param {Object} source The source object.
             * @param {number} srcIndex The index of `source`.
             * @param {Function} [customizer] The function to customize merged values.
             * @param {Object} [stack] Tracks traversed source values and their merged
             *  counterparts.
             */
            function baseMerge(object, source, srcIndex, customizer, stack) {
                if (object === source) {
                    return
                }
                baseFor(
                    source,
                    function(srcValue, key) {
                        stack || (stack = new Stack())
                        if (isObject(srcValue)) {
                            baseMergeDeep(
                                object,
                                source,
                                key,
                                srcIndex,
                                baseMerge,
                                customizer,
                                stack
                            )
                        } else {
                            var newValue = customizer
                                ? customizer(
                                      safeGet(object, key),
                                      srcValue,
                                      key + '',
                                      object,
                                      source,
                                      stack
                                  )
                                : undefined

                            if (newValue === undefined) {
                                newValue = srcValue
                            }
                            assignMergeValue(object, key, newValue)
                        }
                    },
                    keysIn
                )
            }

            module.exports = baseMerge

            /***/
        },

        /***/ '+c4W': /***/ function(module, exports, __webpack_require__) {
            var baseProperty = __webpack_require__('711d'),
                basePropertyDeep = __webpack_require__('4/ic'),
                isKey = __webpack_require__('9ggG'),
                toKey = __webpack_require__('9Nap')

            /**
             * Creates a function that returns the value at `path` of a given object.
             *
             * @static
             * @memberOf _
             * @since 2.4.0
             * @category Util
             * @param {Array|string} path The path of the property to get.
             * @returns {Function} Returns the new accessor function.
             * @example
             *
             * var objects = [
             *   { 'a': { 'b': 2 } },
             *   { 'a': { 'b': 1 } }
             * ];
             *
             * _.map(objects, _.property('a.b'));
             * // => [2, 1]
             *
             * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
             * // => [1, 2]
             */
            function property(path) {
                return isKey(path)
                    ? baseProperty(toKey(path))
                    : basePropertyDeep(path)
            }

            module.exports = property

            /***/
        },

        /***/ '+du+': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const handlers_1 = tslib_1.__importDefault(
                __webpack_require__('PC/d')
            )
            const oidc_client_1 = tslib_1.__importDefault(
                __webpack_require__('O3E8')
            )
            const cookie_store_1 = tslib_1.__importDefault(
                __webpack_require__('qQzh')
            )
            const settings_1 = tslib_1.__importDefault(
                __webpack_require__('Mu3n')
            )
            function createInstance(settings) {
                if (!settings.session) {
                    throw new Error('The session configuration is required')
                }
                const clientProvider = oidc_client_1.default(settings)
                const sessionSettings = new settings_1.default(settings.session)
                const store = new cookie_store_1.default(sessionSettings)
                return {
                    handleLogin: handlers_1.default.LoginHandler(
                        settings,
                        clientProvider
                    ),
                    handleLogout: handlers_1.default.LogoutHandler(
                        settings,
                        sessionSettings
                    ),
                    handleCallback: handlers_1.default.CallbackHandler(
                        settings,
                        clientProvider,
                        store
                    ),
                    handleProfile: handlers_1.default.ProfileHandler(store),
                    getSession: handlers_1.default.SessionHandler(store),
                    requireAuthentication: handlers_1.default.RequireAuthentication(
                        store
                    )
                }
            }
            exports.default = createInstance
            //# sourceMappingURL=instance.node.js.map

            /***/
        },

        /***/ '+iFO': /***/ function(module, exports, __webpack_require__) {
            var baseCreate = __webpack_require__('dTAl'),
                getPrototype = __webpack_require__('LcsW'),
                isPrototype = __webpack_require__('6sVZ')

            /**
             * Initializes an object clone.
             *
             * @private
             * @param {Object} object The object to clone.
             * @returns {Object} Returns the initialized clone.
             */
            function initCloneObject(object) {
                return typeof object.constructor == 'function' &&
                    !isPrototype(object)
                    ? baseCreate(getPrototype(object))
                    : {}
            }

            module.exports = initCloneObject

            /***/
        },

        /***/ '+iuc': /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('wgeU')
            __webpack_require__('FlQf')
            __webpack_require__('bBy9')
            __webpack_require__('B9jh')
            __webpack_require__('dL40')
            __webpack_require__('xvv9')
            __webpack_require__('V+O7')
            module.exports = __webpack_require__('WEpk').Set

            /***/
        },

        /***/ '+jru': /***/ function(module, exports, __webpack_require__) {
            // https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
            __webpack_require__('aPfg')('WeakMap')

            /***/
        },

        /***/ '+oT+': /***/ function(module, exports, __webpack_require__) {
            var _Promise = __webpack_require__('eVuF')

            function asyncGeneratorStep(
                gen,
                resolve,
                reject,
                _next,
                _throw,
                key,
                arg
            ) {
                try {
                    var info = gen[key](arg)
                    var value = info.value
                } catch (error) {
                    reject(error)
                    return
                }

                if (info.done) {
                    resolve(value)
                } else {
                    _Promise.resolve(value).then(_next, _throw)
                }
            }

            function _asyncToGenerator(fn) {
                return function() {
                    var self = this,
                        args = arguments
                    return new _Promise(function(resolve, reject) {
                        var gen = fn.apply(self, args)

                        function _next(value) {
                            asyncGeneratorStep(
                                gen,
                                resolve,
                                reject,
                                _next,
                                _throw,
                                'next',
                                value
                            )
                        }

                        function _throw(err) {
                            asyncGeneratorStep(
                                gen,
                                resolve,
                                reject,
                                _next,
                                _throw,
                                'throw',
                                err
                            )
                        }

                        _next(undefined)
                    })
                }
            }

            module.exports = _asyncToGenerator

            /***/
        },

        /***/ '//Cd': /***/ function(module, exports, __webpack_require__) {
            const { strict: assert } = __webpack_require__('Qs3B')
            const { inspect } = __webpack_require__('jK02')
            const { EOL } = __webpack_require__('jle/')

            const { keyObjectSupported } = __webpack_require__('pDDt')
            const { createPublicKey } = __webpack_require__('1ALl')
            const { keyObjectToJWK } = __webpack_require__('gXwc')
            const {
                THUMBPRINT_MATERIAL,
                PUBLIC_MEMBERS,
                PRIVATE_MEMBERS,
                JWK_MEMBERS,
                KEYOBJECT,
                USES_MAPPING,
                OPS,
                USES
            } = __webpack_require__('ehsS')
            const isObject = __webpack_require__('kF1/')
            const thumbprint = __webpack_require__('uk5n')
            const errors = __webpack_require__('yt7c')

            const privateApi = Symbol('privateApi')
            const { JWK } = __webpack_require__('N+nT')

            class Key {
                constructor(
                    keyObject,
                    {
                        alg,
                        use,
                        kid,
                        key_ops: ops,
                        x5c,
                        x5t,
                        'x5t#S256': x5t256
                    } = {}
                ) {
                    if (use !== undefined) {
                        if (typeof use !== 'string' || !USES.has(use)) {
                            throw new TypeError(
                                '`use` must be either "sig" or "enc" string when provided'
                            )
                        }
                    }

                    if (alg !== undefined) {
                        if (typeof alg !== 'string' || !alg) {
                            throw new TypeError(
                                '`alg` must be a non-empty string when provided'
                            )
                        }
                    }

                    if (kid !== undefined) {
                        if (typeof kid !== 'string' || !kid) {
                            throw new TypeError(
                                '`kid` must be a non-empty string when provided'
                            )
                        }
                    }

                    if (ops !== undefined) {
                        if (
                            !Array.isArray(ops) ||
                            !ops.length ||
                            ops.some(o => typeof o !== 'string')
                        ) {
                            throw new TypeError(
                                '`key_ops` must be a non-empty array of strings when provided'
                            )
                        }
                        ops = Array.from(new Set(ops)).filter(x => OPS.has(x))
                    }

                    if (ops && use) {
                        if (
                            (use === 'enc' &&
                                ops.some(x => USES_MAPPING.sig.has(x))) ||
                            (use === 'sig' &&
                                ops.some(x => USES_MAPPING.enc.has(x)))
                        ) {
                            throw new errors.JWKInvalid(
                                'inconsistent JWK "use" and "key_ops"'
                            )
                        }
                    }

                    if (keyObjectSupported && x5c !== undefined) {
                        if (
                            !Array.isArray(x5c) ||
                            !x5c.length ||
                            x5c.some(c => typeof c !== 'string')
                        ) {
                            throw new TypeError(
                                '`x5c` must be an array of one or more PKIX certificates when provided'
                            )
                        }

                        x5c.forEach((cert, i) => {
                            let publicKey
                            try {
                                publicKey = createPublicKey({
                                    key: `-----BEGIN CERTIFICATE-----${EOL}${cert
                                        .match(/.{1,64}/g)
                                        .join(
                                            EOL
                                        )}${EOL}-----END CERTIFICATE-----`,
                                    format: 'pem'
                                })
                            } catch (err) {
                                throw new errors.JWKInvalid(
                                    `\`x5c\` member at index ${i} is not a valid base64-encoded DER PKIX certificate`
                                )
                            }
                            if (i === 0) {
                                try {
                                    assert.deepEqual(
                                        publicKey.export({
                                            type: 'spki',
                                            format: 'der'
                                        }),
                                        (keyObject.type === 'public'
                                            ? keyObject
                                            : createPublicKey(keyObject)
                                        ).export({
                                            type: 'spki',
                                            format: 'der'
                                        })
                                    )
                                } catch (err) {
                                    throw new errors.JWKInvalid(
                                        'The key in the first `x5c` certificate MUST match the public key represented by the JWK'
                                    )
                                }
                            }
                        })
                    }

                    Object.defineProperties(this, {
                        [KEYOBJECT]: {
                            value: isObject(keyObject) ? undefined : keyObject
                        },
                        keyObject: {
                            get() {
                                if (!keyObjectSupported) {
                                    throw new errors.JOSENotSupported(
                                        'KeyObject class is not supported in your Node.js runtime version'
                                    )
                                }

                                return this[KEYOBJECT]
                            }
                        },
                        type: { value: keyObject.type },
                        private: { value: keyObject.type === 'private' },
                        public: { value: keyObject.type === 'public' },
                        secret: { value: keyObject.type === 'secret' },
                        alg: { value: alg, enumerable: alg !== undefined },
                        use: { value: use, enumerable: use !== undefined },
                        x5c: {
                            enumerable: x5c !== undefined,
                            ...(x5c
                                ? {
                                      get() {
                                          return [...x5c]
                                      }
                                  }
                                : { value: undefined })
                        },
                        key_ops: {
                            enumerable: ops !== undefined,
                            ...(ops
                                ? {
                                      get() {
                                          return [...ops]
                                      }
                                  }
                                : { value: undefined })
                        },
                        kid: {
                            enumerable: true,
                            ...(kid
                                ? { value: kid }
                                : {
                                      get() {
                                          Object.defineProperty(this, 'kid', {
                                              value: this.thumbprint,
                                              configurable: false
                                          })
                                          return this.kid
                                      },
                                      configurable: true
                                  })
                        },
                        ...(x5c
                            ? {
                                  x5t: {
                                      enumerable: true,
                                      ...(x5t
                                          ? { value: x5t }
                                          : {
                                                get() {
                                                    Object.defineProperty(
                                                        this,
                                                        'x5t',
                                                        {
                                                            value: thumbprint.x5t(
                                                                this.x5c[0]
                                                            ),
                                                            configurable: false
                                                        }
                                                    )
                                                    return this.x5t
                                                },
                                                configurable: true
                                            })
                                  }
                              }
                            : undefined),
                        ...(x5c
                            ? {
                                  'x5t#S256': {
                                      enumerable: true,
                                      ...(x5t256
                                          ? { value: x5t256 }
                                          : {
                                                get() {
                                                    Object.defineProperty(
                                                        this,
                                                        'x5t#S256',
                                                        {
                                                            value: thumbprint[
                                                                'x5t#S256'
                                                            ](this.x5c[0]),
                                                            configurable: false
                                                        }
                                                    )
                                                    return this['x5t#S256']
                                                },
                                                configurable: true
                                            })
                                  }
                              }
                            : undefined),
                        thumbprint: {
                            get() {
                                Object.defineProperty(this, 'thumbprint', {
                                    value: thumbprint.kid(
                                        this[THUMBPRINT_MATERIAL]()
                                    ),
                                    configurable: false
                                })
                                return this.thumbprint
                            },
                            configurable: true
                        }
                    })
                }

                toPEM(priv = false, encoding = {}) {
                    if (this.secret) {
                        throw new TypeError(
                            'symmetric keys cannot be exported as PEM'
                        )
                    }

                    if (priv && this.public === true) {
                        throw new TypeError(
                            'public key cannot be exported as private'
                        )
                    }

                    const {
                        type = priv ? 'pkcs8' : 'spki',
                        cipher,
                        passphrase
                    } = encoding

                    let keyObject = this[KEYOBJECT]

                    if (!priv) {
                        if (this.private) {
                            keyObject = createPublicKey(keyObject)
                        }
                        if (cipher || passphrase) {
                            throw new TypeError(
                                'cipher and passphrase can only be applied when exporting private keys'
                            )
                        }
                    }

                    if (priv) {
                        return keyObject.export({
                            format: 'pem',
                            type,
                            cipher,
                            passphrase
                        })
                    }

                    return keyObject.export({ format: 'pem', type })
                }

                toJWK(priv = false) {
                    if (priv && this.public === true) {
                        throw new TypeError(
                            'public key cannot be exported as private'
                        )
                    }

                    const components = [
                        ...this.constructor[
                            priv ? PRIVATE_MEMBERS : PUBLIC_MEMBERS
                        ]
                    ].map(k => [k, this[k]])

                    const result = {}

                    Object.keys(components).forEach(key => {
                        const [k, v] = components[key]

                        result[k] = v
                    })

                    result.kty = this.kty
                    result.kid = this.kid

                    if (this.alg) {
                        result.alg = this.alg
                    }

                    if (this.key_ops && this.key_ops.length) {
                        result.key_ops = this.key_ops
                    }

                    if (this.use) {
                        result.use = this.use
                    }

                    if (this.x5c) {
                        result.x5c = this.x5c
                    }

                    if (this.x5t) {
                        result.x5t = this.x5t
                    }

                    if (this['x5t#S256']) {
                        result['x5t#S256'] = this['x5t#S256']
                    }

                    return result
                }

                [JWK_MEMBERS]() {
                    const props =
                        this[KEYOBJECT].type === 'private'
                            ? this.constructor[PRIVATE_MEMBERS]
                            : this.constructor[PUBLIC_MEMBERS]
                    Object.defineProperties(
                        this,
                        [...props].reduce((acc, component) => {
                            acc[component] = {
                                get() {
                                    const jwk = keyObjectToJWK(this[KEYOBJECT])
                                    Object.defineProperties(
                                        this,
                                        Object.entries(jwk)
                                            .filter(([key]) => props.has(key))
                                            .reduce((acc, [key, value]) => {
                                                acc[key] = {
                                                    value,
                                                    enumerable: this.constructor[
                                                        PUBLIC_MEMBERS
                                                    ].has(key),
                                                    configurable: false
                                                }
                                                return acc
                                            }, {})
                                    )

                                    return this[component]
                                },
                                enumerable: this.constructor[
                                    PUBLIC_MEMBERS
                                ].has(component),
                                configurable: true
                            }
                            return acc
                        }, {})
                    )
                }

                /* c8 ignore next 8 */
                [inspect.custom]() {
                    return `${this.constructor.name} ${inspect(
                        this.toJWK(false),
                        {
                            depth: Infinity,
                            colors: process.stdout.isTTY,
                            compact: false,
                            sorted: true
                        }
                    )}`
                }

                /* c8 ignore next 3 */
                [THUMBPRINT_MATERIAL]() {
                    throw new Error(
                        `"[THUMBPRINT_MATERIAL]()" is not implemented on ${this.constructor.name}`
                    )
                }

                algorithms(operation, /* the rest is private API */ int, opts) {
                    const {
                        use = this.use,
                        alg = this.alg,
                        key_ops: ops = this.key_ops
                    } = int === privateApi ? opts : {}
                    if (alg) {
                        return new Set(
                            this.algorithms(operation, privateApi, {
                                alg: null,
                                use,
                                key_ops: ops
                            }).has(alg)
                                ? [alg]
                                : undefined
                        )
                    }

                    if (typeof operation === 'symbol') {
                        try {
                            return this[operation]()
                        } catch (err) {
                            return new Set()
                        }
                    }

                    if (operation && ops && !ops.includes(operation)) {
                        return new Set()
                    }

                    switch (operation) {
                        case 'decrypt':
                        case 'deriveKey':
                        case 'encrypt':
                        case 'sign':
                        case 'unwrapKey':
                        case 'verify':
                        case 'wrapKey':
                            return new Set(
                                Object.entries(JWK[this.kty][operation])
                                    .map(([alg, fn]) =>
                                        fn(this) ? alg : undefined
                                    )
                                    .filter(Boolean)
                            )
                        case undefined:
                            return new Set([
                                ...this.algorithms('sign'),
                                ...this.algorithms('verify'),
                                ...this.algorithms('decrypt'),
                                ...this.algorithms('encrypt'),
                                ...this.algorithms('unwrapKey'),
                                ...this.algorithms('wrapKey'),
                                ...this.algorithms('deriveKey')
                            ])
                        default:
                            throw new TypeError('invalid key operation')
                    }
                }

                /* c8 ignore next 3 */
                static async generate() {
                    throw new Error(
                        `"static async generate()" is not implemented on ${this.name}`
                    )
                }

                /* c8 ignore next 3 */
                static generateSync() {
                    throw new Error(
                        `"static generateSync()" is not implemented on ${this.name}`
                    )
                }

                /* c8 ignore next 3 */
                static get [PUBLIC_MEMBERS]() {
                    throw new Error(
                        `"static get [PUBLIC_MEMBERS]()" is not implemented on ${this.name}`
                    )
                }

                /* c8 ignore next 3 */
                static get [PRIVATE_MEMBERS]() {
                    throw new Error(
                        `"static get [PRIVATE_MEMBERS]()" is not implemented on ${this.name}`
                    )
                }
            }

            module.exports = Key

            /***/
        },

        /***/ '/0+H': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$defineProperty = __webpack_require__('hfKm')

            var __importDefault =
                (this && this.__importDefault) ||
                function(mod) {
                    return mod && mod.__esModule
                        ? mod
                        : {
                              default: mod
                          }
                }

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            const react_1 = __importDefault(__webpack_require__('q1tI'))

            const amp_context_1 = __webpack_require__('lwAK')

            function isInAmpMode({
                ampFirst = false,
                hybrid = false,
                hasQuery = false
            } = {}) {
                return ampFirst || (hybrid && hasQuery)
            }

            exports.isInAmpMode = isInAmpMode

            function useAmp() {
                // Don't assign the context value to a variable to save bytes
                return isInAmpMode(
                    react_1.default.useContext(amp_context_1.AmpStateContext)
                )
            }

            exports.useAmp = useAmp

            /***/
        },

        /***/ '/0p4': /***/ function(module, exports) {
            module.exports = require('events')

            /***/
        },

        /***/ '/9aa': /***/ function(module, exports, __webpack_require__) {
            var baseGetTag = __webpack_require__('NykK'),
                isObjectLike = __webpack_require__('ExA7')

            /** `Object#toString` result references. */
            var symbolTag = '[object Symbol]'

            /**
             * Checks if `value` is classified as a `Symbol` primitive or object.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
             * @example
             *
             * _.isSymbol(Symbol.iterator);
             * // => true
             *
             * _.isSymbol('abc');
             * // => false
             */
            function isSymbol(value) {
                return (
                    typeof value == 'symbol' ||
                    (isObjectLike(value) && baseGetTag(value) == symbolTag)
                )
            }

            module.exports = isSymbol

            /***/
        },

        /***/ '/JKO': /***/ function(module, exports, __webpack_require__) {
            const merge = __webpack_require__('QkVN')
            const omitBy = __webpack_require__('3WX/')
            const jose = __webpack_require__('xZSz')

            const { assertIssuerConfiguration } = __webpack_require__('N+si')
            const { random } = __webpack_require__('iAgo')
            const now = __webpack_require__('PbSP')
            const request = __webpack_require__('UwMm')
            const instance = __webpack_require__('0pkK')

            const formUrlEncode = value =>
                encodeURIComponent(value).replace(/%20/g, '+')

            async function clientAssertion(endpoint, payload) {
                let alg = this[`${endpoint}_endpoint_auth_signing_alg`]
                if (!alg) {
                    assertIssuerConfiguration(
                        this.issuer,
                        `${endpoint}_endpoint_auth_signing_alg_values_supported`
                    )
                }

                if (
                    this[`${endpoint}_endpoint_auth_method`] ===
                    'client_secret_jwt'
                ) {
                    const key = await this.joseSecret()

                    if (!alg) {
                        const supported = this.issuer[
                            `${endpoint}_endpoint_auth_signing_alg_values_supported`
                        ]
                        alg =
                            Array.isArray(supported) &&
                            supported.find(signAlg =>
                                key.algorithms('sign').has(signAlg)
                            )
                    }

                    return jose.JWS.sign(payload, key, { alg, typ: 'JWT' })
                }

                const keystore = instance(this).get('keystore')

                if (!keystore) {
                    throw new TypeError(
                        'no client jwks provided for signing a client assertion with'
                    )
                }

                if (!alg) {
                    const algs = new Set()

                    keystore.all().forEach(key => {
                        key.algorithms('sign').forEach(
                            Set.prototype.add.bind(algs)
                        )
                    })

                    const supported = this.issuer[
                        `${endpoint}_endpoint_auth_signing_alg_values_supported`
                    ]
                    alg =
                        Array.isArray(supported) &&
                        supported.find(signAlg => algs.has(signAlg))
                }

                const key = keystore.get({ alg, use: 'sig' })
                if (!key) {
                    throw new TypeError(
                        `no key found in client jwks to sign a client assertion with using alg ${alg}`
                    )
                }
                return jose.JWS.sign(payload, key, {
                    alg,
                    typ: 'JWT',
                    kid: key.kid
                })
            }

            async function authFor(endpoint, { clientAssertionPayload } = {}) {
                const authMethod = this[`${endpoint}_endpoint_auth_method`]
                switch (authMethod) {
                    case 'self_signed_tls_client_auth':
                    case 'tls_client_auth':
                    case 'none':
                        return { body: { client_id: this.client_id } }
                    case 'client_secret_post':
                        if (!this.client_secret) {
                            throw new TypeError(
                                'client_secret_post client authentication method requires a client_secret'
                            )
                        }
                        return {
                            body: {
                                client_id: this.client_id,
                                client_secret: this.client_secret
                            }
                        }
                    case 'private_key_jwt':
                    case 'client_secret_jwt': {
                        const timestamp = now()
                        const assertion = await clientAssertion.call(
                            this,
                            endpoint,
                            {
                                iat: timestamp,
                                exp: timestamp + 60,
                                jti: random(),
                                iss: this.client_id,
                                sub: this.client_id,
                                aud: this.issuer[`${endpoint}_endpoint`], // TODO: in v4.x pass the issuer instead (for now clientAssertionPayload can be used for that)
                                ...clientAssertionPayload
                            }
                        )

                        return {
                            body: {
                                client_id: this.client_id,
                                client_assertion: assertion,
                                client_assertion_type:
                                    'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'
                            }
                        }
                    }
                    default: {
                        // client_secret_basic
                        // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the
                        // related appendix. (also https://github.com/panva/node-openid-client/pull/91)
                        // > The client identifier is encoded using the
                        // > "application/x-www-form-urlencoded" encoding algorithm per
                        // > Appendix B, and the encoded value is used as the username; the client
                        // > password is encoded using the same algorithm and used as the
                        // > password.
                        if (!this.client_secret) {
                            throw new TypeError(
                                'client_secret_basic client authentication method requires a client_secret'
                            )
                        }
                        const encoded = `${formUrlEncode(
                            this.client_id
                        )}:${formUrlEncode(this.client_secret)}`
                        const value = Buffer.from(encoded).toString('base64')
                        return { headers: { Authorization: `Basic ${value}` } }
                    }
                }
            }

            function resolveResponseType() {
                const { length, 0: value } = this.response_types

                if (length === 1) {
                    return value
                }

                return undefined
            }

            function resolveRedirectUri() {
                const { length, 0: value } = this.redirect_uris || []

                if (length === 1) {
                    return value
                }

                return undefined
            }

            async function authenticatedPost(
                endpoint,
                opts,
                { clientAssertionPayload, endpointAuthMethod = endpoint } = {}
            ) {
                const auth = await authFor.call(this, endpointAuthMethod, {
                    clientAssertionPayload
                })
                const requestOpts = merge(opts, auth, { form: true })

                const mTLS =
                    this[`${endpointAuthMethod}_endpoint_auth_method`].includes(
                        'tls_client_auth'
                    ) ||
                    (endpoint === 'token' &&
                        this.tls_client_certificate_bound_access_tokens)

                let targetUrl
                if (mTLS && this.issuer.mtls_endpoint_aliases) {
                    targetUrl = this.issuer.mtls_endpoint_aliases[
                        `${endpoint}_endpoint`
                    ]
                }

                targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`]

                if ('body' in requestOpts) {
                    requestOpts.body = omitBy(
                        requestOpts.body,
                        arg => arg === undefined
                    )
                }

                return request.call(
                    this,
                    {
                        ...requestOpts,
                        method: 'POST',
                        url: targetUrl
                    },
                    { mTLS }
                )
            }

            module.exports = {
                resolveResponseType,
                resolveRedirectUri,
                authFor,
                authenticatedPost
            }

            /***/
        },

        /***/ '/SMw': /***/ function(module, exports) {
            function webpackEmptyContext(req) {
                var e = new Error("Cannot find module '" + req + "'")
                e.code = 'MODULE_NOT_FOUND'
                throw e
            }
            webpackEmptyContext.keys = function() {
                return []
            }
            webpackEmptyContext.resolve = webpackEmptyContext
            module.exports = webpackEmptyContext
            webpackEmptyContext.id = '/SMw'

            /***/
        },

        /***/ '/a9y': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _interopRequireDefault = __webpack_require__('KI45')

            exports.__esModule = true
            exports.default = void 0

            var _react = _interopRequireDefault(__webpack_require__('q1tI'))

            var _head = _interopRequireDefault(__webpack_require__('8Kt/'))

            var statusCodes = {
                400: 'Bad Request',
                404: 'This page could not be found',
                405: 'Method Not Allowed',
                500: 'Internal Server Error'
            }
            /**
             * `Error` component used for handling errors.
             */

            class Error extends _react.default.Component {
                static getInitialProps(_ref) {
                    var { res, err } = _ref
                    var statusCode =
                        res && res.statusCode
                            ? res.statusCode
                            : err
                            ? err.statusCode
                            : 404
                    return {
                        statusCode
                    }
                }

                render() {
                    var { statusCode } = this.props
                    var title =
                        this.props.title ||
                        statusCodes[statusCode] ||
                        'An unexpected error has occurred'
                    return _react.default.createElement(
                        'div',
                        {
                            style: styles.error
                        },
                        _react.default.createElement(
                            _head.default,
                            null,
                            _react.default.createElement(
                                'title',
                                null,
                                statusCode,
                                ': ',
                                title
                            )
                        ),
                        _react.default.createElement(
                            'div',
                            null,
                            _react.default.createElement('style', {
                                dangerouslySetInnerHTML: {
                                    __html: 'body { margin: 0 }'
                                }
                            }),
                            statusCode
                                ? _react.default.createElement(
                                      'h1',
                                      {
                                          style: styles.h1
                                      },
                                      statusCode
                                  )
                                : null,
                            _react.default.createElement(
                                'div',
                                {
                                    style: styles.desc
                                },
                                _react.default.createElement(
                                    'h2',
                                    {
                                        style: styles.h2
                                    },
                                    title,
                                    '.'
                                )
                            )
                        )
                    )
                }
            }

            exports.default = Error
            Error.displayName = 'ErrorPage'
            var styles = {
                error: {
                    color: '#000',
                    background: '#fff',
                    fontFamily:
                        '-apple-system, BlinkMacSystemFont, Roboto, "Segoe UI", "Fira Sans", Avenir, "Helvetica Neue", "Lucida Grande", sans-serif',
                    height: '100vh',
                    textAlign: 'center',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center'
                },
                desc: {
                    display: 'inline-block',
                    textAlign: 'left',
                    lineHeight: '49px',
                    height: '49px',
                    verticalAlign: 'middle'
                },
                h1: {
                    display: 'inline-block',
                    borderRight: '1px solid rgba(0, 0, 0,.3)',
                    margin: 0,
                    marginRight: '20px',
                    padding: '10px 23px 10px 0',
                    fontSize: '24px',
                    fontWeight: 500,
                    verticalAlign: 'top'
                },
                h2: {
                    fontSize: '14px',
                    fontWeight: 'normal',
                    lineHeight: 'inherit',
                    margin: 0,
                    padding: 0
                }
            }

            /***/
        },

        /***/ '/bjS': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var __importDefault =
                (this && this.__importDefault) ||
                function(mod) {
                    return mod && mod.__esModule ? mod : { default: mod }
                }
            var __importStar =
                (this && this.__importStar) ||
                function(mod) {
                    if (mod && mod.__esModule) return mod
                    var result = {}
                    if (mod != null)
                        for (var k in mod)
                            if (Object.hasOwnProperty.call(mod, k))
                                result[k] = mod[k]
                    result['default'] = mod
                    return result
                }
            Object.defineProperty(exports, '__esModule', { value: true })
            const react_1 = __importDefault(__webpack_require__('q1tI'))
            const server_1 = __webpack_require__('Fw1r')
            const mitt_1 = __importDefault(__webpack_require__('dZ6Y'))
            const utils_1 = __webpack_require__('g/15')
            const head_1 = __importStar(__webpack_require__('8Kt/'))
            // @ts-ignore types will be added later as it's an internal module
            const loadable_1 = __importDefault(__webpack_require__('2qu3'))
            const data_manager_context_1 = __webpack_require__('qArv')
            const loadable_context_1 = __webpack_require__('jwwS')
            const router_context_1 = __webpack_require__('qOIg')
            const data_manager_1 = __webpack_require__('0IRE')
            const get_page_files_1 = __webpack_require__('teXF')
            const amp_context_1 = __webpack_require__('lwAK')
            const optimize_amp_1 = __importDefault(__webpack_require__('OaTm'))
            const amp_1 = __webpack_require__('/0+H')
            const is_dynamic_1 = __webpack_require__('/jkW')
            const constants_1 = __webpack_require__('dmkc')
            function noRouter() {
                const message =
                    'No router instance found. you should only use "next/router" inside the client side of your app. https://err.sh/zeit/next.js/no-router-instance'
                throw new Error(message)
            }
            class ServerRouter {
                constructor(pathname, query, as) {
                    this.route = pathname.replace(/\/$/, '') || '/'
                    this.pathname = pathname
                    this.query = query
                    this.asPath = as
                }
                push() {
                    noRouter()
                }
                replace() {
                    noRouter()
                }
                reload() {
                    noRouter()
                }
                back() {
                    noRouter()
                }
                prefetch() {
                    noRouter()
                }
                beforePopState() {
                    noRouter()
                }
            }
            // TODO: Remove in the next major version, as this would mean the user is adding event listeners in server-side `render` method
            ServerRouter.events = mitt_1.default()
            function enhanceComponents(options, App, Component) {
                // For backwards compatibility
                if (typeof options === 'function') {
                    return {
                        App,
                        Component: options(Component)
                    }
                }
                return {
                    App: options.enhanceApp ? options.enhanceApp(App) : App,
                    Component: options.enhanceComponent
                        ? options.enhanceComponent(Component)
                        : Component
                }
            }
            function render(renderElementToString, element, ampMode) {
                let html
                let head
                try {
                    html = renderElementToString(element)
                } finally {
                    head =
                        head_1.default.rewind() ||
                        head_1.defaultHead(amp_1.isInAmpMode(ampMode))
                }
                return { html, head }
            }
            function renderDocument(
                Document,
                {
                    dataManagerData,
                    props,
                    docProps,
                    pathname,
                    query,
                    buildId,
                    canonicalBase,
                    assetPrefix,
                    runtimeConfig,
                    nextExport,
                    autoExport,
                    dynamicImportsIds,
                    dangerousAsPath,
                    hasCssMode,
                    err,
                    dev,
                    ampPath,
                    ampState,
                    inAmpMode,
                    hybridAmp,
                    staticMarkup,
                    devFiles,
                    files,
                    polyfillFiles,
                    dynamicImports,
                    htmlProps,
                    bodyTags,
                    headTags
                }
            ) {
                return (
                    '<!DOCTYPE html>' +
                    server_1.renderToStaticMarkup(
                        react_1.default.createElement(
                            amp_context_1.AmpStateContext.Provider,
                            { value: ampState },
                            Document.renderDocument(
                                Document,
                                Object.assign(
                                    {
                                        __NEXT_DATA__: {
                                            dataManager: dataManagerData,
                                            props,
                                            page: pathname,
                                            query,
                                            buildId,
                                            assetPrefix:
                                                assetPrefix === ''
                                                    ? undefined
                                                    : assetPrefix,
                                            runtimeConfig,
                                            nextExport,
                                            autoExport,
                                            dynamicIds:
                                                dynamicImportsIds.length === 0
                                                    ? undefined
                                                    : dynamicImportsIds,
                                            err: err
                                                ? serializeError(dev, err)
                                                : undefined
                                        },
                                        dangerousAsPath,
                                        canonicalBase,
                                        ampPath,
                                        inAmpMode,
                                        isDevelopment: !!dev,
                                        hasCssMode,
                                        hybridAmp,
                                        staticMarkup,
                                        devFiles,
                                        files,
                                        polyfillFiles,
                                        dynamicImports,
                                        assetPrefix,
                                        htmlProps,
                                        bodyTags,
                                        headTags
                                    },
                                    docProps
                                )
                            )
                        )
                    )
                )
            }
            async function renderToHTML(req, res, pathname, query, renderOpts) {
                pathname = pathname === '/index' ? '/' : pathname
                const {
                    err,
                    dev = false,
                    documentMiddlewareEnabled = false,
                    ampBindInitData = false,
                    staticMarkup = false,
                    ampPath = '',
                    App,
                    Document,
                    pageConfig = {},
                    DocumentMiddleware,
                    Component,
                    buildManifest,
                    reactLoadableManifest,
                    ErrorDebug,
                    unstable_getStaticProps,
                    unstable_getStaticParams
                } = renderOpts
                const callMiddleware = async (method, args, props = false) => {
                    let results = props ? {} : []
                    if (Document[`${method}Middleware`]) {
                        let middlewareFunc = await Document[
                            `${method}Middleware`
                        ]
                        middlewareFunc =
                            middlewareFunc.default || middlewareFunc
                        const curResults = await middlewareFunc(...args)
                        if (props) {
                            for (const result of curResults) {
                                results = Object.assign({}, results, result)
                            }
                        } else {
                            results = curResults
                        }
                    }
                    return results
                }
                const headTags = (...args) => callMiddleware('headTags', args)
                const bodyTags = (...args) => callMiddleware('bodyTags', args)
                const htmlProps = (...args) =>
                    callMiddleware('htmlProps', args, true)
                const isSpr = !!unstable_getStaticProps
                const defaultAppGetInitialProps =
                    App.getInitialProps === App.origGetInitialProps
                const hasPageGetInitialProps = !!Component.getInitialProps
                const isAutoExport =
                    !hasPageGetInitialProps &&
                    defaultAppGetInitialProps &&
                    !isSpr
                if (hasPageGetInitialProps && isSpr) {
                    throw new Error(
                        constants_1.SPR_GET_INITIAL_PROPS_CONFLICT +
                            ` ${pathname}`
                    )
                }
                if (!!unstable_getStaticParams && !isSpr) {
                    throw new Error(
                        `unstable_getStaticParams was added without a unstable_getStaticProps in ${pathname}. Without unstable_getStaticProps, unstable_getStaticParams does nothing`
                    )
                }
                if (dev) {
                    const { isValidElementType } = __webpack_require__(
                        !(function webpackMissingModule() {
                            var e = new Error("Cannot find module 'react-is'")
                            e.code = 'MODULE_NOT_FOUND'
                            throw e
                        })()
                    )
                    if (!isValidElementType(Component)) {
                        throw new Error(
                            `The default export is not a React Component in page: "${pathname}"`
                        )
                    }
                    if (!isValidElementType(App)) {
                        throw new Error(
                            `The default export is not a React Component in page: "/_app"`
                        )
                    }
                    if (!isValidElementType(Document)) {
                        throw new Error(
                            `The default export is not a React Component in page: "/_document"`
                        )
                    }
                    if (isAutoExport) {
                        // remove query values except ones that will be set during export
                        query = {
                            amp: query.amp
                        }
                        req.url = pathname
                        renderOpts.nextExport = true
                    }
                }
                if (isAutoExport) renderOpts.autoExport = true
                if (isSpr) renderOpts.nextExport = false
                await loadable_1.default.preloadAll() // Make sure all dynamic imports are loaded
                // @ts-ignore url will always be set
                const asPath = req.url
                const router = new ServerRouter(pathname, query, asPath)
                const ctx = {
                    err,
                    req: isAutoExport ? undefined : req,
                    res: isAutoExport ? undefined : res,
                    pathname,
                    query,
                    asPath,
                    AppTree: props => {
                        return react_1.default.createElement(
                            AppContainer,
                            null,
                            react_1.default.createElement(
                                App,
                                Object.assign({}, props, {
                                    Component: Component,
                                    router: router
                                })
                            )
                        )
                    }
                }
                let props
                if (
                    documentMiddlewareEnabled &&
                    typeof DocumentMiddleware === 'function'
                ) {
                    await DocumentMiddleware(ctx)
                }
                let dataManager
                if (ampBindInitData) {
                    dataManager = new data_manager_1.DataManager()
                }
                const ampState = {
                    ampFirst: pageConfig.amp === true,
                    hasQuery: Boolean(query.amp),
                    hybrid: pageConfig.amp === 'hybrid'
                }
                const reactLoadableModules = []
                const AppContainer = ({ children }) =>
                    react_1.default.createElement(
                        router_context_1.RouterContext.Provider,
                        { value: router },
                        react_1.default.createElement(
                            data_manager_context_1.DataManagerContext.Provider,
                            { value: dataManager },
                            react_1.default.createElement(
                                amp_context_1.AmpStateContext.Provider,
                                { value: ampState },
                                react_1.default.createElement(
                                    loadable_context_1.LoadableContext.Provider,
                                    {
                                        value: moduleName =>
                                            reactLoadableModules.push(
                                                moduleName
                                            )
                                    },
                                    children
                                )
                            )
                        )
                    )
                try {
                    props = await utils_1.loadGetInitialProps(App, {
                        AppTree: ctx.AppTree,
                        Component,
                        router,
                        ctx
                    })
                    if (isSpr) {
                        const data = await unstable_getStaticProps({
                            params: is_dynamic_1.isDynamicRoute(pathname)
                                ? query
                                : undefined
                        })
                        const invalidKeys = Object.keys(data).filter(
                            key => key !== 'revalidate' && key !== 'props'
                        )
                        if (invalidKeys.length) {
                            throw new Error(
                                `Additional keys were returned from \`getStaticProps\`. Properties intended for your component must be nested under the \`props\` key, e.g.:` +
                                    `\n\n\treturn { props: { title: 'My Title', content: '...' }` +
                                    `\n\nKeys that need moved: ${invalidKeys.join(
                                        ', '
                                    )}.
        `
                            )
                        }
                        if (typeof data.revalidate === 'number') {
                            if (!Number.isInteger(data.revalidate)) {
                                throw new Error(
                                    `A page's revalidate option must be seconds expressed as a natural number. Mixed numbers, such as '${data.revalidate}', cannot be used.` +
                                        `\nTry changing the value to '${Math.ceil(
                                            data.revalidate
                                        )}' or using \`Math.ceil()\` if you're computing the value.`
                                )
                            } else if (data.revalidate <= 0) {
                                throw new Error(
                                    `A page's revalidate option can not be less than or equal to zero. A revalidate option of zero means to revalidate after _every_ request, and implies stale data cannot be tolerated.` +
                                        `\n\nTo never revalidate, you can set revalidate to \`false\` (only ran once at build-time).` +
                                        `\nTo revalidate as soon as possible, you can set the value to \`1\`.`
                                )
                            } else if (data.revalidate > 31536000) {
                                // if it's greater than a year for some reason error
                                console.warn(
                                    `Warning: A page's revalidate option was set to more than a year. This may have been done in error.` +
                                        `\nTo only run getStaticProps at build-time and not revalidate at runtime, you can set \`revalidate\` to \`false\`!`
                                )
                            }
                        } else if (data.revalidate === false) {
                            // `false` is an allowed behavior. We'll catch `revalidate: true` and
                            // fall into our default behavior.
                        } else {
                            // By default, we revalidate after 1 second. This value is optimal for
                            // the most up-to-date page possible, but without a 1-to-1
                            // request-refresh ratio.
                            data.revalidate = 1
                        }
                        props.pageProps = data.props
                        renderOpts.revalidate = data.revalidate
                        renderOpts.sprData = props
                    }
                } catch (err) {
                    if (!dev || !err) throw err
                    ctx.err = err
                    renderOpts.err = err
                }
                // the response might be finished on the getInitialProps call
                if (utils_1.isResSent(res) && !isSpr) return null
                const devFiles = buildManifest.devFiles
                const files = [
                    ...new Set([
                        ...get_page_files_1.getPageFiles(
                            buildManifest,
                            pathname
                        ),
                        ...get_page_files_1.getPageFiles(buildManifest, '/_app')
                    ])
                ]
                const polyfillFiles = get_page_files_1.getPageFiles(
                    buildManifest,
                    '/_polyfills'
                )
                const renderElementToString = staticMarkup
                    ? server_1.renderToStaticMarkup
                    : server_1.renderToString
                const renderPageError = () => {
                    if (ctx.err && ErrorDebug) {
                        return render(
                            renderElementToString,
                            react_1.default.createElement(ErrorDebug, {
                                error: ctx.err
                            }),
                            ampState
                        )
                    }
                    if (dev && (props.router || props.Component)) {
                        throw new Error(
                            `'router' and 'Component' can not be returned in getInitialProps from _app.js https://err.sh/zeit/next.js/cant-override-next-props`
                        )
                    }
                }
                let renderPage
                if (ampBindInitData) {
                    const ssrPrepass = __webpack_require__('73TM')
                    renderPage = async (options = {}) => {
                        const renderError = renderPageError()
                        if (renderError) return renderError
                        const {
                            App: EnhancedApp,
                            Component: EnhancedComponent
                        } = enhanceComponents(options, App, Component)
                        const Application = () =>
                            react_1.default.createElement(
                                AppContainer,
                                null,
                                react_1.default.createElement(
                                    EnhancedApp,
                                    Object.assign(
                                        {
                                            Component: EnhancedComponent,
                                            router: router
                                        },
                                        props
                                    )
                                )
                            )
                        const element = react_1.default.createElement(
                            Application,
                            null
                        )
                        try {
                            return render(
                                renderElementToString,
                                element,
                                ampState
                            )
                        } catch (err) {
                            if (
                                err &&
                                typeof err === 'object' &&
                                typeof err.then === 'function'
                            ) {
                                await ssrPrepass(element)
                                if (renderOpts.dataOnly) {
                                    return {
                                        html: '',
                                        head: [],
                                        dataOnly: true
                                    }
                                } else {
                                    return render(
                                        renderElementToString,
                                        element,
                                        ampState
                                    )
                                }
                            }
                            throw err
                        }
                    }
                } else {
                    renderPage = (options = {}) => {
                        const renderError = renderPageError()
                        if (renderError) return renderError
                        const {
                            App: EnhancedApp,
                            Component: EnhancedComponent
                        } = enhanceComponents(options, App, Component)
                        return render(
                            renderElementToString,
                            react_1.default.createElement(
                                AppContainer,
                                null,
                                react_1.default.createElement(
                                    EnhancedApp,
                                    Object.assign(
                                        {
                                            Component: EnhancedComponent,
                                            router: router
                                        },
                                        props
                                    )
                                )
                            ),
                            ampState
                        )
                    }
                }
                const documentCtx = Object.assign({}, ctx, { renderPage })
                const docProps = await utils_1.loadGetInitialProps(
                    Document,
                    documentCtx
                )
                // the response might be finished on the getInitialProps call
                if (utils_1.isResSent(res) && !isSpr) return null
                let dataManagerData = '[]'
                if (dataManager) {
                    dataManagerData = JSON.stringify([...dataManager.getData()])
                }
                if (!docProps || typeof docProps.html !== 'string') {
                    const message = `"${utils_1.getDisplayName(
                        Document
                    )}.getInitialProps()" should resolve to an object with a "html" prop set with a valid html string`
                    throw new Error(message)
                }
                if (docProps.dataOnly) {
                    return dataManagerData
                }
                const dynamicImportIdsSet = new Set()
                const dynamicImports = []
                for (const mod of reactLoadableModules) {
                    const manifestItem = reactLoadableManifest[mod]
                    if (manifestItem) {
                        manifestItem.forEach(item => {
                            dynamicImports.push(item)
                            dynamicImportIdsSet.add(item.id)
                        })
                    }
                }
                const dynamicImportsIds = [...dynamicImportIdsSet]
                const inAmpMode = amp_1.isInAmpMode(ampState)
                const hybridAmp = ampState.hybrid
                // update renderOpts so export knows current state
                renderOpts.inAmpMode = inAmpMode
                renderOpts.hybridAmp = hybridAmp
                let html = renderDocument(
                    Document,
                    Object.assign({}, renderOpts, {
                        dangerousAsPath: router.asPath,
                        dataManagerData,
                        ampState,
                        props,
                        headTags: await headTags(documentCtx),
                        bodyTags: await bodyTags(documentCtx),
                        htmlProps: await htmlProps(documentCtx),
                        docProps,
                        pathname,
                        ampPath,
                        query,
                        inAmpMode,
                        hybridAmp,
                        dynamicImportsIds,
                        dynamicImports,
                        files,
                        devFiles,
                        polyfillFiles
                    })
                )
                if (inAmpMode && html) {
                    // use replace to allow rendering directly to body in AMP mode
                    html = html.replace(
                        '__NEXT_AMP_RENDER_TARGET__',
                        `<!-- __NEXT_DATA__ -->${docProps.html}`
                    )
                    html = await optimize_amp_1.default(html)
                    if (renderOpts.ampValidator) {
                        await renderOpts.ampValidator(html, pathname)
                    }
                }
                if (inAmpMode || hybridAmp) {
                    // fix &amp being escaped for amphtml rel link
                    html = html.replace(/&amp;amp=1/g, '&amp=1')
                }
                return html
            }
            exports.renderToHTML = renderToHTML
            function errorToJSON(err) {
                const { name, message, stack } = err
                return { name, message, stack }
            }
            function serializeError(dev, err) {
                if (dev) {
                    return errorToJSON(err)
                }
                return {
                    name: 'Internal Server Error.',
                    message: '500 - Internal Server Error.',
                    statusCode: 500
                }
            }

            /***/
        },

        /***/ '/co4': /***/ function(module, exports, __webpack_require__) {
            /* eslint-disable no-underscore-dangle */

            const url = __webpack_require__('bzos')
            const { format } = __webpack_require__('jK02')

            const cloneDeep = __webpack_require__('BkRI')

            const { RPError, OPError } = __webpack_require__('L71r')
            const { BaseClient } = __webpack_require__('HrFp')
            const { random, codeChallenge } = __webpack_require__('iAgo')
            const pick = __webpack_require__('LZmR')
            const {
                resolveResponseType,
                resolveRedirectUri
            } = __webpack_require__('/JKO')

            function verified(err, user, info = {}) {
                if (err) {
                    this.error(err)
                } else if (!user) {
                    this.fail(info)
                } else {
                    this.success(user, info)
                }
            }

            /**
             * @name constructor
             * @api public
             */
            function OpenIDConnectStrategy(
                {
                    client,
                    params = {},
                    passReqToCallback = false,
                    sessionKey,
                    usePKCE = false
                } = {},
                verify
            ) {
                if (!(client instanceof BaseClient)) {
                    throw new TypeError(
                        'client must be an instance of openid-client Client'
                    )
                }

                if (typeof verify !== 'function') {
                    throw new TypeError('verify callback must be a function')
                }

                if (!client.issuer || !client.issuer.issuer) {
                    throw new TypeError(
                        'client must have an issuer with an identifier'
                    )
                }

                this._client = client
                this._issuer = client.issuer
                this._verify = verify
                this._passReqToCallback = passReqToCallback
                this._usePKCE = usePKCE
                this._key =
                    sessionKey ||
                    `oidc:${url.parse(this._issuer.issuer).hostname}`
                this._params = cloneDeep(params)

                if (this._usePKCE === true) {
                    const supportedMethods = this._issuer
                        .code_challenge_methods_supported
                    if (!Array.isArray(supportedMethods)) {
                        throw new TypeError(
                            'code_challenge_methods_supported is not properly set on issuer'
                        )
                    }
                    if (supportedMethods.includes('S256')) {
                        this._usePKCE = 'S256'
                    } else if (supportedMethods.includes('plain')) {
                        this._usePKCE = 'plain'
                    } else {
                        throw new TypeError(
                            'neither supported code_challenge_method is supported by the issuer'
                        )
                    }
                } else if (
                    typeof this._usePKCE === 'string' &&
                    !['plain', 'S256'].includes(this._usePKCE)
                ) {
                    throw new TypeError(
                        `${this._usePKCE} is not valid/implemented PKCE code_challenge_method`
                    )
                }

                this.name = url.parse(client.issuer.issuer).hostname

                if (!this._params.response_type)
                    this._params.response_type = resolveResponseType.call(
                        client
                    )
                if (!this._params.redirect_uri)
                    this._params.redirect_uri = resolveRedirectUri.call(client)
                if (!this._params.scope) this._params.scope = 'openid'
            }

            OpenIDConnectStrategy.prototype.authenticate = function authenticate(
                req,
                options
            ) {
                ;(async () => {
                    const client = this._client
                    if (!req.session) {
                        throw new TypeError(
                            'authentication requires session support'
                        )
                    }
                    const reqParams = client.callbackParams(req)
                    const sessionKey = this._key

                    /* start authentication request */
                    if (Object.keys(reqParams).length === 0) {
                        // provide options object with extra authentication parameters
                        const params = {
                            state: random(),
                            ...this._params,
                            ...options
                        }

                        if (
                            !params.nonce &&
                            params.response_type.includes('id_token')
                        ) {
                            params.nonce = random()
                        }

                        req.session[sessionKey] = pick(
                            params,
                            'nonce',
                            'state',
                            'max_age',
                            'response_type'
                        )

                        if (this._usePKCE) {
                            const verifier = random()
                            req.session[sessionKey].code_verifier = verifier

                            switch (
                                this._usePKCE // eslint-disable-line default-case
                            ) {
                                case 'S256':
                                    params.code_challenge = codeChallenge(
                                        verifier
                                    )
                                    params.code_challenge_method = 'S256'
                                    break
                                case 'plain':
                                    params.code_challenge = verifier
                                    break
                            }
                        }

                        this.redirect(client.authorizationUrl(params))
                        return
                    }
                    /* end authentication request */

                    /* start authentication response */

                    const session = req.session[sessionKey]
                    if (Object.keys(session || {}).length === 0) {
                        throw new Error(
                            format(
                                'did not find expected authorization request details in session, req.session["%s"] is %j',
                                sessionKey,
                                session
                            )
                        )
                    }

                    const {
                        state,
                        nonce,
                        max_age: maxAge,
                        code_verifier: codeVerifier,
                        response_type: responseType
                    } = session

                    try {
                        delete req.session[sessionKey]
                    } catch (err) {}

                    const opts = {
                        redirect_uri: this._params.redirect_uri,
                        ...options
                    }

                    const checks = {
                        state,
                        nonce,
                        max_age: maxAge,
                        code_verifier: codeVerifier,
                        response_type: responseType
                    }

                    const tokenset = await client.callback(
                        opts.redirect_uri,
                        reqParams,
                        checks
                    )

                    const passReq = this._passReqToCallback
                    const loadUserinfo =
                        this._verify.length > (passReq ? 3 : 2) &&
                        client.issuer.userinfo_endpoint

                    const args = [tokenset, verified.bind(this)]

                    if (loadUserinfo) {
                        if (!tokenset.access_token) {
                            throw new RPError({
                                message:
                                    'expected access_token to be returned when asking for userinfo in verify callback',
                                tokenset
                            })
                        }
                        const userinfo = await client.userinfo(tokenset)
                        args.splice(1, 0, userinfo)
                    }

                    if (passReq) {
                        args.unshift(req)
                    }

                    this._verify(...args)
                    /* end authentication response */
                })().catch(error => {
                    if (
                        (error instanceof OPError &&
                            error.error !== 'server_error' &&
                            !error.error.startsWith('invalid')) ||
                        error instanceof RPError
                    ) {
                        this.fail(error)
                    } else {
                        this.error(error)
                    }
                })
            }

            module.exports = OpenIDConnectStrategy

            /***/
        },

        /***/ '/eQG': /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('v5Dd')
            var $Object = __webpack_require__('WEpk').Object
            module.exports = function getOwnPropertyDescriptor(it, key) {
                return $Object.getOwnPropertyDescriptor(it, key)
            }

            /***/
        },

        /***/ '/h46': /***/ function(module, exports, __webpack_require__) {
            // https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
            __webpack_require__('cHUd')('Map')

            /***/
        },

        /***/ '/hdj': /***/ function(module, exports, __webpack_require__) {
            const { deflateRawSync } = __webpack_require__('FMKJ')

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const generateIV = __webpack_require__('X3uD')
            const base64url = __webpack_require__('Xab3')
            const getKey = __webpack_require__('oGTz')
            const isObject = __webpack_require__('kF1/')
            const { createSecretKey } = __webpack_require__('1ALl')
            const deepClone = __webpack_require__('O9d4')
            const importKey = __webpack_require__('GhER')
            const { JWEInvalid } = __webpack_require__('yt7c')
            const {
                check,
                keyManagementEncrypt,
                encrypt
            } = __webpack_require__('FUB/')

            const serializers = __webpack_require__('ARPQ')
            const generateCEK = __webpack_require__('RGIU')
            const validateHeaders = __webpack_require__('OHZa')

            const PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT')

            class Encrypt {
                // TODO: in v2.x swap unprotectedHeader and aad
                constructor(
                    cleartext,
                    protectedHeader,
                    unprotectedHeader,
                    aad
                ) {
                    if (
                        !Buffer.isBuffer(cleartext) &&
                        typeof cleartext !== 'string'
                    ) {
                        throw new TypeError(
                            'cleartext argument must be a Buffer or a string'
                        )
                    }
                    cleartext = Buffer.from(cleartext)

                    if (
                        aad !== undefined &&
                        !Buffer.isBuffer(aad) &&
                        typeof aad !== 'string'
                    ) {
                        throw new TypeError(
                            'aad argument must be a Buffer or a string when provided'
                        )
                    }
                    aad = aad ? Buffer.from(aad) : undefined

                    if (
                        protectedHeader !== undefined &&
                        !isObject(protectedHeader)
                    ) {
                        throw new TypeError(
                            'protectedHeader argument must be a plain object when provided'
                        )
                    }

                    if (
                        unprotectedHeader !== undefined &&
                        !isObject(unprotectedHeader)
                    ) {
                        throw new TypeError(
                            'unprotectedHeader argument must be a plain object when provided'
                        )
                    }

                    this._recipients = []
                    this._cleartext = cleartext
                    this._aad = aad
                    this._unprotected = unprotectedHeader
                        ? deepClone(unprotectedHeader)
                        : undefined
                    this._protected = protectedHeader
                        ? deepClone(protectedHeader)
                        : undefined
                }

                /*
                 * @public
                 */
                recipient(key, header) {
                    key = getKey(key)

                    if (header !== undefined && !isObject(header)) {
                        throw new TypeError(
                            'header argument must be a plain object when provided'
                        )
                    }

                    this._recipients.push({
                        key,
                        header: header ? deepClone(header) : undefined
                    })

                    return this
                }

                /*
                 * @private
                 */
                [PROCESS_RECIPIENT](recipient) {
                    const unprotectedHeader = this._unprotected
                    const protectedHeader = this._protected
                    const { length: recipientCount } = this._recipients

                    const jweHeader = {
                        ...protectedHeader,
                        ...unprotectedHeader,
                        ...recipient.header
                    }
                    const { key } = recipient

                    const enc = jweHeader.enc
                    let alg = jweHeader.alg

                    if (key.use === 'sig') {
                        throw new TypeError(
                            'a key with "use":"sig" is not usable for encryption'
                        )
                    }

                    if (alg === 'dir') {
                        check(key, 'encrypt', enc)
                    } else if (alg) {
                        check(key, 'keyManagementEncrypt', alg)
                    } else {
                        alg =
                            key.alg ||
                            [...key.algorithms('wrapKey')][0] ||
                            [...key.algorithms('deriveKey')][0]

                        if (alg === 'ECDH-ES' && recipientCount !== 1) {
                            alg = [...key.algorithms('deriveKey')][1]
                        }

                        if (!alg) {
                            throw new JWEInvalid(
                                'could not resolve a usable "alg" for a recipient'
                            )
                        }

                        if (recipientCount === 1) {
                            if (protectedHeader) {
                                protectedHeader.alg = alg
                            } else {
                                this._protected = { alg }
                            }
                        } else {
                            if (recipient.header) {
                                recipient.header.alg = alg
                            } else {
                                recipient.header = { alg }
                            }
                        }
                    }

                    let wrapped
                    let generatedHeader

                    if (key.kty === 'oct' && alg === 'dir') {
                        this._cek = importKey(key[KEYOBJECT], {
                            use: 'enc',
                            alg: enc
                        })
                    } else {
                        check(this._cek, 'encrypt', enc)
                        ;({
                            wrapped,
                            header: generatedHeader
                        } = keyManagementEncrypt(
                            alg,
                            key,
                            this._cek[KEYOBJECT].export(),
                            { enc, alg }
                        ))
                        if (alg === 'ECDH-ES') {
                            this._cek = importKey(createSecretKey(wrapped), {
                                use: 'enc',
                                alg: enc
                            })
                        }
                    }

                    if (alg === 'dir' || alg === 'ECDH-ES') {
                        recipient.encrypted_key = ''
                    } else {
                        recipient.encrypted_key = base64url.encodeBuffer(
                            wrapped
                        )
                    }

                    if (generatedHeader) {
                        recipient.generatedHeader = generatedHeader
                    }
                }

                /*
                 * @public
                 */
                encrypt(serialization) {
                    const serializer = serializers[serialization]
                    if (!serializer) {
                        throw new TypeError(
                            'serialization must be one of "compact", "flattened", "general"'
                        )
                    }

                    if (!this._recipients.length) {
                        throw new JWEInvalid('missing recipients')
                    }

                    serializer.validate(
                        this._protected,
                        this._unprotected,
                        this._aad,
                        this._recipients
                    )

                    let enc = validateHeaders(
                        this._protected,
                        this._unprotected,
                        this._recipients,
                        false,
                        this._protected ? this._protected.crit : undefined
                    )
                    if (!enc) {
                        enc = 'A128CBC-HS256'
                        if (this._protected) {
                            this._protected.enc = enc
                        } else {
                            this._protected = { enc }
                        }
                    }
                    const final = {}
                    this._cek = generateCEK(enc)

                    for (const recipient of this._recipients) {
                        this[PROCESS_RECIPIENT](recipient)
                    }

                    const iv = generateIV(enc)
                    final.iv = base64url.encodeBuffer(iv)

                    if (
                        this._recipients.length === 1 &&
                        this._recipients[0].generatedHeader
                    ) {
                        const [{ generatedHeader }] = this._recipients
                        delete this._recipients[0].generatedHeader
                        this._protected = {
                            ...this._protected,
                            ...generatedHeader
                        }
                    }

                    if (this._protected) {
                        final.protected = base64url.JSON.encode(this._protected)
                    }
                    final.unprotected = this._unprotected

                    let aad
                    if (this._aad) {
                        final.aad = base64url.encode(this._aad)
                        aad = Buffer.concat([
                            Buffer.from(final.protected || ''),
                            Buffer.from('.'),
                            Buffer.from(final.aad)
                        ])
                    } else {
                        aad = Buffer.from(final.protected || '')
                    }

                    let cleartext = this._cleartext
                    if (this._protected && 'zip' in this._protected) {
                        cleartext = deflateRawSync(cleartext)
                    }

                    const { ciphertext, tag } = encrypt(
                        enc,
                        this._cek,
                        cleartext,
                        { iv, aad }
                    )
                    final.tag = base64url.encodeBuffer(tag)
                    final.ciphertext = base64url.encodeBuffer(ciphertext)

                    return serializer(final, this._recipients)
                }
            }

            module.exports = Encrypt

            /***/
        },

        /***/ '/jkW': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$defineProperty = __webpack_require__('hfKm')

            _Object$defineProperty(exports, '__esModule', {
                value: true
            }) // Identify /[param]/ in route string

            const TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/

            function isDynamicRoute(route) {
                return TEST_ROUTE.test(route)
            }

            exports.isDynamicRoute = isDynamicRoute

            /***/
        },

        /***/ '/sST': /***/ function(module, exports, __webpack_require__) {
            const {
                sign: signOneShot,
                verify: verifyOneShot,
                createSign,
                createVerify,
                getCurves
            } = __webpack_require__('PJMN')

            const { derToJose, joseToDer } = __webpack_require__('f0Nx')
            const { KEYOBJECT } = __webpack_require__('ehsS')
            const resolveNodeAlg = __webpack_require__('uGJc')
            const { asInput } = __webpack_require__('1ALl')
            const { dsaEncodingSupported } = __webpack_require__('pDDt')
            const { name: secp256k1 } = __webpack_require__('F/JS')

            let sign, verify

            if (dsaEncodingSupported) {
                sign = (
                    jwaAlg,
                    nodeAlg,
                    { [KEYOBJECT]: keyObject },
                    payload
                ) => {
                    if (typeof payload === 'string') {
                        payload = Buffer.from(payload)
                    }
                    return signOneShot(nodeAlg, payload, {
                        key: asInput(keyObject, false),
                        dsaEncoding: 'ieee-p1363'
                    })
                }
                verify = (
                    jwaAlg,
                    nodeAlg,
                    { [KEYOBJECT]: keyObject },
                    payload,
                    signature
                ) => {
                    try {
                        return verifyOneShot(
                            nodeAlg,
                            payload,
                            {
                                key: asInput(keyObject, true),
                                dsaEncoding: 'ieee-p1363'
                            },
                            signature
                        )
                    } catch (err) {
                        return false
                    }
                }
            } else {
                sign = (
                    jwaAlg,
                    nodeAlg,
                    { [KEYOBJECT]: keyObject },
                    payload
                ) => {
                    return derToJose(
                        createSign(nodeAlg)
                            .update(payload)
                            .sign(asInput(keyObject, false)),
                        jwaAlg
                    )
                }
                verify = (
                    jwaAlg,
                    nodeAlg,
                    { [KEYOBJECT]: keyObject },
                    payload,
                    signature
                ) => {
                    try {
                        return createVerify(nodeAlg)
                            .update(payload)
                            .verify(
                                asInput(keyObject, true),
                                joseToDer(signature, jwaAlg)
                            )
                    } catch (err) {
                        return false
                    }
                }
            }

            const crvToAlg = crv => {
                switch (crv) {
                    case 'P-256':
                        return 'ES256'
                    case secp256k1:
                        return 'ES256K'
                    case 'P-384':
                        return 'ES384'
                    case 'P-521':
                        return 'ES512'
                }
            }

            module.exports = (JWA, JWK) => {
                const algs = []

                if (getCurves().includes('prime256v1')) {
                    algs.push('ES256')
                }

                if (getCurves().includes('secp256k1')) {
                    algs.push('ES256K')
                }

                if (getCurves().includes('secp384r1')) {
                    algs.push('ES384')
                }

                if (getCurves().includes('secp521r1')) {
                    algs.push('ES512')
                }

                algs.forEach(jwaAlg => {
                    const nodeAlg = resolveNodeAlg(jwaAlg)
                    JWA.sign.set(jwaAlg, sign.bind(undefined, jwaAlg, nodeAlg))
                    JWA.verify.set(
                        jwaAlg,
                        verify.bind(undefined, jwaAlg, nodeAlg)
                    )
                    JWK.EC.sign[jwaAlg] = key =>
                        key.private && JWK.EC.verify[jwaAlg](key)
                    JWK.EC.verify[jwaAlg] = key =>
                        (key.use === 'sig' || key.use === undefined) &&
                        crvToAlg(key.crv) === jwaAlg
                })
            }

            /***/
        },

        /***/ '03A+': /***/ function(module, exports, __webpack_require__) {
            var baseIsArguments = __webpack_require__('JTzB'),
                isObjectLike = __webpack_require__('ExA7')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /** Built-in value references. */
            var propertyIsEnumerable = objectProto.propertyIsEnumerable

            /**
             * Checks if `value` is likely an `arguments` object.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an `arguments` object,
             *  else `false`.
             * @example
             *
             * _.isArguments(function() { return arguments; }());
             * // => true
             *
             * _.isArguments([1, 2, 3]);
             * // => false
             */
            var isArguments = baseIsArguments(
                (function() {
                    return arguments
                })()
            )
                ? baseIsArguments
                : function(value) {
                      return (
                          isObjectLike(value) &&
                          hasOwnProperty.call(value, 'callee') &&
                          !propertyIsEnumerable.call(value, 'callee')
                      )
                  }

            module.exports = isArguments

            /***/
        },

        /***/ '05og': /***/ function(module, exports, __webpack_require__) {
            var url = __webpack_require__('bzos')
            var http = __webpack_require__('KEll')
            var https = __webpack_require__('7WL4')
            var assert = __webpack_require__('Qs3B')
            var Writable = __webpack_require__('msIP').Writable
            var debug = __webpack_require__('kGOt')('follow-redirects')

            // RFC7231§4.2.1: Of the request methods defined by this specification,
            // the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.
            var SAFE_METHODS = {
                GET: true,
                HEAD: true,
                OPTIONS: true,
                TRACE: true
            }

            // Create handlers that pass events from native requests
            var eventHandlers = Object.create(null)
            ;['abort', 'aborted', 'error', 'socket', 'timeout'].forEach(
                function(event) {
                    eventHandlers[event] = function(arg) {
                        this._redirectable.emit(event, arg)
                    }
                }
            )

            // An HTTP(S) request that can be redirected
            function RedirectableRequest(options, responseCallback) {
                // Initialize the request
                Writable.call(this)
                options.headers = options.headers || {}
                this._options = options
                this._redirectCount = 0
                this._redirects = []
                this._requestBodyLength = 0
                this._requestBodyBuffers = []

                // Since http.request treats host as an alias of hostname,
                // but the url module interprets host as hostname plus port,
                // eliminate the host property to avoid confusion.
                if (options.host) {
                    // Use hostname if set, because it has precedence
                    if (!options.hostname) {
                        options.hostname = options.host
                    }
                    delete options.host
                }

                // Attach a callback if passed
                if (responseCallback) {
                    this.on('response', responseCallback)
                }

                // React to responses of native requests
                var self = this
                this._onNativeResponse = function(response) {
                    self._processResponse(response)
                }

                // Complete the URL object when necessary
                if (!options.pathname && options.path) {
                    var searchPos = options.path.indexOf('?')
                    if (searchPos < 0) {
                        options.pathname = options.path
                    } else {
                        options.pathname = options.path.substring(0, searchPos)
                        options.search = options.path.substring(searchPos)
                    }
                }

                // Perform the first request
                this._performRequest()
            }
            RedirectableRequest.prototype = Object.create(Writable.prototype)

            // Writes buffered data to the current native request
            RedirectableRequest.prototype.write = function(
                data,
                encoding,
                callback
            ) {
                // Validate input and shift parameters if necessary
                if (
                    !(
                        typeof data === 'string' ||
                        (typeof data === 'object' && 'length' in data)
                    )
                ) {
                    throw new Error(
                        'data should be a string, Buffer or Uint8Array'
                    )
                }
                if (typeof encoding === 'function') {
                    callback = encoding
                    encoding = null
                }

                // Ignore empty buffers, since writing them doesn't invoke the callback
                // https://github.com/nodejs/node/issues/22066
                if (data.length === 0) {
                    if (callback) {
                        callback()
                    }
                    return
                }
                // Only write when we don't exceed the maximum body length
                if (
                    this._requestBodyLength + data.length <=
                    this._options.maxBodyLength
                ) {
                    this._requestBodyLength += data.length
                    this._requestBodyBuffers.push({
                        data: data,
                        encoding: encoding
                    })
                    this._currentRequest.write(data, encoding, callback)
                }
                // Error when we exceed the maximum body length
                else {
                    this.emit(
                        'error',
                        new Error(
                            'Request body larger than maxBodyLength limit'
                        )
                    )
                    this.abort()
                }
            }

            // Ends the current native request
            RedirectableRequest.prototype.end = function(
                data,
                encoding,
                callback
            ) {
                // Shift parameters if necessary
                if (typeof data === 'function') {
                    callback = data
                    data = encoding = null
                } else if (typeof encoding === 'function') {
                    callback = encoding
                    encoding = null
                }

                // Write data and end
                var currentRequest = this._currentRequest
                this.write(data || '', encoding, function() {
                    currentRequest.end(null, null, callback)
                })
            }

            // Sets a header value on the current native request
            RedirectableRequest.prototype.setHeader = function(name, value) {
                this._options.headers[name] = value
                this._currentRequest.setHeader(name, value)
            }

            // Clears a header value on the current native request
            RedirectableRequest.prototype.removeHeader = function(name) {
                delete this._options.headers[name]
                this._currentRequest.removeHeader(name)
            }

            // Proxy all other public ClientRequest methods
            ;[
                'abort',
                'flushHeaders',
                'getHeader',
                'setNoDelay',
                'setSocketKeepAlive',
                'setTimeout'
            ].forEach(function(method) {
                RedirectableRequest.prototype[method] = function(a, b) {
                    return this._currentRequest[method](a, b)
                }
            })

            // Proxy all public ClientRequest properties
            ;['aborted', 'connection', 'socket'].forEach(function(property) {
                Object.defineProperty(RedirectableRequest.prototype, property, {
                    get: function() {
                        return this._currentRequest[property]
                    }
                })
            })

            // Executes the next native request (initial or redirect)
            RedirectableRequest.prototype._performRequest = function() {
                // Load the native protocol
                var protocol = this._options.protocol
                var nativeProtocol = this._options.nativeProtocols[protocol]
                if (!nativeProtocol) {
                    this.emit(
                        'error',
                        new Error('Unsupported protocol ' + protocol)
                    )
                    return
                }

                // If specified, use the agent corresponding to the protocol
                // (HTTP and HTTPS use different types of agents)
                if (this._options.agents) {
                    var scheme = protocol.substr(0, protocol.length - 1)
                    this._options.agent = this._options.agents[scheme]
                }

                // Create the native request
                var request = (this._currentRequest = nativeProtocol.request(
                    this._options,
                    this._onNativeResponse
                ))
                this._currentUrl = url.format(this._options)

                // Set up event handlers
                request._redirectable = this
                for (var event in eventHandlers) {
                    /* istanbul ignore else */
                    if (event) {
                        request.on(event, eventHandlers[event])
                    }
                }

                // End a redirected request
                // (The first request must be ended explicitly with RedirectableRequest#end)
                if (this._isRedirect) {
                    // Write the request entity and end.
                    var i = 0
                    var buffers = this._requestBodyBuffers
                    ;(function writeNext() {
                        if (i < buffers.length) {
                            var buffer = buffers[i++]
                            request.write(
                                buffer.data,
                                buffer.encoding,
                                writeNext
                            )
                        } else {
                            request.end()
                        }
                    })()
                }
            }

            // Processes a response from the current native request
            RedirectableRequest.prototype._processResponse = function(
                response
            ) {
                // Store the redirected response
                if (this._options.trackRedirects) {
                    this._redirects.push({
                        url: this._currentUrl,
                        headers: response.headers,
                        statusCode: response.statusCode
                    })
                }

                // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
                // that further action needs to be taken by the user agent in order to
                // fulfill the request. If a Location header field is provided,
                // the user agent MAY automatically redirect its request to the URI
                // referenced by the Location field value,
                // even if the specific status code is not understood.
                var location = response.headers.location
                if (
                    location &&
                    this._options.followRedirects !== false &&
                    response.statusCode >= 300 &&
                    response.statusCode < 400
                ) {
                    // RFC7231§6.4: A client SHOULD detect and intervene
                    // in cyclical redirections (i.e., "infinite" redirection loops).
                    if (++this._redirectCount > this._options.maxRedirects) {
                        this.emit('error', new Error('Max redirects exceeded.'))
                        return
                    }

                    // RFC7231§6.4: Automatic redirection needs to done with
                    // care for methods not known to be safe […],
                    // since the user might not wish to redirect an unsafe request.
                    // RFC7231§6.4.7: The 307 (Temporary Redirect) status code indicates
                    // that the target resource resides temporarily under a different URI
                    // and the user agent MUST NOT change the request method
                    // if it performs an automatic redirection to that URI.
                    var header
                    var headers = this._options.headers
                    if (
                        response.statusCode !== 307 &&
                        !(this._options.method in SAFE_METHODS)
                    ) {
                        this._options.method = 'GET'
                        // Drop a possible entity and headers related to it
                        this._requestBodyBuffers = []
                        for (header in headers) {
                            if (/^content-/i.test(header)) {
                                delete headers[header]
                            }
                        }
                    }

                    // Drop the Host header, as the redirect might lead to a different host
                    if (!this._isRedirect) {
                        for (header in headers) {
                            if (/^host$/i.test(header)) {
                                delete headers[header]
                            }
                        }
                    }

                    // Perform the redirected request
                    var redirectUrl = url.resolve(this._currentUrl, location)
                    debug('redirecting to', redirectUrl)
                    Object.assign(this._options, url.parse(redirectUrl))
                    this._isRedirect = true
                    this._performRequest()

                    // Discard the remainder of the response to avoid waiting for data
                    response.destroy()
                } else {
                    // The response is not a redirect; return it as-is
                    response.responseUrl = this._currentUrl
                    response.redirects = this._redirects
                    this.emit('response', response)

                    // Clean up
                    this._requestBodyBuffers = []
                }
            }

            // Wraps the key/value object of protocols with redirect functionality
            function wrap(protocols) {
                // Default settings
                var exports = {
                    maxRedirects: 21,
                    maxBodyLength: 10 * 1024 * 1024
                }

                // Wrap each protocol
                var nativeProtocols = {}
                Object.keys(protocols).forEach(function(scheme) {
                    var protocol = scheme + ':'
                    var nativeProtocol = (nativeProtocols[protocol] =
                        protocols[scheme])
                    var wrappedProtocol = (exports[scheme] = Object.create(
                        nativeProtocol
                    ))

                    // Executes a request, following redirects
                    wrappedProtocol.request = function(options, callback) {
                        if (typeof options === 'string') {
                            options = url.parse(options)
                            options.maxRedirects = exports.maxRedirects
                        } else {
                            options = Object.assign(
                                {
                                    protocol: protocol,
                                    maxRedirects: exports.maxRedirects,
                                    maxBodyLength: exports.maxBodyLength
                                },
                                options
                            )
                        }
                        options.nativeProtocols = nativeProtocols
                        assert.equal(
                            options.protocol,
                            protocol,
                            'protocol mismatch'
                        )
                        debug('options', options)
                        return new RedirectableRequest(options, callback)
                    }

                    // Executes a GET request, following redirects
                    wrappedProtocol.get = function(options, callback) {
                        var request = wrappedProtocol.request(options, callback)
                        request.end()
                        return request
                    }
                })
                return exports
            }

            // Exports
            module.exports = wrap({ http: http, https: https })
            module.exports.wrap = wrap

            /***/
        },

        /***/ '0Aai': /***/ function(module, exports) {
            const REGISTRY = new Map()

            module.exports = REGISTRY

            /***/
        },

        /***/ '0Bsm': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _interopRequireDefault = __webpack_require__('KI45')

            exports.__esModule = true
            exports.default = withRouter

            var _extends2 = _interopRequireDefault(__webpack_require__('htGi'))

            var _react = _interopRequireDefault(__webpack_require__('q1tI'))

            var _router = __webpack_require__('nOHt')

            function withRouter(ComposedComponent) {
                function WithRouterWrapper(props) {
                    return _react.default.createElement(
                        ComposedComponent,
                        (0, _extends2.default)(
                            {
                                router: (0, _router.useRouter)()
                            },
                            props
                        )
                    )
                }

                WithRouterWrapper.getInitialProps =
                    ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
                WithRouterWrapper.origGetInitialProps =
                    ComposedComponent.origGetInitialProps

                if (false) {
                    var name
                }

                return WithRouterWrapper
            }

            /***/
        },

        /***/ '0Cz8': /***/ function(module, exports, __webpack_require__) {
            var ListCache = __webpack_require__('Xi7e'),
                Map = __webpack_require__('ebwN'),
                MapCache = __webpack_require__('e4Nc')

            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200

            /**
             * Sets the stack `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf Stack
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the stack cache instance.
             */
            function stackSet(key, value) {
                var data = this.__data__
                if (data instanceof ListCache) {
                    var pairs = data.__data__
                    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                        pairs.push([key, value])
                        this.size = ++data.size
                        return this
                    }
                    data = this.__data__ = new MapCache(pairs)
                }
                data.set(key, value)
                this.size = data.size
                return this
            }

            module.exports = stackSet

            /***/
        },

        /***/ '0IRE': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Map = __webpack_require__('LX0d')

            var _Object$defineProperty = __webpack_require__('hfKm')

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            class DataManager {
                constructor(data) {
                    this.data = new _Map(data)
                }

                getData() {
                    return this.data
                }

                get(key) {
                    return this.data.get(key)
                }

                set(key, value) {
                    this.data.set(key, value)
                }

                overwrite(data) {
                    this.data = new _Map(data)
                }
            }

            exports.DataManager = DataManager

            /***/
        },

        /***/ '0pkK': /***/ function(module, exports) {
            const privateProps = new WeakMap()

            module.exports = ctx => {
                if (!privateProps.has(ctx)) {
                    privateProps.set(ctx, new Map([['metadata', new Map()]]))
                }
                return privateProps.get(ctx)
            }

            /***/
        },

        /***/ '0ycA': /***/ function(module, exports) {
            /**
             * This method returns a new empty array.
             *
             * @static
             * @memberOf _
             * @since 4.13.0
             * @category Util
             * @returns {Array} Returns the new empty array.
             * @example
             *
             * var arrays = _.times(2, _.stubArray);
             *
             * console.log(arrays);
             * // => [[], []]
             *
             * console.log(arrays[0] === arrays[1]);
             * // => false
             */
            function stubArray() {
                return []
            }

            module.exports = stubArray

            /***/
        },

        /***/ '1+5i': /***/ function(module, exports, __webpack_require__) {
            var baseIsSet = __webpack_require__('w/wX'),
                baseUnary = __webpack_require__('sEf8'),
                nodeUtil = __webpack_require__('mdPL')

            /* Node.js helper references. */
            var nodeIsSet = nodeUtil && nodeUtil.isSet

            /**
             * Checks if `value` is classified as a `Set` object.
             *
             * @static
             * @memberOf _
             * @since 4.3.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a set, else `false`.
             * @example
             *
             * _.isSet(new Set);
             * // => true
             *
             * _.isSet(new WeakSet);
             * // => false
             */
            var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet

            module.exports = isSet

            /***/
        },

        /***/ '10GS': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const fs = __webpack_require__('mw/K')
            const util = __webpack_require__('jK02')
            const is = __webpack_require__('6mOv')
            const isFormData = __webpack_require__('faWz')

            module.exports = async options => {
                const { body } = options

                if (options.headers['content-length']) {
                    return Number(options.headers['content-length'])
                }

                if (!body && !options.stream) {
                    return 0
                }

                if (is.string(body)) {
                    return Buffer.byteLength(body)
                }

                if (isFormData(body)) {
                    return util.promisify(body.getLength.bind(body))()
                }

                if (body instanceof fs.ReadStream) {
                    const { size } = await util.promisify(fs.stat)(body.path)
                    return size
                }

                return null
            }

            /***/
        },

        /***/ '16Al': /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /**
             * Copyright (c) 2013-present, Facebook, Inc.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */

            var ReactPropTypesSecret = __webpack_require__('WbBG')

            function emptyFunction() {}
            function emptyFunctionWithReset() {}
            emptyFunctionWithReset.resetWarningCache = emptyFunction

            module.exports = function() {
                function shim(
                    props,
                    propName,
                    componentName,
                    location,
                    propFullName,
                    secret
                ) {
                    if (secret === ReactPropTypesSecret) {
                        // It is still safe when called from React.
                        return
                    }
                    var err = new Error(
                        'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
                            'Use PropTypes.checkPropTypes() to call them. ' +
                            'Read more at http://fb.me/use-check-prop-types'
                    )
                    err.name = 'Invariant Violation'
                    throw err
                }
                shim.isRequired = shim
                function getShim() {
                    return shim
                }
                // Important!
                // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
                var ReactPropTypes = {
                    array: shim,
                    bool: shim,
                    func: shim,
                    number: shim,
                    object: shim,
                    string: shim,
                    symbol: shim,

                    any: shim,
                    arrayOf: getShim,
                    element: shim,
                    elementType: shim,
                    instanceOf: getShim,
                    node: shim,
                    objectOf: getShim,
                    oneOf: getShim,
                    oneOfType: getShim,
                    shape: getShim,
                    exact: getShim,

                    checkPropTypes: emptyFunctionWithReset,
                    resetWarningCache: emptyFunction
                }

                ReactPropTypes.PropTypes = ReactPropTypes

                return ReactPropTypes
            }

            /***/
        },

        /***/ '17x9': /***/ function(module, exports, __webpack_require__) {
            /**
             * Copyright (c) 2013-present, Facebook, Inc.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */

            if (false) {
                var throwOnDirectAccess, ReactIs
            } else {
                // By explicitly using `prop-types` you are opting into new production behavior.
                // http://fb.me/prop-types-in-prod
                module.exports = __webpack_require__('16Al')()
            }

            /***/
        },

        /***/ '1ALl': /***/ function(module, exports, __webpack_require__) {
            const { keyObjectSupported } = __webpack_require__('pDDt')

            let createPublicKey
            let createPrivateKey
            let createSecretKey
            let KeyObject
            let asInput

            if (keyObjectSupported) {
                ;({
                    createPublicKey,
                    createPrivateKey,
                    createSecretKey,
                    KeyObject
                } = __webpack_require__('PJMN'))
                asInput = input => input
            } else {
                const { EOL } = __webpack_require__('jle/')

                const errors = __webpack_require__('yt7c')
                const isObject = __webpack_require__('kF1/')
                const asn1 = __webpack_require__('u88T')
                const toInput = Symbol('toInput')

                const namedCurve = Symbol('namedCurve')

                asInput = (keyObject, needsPublic) => {
                    if (keyObject instanceof KeyObject) {
                        return keyObject[toInput](needsPublic)
                    }

                    return createSecretKey(keyObject)[toInput](needsPublic)
                }

                const pemToDer = pem =>
                    Buffer.from(
                        pem.replace(
                            /(?:-----(?:BEGIN|END)(?: (?:RSA|EC))? (?:PRIVATE|PUBLIC) KEY-----|\s)/g,
                            ''
                        ),
                        'base64'
                    )
                const derToPem = (der, label) =>
                    `-----BEGIN ${label}-----${EOL}${der
                        .toString('base64')
                        .match(/.{1,64}/g)
                        .join(EOL)}${EOL}-----END ${label}-----`
                const unsupported = label => {
                    switch (label) {
                        case '1.3.101.110':
                            label = 'X25519'
                            break
                        case '1.3.101.111':
                            label = 'X448'
                            break
                        case '1.3.101.112':
                            label = 'Ed25519'
                            break
                        case '1.3.101.113':
                            label = 'Ed448'
                            break
                        default:
                            label = `OID ${label}`
                    }

                    throw new errors.JOSENotSupported(
                        `${label} is not supported in your Node.js runtime version`
                    )
                }

                KeyObject = class KeyObject {
                    export({ cipher, passphrase, type, format } = {}) {
                        if (this._type === 'secret') {
                            return this._buffer
                        }

                        if (this._type === 'public') {
                            if (this.asymmetricKeyType === 'rsa') {
                                switch (type) {
                                    case 'pkcs1':
                                        if (format === 'pem') {
                                            return this._pem
                                        }

                                        return pemToDer(this._pem)
                                    case 'spki': {
                                        const PublicKeyInfo = asn1.get(
                                            'PublicKeyInfo'
                                        )
                                        const pem = PublicKeyInfo.encode(
                                            {
                                                algorithm: {
                                                    algorithm: '1.2.840.113549.1.1.1'.split(
                                                        '.'
                                                    ),
                                                    parameters: Buffer.from(
                                                        'BQA=',
                                                        'base64'
                                                    )
                                                },
                                                publicKey: {
                                                    unused: 0,
                                                    data: pemToDer(this._pem)
                                                }
                                            },
                                            'pem',
                                            { label: 'PUBLIC KEY' }
                                        )

                                        return format === 'pem'
                                            ? pem
                                            : pemToDer(pem)
                                    }
                                    default:
                                        throw new TypeError(
                                            `The value ${type} is invalid for option "type"`
                                        )
                                }
                            }

                            if (this.asymmetricKeyType === 'ec') {
                                if (type !== 'spki') {
                                    throw new TypeError(
                                        `The value ${type} is invalid for option "type"`
                                    )
                                }

                                if (format === 'pem') {
                                    return this._pem
                                }

                                return pemToDer(this._pem)
                            }
                        }

                        if (this._type === 'private') {
                            if (
                                passphrase !== undefined ||
                                cipher !== undefined
                            ) {
                                throw new errors.JOSENotSupported(
                                    'encrypted private keys are not supported in your Node.js runtime version'
                                )
                            }

                            if (type === 'pkcs8') {
                                if (this._pkcs8) {
                                    if (
                                        format === 'der' &&
                                        typeof this._pkcs8 === 'string'
                                    ) {
                                        return pemToDer(this._pkcs8)
                                    }

                                    if (
                                        format === 'pem' &&
                                        Buffer.isBuffer(this._pkcs8)
                                    ) {
                                        return derToPem(
                                            this._pkcs8,
                                            'PRIVATE KEY'
                                        )
                                    }

                                    return this._pkcs8
                                }

                                if (this.asymmetricKeyType === 'rsa') {
                                    const parsed = this._asn1
                                    const RSAPrivateKey = asn1.get(
                                        'RSAPrivateKey'
                                    )
                                    const privateKey = RSAPrivateKey.encode(
                                        parsed
                                    )
                                    const PrivateKeyInfo = asn1.get(
                                        'PrivateKeyInfo'
                                    )
                                    const pkcs8 = PrivateKeyInfo.encode({
                                        version: 0,
                                        privateKey,
                                        algorithm: {
                                            algorithm: '1.2.840.113549.1.1.1'.split(
                                                '.'
                                            ),
                                            parameters: Buffer.from(
                                                'BQA=',
                                                'base64'
                                            )
                                        }
                                    })

                                    this._pkcs8 = pkcs8

                                    return this.export({ type, format })
                                }

                                if (this.asymmetricKeyType === 'ec') {
                                    const parsed = this._asn1
                                    const ECPrivateKey = asn1.get(
                                        'ECPrivateKey'
                                    )
                                    const privateKey = ECPrivateKey.encode({
                                        version: parsed.version,
                                        privateKey: parsed.privateKey,
                                        publicKey: parsed.publicKey
                                    })
                                    const PrivateKeyInfo = asn1.get(
                                        'PrivateKeyInfo'
                                    )
                                    const OID = asn1.get('OID')
                                    const pkcs8 = PrivateKeyInfo.encode({
                                        version: 0,
                                        privateKey,
                                        algorithm: {
                                            algorithm: '1.2.840.10045.2.1'.split(
                                                '.'
                                            ),
                                            parameters: OID.encode(
                                                this._asn1.parameters.value
                                            )
                                        }
                                    })

                                    this._pkcs8 = pkcs8

                                    return this.export({ type, format })
                                }
                            }

                            if (
                                this.asymmetricKeyType === 'rsa' &&
                                type === 'pkcs1'
                            ) {
                                if (format === 'pem') {
                                    return this._pem
                                }

                                return pemToDer(this._pem)
                            } else if (
                                this.asymmetricKeyType === 'ec' &&
                                type === 'sec1'
                            ) {
                                if (format === 'pem') {
                                    return this._pem
                                }

                                return pemToDer(this._pem)
                            } else {
                                throw new TypeError(
                                    `The value ${type} is invalid for option "type"`
                                )
                            }
                        }
                    }

                    get type() {
                        return this._type
                    }

                    get asymmetricKeyType() {
                        return this._asymmetricKeyType
                    }

                    get symmetricKeySize() {
                        return this._symmetricKeySize
                    }

                    [toInput](needsPublic) {
                        switch (this._type) {
                            case 'secret':
                                return this._buffer
                            case 'public':
                                return this._pem
                            default:
                                if (needsPublic) {
                                    if (!('_pub' in this)) {
                                        this._pub = createPublicKey(this)
                                    }

                                    return this._pub[toInput](false)
                                }

                                return this._pem
                        }
                    }
                }

                createSecretKey = buffer => {
                    if (!Buffer.isBuffer(buffer) || !buffer.length) {
                        throw new TypeError(
                            'input must be a non-empty Buffer instance'
                        )
                    }

                    const keyObject = new KeyObject()
                    keyObject._buffer = Buffer.from(buffer)
                    keyObject._symmetricKeySize = buffer.length
                    keyObject._type = 'secret'

                    return keyObject
                }

                createPublicKey = input => {
                    if (input instanceof KeyObject) {
                        if (input.type !== 'private') {
                            throw new TypeError(
                                `Invalid key object type ${input.type}, expected private.`
                            )
                        }

                        switch (input.asymmetricKeyType) {
                            case 'ec': {
                                const PublicKeyInfo = asn1.get('PublicKeyInfo')
                                const OID = asn1.get('OID')
                                const key = PublicKeyInfo.encode({
                                    algorithm: {
                                        algorithm: '1.2.840.10045.2.1'.split(
                                            '.'
                                        ),
                                        parameters: OID.encode(
                                            input._asn1.parameters.value
                                        )
                                    },
                                    publicKey: input._asn1.publicKey
                                })

                                return createPublicKey({
                                    key,
                                    format: 'der',
                                    type: 'spki'
                                })
                            }
                            case 'rsa': {
                                const RSAPublicKey = asn1.get('RSAPublicKey')
                                const key = RSAPublicKey.encode(input._asn1)
                                return createPublicKey({
                                    key,
                                    format: 'der',
                                    type: 'pkcs1'
                                })
                            }
                        }
                    }

                    if (typeof input === 'string' || Buffer.isBuffer(input)) {
                        input = { key: input, format: 'pem' }
                    }

                    if (!isObject(input)) {
                        throw new TypeError(
                            'input must be a string, Buffer or an object'
                        )
                    }

                    const { format, passphrase } = input
                    let { key, type } = input

                    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {
                        throw new TypeError('key must be a string or Buffer')
                    }

                    if (format !== 'pem' && format !== 'der') {
                        throw new TypeError(
                            'format must be one of "pem" or "der"'
                        )
                    }

                    let label
                    if (format === 'pem') {
                        key = key.toString()
                        switch (key.split(/\r?\n/g)[0].toString()) {
                            case '-----BEGIN PUBLIC KEY-----':
                                type = 'spki'
                                label = 'PUBLIC KEY'
                                break
                            case '-----BEGIN RSA PUBLIC KEY-----':
                                type = 'pkcs1'
                                label = 'RSA PUBLIC KEY'
                                break
                            case '-----BEGIN CERTIFICATE-----':
                                throw new errors.JOSENotSupported(
                                    'X.509 certificates are not supported in your Node.js runtime version'
                                )
                            case '-----BEGIN PRIVATE KEY-----':
                            case '-----BEGIN EC PRIVATE KEY-----':
                            case '-----BEGIN RSA PRIVATE KEY-----':
                                return createPublicKey(createPrivateKey(key))
                            default:
                                throw new TypeError(
                                    'unknown/unsupported PEM type'
                                )
                        }
                    }

                    switch (type) {
                        case 'spki': {
                            const PublicKeyInfo = asn1.get('PublicKeyInfo')
                            const parsed = PublicKeyInfo.decode(key, format, {
                                label
                            })

                            let type, keyObject
                            const oid = parsed.algorithm.algorithm.join('.')
                            switch (oid) {
                                case '1.2.840.10045.2.1': {
                                    keyObject = new KeyObject()
                                    keyObject._asn1 = parsed
                                    keyObject._asymmetricKeyType = 'ec'
                                    keyObject._type = 'public'
                                    keyObject._pem = PublicKeyInfo.encode(
                                        parsed,
                                        'pem',
                                        { label: 'PUBLIC KEY' }
                                    )

                                    break
                                }
                                case '1.2.840.113549.1.1.1': {
                                    type = 'pkcs1'
                                    keyObject = createPublicKey({
                                        type,
                                        key: parsed.publicKey.data,
                                        format: 'der'
                                    })
                                    break
                                }
                                default:
                                    unsupported(oid)
                            }

                            return keyObject
                        }
                        case 'pkcs1': {
                            const RSAPublicKey = asn1.get('RSAPublicKey')
                            const parsed = RSAPublicKey.decode(key, format, {
                                label
                            })

                            // special case when private pkcs1 PEM / DER is used with createPublicKey
                            if (parsed.n === 0n) {
                                return createPublicKey(
                                    createPrivateKey({
                                        key,
                                        format,
                                        type,
                                        passphrase
                                    })
                                )
                            }

                            const keyObject = new KeyObject()
                            keyObject._asn1 = parsed
                            keyObject._asymmetricKeyType = 'rsa'
                            keyObject._type = 'public'
                            keyObject._pem = RSAPublicKey.encode(
                                parsed,
                                'pem',
                                { label: 'RSA PUBLIC KEY' }
                            )

                            return keyObject
                        }
                        case 'pkcs8':
                        case 'sec1':
                            return createPublicKey(
                                createPrivateKey({
                                    format,
                                    key,
                                    type,
                                    passphrase
                                })
                            )
                        default:
                            throw new TypeError(
                                `The value ${type} is invalid for option "type"`
                            )
                    }
                }

                createPrivateKey = (input, hints) => {
                    if (typeof input === 'string' || Buffer.isBuffer(input)) {
                        input = { key: input, format: 'pem' }
                    }

                    if (!isObject(input)) {
                        throw new TypeError(
                            'input must be a string, Buffer or an object'
                        )
                    }

                    const { format, passphrase } = input
                    let { key, type } = input

                    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {
                        throw new TypeError('key must be a string or Buffer')
                    }

                    if (passphrase !== undefined) {
                        throw new errors.JOSENotSupported(
                            'encrypted private keys are not supported in your Node.js runtime version'
                        )
                    }

                    if (format !== 'pem' && format !== 'der') {
                        throw new TypeError(
                            'format must be one of "pem" or "der"'
                        )
                    }

                    let label
                    if (format === 'pem') {
                        key = key.toString()
                        switch (key.split(/\r?\n/g)[0].toString()) {
                            case '-----BEGIN PRIVATE KEY-----':
                                type = 'pkcs8'
                                label = 'PRIVATE KEY'
                                break
                            case '-----BEGIN EC PRIVATE KEY-----':
                                type = 'sec1'
                                label = 'EC PRIVATE KEY'
                                break
                            case '-----BEGIN RSA PRIVATE KEY-----':
                                type = 'pkcs1'
                                label = 'RSA PRIVATE KEY'
                                break
                            default:
                                throw new TypeError(
                                    'unknown/unsupported PEM type'
                                )
                        }
                    }

                    switch (type) {
                        case 'pkcs8': {
                            const PrivateKeyInfo = asn1.get('PrivateKeyInfo')
                            const parsed = PrivateKeyInfo.decode(key, format, {
                                label
                            })

                            let type, keyObject
                            const oid = parsed.algorithm.algorithm.join('.')
                            switch (oid) {
                                case '1.2.840.10045.2.1': {
                                    const OID = asn1.get('OID')
                                    type = 'sec1'
                                    keyObject = createPrivateKey(
                                        {
                                            type,
                                            key: parsed.privateKey,
                                            format: 'der'
                                        },
                                        {
                                            [namedCurve]: OID.decode(
                                                parsed.algorithm.parameters
                                            )
                                        }
                                    )
                                    break
                                }
                                case '1.2.840.113549.1.1.1': {
                                    type = 'pkcs1'
                                    keyObject = createPrivateKey({
                                        type,
                                        key: parsed.privateKey,
                                        format: 'der'
                                    })
                                    break
                                }
                                default:
                                    unsupported(oid)
                            }

                            keyObject._pkcs8 = key
                            return keyObject
                        }
                        case 'pkcs1': {
                            const RSAPrivateKey = asn1.get('RSAPrivateKey')
                            const parsed = RSAPrivateKey.decode(key, format, {
                                label
                            })

                            const keyObject = new KeyObject()
                            keyObject._asn1 = parsed
                            keyObject._asymmetricKeyType = 'rsa'
                            keyObject._type = 'private'
                            keyObject._pem = RSAPrivateKey.encode(
                                parsed,
                                'pem',
                                { label: 'RSA PRIVATE KEY' }
                            )

                            return keyObject
                        }
                        case 'sec1': {
                            const ECPrivateKey = asn1.get('ECPrivateKey')
                            let parsed = ECPrivateKey.decode(key, format, {
                                label
                            })

                            if (
                                !('parameters' in parsed) &&
                                !hints[namedCurve]
                            ) {
                                throw new Error('invalid sec1')
                            } else if (!('parameters' in parsed)) {
                                parsed = {
                                    ...parsed,
                                    parameters: {
                                        type: 'namedCurve',
                                        value: hints[namedCurve]
                                    }
                                }
                            }

                            const keyObject = new KeyObject()
                            keyObject._asn1 = parsed
                            keyObject._asymmetricKeyType = 'ec'
                            keyObject._type = 'private'
                            keyObject._pem = ECPrivateKey.encode(
                                parsed,
                                'pem',
                                { label: 'EC PRIVATE KEY' }
                            )

                            return keyObject
                        }
                        default:
                            throw new TypeError(
                                `The value ${type} is invalid for option "type"`
                            )
                    }
                }
            }

            module.exports = {
                createPublicKey,
                createPrivateKey,
                createSecretKey,
                KeyObject,
                asInput
            }

            /***/
        },

        /***/ '1Gj5': /***/ function(module, exports) {
            // Helper
            function reverse(map) {
                const res = {}

                Object.keys(map).forEach(function(key) {
                    // Convert key to integer if it is stringified
                    if ((key | 0) == key) {
                        key = key | 0
                    } // eslint-disable-line eqeqeq

                    const value = map[key]
                    res[value] = key
                })

                return res
            }

            exports.tagClass = {
                0: 'universal',
                1: 'application',
                2: 'context',
                3: 'private'
            }
            exports.tagClassByName = reverse(exports.tagClass)

            exports.tag = {
                0x00: 'end',
                0x01: 'bool',
                0x02: 'int',
                0x03: 'bitstr',
                0x04: 'octstr',
                0x05: 'null_',
                0x06: 'objid',
                0x07: 'objDesc',
                0x08: 'external',
                0x09: 'real',
                0x0a: 'enum',
                0x0b: 'embed',
                0x0c: 'utf8str',
                0x0d: 'relativeOid',
                0x10: 'seq',
                0x11: 'set',
                0x12: 'numstr',
                0x13: 'printstr',
                0x14: 't61str',
                0x15: 'videostr',
                0x16: 'ia5str',
                0x17: 'utctime',
                0x18: 'gentime',
                0x19: 'graphstr',
                0x1a: 'iso646str',
                0x1b: 'genstr',
                0x1c: 'unistr',
                0x1d: 'charstr',
                0x1e: 'bmpstr'
            }
            exports.tagByName = reverse(exports.tag)

            /***/
        },

        /***/ '1WHo': /***/ function(module, exports, __webpack_require__) {
            const { inherits } = __webpack_require__('jK02')

            function Reporter(options) {
                this._reporterState = {
                    obj: null,
                    path: [],
                    options: options || {},
                    errors: []
                }
            }

            Reporter.prototype.isError = function isError(obj) {
                return obj instanceof ReporterError
            }

            Reporter.prototype.save = function save() {
                const state = this._reporterState

                return { obj: state.obj, pathLen: state.path.length }
            }

            Reporter.prototype.restore = function restore(data) {
                const state = this._reporterState

                state.obj = data.obj
                state.path = state.path.slice(0, data.pathLen)
            }

            Reporter.prototype.enterKey = function enterKey(key) {
                return this._reporterState.path.push(key)
            }

            Reporter.prototype.exitKey = function exitKey(index) {
                const state = this._reporterState

                state.path = state.path.slice(0, index - 1)
            }

            Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
                const state = this._reporterState

                this.exitKey(index)
                if (state.obj !== null) {
                    state.obj[key] = value
                }
            }

            Reporter.prototype.path = function path() {
                return this._reporterState.path.join('/')
            }

            Reporter.prototype.enterObject = function enterObject() {
                const state = this._reporterState

                const prev = state.obj
                state.obj = {}
                return prev
            }

            Reporter.prototype.leaveObject = function leaveObject(prev) {
                const state = this._reporterState

                const now = state.obj
                state.obj = prev
                return now
            }

            Reporter.prototype.error = function error(msg) {
                let err
                const state = this._reporterState

                const inherited = msg instanceof ReporterError
                if (inherited) {
                    err = msg
                } else {
                    err = new ReporterError(
                        state.path
                            .map(function(elem) {
                                return `[${JSON.stringify(elem)}]`
                            })
                            .join(''),
                        msg.message || msg,
                        msg.stack
                    )
                }

                if (!state.options.partial) {
                    throw err
                }

                if (!inherited) {
                    state.errors.push(err)
                }

                return err
            }

            Reporter.prototype.wrapResult = function wrapResult(result) {
                const state = this._reporterState
                if (!state.options.partial) {
                    return result
                }

                return {
                    result: this.isError(result) ? null : result,
                    errors: state.errors
                }
            }

            function ReporterError(path, msg) {
                this.path = path
                this.rethrow(msg)
            }
            inherits(ReporterError, Error)

            ReporterError.prototype.rethrow = function rethrow(msg) {
                this.message = `${msg} at: ${this.path || '(shallow)'}`
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, ReporterError)
                }

                if (!this.stack) {
                    try {
                        // IE only adds stack when thrown
                        throw new Error(this.message)
                    } catch (e) {
                        this.stack = e.stack
                    }
                }
                return this
            }

            exports.Reporter = Reporter

            /***/
        },

        /***/ '1gXH': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const base64url_1 = tslib_1.__importDefault(
                __webpack_require__('+00W')
            )
            const crypto_1 = __webpack_require__('PJMN')
            const version_1 = tslib_1.__importDefault(
                __webpack_require__('Nndd')
            )
            const cookies_1 = __webpack_require__('gKi1')
            function telemetry() {
                const bytes = Buffer.from(
                    JSON.stringify({
                        name: 'nextjs-auth0',
                        version: version_1.default
                    })
                )
                return bytes
                    .toString('base64')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=+$/, '')
            }
            function loginHandler(settings, clientProvider) {
                return (req, res, options = {}) =>
                    tslib_1.__awaiter(this, void 0, void 0, function*() {
                        if (!res) {
                            throw new Error('Response is not available')
                        }
                        // Generate the state
                        const state = base64url_1.default(
                            crypto_1.randomBytes(48)
                        )
                        // Create the authorization url.
                        const client = yield clientProvider()
                        const authParams = (options && options.authParams) || {}
                        const authorizationUrl = client.authorizationUrl(
                            Object.assign(
                                {
                                    redirect_uri: settings.redirectUri,
                                    scope: settings.scope,
                                    response_type: 'code',
                                    audience: settings.audience,
                                    state,
                                    auth0Client: telemetry()
                                },
                                authParams
                            )
                        )
                        // Set the necessary cookies
                        cookies_1.setCookies(req, res, [
                            {
                                name: 'a0:state',
                                value: state,
                                maxAge: 60 * 60
                            }
                        ])
                        // Redirect to the authorize endpoint.
                        res.writeHead(302, {
                            Location: authorizationUrl
                        })
                        res.end()
                    })
            }
            exports.default = loginHandler
            //# sourceMappingURL=login.js.map

            /***/
        },

        /***/ '1hJj': /***/ function(module, exports, __webpack_require__) {
            var MapCache = __webpack_require__('e4Nc'),
                setCacheAdd = __webpack_require__('ftKO'),
                setCacheHas = __webpack_require__('3A9y')

            /**
             *
             * Creates an array cache object to store unique values.
             *
             * @private
             * @constructor
             * @param {Array} [values] The values to cache.
             */
            function SetCache(values) {
                var index = -1,
                    length = values == null ? 0 : values.length

                this.__data__ = new MapCache()
                while (++index < length) {
                    this.add(values[index])
                }
            }

            // Add methods to `SetCache`.
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd
            SetCache.prototype.has = setCacheHas

            module.exports = SetCache

            /***/
        },

        /***/ '1jOq': /***/ function(module, exports) {
            // Returns a wrapper function that returns a wrapped callback
            // The wrapper function should do some stuff, and return a
            // presumably different callback function.
            // This makes sure that own properties are retained, so that
            // decorations and such are not lost along the way.
            module.exports = wrappy
            function wrappy(fn, cb) {
                if (fn && cb) return wrappy(fn)(cb)

                if (typeof fn !== 'function')
                    throw new TypeError('need wrapper function')

                Object.keys(fn).forEach(function(k) {
                    wrapper[k] = fn[k]
                })

                return wrapper

                function wrapper() {
                    var args = new Array(arguments.length)
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i]
                    }
                    var ret = fn.apply(this, args)
                    var cb = args[args.length - 1]
                    if (typeof ret === 'function' && ret !== cb) {
                        Object.keys(cb).forEach(function(k) {
                            ret[k] = cb[k]
                        })
                    }
                    return ret
                }
            }

            /***/
        },

        /***/ '21rS': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const PassThrough = __webpack_require__('msIP').PassThrough
            const mimicResponse = __webpack_require__('qsvm')

            const cloneResponse = response => {
                if (!(response && response.pipe)) {
                    throw new TypeError(
                        'Parameter `response` must be a response stream.'
                    )
                }

                const clone = new PassThrough()
                mimicResponse(response, clone)

                return response.pipe(clone)
            }

            module.exports = cloneResponse

            /***/
        },

        /***/ '29s/': /***/ function(module, exports, __webpack_require__) {
            var core = __webpack_require__('WEpk')
            var global = __webpack_require__('5T2Y')
            var SHARED = '__core-js_shared__'
            var store = global[SHARED] || (global[SHARED] = {})

            ;(module.exports = function(key, value) {
                return (
                    store[key] ||
                    (store[key] = value !== undefined ? value : {})
                )
            })('versions', []).push({
                version: core.version,
                mode: __webpack_require__('uOPS') ? 'pure' : 'global',
                copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
            })

            /***/
        },

        /***/ '2Eek': /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('W7oM')

            /***/
        },

        /***/ '2GTP': /***/ function(module, exports, __webpack_require__) {
            // optional / simple context binding
            var aFunction = __webpack_require__('eaoh')
            module.exports = function(fn, that, length) {
                aFunction(fn)
                if (that === undefined) return fn
                switch (length) {
                    case 1:
                        return function(a) {
                            return fn.call(that, a)
                        }
                    case 2:
                        return function(a, b) {
                            return fn.call(that, a, b)
                        }
                    case 3:
                        return function(a, b, c) {
                            return fn.call(that, a, b, c)
                        }
                }
                return function(/* ...args */) {
                    return fn.apply(that, arguments)
                }
            }

            /***/
        },

        /***/ '2IvE': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const net = __webpack_require__('Qs2e')

            class TimeoutError extends Error {
                constructor(threshold, event) {
                    super(`Timeout awaiting '${event}' for ${threshold}ms`)
                    this.name = 'TimeoutError'
                    this.code = 'ETIMEDOUT'
                    this.event = event
                }
            }

            const reentry = Symbol('reentry')

            const noop = () => {}

            module.exports = (request, delays, options) => {
                /* istanbul ignore next: this makes sure timed-out isn't called twice */
                if (request[reentry]) {
                    return
                }

                request[reentry] = true

                let stopNewTimeouts = false

                const addTimeout = (delay, callback, ...args) => {
                    // An error had been thrown before. Going further would result in uncaught errors.
                    // See https://github.com/sindresorhus/got/issues/631#issuecomment-435675051
                    if (stopNewTimeouts) {
                        return noop
                    }

                    // Event loop order is timers, poll, immediates.
                    // The timed event may emit during the current tick poll phase, so
                    // defer calling the handler until the poll phase completes.
                    let immediate
                    const timeout = setTimeout(() => {
                        immediate = setImmediate(callback, delay, ...args)
                        /* istanbul ignore next: added in node v9.7.0 */
                        if (immediate.unref) {
                            immediate.unref()
                        }
                    }, delay)

                    /* istanbul ignore next: in order to support electron renderer */
                    if (timeout.unref) {
                        timeout.unref()
                    }

                    const cancel = () => {
                        clearTimeout(timeout)
                        clearImmediate(immediate)
                    }

                    cancelers.push(cancel)

                    return cancel
                }

                const { host, hostname } = options
                const timeoutHandler = (delay, event) => {
                    request.emit('error', new TimeoutError(delay, event))
                    request.once('error', () => {}) // Ignore the `socket hung up` error made by request.abort()

                    request.abort()
                }

                const cancelers = []
                const cancelTimeouts = () => {
                    stopNewTimeouts = true
                    cancelers.forEach(cancelTimeout => cancelTimeout())
                }

                request.once('error', cancelTimeouts)
                request.once('response', response => {
                    response.once('end', cancelTimeouts)
                })

                if (delays.request !== undefined) {
                    addTimeout(delays.request, timeoutHandler, 'request')
                }

                if (delays.socket !== undefined) {
                    const socketTimeoutHandler = () => {
                        timeoutHandler(delays.socket, 'socket')
                    }

                    request.setTimeout(delays.socket, socketTimeoutHandler)

                    // `request.setTimeout(0)` causes a memory leak.
                    // We can just remove the listener and forget about the timer - it's unreffed.
                    // See https://github.com/sindresorhus/got/issues/690
                    cancelers.push(() =>
                        request.removeListener('timeout', socketTimeoutHandler)
                    )
                }

                if (
                    delays.lookup !== undefined &&
                    !request.socketPath &&
                    !net.isIP(hostname || host)
                ) {
                    request.once('socket', socket => {
                        /* istanbul ignore next: hard to test */
                        if (socket.connecting) {
                            const cancelTimeout = addTimeout(
                                delays.lookup,
                                timeoutHandler,
                                'lookup'
                            )
                            socket.once('lookup', cancelTimeout)
                        }
                    })
                }

                if (delays.connect !== undefined) {
                    request.once('socket', socket => {
                        /* istanbul ignore next: hard to test */
                        if (socket.connecting) {
                            const timeConnect = () =>
                                addTimeout(
                                    delays.connect,
                                    timeoutHandler,
                                    'connect'
                                )

                            if (
                                request.socketPath ||
                                net.isIP(hostname || host)
                            ) {
                                socket.once('connect', timeConnect())
                            } else {
                                socket.once('lookup', error => {
                                    if (error === null) {
                                        socket.once('connect', timeConnect())
                                    }
                                })
                            }
                        }
                    })
                }

                if (
                    delays.secureConnect !== undefined &&
                    options.protocol === 'https:'
                ) {
                    request.once('socket', socket => {
                        /* istanbul ignore next: hard to test */
                        if (socket.connecting) {
                            socket.once('connect', () => {
                                const cancelTimeout = addTimeout(
                                    delays.secureConnect,
                                    timeoutHandler,
                                    'secureConnect'
                                )
                                socket.once('secureConnect', cancelTimeout)
                            })
                        }
                    })
                }

                if (delays.send !== undefined) {
                    request.once('socket', socket => {
                        const timeRequest = () =>
                            addTimeout(delays.send, timeoutHandler, 'send')
                        /* istanbul ignore next: hard to test */
                        if (socket.connecting) {
                            socket.once('connect', () => {
                                request.once('upload-complete', timeRequest())
                            })
                        } else {
                            request.once('upload-complete', timeRequest())
                        }
                    })
                }

                if (delays.response !== undefined) {
                    request.once('upload-complete', () => {
                        const cancelTimeout = addTimeout(
                            delays.response,
                            timeoutHandler,
                            'response'
                        )
                        request.once('response', cancelTimeout)
                    })
                }
            }

            module.exports.TimeoutError = TimeoutError

            /***/
        },

        /***/ '2KX+': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            function profileHandler(sessionStore) {
                return (req, res) =>
                    tslib_1.__awaiter(this, void 0, void 0, function*() {
                        if (!req) {
                            throw new Error('Request is not available')
                        }
                        if (!res) {
                            throw new Error('Response is not available')
                        }
                        const session = yield sessionStore.read(req)
                        if (!session || !session.user) {
                            res.status(401).json({
                                error: 'not_authenticated',
                                description:
                                    'The user does not have an active session or is not authenticated'
                            })
                            return
                        }
                        res.json(session.user)
                    })
            }
            exports.default = profileHandler
            //# sourceMappingURL=profile.js.map

            /***/
        },

        /***/ '2NqA': /***/ function(
            module,
            __webpack_exports__,
            __webpack_require__
        ) {
            'use strict'
            /* harmony import */ var _auth0_nextjs_auth0__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                'qwdb'
            )
            /* harmony import */ var _auth0_nextjs_auth0__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
                _auth0_nextjs_auth0__WEBPACK_IMPORTED_MODULE_0__
            )

            /* harmony default export */ __webpack_exports__['a'] = Object(
                _auth0_nextjs_auth0__WEBPACK_IMPORTED_MODULE_0__['initAuth0']
            )({
                clientId: 'pd7pNi0CFbkPtmuZof0tg7HNcb2uoY53',
                clientSecret:
                    'bTsCl2WWhXY7bLlEVs3kQL9a_4vzs3MHcV3EIILcC-5rnyPNHtz1yTpLManmIOBo',
                scope: 'openid profile',
                domain: 'osborne-dev.auth0.com',
                redirectUri:
                    'https://www.shopping-list-app.com/api/auth/callback',
                postLogoutRedirectUri: 'https://www.shopping-list-app.com/',
                session: {
                    cookieSecret:
                        'viloxyf_z2GW6K4CT-KQD_MoLEA2wqv5jWuq4Jd0P7ymgG5GJGMpvMneXZzhK3sL',
                    cookieLifetime: 7200
                }
            })

            /***/
        },

        /***/ '2SVd': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /**
             * Determines whether the specified URL is absolute
             *
             * @param {string} url The URL to test
             * @returns {boolean} True if the specified URL is absolute, otherwise false
             */
            module.exports = function isAbsoluteURL(url) {
                // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
                // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
                // by any combination of letters, digits, plus, period, or hyphen.
                return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
            }

            /***/
        },

        /***/ '2ZRA': /***/ function(
            module,
            __webpack_exports__,
            __webpack_require__
        ) {
            'use strict'

            // EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/define-property.js
            var define_property = __webpack_require__('hfKm')
            var define_property_default = /*#__PURE__*/ __webpack_require__.n(
                define_property
            )

            // EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/define-properties.js
            var define_properties = __webpack_require__('2Eek')
            var define_properties_default = /*#__PURE__*/ __webpack_require__.n(
                define_properties
            )

            // EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/get-own-property-descriptors.js
            var get_own_property_descriptors = __webpack_require__('XoMD')
            var get_own_property_descriptors_default = /*#__PURE__*/ __webpack_require__.n(
                get_own_property_descriptors
            )

            // EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/get-own-property-descriptor.js
            var get_own_property_descriptor = __webpack_require__('Jo+v')
            var get_own_property_descriptor_default = /*#__PURE__*/ __webpack_require__.n(
                get_own_property_descriptor
            )

            // EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/get-own-property-symbols.js
            var get_own_property_symbols = __webpack_require__('4mXO')
            var get_own_property_symbols_default = /*#__PURE__*/ __webpack_require__.n(
                get_own_property_symbols
            )

            // EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/keys.js
            var object_keys = __webpack_require__('pLtp')
            var keys_default = /*#__PURE__*/ __webpack_require__.n(object_keys)

            // CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty.js

            function _defineProperty(obj, key, value) {
                if (key in obj) {
                    define_property_default()(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    })
                } else {
                    obj[key] = value
                }

                return obj
            }
            // EXTERNAL MODULE: ./node_modules/react/index.js
            var react = __webpack_require__('q1tI')

            // EXTERNAL MODULE: ./node_modules/axios/index.js
            var axios = __webpack_require__('vDqi')
            var axios_default = /*#__PURE__*/ __webpack_require__.n(axios)

            // CONCATENATED MODULE: ./src/context/ShoppingItemContext/shoppingItem.context.tsx

            var __jsx = react['createElement']

            function ownKeys(object, enumerableOnly) {
                var keys = keys_default()(object)
                if (get_own_property_symbols_default.a) {
                    var symbols = get_own_property_symbols_default()(object)
                    if (enumerableOnly)
                        symbols = symbols.filter(function(sym) {
                            return get_own_property_descriptor_default()(
                                object,
                                sym
                            ).enumerable
                        })
                    keys.push.apply(keys, symbols)
                }
                return keys
            }

            function _objectSpread(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i] != null ? arguments[i] : {}
                    if (i % 2) {
                        ownKeys(Object(source), true).forEach(function(key) {
                            _defineProperty(target, key, source[key])
                        })
                    } else if (get_own_property_descriptors_default.a) {
                        define_properties_default()(
                            target,
                            get_own_property_descriptors_default()(source)
                        )
                    } else {
                        ownKeys(Object(source)).forEach(function(key) {
                            define_property_default()(
                                target,
                                key,
                                get_own_property_descriptor_default()(
                                    source,
                                    key
                                )
                            )
                        })
                    }
                }
                return target
            }

            const shoppingItem_context_initState = {
                items: [],
                addItem: () => {},
                editItem: () => {},
                deleteItem: () => {}
            }
            const ShoppingItemContext = react['createContext'](
                shoppingItem_context_initState
            )
            const ShoppingItemProvider = ({ children }) => {
                const [items, setItems] = react['useState']([])

                const addItem = async name => {
                    try {
                        const results = await axios_default.a.post(
                            '/api/item',
                            {
                                name
                            }
                        ) // console.log(results)
                    } catch (err) {
                        console.error(err)
                    } finally {
                        const newItem = {
                            name,
                            id: items.length + 1,
                            isPurchased: false
                        }
                        const newItems = [...items, newItem]
                        setItems(newItems)
                    }
                }

                const editItem = id => {
                    const item = items.filter(item => item.id === id)

                    const newItem = _objectSpread({}, item[0], {
                        isPurchased: !item[0].isPurchased
                    })

                    const newItems = items.map(item =>
                        item.id === id ? newItem : item
                    )
                    setItems(newItems)
                }

                const deleteItem = id => {
                    const newItems = items.filter(item => item.id !== id)
                    setItems(newItems)
                }

                const initState = {
                    items,
                    addItem,
                    editItem,
                    deleteItem
                }
                return __jsx(
                    ShoppingItemContext.Provider,
                    {
                        value: initState
                    },
                    children
                )
            }
            // CONCATENATED MODULE: ./src/context/index.tsx
            /* concated harmony reexport ShoppingItemContext */ __webpack_require__.d(
                __webpack_exports__,
                'a',
                function() {
                    return ShoppingItemContext
                }
            )
            /* concated harmony reexport ShoppingItemProvider */ __webpack_require__.d(
                __webpack_exports__,
                'b',
                function() {
                    return ShoppingItemProvider
                }
            )

            /***/
        },

        /***/ '2faE': /***/ function(module, exports, __webpack_require__) {
            var anObject = __webpack_require__('5K7Z')
            var IE8_DOM_DEFINE = __webpack_require__('eUtF')
            var toPrimitive = __webpack_require__('G8Mo')
            var dP = Object.defineProperty

            exports.f = __webpack_require__('jmDH')
                ? Object.defineProperty
                : function defineProperty(O, P, Attributes) {
                      anObject(O)
                      P = toPrimitive(P, true)
                      anObject(Attributes)
                      if (IE8_DOM_DEFINE)
                          try {
                              return dP(O, P, Attributes)
                          } catch (e) {
                              /* empty */
                          }
                      if ('get' in Attributes || 'set' in Attributes)
                          throw TypeError('Accessors not supported!')
                      if ('value' in Attributes) O[P] = Attributes.value
                      return O
                  }

            /***/
        },

        /***/ '2gN3': /***/ function(module, exports, __webpack_require__) {
            var root = __webpack_require__('Kz5y')

            /** Used to detect overreaching core-js shims. */
            var coreJsData = root['__core-js_shared__']

            module.exports = coreJsData

            /***/
        },

        /***/ '2qu3': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /**
@copyright (c) 2017-present James Kyle <me@thejameskyle.com>
 MIT License
 Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
 The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE
*/
            // https://github.com/jamiebuilds/react-loadable/blob/v5.5.0/src/index.js
            // Modified to be compatible with webpack 4 / Next.js

            var _Set = __webpack_require__('ttDY')

            var _Array$isArray = __webpack_require__('p0XB')

            var _Object$assign = __webpack_require__('UXZV')

            var _Promise = __webpack_require__('eVuF')

            var _Object$keys = __webpack_require__('pLtp')

            var _Object$defineProperty = __webpack_require__('hfKm')

            var __importDefault =
                (this && this.__importDefault) ||
                function(mod) {
                    return mod && mod.__esModule
                        ? mod
                        : {
                              default: mod
                          }
                }

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            const react_1 = __importDefault(__webpack_require__('q1tI'))

            const use_subscription_1 = __webpack_require__('8L3h')

            const loadable_context_1 = __webpack_require__('jwwS')

            const ALL_INITIALIZERS = []
            const READY_INITIALIZERS = []
            let initialized = false

            function load(loader) {
                let promise = loader()
                let state = {
                    loading: true,
                    loaded: null,
                    error: null
                }
                state.promise = promise
                    .then(loaded => {
                        state.loading = false
                        state.loaded = loaded
                        return loaded
                    })
                    .catch(err => {
                        state.loading = false
                        state.error = err
                        throw err
                    })
                return state
            }

            function loadMap(obj) {
                let state = {
                    loading: false,
                    loaded: {},
                    error: null
                }
                let promises = []

                try {
                    _Object$keys(obj).forEach(key => {
                        let result = load(obj[key])

                        if (!result.loading) {
                            state.loaded[key] = result.loaded
                            state.error = result.error
                        } else {
                            state.loading = true
                        }

                        promises.push(result.promise)
                        result.promise
                            .then(res => {
                                state.loaded[key] = res
                            })
                            .catch(err => {
                                state.error = err
                            })
                    })
                } catch (err) {
                    state.error = err
                }

                state.promise = _Promise
                    .all(promises)
                    .then(res => {
                        state.loading = false
                        return res
                    })
                    .catch(err => {
                        state.loading = false
                        throw err
                    })
                return state
            }

            function resolve(obj) {
                return obj && obj.__esModule ? obj.default : obj
            }

            function render(loaded, props) {
                return react_1.default.createElement(resolve(loaded), props)
            }

            function createLoadableComponent(loadFn, options) {
                let opts = _Object$assign(
                    {
                        loader: null,
                        loading: null,
                        delay: 200,
                        timeout: null,
                        render: render,
                        webpack: null,
                        modules: null
                    },
                    options
                )

                let subscription = null

                function init() {
                    if (!subscription) {
                        const sub = new LoadableSubscription(loadFn, opts)
                        subscription = {
                            getCurrentValue: sub.getCurrentValue.bind(sub),
                            subscribe: sub.subscribe.bind(sub),
                            retry: sub.retry.bind(sub),
                            promise: sub.promise.bind(sub)
                        }
                    }

                    return subscription.promise()
                } // Server only

                if (true) {
                    ALL_INITIALIZERS.push(init)
                } // Client only

                if (
                    !initialized &&
                    false &&
                    typeof opts.webpack === 'function'
                ) {
                    const moduleIds = opts.webpack()
                    READY_INITIALIZERS.push(ids => {
                        for (const moduleId of moduleIds) {
                            if (ids.indexOf(moduleId) !== -1) {
                                return init()
                            }
                        }
                    })
                }

                const LoadableComponent = (props, ref) => {
                    init()
                    const context = react_1.default.useContext(
                        loadable_context_1.LoadableContext
                    )
                    const state = use_subscription_1.useSubscription(
                        subscription
                    )
                    react_1.default.useImperativeHandle(ref, () => ({
                        retry: subscription.retry
                    }))

                    if (context && _Array$isArray(opts.modules)) {
                        opts.modules.forEach(moduleName => {
                            context(moduleName)
                        })
                    }

                    if (state.loading || state.error) {
                        return react_1.default.createElement(opts.loading, {
                            isLoading: state.loading,
                            pastDelay: state.pastDelay,
                            timedOut: state.timedOut,
                            error: state.error,
                            retry: subscription.retry
                        })
                    } else if (state.loaded) {
                        return opts.render(state.loaded, props)
                    } else {
                        return null
                    }
                }

                LoadableComponent.preload = () => init()

                LoadableComponent.displayName = 'LoadableComponent'
                return react_1.default.forwardRef(LoadableComponent)
            }

            class LoadableSubscription {
                constructor(loadFn, opts) {
                    this._loadFn = loadFn
                    this._opts = opts
                    this._callbacks = new _Set()
                    this._delay = null
                    this._timeout = null
                    this.retry()
                }

                promise() {
                    return this._res.promise
                }

                retry() {
                    this._clearTimeouts()

                    this._res = this._loadFn(this._opts.loader)
                    this._state = {
                        pastDelay: false,
                        timedOut: false
                    }
                    const { _res: res, _opts: opts } = this

                    if (res.loading) {
                        if (typeof opts.delay === 'number') {
                            if (opts.delay === 0) {
                                this._state.pastDelay = true
                            } else {
                                this._delay = setTimeout(() => {
                                    this._update({
                                        pastDelay: true
                                    })
                                }, opts.delay)
                            }
                        }

                        if (typeof opts.timeout === 'number') {
                            this._timeout = setTimeout(() => {
                                this._update({
                                    timedOut: true
                                })
                            }, opts.timeout)
                        }
                    }

                    this._res.promise
                        .then(() => {
                            this._update()

                            this._clearTimeouts()
                        }) // eslint-disable-next-line handle-callback-err
                        .catch(err => {
                            this._update()

                            this._clearTimeouts()
                        })

                    this._update({})
                }

                _update(partial) {
                    this._state = _Object$assign({}, this._state, partial)

                    this._callbacks.forEach(callback => callback())
                }

                _clearTimeouts() {
                    clearTimeout(this._delay)
                    clearTimeout(this._timeout)
                }

                getCurrentValue() {
                    return _Object$assign({}, this._state, {
                        error: this._res.error,
                        loaded: this._res.loaded,
                        loading: this._res.loading
                    })
                }

                subscribe(callback) {
                    this._callbacks.add(callback)

                    return () => {
                        this._callbacks.delete(callback)
                    }
                }
            }

            function Loadable(opts) {
                return createLoadableComponent(load, opts)
            }

            function LoadableMap(opts) {
                if (typeof opts.render !== 'function') {
                    throw new Error(
                        'LoadableMap requires a `render(loaded, props)` function'
                    )
                }

                return createLoadableComponent(loadMap, opts)
            }

            Loadable.Map = LoadableMap

            function flushInitializers(initializers, ids) {
                let promises = []

                while (initializers.length) {
                    let init = initializers.pop()
                    promises.push(init(ids))
                }

                return _Promise.all(promises).then(() => {
                    if (initializers.length) {
                        return flushInitializers(initializers, ids)
                    }
                })
            }

            Loadable.preloadAll = () => {
                return new _Promise((resolve, reject) => {
                    flushInitializers(ALL_INITIALIZERS).then(resolve, reject)
                })
            }

            Loadable.preloadReady = (ids = []) => {
                return new _Promise(resolve => {
                    const res = () => {
                        initialized = true
                        return resolve()
                    } // We always will resolve, errors should be handled within loading UIs.

                    flushInitializers(READY_INITIALIZERS, ids).then(res, res)
                })
            }

            if (false) {
            }

            exports.default = Loadable

            /***/
        },

        /***/ '33Iv': /***/ function(module, exports, __webpack_require__) {
            const { inflateRawSync } = __webpack_require__('FMKJ')

            const base64url = __webpack_require__('Xab3')
            const getKey = __webpack_require__('oGTz')
            const { KeyStore } = __webpack_require__('WPgm')
            const errors = __webpack_require__('yt7c')
            const {
                check,
                decrypt,
                keyManagementDecrypt
            } = __webpack_require__('FUB/')
            const JWK = __webpack_require__('lA9T')

            const { createSecretKey } = __webpack_require__('1ALl')
            const generateCEK = __webpack_require__('RGIU')
            const validateHeaders = __webpack_require__('OHZa')
            const { detect: resolveSerialization } = __webpack_require__('ARPQ')

            const SINGLE_RECIPIENT = new Set(['compact', 'flattened'])

            const combineHeader = (
                prot = {},
                unprotected = {},
                header = {}
            ) => {
                if (typeof prot === 'string') {
                    prot = base64url.JSON.decode(prot)
                }

                const p2s = prot.p2s || unprotected.p2s || header.p2s
                const apu = prot.apu || unprotected.apu || header.apu
                const apv = prot.apv || unprotected.apv || header.apv
                const iv = prot.iv || unprotected.iv || header.iv
                const tag = prot.tag || unprotected.tag || header.tag

                return {
                    ...prot,
                    ...unprotected,
                    ...header,
                    ...(typeof p2s === 'string'
                        ? { p2s: base64url.decodeToBuffer(p2s) }
                        : undefined),
                    ...(typeof apu === 'string'
                        ? { apu: base64url.decodeToBuffer(apu) }
                        : undefined),
                    ...(typeof apv === 'string'
                        ? { apv: base64url.decodeToBuffer(apv) }
                        : undefined),
                    ...(typeof iv === 'string'
                        ? { iv: base64url.decodeToBuffer(iv) }
                        : undefined),
                    ...(typeof tag === 'string'
                        ? { tag: base64url.decodeToBuffer(tag) }
                        : undefined)
                }
            }

            /*
             * @public
             */
            const jweDecrypt = (
                skipValidateHeaders,
                serialization,
                jwe,
                key,
                { crit = [], complete = false, algorithms } = {}
            ) => {
                key = getKey(key, true)

                if (
                    algorithms !== undefined &&
                    (!Array.isArray(algorithms) ||
                        algorithms.some(s => typeof s !== 'string' || !s))
                ) {
                    throw new TypeError(
                        '"algorithms" option must be an array of non-empty strings'
                    )
                } else if (algorithms) {
                    algorithms = new Set(algorithms)
                }

                if (
                    !Array.isArray(crit) ||
                    crit.some(s => typeof s !== 'string' || !s)
                ) {
                    throw new TypeError(
                        '"crit" option must be an array of non-empty strings'
                    )
                }

                if (!serialization) {
                    serialization = resolveSerialization(jwe)
                }

                let alg,
                    ciphertext,
                    enc,
                    encryptedKey,
                    iv,
                    opts,
                    prot,
                    tag,
                    unprotected,
                    cek,
                    aad,
                    header

                // treat general format with one recipient as flattened
                // skips iteration and avoids multi errors in this case
                if (
                    serialization === 'general' &&
                    jwe.recipients.length === 1
                ) {
                    serialization = 'flattened'
                    const { recipients, ...root } = jwe
                    jwe = { ...root, ...recipients[0] }
                }

                if (SINGLE_RECIPIENT.has(serialization)) {
                    if (serialization === 'compact') {
                        // compact serialization format
                        ;[prot, encryptedKey, iv, ciphertext, tag] = jwe.split(
                            '.'
                        )
                    } else {
                        // flattened serialization format
                        ;({
                            protected: prot,
                            encrypted_key: encryptedKey,
                            iv,
                            ciphertext,
                            tag,
                            unprotected,
                            aad,
                            header
                        } = jwe)
                    }

                    if (!skipValidateHeaders) {
                        validateHeaders(
                            prot,
                            unprotected,
                            [{ header }],
                            true,
                            crit
                        )
                    }

                    opts = combineHeader(prot, unprotected, header)
                    ;({ alg, enc } = opts)

                    if (
                        algorithms &&
                        !algorithms.has(alg === 'dir' ? enc : alg)
                    ) {
                        throw new errors.JOSEAlgNotWhitelisted(
                            'alg not whitelisted'
                        )
                    }

                    if (key instanceof KeyStore) {
                        const keystore = key
                        let keys
                        if (opts.alg === 'dir') {
                            keys = keystore.all({
                                kid: opts.kid,
                                alg: opts.enc,
                                key_ops: ['decrypt']
                            })
                        } else {
                            keys = keystore.all({
                                kid: opts.kid,
                                alg: opts.alg,
                                key_ops: ['unwrapKey']
                            })
                        }
                        switch (keys.length) {
                            case 0:
                                throw new errors.JWKSNoMatchingKey()
                            case 1:
                                // treat the call as if a Key instance was passed in
                                // skips iteration and avoids multi errors in this case
                                key = keys[0]
                                break
                            default: {
                                const errs = []
                                for (const key of keys) {
                                    try {
                                        return jweDecrypt(
                                            true,
                                            serialization,
                                            jwe,
                                            key,
                                            {
                                                crit,
                                                complete,
                                                algorithms: algorithms
                                                    ? [...algorithms]
                                                    : undefined
                                            }
                                        )
                                    } catch (err) {
                                        errs.push(err)
                                        continue
                                    }
                                }

                                const multi = new errors.JOSEMultiError(errs)
                                if (
                                    [...multi].some(
                                        e =>
                                            e instanceof
                                            errors.JWEDecryptionFailed
                                    )
                                ) {
                                    throw new errors.JWEDecryptionFailed()
                                }
                                throw multi
                            }
                        }
                    }

                    check(
                        key,
                        ...(alg === 'dir'
                            ? ['decrypt', enc]
                            : ['keyManagementDecrypt', alg])
                    )

                    try {
                        if (alg === 'dir') {
                            cek = JWK.asKey(key, { alg: enc, use: 'enc' })
                        } else if (alg === 'ECDH-ES') {
                            const unwrapped = keyManagementDecrypt(
                                alg,
                                key,
                                undefined,
                                opts
                            )
                            cek = JWK.asKey(createSecretKey(unwrapped), {
                                alg: enc,
                                use: 'enc'
                            })
                        } else {
                            const unwrapped = keyManagementDecrypt(
                                alg,
                                key,
                                base64url.decodeToBuffer(encryptedKey),
                                opts
                            )
                            cek = JWK.asKey(createSecretKey(unwrapped), {
                                alg: enc,
                                use: 'enc'
                            })
                        }
                    } catch (err) {
                        // To mitigate the attacks described in RFC 3218, the
                        // recipient MUST NOT distinguish between format, padding, and length
                        // errors of encrypted keys.  It is strongly recommended, in the event
                        // of receiving an improperly formatted key, that the recipient
                        // substitute a randomly generated CEK and proceed to the next step, to
                        // mitigate timing attacks.
                        cek = generateCEK(enc)
                    }

                    let adata
                    if (aad) {
                        adata = Buffer.concat([
                            Buffer.from(prot || ''),
                            Buffer.from('.'),
                            Buffer.from(aad)
                        ])
                    } else {
                        adata = Buffer.from(prot || '')
                    }

                    try {
                        iv = base64url.decodeToBuffer(iv)
                    } catch (err) {}
                    try {
                        tag = base64url.decodeToBuffer(tag)
                    } catch (err) {}

                    let cleartext = decrypt(
                        enc,
                        cek,
                        base64url.decodeToBuffer(ciphertext),
                        { iv, tag, aad: adata }
                    )

                    if (opts.zip) {
                        cleartext = inflateRawSync(cleartext)
                    }

                    if (complete) {
                        const result = { cleartext, key, cek }
                        if (aad) result.aad = aad
                        if (header) result.header = header
                        if (unprotected) result.unprotected = unprotected
                        if (prot) result.protected = base64url.JSON.decode(prot)
                        return result
                    }

                    return cleartext
                }

                validateHeaders(
                    jwe.protected,
                    jwe.unprotected,
                    jwe.recipients.map(({ header }) => ({ header })),
                    true,
                    crit
                )

                // general serialization format
                const { recipients, ...root } = jwe
                const errs = []
                for (const recipient of recipients) {
                    try {
                        return jweDecrypt(
                            true,
                            'flattened',
                            { ...root, ...recipient },
                            key,
                            {
                                crit,
                                complete,
                                algorithms: algorithms
                                    ? [...algorithms]
                                    : undefined
                            }
                        )
                    } catch (err) {
                        errs.push(err)
                        continue
                    }
                }

                const multi = new errors.JOSEMultiError(errs)
                if (
                    [...multi].some(
                        e => e instanceof errors.JWEDecryptionFailed
                    )
                ) {
                    throw new errors.JWEDecryptionFailed()
                } else if (
                    [...multi].every(e => e instanceof errors.JWKSNoMatchingKey)
                ) {
                    throw new errors.JWKSNoMatchingKey()
                }
                throw multi
            }

            module.exports = jweDecrypt.bind(undefined, false, undefined)

            /***/
        },

        /***/ '3A9y': /***/ function(module, exports) {
            /**
             * Checks if `value` is in the array cache.
             *
             * @private
             * @name has
             * @memberOf SetCache
             * @param {*} value The value to search for.
             * @returns {number} Returns `true` if `value` is found, else `false`.
             */
            function setCacheHas(value) {
                return this.__data__.has(value)
            }

            module.exports = setCacheHas

            /***/
        },

        /***/ '3Fdi': /***/ function(module, exports) {
            /** Used for built-in method references. */
            var funcProto = Function.prototype

            /** Used to resolve the decompiled source of functions. */
            var funcToString = funcProto.toString

            /**
             * Converts `func` to its source code.
             *
             * @private
             * @param {Function} func The function to convert.
             * @returns {string} Returns the source code.
             */
            function toSource(func) {
                if (func != null) {
                    try {
                        return funcToString.call(func)
                    } catch (e) {}
                    try {
                        return func + ''
                    } catch (e) {}
                }
                return ''
            }

            module.exports = toSource

            /***/
        },

        /***/ '3GJH': /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('lCc8')
            var $Object = __webpack_require__('WEpk').Object
            module.exports = function create(P, D) {
                return $Object.create(P, D)
            }

            /***/
        },

        /***/ '3HlQ': /***/ function(module, exports, __webpack_require__) {
            const {
                generateKeyPairSync,
                generateKeyPair: async
            } = __webpack_require__('PJMN')
            const { promisify } = __webpack_require__('jK02')

            const {
                THUMBPRINT_MATERIAL,
                JWK_MEMBERS,
                PUBLIC_MEMBERS,
                PRIVATE_MEMBERS,
                KEY_MANAGEMENT_DECRYPT,
                KEY_MANAGEMENT_ENCRYPT
            } = __webpack_require__('ehsS')
            const { EC_CURVES } = __webpack_require__('N+nT')
            const { keyObjectSupported } = __webpack_require__('pDDt')
            const { createPublicKey, createPrivateKey } = __webpack_require__(
                '1ALl'
            )

            const errors = __webpack_require__('yt7c')
            const { name: secp256k1 } = __webpack_require__('F/JS')

            const Key = __webpack_require__('//Cd')

            const generateKeyPair = promisify(async)

            const EC_PUBLIC = new Set(['crv', 'x', 'y'])
            Object.freeze(EC_PUBLIC)
            const EC_PRIVATE = new Set([...EC_PUBLIC, 'd'])
            Object.freeze(EC_PRIVATE)

            // Elliptic Curve Key Type
            class ECKey extends Key {
                constructor(...args) {
                    super(...args)
                    this[JWK_MEMBERS]()
                    Object.defineProperty(this, 'kty', {
                        value: 'EC',
                        enumerable: true
                    })
                    if (!this.crv) {
                        throw new errors.JOSENotSupported(
                            'unsupported EC key curve'
                        )
                    }
                }

                static get [PUBLIC_MEMBERS]() {
                    return EC_PUBLIC
                }

                static get [PRIVATE_MEMBERS]() {
                    return EC_PRIVATE
                }

                // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special
                // JSON.stringify handling in V8
                [THUMBPRINT_MATERIAL]() {
                    return { crv: this.crv, kty: 'EC', x: this.x, y: this.y }
                }

                [KEY_MANAGEMENT_ENCRYPT]() {
                    return this.algorithms('deriveKey')
                }

                [KEY_MANAGEMENT_DECRYPT]() {
                    if (this.public) {
                        return new Set()
                    }
                    return this.algorithms('deriveKey')
                }

                static async generate(crv = 'P-256', privat = true) {
                    if (!EC_CURVES.has(crv)) {
                        throw new errors.JOSENotSupported(
                            `unsupported EC key curve: ${crv}`
                        )
                    }

                    if (crv === secp256k1 && crv !== 'secp256k1') {
                        crv = 'secp256k1'
                    }

                    let privateKey, publicKey

                    if (keyObjectSupported) {
                        ;({
                            privateKey,
                            publicKey
                        } = await generateKeyPair('ec', { namedCurve: crv }))
                        return privat ? privateKey : publicKey
                    }

                    ;({ privateKey, publicKey } = await generateKeyPair('ec', {
                        namedCurve: crv,
                        publicKeyEncoding: { type: 'spki', format: 'pem' },
                        privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
                    }))

                    if (privat) {
                        return createPrivateKey(privateKey)
                    } else {
                        return createPublicKey(publicKey)
                    }
                }

                static generateSync(crv = 'P-256', privat = true) {
                    if (!EC_CURVES.has(crv)) {
                        throw new errors.JOSENotSupported(
                            `unsupported EC key curve: ${crv}`
                        )
                    }

                    if (crv === secp256k1 && crv !== 'secp256k1') {
                        crv = 'secp256k1'
                    }

                    let privateKey, publicKey

                    if (keyObjectSupported) {
                        ;({ privateKey, publicKey } = generateKeyPairSync(
                            'ec',
                            { namedCurve: crv }
                        ))
                        return privat ? privateKey : publicKey
                    }

                    ;({ privateKey, publicKey } = generateKeyPairSync('ec', {
                        namedCurve: crv,
                        publicKeyEncoding: { type: 'spki', format: 'pem' },
                        privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
                    }))

                    if (privat) {
                        return createPrivateKey(privateKey)
                    } else {
                        return createPublicKey(publicKey)
                    }
                }
            }

            module.exports = ECKey

            /***/
        },

        /***/ '3L66': /***/ function(module, exports, __webpack_require__) {
            var isArrayLike = __webpack_require__('MMmD'),
                isObjectLike = __webpack_require__('ExA7')

            /**
             * This method is like `_.isArrayLike` except that it also checks if `value`
             * is an object.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an array-like object,
             *  else `false`.
             * @example
             *
             * _.isArrayLikeObject([1, 2, 3]);
             * // => true
             *
             * _.isArrayLikeObject(document.body.children);
             * // => true
             *
             * _.isArrayLikeObject('abc');
             * // => false
             *
             * _.isArrayLikeObject(_.noop);
             * // => false
             */
            function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value)
            }

            module.exports = isArrayLikeObject

            /***/
        },

        /***/ '3OWR': /***/ function(module, exports, __webpack_require__) {
            var assignValue = __webpack_require__('MrPd'),
                copyObject = __webpack_require__('juv8'),
                createAssigner = __webpack_require__('LsHQ'),
                isArrayLike = __webpack_require__('MMmD'),
                isPrototype = __webpack_require__('6sVZ'),
                keys = __webpack_require__('7GkX')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Assigns own enumerable string keyed properties of source objects to the
             * destination object. Source objects are applied from left to right.
             * Subsequent sources overwrite property assignments of previous sources.
             *
             * **Note:** This method mutates `object` and is loosely based on
             * [`Object.assign`](https://mdn.io/Object/assign).
             *
             * @static
             * @memberOf _
             * @since 0.10.0
             * @category Object
             * @param {Object} object The destination object.
             * @param {...Object} [sources] The source objects.
             * @returns {Object} Returns `object`.
             * @see _.assignIn
             * @example
             *
             * function Foo() {
             *   this.a = 1;
             * }
             *
             * function Bar() {
             *   this.c = 3;
             * }
             *
             * Foo.prototype.b = 2;
             * Bar.prototype.d = 4;
             *
             * _.assign({ 'a': 0 }, new Foo, new Bar);
             * // => { 'a': 1, 'c': 3 }
             */
            var assign = createAssigner(function(object, source) {
                if (isPrototype(source) || isArrayLike(source)) {
                    copyObject(source, keys(source), object)
                    return
                }
                for (var key in source) {
                    if (hasOwnProperty.call(source, key)) {
                        assignValue(object, key, source[key])
                    }
                }
            })

            module.exports = assign

            /***/
        },

        /***/ '3WX/': /***/ function(module, exports, __webpack_require__) {
            var baseIteratee = __webpack_require__('ut/Y'),
                negate = __webpack_require__('oKwy'),
                pickBy = __webpack_require__('d8FT')

            /**
             * The opposite of `_.pickBy`; this method creates an object composed of
             * the own and inherited enumerable string keyed properties of `object` that
             * `predicate` doesn't return truthy for. The predicate is invoked with two
             * arguments: (value, key).
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Object
             * @param {Object} object The source object.
             * @param {Function} [predicate=_.identity] The function invoked per property.
             * @returns {Object} Returns the new object.
             * @example
             *
             * var object = { 'a': 1, 'b': '2', 'c': 3 };
             *
             * _.omitBy(object, _.isNumber);
             * // => { 'b': '2' }
             */
            function omitBy(object, predicate) {
                return pickBy(object, negate(baseIteratee(predicate)))
            }

            module.exports = omitBy

            /***/
        },

        /***/ '3Zki': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(input) {
                if (!input) {
                    return ''
                }

                let escaped = ''

                for (let i = 0; i < input.length; ++i) {
                    const charCode = input.charCodeAt(i)

                    if (internals.isSafe(charCode)) {
                        escaped += input[i]
                    } else {
                        escaped += internals.escapeHtmlChar(charCode)
                    }
                }

                return escaped
            }

            internals.escapeHtmlChar = function(charCode) {
                const namedEscape = internals.namedHtml[charCode]
                if (typeof namedEscape !== 'undefined') {
                    return namedEscape
                }

                if (charCode >= 256) {
                    return '&#' + charCode + ';'
                }

                const hexValue = charCode.toString(16).padStart(2, '0')
                return `&#x${hexValue};`
            }

            internals.isSafe = function(charCode) {
                return typeof internals.safeCharCodes[charCode] !== 'undefined'
            }

            internals.namedHtml = {
                '38': '&amp;',
                '60': '&lt;',
                '62': '&gt;',
                '34': '&quot;',
                '160': '&nbsp;',
                '162': '&cent;',
                '163': '&pound;',
                '164': '&curren;',
                '169': '&copy;',
                '174': '&reg;'
            }

            internals.safeCharCodes = (function() {
                const safe = {}

                for (let i = 32; i < 123; ++i) {
                    if (
                        i >= 97 || // a-z
                        (i >= 65 && i <= 90) || // A-Z
                        (i >= 48 && i <= 57) || // 0-9
                        i === 32 || // space
                        i === 46 || // .
                        i === 44 || // ,
                        i === 45 || // -
                        i === 58 || // :
                        i === 95
                    ) {
                        // _

                        safe[i] = null
                    }
                }

                return safe
            })()

            /***/
        },

        /***/ '3niX': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            exports.__esModule = true
            exports.flush = flush
            exports['default'] = void 0

            var _react = __webpack_require__('q1tI')

            var _stylesheetRegistry = _interopRequireDefault(
                __webpack_require__('SevZ')
            )

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj }
            }

            function _inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype)
                subClass.prototype.constructor = subClass
                subClass.__proto__ = superClass
            }

            var styleSheetRegistry = new _stylesheetRegistry['default']()

            var JSXStyle =
                /*#__PURE__*/
                (function(_Component) {
                    _inheritsLoose(JSXStyle, _Component)

                    function JSXStyle(props) {
                        var _this

                        _this = _Component.call(this, props) || this
                        _this.prevProps = {}
                        return _this
                    }

                    JSXStyle.dynamic = function dynamic(info) {
                        return info
                            .map(function(tagInfo) {
                                var baseId = tagInfo[0]
                                var props = tagInfo[1]
                                return styleSheetRegistry.computeId(
                                    baseId,
                                    props
                                )
                            })
                            .join(' ')
                    } // probably faster than PureComponent (shallowEqual)

                    var _proto = JSXStyle.prototype

                    _proto.shouldComponentUpdate = function shouldComponentUpdate(
                        otherProps
                    ) {
                        return (
                            this.props.id !== otherProps.id || // We do this check because `dynamic` is an array of strings or undefined.
                            // These are the computed values for dynamic styles.
                            String(this.props.dynamic) !==
                                String(otherProps.dynamic)
                        )
                    }

                    _proto.componentWillUnmount = function componentWillUnmount() {
                        styleSheetRegistry.remove(this.props)
                    }

                    _proto.render = function render() {
                        // This is a workaround to make the side effect async safe in the "render" phase.
                        // See https://github.com/zeit/styled-jsx/pull/484
                        if (this.shouldComponentUpdate(this.prevProps)) {
                            // Updates
                            if (this.prevProps.id) {
                                styleSheetRegistry.remove(this.prevProps)
                            }

                            styleSheetRegistry.add(this.props)
                            this.prevProps = this.props
                        }

                        return null
                    }

                    return JSXStyle
                })(_react.Component)

            exports['default'] = JSXStyle

            function flush() {
                var cssRules = styleSheetRegistry.cssRules()
                styleSheetRegistry.flush()
                return cssRules
            }

            /***/
        },

        /***/ '4/ic': /***/ function(module, exports, __webpack_require__) {
            var baseGet = __webpack_require__('ZWtO')

            /**
             * A specialized version of `baseProperty` which supports deep paths.
             *
             * @private
             * @param {Array|string} path The path of the property to get.
             * @returns {Function} Returns the new accessor function.
             */
            function basePropertyDeep(path) {
                return function(object) {
                    return baseGet(object, path)
                }
            }

            module.exports = basePropertyDeep

            /***/
        },

        /***/ '44Ds': /***/ function(module, exports, __webpack_require__) {
            var MapCache = __webpack_require__('e4Nc')

            /** Error message constants. */
            var FUNC_ERROR_TEXT = 'Expected a function'

            /**
             * Creates a function that memoizes the result of `func`. If `resolver` is
             * provided, it determines the cache key for storing the result based on the
             * arguments provided to the memoized function. By default, the first argument
             * provided to the memoized function is used as the map cache key. The `func`
             * is invoked with the `this` binding of the memoized function.
             *
             * **Note:** The cache is exposed as the `cache` property on the memoized
             * function. Its creation may be customized by replacing the `_.memoize.Cache`
             * constructor with one whose instances implement the
             * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
             * method interface of `clear`, `delete`, `get`, `has`, and `set`.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Function
             * @param {Function} func The function to have its output memoized.
             * @param {Function} [resolver] The function to resolve the cache key.
             * @returns {Function} Returns the new memoized function.
             * @example
             *
             * var object = { 'a': 1, 'b': 2 };
             * var other = { 'c': 3, 'd': 4 };
             *
             * var values = _.memoize(_.values);
             * values(object);
             * // => [1, 2]
             *
             * values(other);
             * // => [3, 4]
             *
             * object.a = 2;
             * values(object);
             * // => [1, 2]
             *
             * // Modify the result cache.
             * values.cache.set(object, ['a', 'b']);
             * values(object);
             * // => ['a', 'b']
             *
             * // Replace `_.memoize.Cache`.
             * _.memoize.Cache = WeakMap;
             */
            function memoize(func, resolver) {
                if (
                    typeof func != 'function' ||
                    (resolver != null && typeof resolver != 'function')
                ) {
                    throw new TypeError(FUNC_ERROR_TEXT)
                }
                var memoized = function() {
                    var args = arguments,
                        key = resolver ? resolver.apply(this, args) : args[0],
                        cache = memoized.cache

                    if (cache.has(key)) {
                        return cache.get(key)
                    }
                    var result = func.apply(this, args)
                    memoized.cache = cache.set(key, result) || cache
                    return result
                }
                memoized.cache = new (memoize.Cache || MapCache)()
                return memoized
            }

            // Expose `MapCache`.
            memoize.Cache = MapCache

            module.exports = memoize

            /***/
        },

        /***/ '4DFU': /***/ function(module, exports, __webpack_require__) {
            var baseMerge = __webpack_require__('+Qka'),
                isObject = __webpack_require__('GoyQ')

            /**
             * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
             * objects into destination objects that are passed thru.
             *
             * @private
             * @param {*} objValue The destination value.
             * @param {*} srcValue The source value.
             * @param {string} key The key of the property to merge.
             * @param {Object} object The parent object of `objValue`.
             * @param {Object} source The parent object of `srcValue`.
             * @param {Object} [stack] Tracks traversed source values and their merged
             *  counterparts.
             * @returns {*} Returns the value to assign.
             */
            function customDefaultsMerge(
                objValue,
                srcValue,
                key,
                object,
                source,
                stack
            ) {
                if (isObject(objValue) && isObject(srcValue)) {
                    // Recursively merge objects and arrays (susceptible to call stack limits).
                    stack.set(srcValue, objValue)
                    baseMerge(
                        objValue,
                        srcValue,
                        undefined,
                        customDefaultsMerge,
                        stack
                    )
                    stack['delete'](srcValue)
                }
                return objValue
            }

            module.exports = customDefaultsMerge

            /***/
        },

        /***/ '4UWp': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const EventEmitter = __webpack_require__('/0p4')
            const getStream = __webpack_require__('NFjz')
            const is = __webpack_require__('6mOv')
            const PCancelable = __webpack_require__('Qxd3')
            const requestAsEventEmitter = __webpack_require__('y/nk')
            const { HTTPError, ParseError, ReadError } = __webpack_require__(
                '9Fi5'
            )
            const { options: mergeOptions } = __webpack_require__('AW8e')
            const { reNormalize } = __webpack_require__('whhB')

            const asPromise = options => {
                const proxy = new EventEmitter()

                const promise = new PCancelable((resolve, reject, onCancel) => {
                    const emitter = requestAsEventEmitter(options)

                    onCancel(emitter.abort)

                    emitter.on('response', async response => {
                        proxy.emit('response', response)

                        const stream = is.null(options.encoding)
                            ? getStream.buffer(response)
                            : getStream(response, options)

                        let data
                        try {
                            data = await stream
                        } catch (error) {
                            reject(new ReadError(error, options))
                            return
                        }

                        const limitStatusCode = options.followRedirect
                            ? 299
                            : 399

                        response.body = data

                        try {
                            for (const [index, hook] of Object.entries(
                                options.hooks.afterResponse
                            )) {
                                // eslint-disable-next-line no-await-in-loop
                                response = await hook(
                                    response,
                                    updatedOptions => {
                                        updatedOptions = reNormalize(
                                            mergeOptions(options, {
                                                ...updatedOptions,
                                                retry: 0,
                                                throwHttpErrors: false
                                            })
                                        )

                                        // Remove any further hooks for that request, because we we'll call them anyway.
                                        // The loop continues. We don't want duplicates (asPromise recursion).
                                        updatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(
                                            0,
                                            index
                                        )

                                        return asPromise(updatedOptions)
                                    }
                                )
                            }
                        } catch (error) {
                            reject(error)
                            return
                        }

                        const { statusCode } = response

                        if (options.json && response.body) {
                            try {
                                response.body = JSON.parse(response.body)
                            } catch (error) {
                                if (statusCode >= 200 && statusCode < 300) {
                                    const parseError = new ParseError(
                                        error,
                                        statusCode,
                                        options,
                                        data
                                    )
                                    Object.defineProperty(
                                        parseError,
                                        'response',
                                        { value: response }
                                    )
                                    reject(parseError)
                                    return
                                }
                            }
                        }

                        if (
                            statusCode !== 304 &&
                            (statusCode < 200 || statusCode > limitStatusCode)
                        ) {
                            const error = new HTTPError(response, options)
                            Object.defineProperty(error, 'response', {
                                value: response
                            })
                            if (emitter.retry(error) === false) {
                                if (options.throwHttpErrors) {
                                    reject(error)
                                    return
                                }

                                resolve(response)
                            }

                            return
                        }

                        resolve(response)
                    })

                    emitter.once('error', reject)
                    ;[
                        'request',
                        'redirect',
                        'uploadProgress',
                        'downloadProgress'
                    ].forEach(event =>
                        emitter.on(event, (...args) =>
                            proxy.emit(event, ...args)
                        )
                    )
                })

                promise.on = (name, fn) => {
                    proxy.on(name, fn)
                    return promise
                }

                return promise
            }

            module.exports = asPromise

            /***/
        },

        /***/ '4kuk': /***/ function(module, exports, __webpack_require__) {
            var hashClear = __webpack_require__('SfRM'),
                hashDelete = __webpack_require__('Hvzi'),
                hashGet = __webpack_require__('u8Dt'),
                hashHas = __webpack_require__('ekgI'),
                hashSet = __webpack_require__('JSQU')

            /**
             * Creates a hash object.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function Hash(entries) {
                var index = -1,
                    length = entries == null ? 0 : entries.length

                this.clear()
                while (++index < length) {
                    var entry = entries[index]
                    this.set(entry[0], entry[1])
                }
            }

            // Add methods to `Hash`.
            Hash.prototype.clear = hashClear
            Hash.prototype['delete'] = hashDelete
            Hash.prototype.get = hashGet
            Hash.prototype.has = hashHas
            Hash.prototype.set = hashSet

            module.exports = Hash

            /***/
        },

        /***/ '4mXO': /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('7TPF')

            /***/
        },

        /***/ '4sDh': /***/ function(module, exports, __webpack_require__) {
            var castPath = __webpack_require__('4uTw'),
                isArguments = __webpack_require__('03A+'),
                isArray = __webpack_require__('Z0cm'),
                isIndex = __webpack_require__('wJg7'),
                isLength = __webpack_require__('shjB'),
                toKey = __webpack_require__('9Nap')

            /**
             * Checks if `path` exists on `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Array|string} path The path to check.
             * @param {Function} hasFunc The function to check properties.
             * @returns {boolean} Returns `true` if `path` exists, else `false`.
             */
            function hasPath(object, path, hasFunc) {
                path = castPath(path, object)

                var index = -1,
                    length = path.length,
                    result = false

                while (++index < length) {
                    var key = toKey(path[index])
                    if (!(result = object != null && hasFunc(object, key))) {
                        break
                    }
                    object = object[key]
                }
                if (result || ++index != length) {
                    return result
                }
                length = object == null ? 0 : object.length
                return (
                    !!length &&
                    isLength(length) &&
                    isIndex(key, length) &&
                    (isArray(object) || isArguments(object))
                )
            }

            module.exports = hasPath

            /***/
        },

        /***/ '4uTw': /***/ function(module, exports, __webpack_require__) {
            var isArray = __webpack_require__('Z0cm'),
                isKey = __webpack_require__('9ggG'),
                stringToPath = __webpack_require__('GNiM'),
                toString = __webpack_require__('dt0z')

            /**
             * Casts `value` to a path array if it's not one.
             *
             * @private
             * @param {*} value The value to inspect.
             * @param {Object} [object] The object to query keys on.
             * @returns {Array} Returns the cast property path array.
             */
            function castPath(value, object) {
                if (isArray(value)) {
                    return value
                }
                return isKey(value, object)
                    ? [value]
                    : stringToPath(toString(value))
            }

            module.exports = castPath

            /***/
        },

        /***/ '5K7Z': /***/ function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__('93I4')
            module.exports = function(it) {
                if (!isObject(it)) throw TypeError(it + ' is not an object!')
                return it
            }

            /***/
        },

        /***/ '5T2Y': /***/ function(module, exports) {
            // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
            var global = (module.exports =
                typeof window != 'undefined' && window.Math == Math
                    ? window
                    : typeof self != 'undefined' && self.Math == Math
                    ? self
                    : // eslint-disable-next-line no-new-func
                      Function('return this')())
            if (typeof __g == 'number') __g = global // eslint-disable-line no-undef

            /***/
        },

        /***/ '5Tg0': /***/ function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */ ;(function(module) {
                var root = __webpack_require__('Kz5y')

                /** Detect free variable `exports`. */
                var freeExports =
                    true && exports && !exports.nodeType && exports

                /** Detect free variable `module`. */
                var freeModule =
                    freeExports &&
                    typeof module == 'object' &&
                    module &&
                    !module.nodeType &&
                    module

                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports =
                    freeModule && freeModule.exports === freeExports

                /** Built-in value references. */
                var Buffer = moduleExports ? root.Buffer : undefined,
                    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined

                /**
                 * Creates a clone of  `buffer`.
                 *
                 * @private
                 * @param {Buffer} buffer The buffer to clone.
                 * @param {boolean} [isDeep] Specify a deep clone.
                 * @returns {Buffer} Returns the cloned buffer.
                 */
                function cloneBuffer(buffer, isDeep) {
                    if (isDeep) {
                        return buffer.slice()
                    }
                    var length = buffer.length,
                        result = allocUnsafe
                            ? allocUnsafe(length)
                            : new buffer.constructor(length)

                    buffer.copy(result)
                    return result
                }

                module.exports = cloneBuffer

                /* WEBPACK VAR INJECTION */
            }.call(this, __webpack_require__('YuTi')(module)))

            /***/
        },

        /***/ '5Uuq': /***/ function(module, exports, __webpack_require__) {
            var _Object$getOwnPropertyDescriptor = __webpack_require__('Jo+v')

            var _Object$defineProperty = __webpack_require__('hfKm')

            var _WeakMap = __webpack_require__('G4HQ')

            function _getRequireWildcardCache() {
                if (typeof _WeakMap !== 'function') return null
                var cache = new _WeakMap()

                _getRequireWildcardCache = function _getRequireWildcardCache() {
                    return cache
                }

                return cache
            }

            function _interopRequireWildcard(obj) {
                if (obj && obj.__esModule) {
                    return obj
                }

                var cache = _getRequireWildcardCache()

                if (cache && cache.has(obj)) {
                    return cache.get(obj)
                }

                var newObj = {}

                if (obj != null) {
                    var hasPropertyDescriptor =
                        _Object$defineProperty &&
                        _Object$getOwnPropertyDescriptor

                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            var desc = hasPropertyDescriptor
                                ? _Object$getOwnPropertyDescriptor(obj, key)
                                : null

                            if (desc && (desc.get || desc.set)) {
                                _Object$defineProperty(newObj, key, desc)
                            } else {
                                newObj[key] = obj[key]
                            }
                        }
                    }
                }

                newObj['default'] = obj

                if (cache) {
                    cache.set(obj, newObj)
                }

                return newObj
            }

            module.exports = _interopRequireWildcard

            /***/
        },

        /***/ '5ZhA': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Assert = __webpack_require__('GlC0')
            const Clone = __webpack_require__('qnp3')
            const Utils = __webpack_require__('O0PD')

            const internals = {}

            module.exports = internals.merge = function(
                target,
                source,
                options
            ) {
                Assert(
                    target && typeof target === 'object',
                    'Invalid target value: must be an object'
                )
                Assert(
                    source === null ||
                        source === undefined ||
                        typeof source === 'object',
                    'Invalid source value: must be null, undefined, or an object'
                )

                if (!source) {
                    return target
                }

                options = Object.assign(
                    { nullOverride: true, mergeArrays: true },
                    options
                )

                if (Array.isArray(source)) {
                    Assert(
                        Array.isArray(target),
                        'Cannot merge array onto an object'
                    )
                    if (!options.mergeArrays) {
                        target.length = 0 // Must not change target assignment
                    }

                    for (let i = 0; i < source.length; ++i) {
                        target.push(
                            Clone(source[i], { symbols: options.symbols })
                        )
                    }

                    return target
                }

                const keys = Utils.keys(source, options)
                for (let i = 0; i < keys.length; ++i) {
                    const key = keys[i]
                    if (
                        key === '__proto__' ||
                        !Object.prototype.propertyIsEnumerable.call(source, key)
                    ) {
                        continue
                    }

                    const value = source[key]
                    if (value && typeof value === 'object') {
                        if (
                            !target[key] ||
                            typeof target[key] !== 'object' ||
                            Array.isArray(target[key]) !==
                                Array.isArray(value) ||
                            value instanceof Date ||
                            (Buffer && Buffer.isBuffer(value)) || // $lab:coverage:ignore$
                            value instanceof RegExp
                        ) {
                            target[key] = Clone(value, {
                                symbols: options.symbols
                            })
                        } else {
                            internals.merge(target[key], value, options)
                        }
                    } else {
                        if (value !== null && value !== undefined) {
                            // Explicit to preserve empty strings

                            target[key] = value
                        } else if (options.nullOverride) {
                            target[key] = value
                        }
                    }
                }

                return target
            }

            /***/
        },

        /***/ '5fWB': /***/ function(module, exports, __webpack_require__) {
            const { createSign, createVerify } = __webpack_require__('PJMN')

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const resolveNodeAlg = __webpack_require__('uGJc')
            const { asInput } = __webpack_require__('1ALl')

            const sign = (nodeAlg, { [KEYOBJECT]: keyObject }, payload) => {
                return createSign(nodeAlg)
                    .update(payload)
                    .sign(asInput(keyObject, false))
            }

            const verify = (
                nodeAlg,
                { [KEYOBJECT]: keyObject },
                payload,
                signature
            ) => {
                return createVerify(nodeAlg)
                    .update(payload)
                    .verify(asInput(keyObject, true), signature)
            }

            const LENGTHS = {
                RS256: 0,
                RS384: 624,
                RS512: 752
            }

            module.exports = (JWA, JWK) => {
                ;['RS256', 'RS384', 'RS512'].forEach(jwaAlg => {
                    const nodeAlg = resolveNodeAlg(jwaAlg)
                    JWA.sign.set(jwaAlg, sign.bind(undefined, nodeAlg))
                    JWA.verify.set(jwaAlg, verify.bind(undefined, nodeAlg))
                    JWK.RSA.sign[jwaAlg] = key =>
                        key.private && JWK.RSA.verify[jwaAlg](key)
                    JWK.RSA.verify[jwaAlg] = key =>
                        (key.use === 'sig' || key.use === undefined) &&
                        key.length >= LENGTHS[jwaAlg]
                })
            }

            /***/
        },

        /***/ '5kZ8': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {
                suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
            }

            exports.parse = function(text, reviver, options) {
                // Normalize arguments

                if (!options) {
                    if (reviver && typeof reviver === 'object') {
                        options = reviver
                        reviver = undefined
                    } else {
                        options = {}
                    }
                }

                // Parse normally, allowing exceptions

                const obj = JSON.parse(text, reviver)

                // options.protoAction: 'error' (default) / 'remove' / 'ignore'

                if (options.protoAction === 'ignore') {
                    return obj
                }

                // Ignore null and non-objects

                if (!obj || typeof obj !== 'object') {
                    return obj
                }

                // Check original string for potential exploit

                if (!text.match(internals.suspectRx)) {
                    return obj
                }

                // Scan result for proto keys

                exports.scan(obj, options)

                return obj
            }

            exports.scan = function(obj, options) {
                options = options || {}

                let next = [obj]

                while (next.length) {
                    const nodes = next
                    next = []

                    for (const node of nodes) {
                        if (
                            Object.prototype.hasOwnProperty.call(
                                node,
                                '__proto__'
                            )
                        ) {
                            // Avoid calling node.hasOwnProperty directly
                            if (options.protoAction !== 'remove') {
                                throw new SyntaxError(
                                    'Object contains forbidden prototype property'
                                )
                            }

                            delete node.__proto__
                        }

                        for (const key in node) {
                            const value = node[key]
                            if (value && typeof value === 'object') {
                                next.push(node[key])
                            }
                        }
                    }
                }
            }

            exports.safeParse = function(text, reviver) {
                try {
                    return exports.parse(text, reviver)
                } catch (ignoreError) {
                    return null
                }
            }

            /***/
        },

        /***/ '5oMp': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /**
             * Creates a new URL by combining the specified URLs
             *
             * @param {string} baseURL The base URL
             * @param {string} relativeURL The relative URL
             * @returns {string} The combined URL
             */
            module.exports = function combineURLs(baseURL, relativeURL) {
                return relativeURL
                    ? baseURL.replace(/\/+$/, '') +
                          '/' +
                          relativeURL.replace(/^\/+/, '')
                    : baseURL
            }

            /***/
        },

        /***/ '5sMl': /***/ function(module, exports, __webpack_require__) {
            const crypto = __webpack_require__('PJMN')

            const [major, minor] = process.version
                .substr(1)
                .split('.')
                .map(x => parseInt(x, 10))
            const xofOutputLength = major > 12 || (major === 12 && minor >= 8)
            const shake256 =
                xofOutputLength && crypto.getHashes().includes('shake256')

            module.exports = shake256

            /***/
        },

        /***/ '5sNo': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const cookies_1 = __webpack_require__('gKi1')
            function callbackHandler(settings, clientProvider, sessionStore) {
                return (req, res, options) =>
                    tslib_1.__awaiter(this, void 0, void 0, function*() {
                        if (!res) {
                            throw new Error('Response is not available')
                        }
                        if (!req) {
                            throw new Error('Request is not available')
                        }
                        // Parse the cookies.
                        const cookies = cookies_1.parseCookies(req)
                        // Require that we have a state.
                        const state = cookies['a0:state']
                        if (!state) {
                            throw new Error(
                                'Invalid request, an initial state could not be found'
                            )
                        }
                        // Execute the code exchange
                        const client = yield clientProvider()
                        const params = client.callbackParams(req)
                        const tokenSet = yield client.callback(
                            settings.redirectUri,
                            params,
                            {
                                state
                            }
                        )
                        // Get the claims without any OIDC specific claim.
                        const claims = tokenSet.claims()
                        if (claims.aud) {
                            delete claims.aud
                        }
                        if (claims.exp) {
                            delete claims.exp
                        }
                        if (claims.iat) {
                            delete claims.iat
                        }
                        if (claims.iss) {
                            delete claims.iss
                        }
                        // Create the session.
                        const session = {
                            user: Object.assign({}, claims),
                            idToken: tokenSet.id_token,
                            accessToken: tokenSet.access_token,
                            refreshToken: tokenSet.refresh_token,
                            createdAt: Date.now()
                        }
                        // Create the session.
                        yield sessionStore.save(req, res, session)
                        // Redirect to the homepage.
                        const redirectTo =
                            (options && options.redirectTo) || '/'
                        res.writeHead(302, {
                            Location: redirectTo
                        })
                        res.end()
                    })
            }
            exports.default = callbackHandler
            //# sourceMappingURL=callback.js.map

            /***/
        },

        /***/ '5vMV': /***/ function(module, exports, __webpack_require__) {
            var has = __webpack_require__('B+OT')
            var toIObject = __webpack_require__('NsO/')
            var arrayIndexOf = __webpack_require__('W070')(false)
            var IE_PROTO = __webpack_require__('VVlx')('IE_PROTO')

            module.exports = function(object, names) {
                var O = toIObject(object)
                var i = 0
                var result = []
                var key
                for (key in O)
                    if (key != IE_PROTO) has(O, key) && result.push(key)
                // Don't enum bug & hidden keys
                while (names.length > i)
                    if (has(O, (key = names[i++]))) {
                        ~arrayIndexOf(result, key) || result.push(key)
                    }
                return result
            }

            /***/
        },

        /***/ '6/1s': /***/ function(module, exports, __webpack_require__) {
            var META = __webpack_require__('YqAc')('meta')
            var isObject = __webpack_require__('93I4')
            var has = __webpack_require__('B+OT')
            var setDesc = __webpack_require__('2faE').f
            var id = 0
            var isExtensible =
                Object.isExtensible ||
                function() {
                    return true
                }
            var FREEZE = !__webpack_require__('KUxP')(function() {
                return isExtensible(Object.preventExtensions({}))
            })
            var setMeta = function(it) {
                setDesc(it, META, {
                    value: {
                        i: 'O' + ++id, // object ID
                        w: {} // weak collections IDs
                    }
                })
            }
            var fastKey = function(it, create) {
                // return primitive with prefix
                if (!isObject(it))
                    return typeof it == 'symbol'
                        ? it
                        : (typeof it == 'string' ? 'S' : 'P') + it
                if (!has(it, META)) {
                    // can't set metadata to uncaught frozen object
                    if (!isExtensible(it)) return 'F'
                    // not necessary to add metadata
                    if (!create) return 'E'
                    // add missing metadata
                    setMeta(it)
                    // return object ID
                }
                return it[META].i
            }
            var getWeak = function(it, create) {
                if (!has(it, META)) {
                    // can't set metadata to uncaught frozen object
                    if (!isExtensible(it)) return true
                    // not necessary to add metadata
                    if (!create) return false
                    // add missing metadata
                    setMeta(it)
                    // return hash weak collections IDs
                }
                return it[META].w
            }
            // add metadata on freeze-family methods calling
            var onFreeze = function(it) {
                if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META))
                    setMeta(it)
                return it
            }
            var meta = (module.exports = {
                KEY: META,
                NEED: false,
                fastKey: fastKey,
                getWeak: getWeak,
                onFreeze: onFreeze
            })

            /***/
        },

        /***/ '67Bq': /***/ function(module) {
            module.exports = JSON.parse('{}')

            /***/
        },

        /***/ '6CmU': /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('LzdP')
            module.exports = __webpack_require__('WEpk').Date.now

            /***/
        },

        /***/ '6I+L': /***/ function(module, exports, __webpack_require__) {
            const isObject = __webpack_require__('kF1/')
            const secs = __webpack_require__('o156')
            const epoch = __webpack_require__('F4x3')
            const getKey = __webpack_require__('oGTz')
            const JWS = __webpack_require__('sR+5')

            const isString = __webpack_require__('mRrf').isString.bind(
                undefined,
                TypeError
            )

            const validateOptions = options => {
                if (typeof options.iat !== 'boolean') {
                    throw new TypeError('options.iat must be a boolean')
                }

                if (typeof options.kid !== 'boolean') {
                    throw new TypeError('options.kid must be a boolean')
                }

                isString(options.subject, 'options.subject')
                isString(options.issuer, 'options.issuer')

                if (
                    options.audience !== undefined &&
                    (typeof options.audience !== 'string' ||
                        !options.audience) &&
                        (!Array.isArray(options.audience) ||
                            options.audience.length === 0 ||
                            options.audience.some(
                                a => !a || typeof a !== 'string'
                            ))
                ) {
                    throw new TypeError(
                        'options.audience must be a string or an array of strings'
                    )
                }

                if (!isObject(options.header)) {
                    throw new TypeError('options.header must be an object')
                }

                isString(options.algorithm, 'options.algorithm')
                isString(options.expiresIn, 'options.expiresIn')
                isString(options.notBefore, 'options.notBefore')
                isString(options.jti, 'options.jti')
                isString(options.nonce, 'options.nonce')

                if (
                    options.now !== undefined &&
                    (!(options.now instanceof Date) || !options.now.getTime())
                ) {
                    throw new TypeError(
                        'options.now must be a valid Date object'
                    )
                }
            }

            module.exports = (payload, key, options = {}) => {
                if (!isObject(options)) {
                    throw new TypeError('options must be an object')
                }

                const {
                    algorithm,
                    audience,
                    expiresIn,
                    header = {},
                    iat = true,
                    issuer,
                    jti,
                    kid = true,
                    nonce,
                    notBefore,
                    subject,
                    now
                } = options

                validateOptions({
                    algorithm,
                    audience,
                    expiresIn,
                    header,
                    iat,
                    issuer,
                    jti,
                    kid,
                    nonce,
                    notBefore,
                    now,
                    subject
                })

                if (!isObject(payload)) {
                    throw new TypeError('payload must be an object')
                }

                let unix
                if (expiresIn || notBefore || iat) {
                    unix = epoch(now || new Date())
                }

                payload = {
                    ...payload,
                    sub: subject || payload.sub,
                    aud: audience || payload.aud,
                    iss: issuer || payload.iss,
                    jti: jti || payload.jti,
                    iat: iat ? unix : payload.iat,
                    nonce: nonce || payload.nonce,
                    exp: expiresIn ? unix + secs(expiresIn) : payload.exp,
                    nbf: notBefore ? unix + secs(notBefore) : payload.nbf
                }

                key = getKey(key)

                let includeKid

                if (typeof options.kid === 'boolean') {
                    includeKid = kid
                } else {
                    includeKid = !key.secret
                }

                return JWS.sign(JSON.stringify(payload), key, {
                    ...header,
                    alg: algorithm || header.alg,
                    kid: includeKid ? key.kid : header.kid
                })
            }

            /***/
        },

        /***/ '6gLP': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            function createDummyBrowserInstance() {
                return {
                    isBrowser: true,
                    handleLogin: () => {
                        throw new Error(
                            'The handleLogin method can only be used from the server side'
                        )
                    },
                    handleLogout: () => {
                        throw new Error(
                            'The handleLogout method can only be used from the server side'
                        )
                    },
                    handleCallback: () => {
                        throw new Error(
                            'The handleCallback method can only be used from the server side'
                        )
                    },
                    handleProfile: () => {
                        throw new Error(
                            'The handleProfile method can only be used from the server side'
                        )
                    },
                    getSession: () => {
                        throw new Error(
                            'The getSession method can only be used from the server side'
                        )
                    },
                    requireAuthentication: () => () => {
                        throw new Error(
                            'The requireAuthentication method can only be used from the server side'
                        )
                    }
                }
            }
            exports.default = createDummyBrowserInstance
            //# sourceMappingURL=instance.browser.js.map

            /***/
        },

        /***/ '6mOv': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /// <reference lib="es2016"/>
            /// <reference lib="es2017.sharedmemory"/>
            /// <reference lib="esnext.asynciterable"/>
            /// <reference lib="dom"/>
            Object.defineProperty(exports, '__esModule', { value: true })
            // TODO: Use the `URL` global when targeting Node.js 10
            // tslint:disable-next-line
            const URLGlobal =
                typeof URL === 'undefined'
                    ? __webpack_require__('bzos').URL
                    : URL
            const toString = Object.prototype.toString
            const isOfType = type => value => typeof value === type
            const isBuffer = input =>
                !is.nullOrUndefined(input) &&
                !is.nullOrUndefined(input.constructor) &&
                is.function_(input.constructor.isBuffer) &&
                input.constructor.isBuffer(input)
            const getObjectType = value => {
                const objectName = toString.call(value).slice(8, -1)
                if (objectName) {
                    return objectName
                }
                return null
            }
            const isObjectOfType = type => value =>
                getObjectType(value) === type
            function is(value) {
                switch (value) {
                    case null:
                        return 'null' /* null */
                    case true:
                    case false:
                        return 'boolean' /* boolean */
                    default:
                }
                switch (typeof value) {
                    case 'undefined':
                        return 'undefined' /* undefined */
                    case 'string':
                        return 'string' /* string */
                    case 'number':
                        return 'number' /* number */
                    case 'symbol':
                        return 'symbol' /* symbol */
                    default:
                }
                if (is.function_(value)) {
                    return 'Function' /* Function */
                }
                if (is.observable(value)) {
                    return 'Observable' /* Observable */
                }
                if (Array.isArray(value)) {
                    return 'Array' /* Array */
                }
                if (isBuffer(value)) {
                    return 'Buffer' /* Buffer */
                }
                const tagType = getObjectType(value)
                if (tagType) {
                    return tagType
                }
                if (
                    value instanceof String ||
                    value instanceof Boolean ||
                    value instanceof Number
                ) {
                    throw new TypeError(
                        "Please don't use object wrappers for primitive types"
                    )
                }
                return 'Object' /* Object */
            }
            ;(function(is) {
                // tslint:disable-next-line:strict-type-predicates
                const isObject = value => typeof value === 'object'
                // tslint:disable:variable-name
                is.undefined = isOfType('undefined')
                is.string = isOfType('string')
                is.number = isOfType('number')
                is.function_ = isOfType('function')
                // tslint:disable-next-line:strict-type-predicates
                is.null_ = value => value === null
                is.class_ = value =>
                    is.function_(value) && value.toString().startsWith('class ')
                is.boolean = value => value === true || value === false
                is.symbol = isOfType('symbol')
                // tslint:enable:variable-name
                is.numericString = value =>
                    is.string(value) &&
                    value.length > 0 &&
                    !Number.isNaN(Number(value))
                is.array = Array.isArray
                is.buffer = isBuffer
                is.nullOrUndefined = value =>
                    is.null_(value) || is.undefined(value)
                is.object = value =>
                    !is.nullOrUndefined(value) &&
                    (is.function_(value) || isObject(value))
                is.iterable = value =>
                    !is.nullOrUndefined(value) &&
                    is.function_(value[Symbol.iterator])
                is.asyncIterable = value =>
                    !is.nullOrUndefined(value) &&
                    is.function_(value[Symbol.asyncIterator])
                is.generator = value =>
                    is.iterable(value) &&
                    is.function_(value.next) &&
                    is.function_(value.throw)
                is.nativePromise = value =>
                    isObjectOfType('Promise' /* Promise */)(value)
                const hasPromiseAPI = value =>
                    !is.null_(value) &&
                    isObject(value) &&
                    is.function_(value.then) &&
                    is.function_(value.catch)
                is.promise = value =>
                    is.nativePromise(value) || hasPromiseAPI(value)
                is.generatorFunction = isObjectOfType(
                    'GeneratorFunction' /* GeneratorFunction */
                )
                is.asyncFunction = isObjectOfType(
                    'AsyncFunction' /* AsyncFunction */
                )
                is.boundFunction = value =>
                    is.function_(value) && !value.hasOwnProperty('prototype')
                is.regExp = isObjectOfType('RegExp' /* RegExp */)
                is.date = isObjectOfType('Date' /* Date */)
                is.error = isObjectOfType('Error' /* Error */)
                is.map = value => isObjectOfType('Map' /* Map */)(value)
                is.set = value => isObjectOfType('Set' /* Set */)(value)
                is.weakMap = value =>
                    isObjectOfType('WeakMap' /* WeakMap */)(value)
                is.weakSet = value =>
                    isObjectOfType('WeakSet' /* WeakSet */)(value)
                is.int8Array = isObjectOfType('Int8Array' /* Int8Array */)
                is.uint8Array = isObjectOfType('Uint8Array' /* Uint8Array */)
                is.uint8ClampedArray = isObjectOfType(
                    'Uint8ClampedArray' /* Uint8ClampedArray */
                )
                is.int16Array = isObjectOfType('Int16Array' /* Int16Array */)
                is.uint16Array = isObjectOfType('Uint16Array' /* Uint16Array */)
                is.int32Array = isObjectOfType('Int32Array' /* Int32Array */)
                is.uint32Array = isObjectOfType('Uint32Array' /* Uint32Array */)
                is.float32Array = isObjectOfType(
                    'Float32Array' /* Float32Array */
                )
                is.float64Array = isObjectOfType(
                    'Float64Array' /* Float64Array */
                )
                is.arrayBuffer = isObjectOfType('ArrayBuffer' /* ArrayBuffer */)
                is.sharedArrayBuffer = isObjectOfType(
                    'SharedArrayBuffer' /* SharedArrayBuffer */
                )
                is.dataView = isObjectOfType('DataView' /* DataView */)
                is.directInstanceOf = (instance, klass) =>
                    Object.getPrototypeOf(instance) === klass.prototype
                is.urlInstance = value => isObjectOfType('URL' /* URL */)(value)
                is.urlString = value => {
                    if (!is.string(value)) {
                        return false
                    }
                    try {
                        new URLGlobal(value) // tslint:disable-line no-unused-expression
                        return true
                    } catch (_a) {
                        return false
                    }
                }
                is.truthy = value => Boolean(value)
                is.falsy = value => !value
                is.nan = value => Number.isNaN(value)
                const primitiveTypes = new Set([
                    'undefined',
                    'string',
                    'number',
                    'boolean',
                    'symbol'
                ])
                is.primitive = value =>
                    is.null_(value) || primitiveTypes.has(typeof value)
                is.integer = value => Number.isInteger(value)
                is.safeInteger = value => Number.isSafeInteger(value)
                is.plainObject = value => {
                    // From: https://github.com/sindresorhus/is-plain-obj/blob/master/index.js
                    let prototype
                    return (
                        getObjectType(value) === 'Object' /* Object */ &&
                        ((prototype = Object.getPrototypeOf(value)),
                        prototype === null || // tslint:disable-line:ban-comma-operator
                            prototype === Object.getPrototypeOf({}))
                    )
                }
                const typedArrayTypes = new Set([
                    'Int8Array' /* Int8Array */,
                    'Uint8Array' /* Uint8Array */,
                    'Uint8ClampedArray' /* Uint8ClampedArray */,
                    'Int16Array' /* Int16Array */,
                    'Uint16Array' /* Uint16Array */,
                    'Int32Array' /* Int32Array */,
                    'Uint32Array' /* Uint32Array */,
                    'Float32Array' /* Float32Array */,
                    'Float64Array' /* Float64Array */
                ])
                is.typedArray = value => {
                    const objectType = getObjectType(value)
                    if (objectType === null) {
                        return false
                    }
                    return typedArrayTypes.has(objectType)
                }
                const isValidLength = value =>
                    is.safeInteger(value) && value > -1
                is.arrayLike = value =>
                    !is.nullOrUndefined(value) &&
                    !is.function_(value) &&
                    isValidLength(value.length)
                is.inRange = (value, range) => {
                    if (is.number(range)) {
                        return (
                            value >= Math.min(0, range) &&
                            value <= Math.max(range, 0)
                        )
                    }
                    if (is.array(range) && range.length === 2) {
                        return (
                            value >= Math.min(...range) &&
                            value <= Math.max(...range)
                        )
                    }
                    throw new TypeError(
                        `Invalid range: ${JSON.stringify(range)}`
                    )
                }
                const NODE_TYPE_ELEMENT = 1
                const DOM_PROPERTIES_TO_CHECK = [
                    'innerHTML',
                    'ownerDocument',
                    'style',
                    'attributes',
                    'nodeValue'
                ]
                is.domElement = value =>
                    is.object(value) &&
                    value.nodeType === NODE_TYPE_ELEMENT &&
                    is.string(value.nodeName) &&
                    !is.plainObject(value) &&
                    DOM_PROPERTIES_TO_CHECK.every(property => property in value)
                is.observable = value => {
                    if (!value) {
                        return false
                    }
                    if (
                        value[Symbol.observable] &&
                        value === value[Symbol.observable]()
                    ) {
                        return true
                    }
                    if (
                        value['@@observable'] &&
                        value === value['@@observable']()
                    ) {
                        return true
                    }
                    return false
                }
                is.nodeStream = value =>
                    !is.nullOrUndefined(value) &&
                    isObject(value) &&
                    is.function_(value.pipe) &&
                    !is.observable(value)
                is.infinite = value => value === Infinity || value === -Infinity
                const isAbsoluteMod2 = rem => value =>
                    is.integer(value) && Math.abs(value % 2) === rem
                is.even = isAbsoluteMod2(0)
                is.odd = isAbsoluteMod2(1)
                const isWhiteSpaceString = value =>
                    is.string(value) && /\S/.test(value) === false
                is.emptyArray = value => is.array(value) && value.length === 0
                is.nonEmptyArray = value => is.array(value) && value.length > 0
                is.emptyString = value => is.string(value) && value.length === 0
                is.nonEmptyString = value =>
                    is.string(value) && value.length > 0
                is.emptyStringOrWhitespace = value =>
                    is.emptyString(value) || isWhiteSpaceString(value)
                is.emptyObject = value =>
                    is.object(value) &&
                    !is.map(value) &&
                    !is.set(value) &&
                    Object.keys(value).length === 0
                is.nonEmptyObject = value =>
                    is.object(value) &&
                    !is.map(value) &&
                    !is.set(value) &&
                    Object.keys(value).length > 0
                is.emptySet = value => is.set(value) && value.size === 0
                is.nonEmptySet = value => is.set(value) && value.size > 0
                is.emptyMap = value => is.map(value) && value.size === 0
                is.nonEmptyMap = value => is.map(value) && value.size > 0
                const predicateOnArray = (method, predicate, values) => {
                    if (is.function_(predicate) === false) {
                        throw new TypeError(
                            `Invalid predicate: ${JSON.stringify(predicate)}`
                        )
                    }
                    if (values.length === 0) {
                        throw new TypeError('Invalid number of values')
                    }
                    return method.call(values, predicate)
                }
                // tslint:disable variable-name
                is.any = (predicate, ...values) =>
                    predicateOnArray(Array.prototype.some, predicate, values)
                is.all = (predicate, ...values) =>
                    predicateOnArray(Array.prototype.every, predicate, values)
                // tslint:enable variable-name
            })(is || (is = {}))
            // Some few keywords are reserved, but we'll populate them for Node.js users
            // See https://github.com/Microsoft/TypeScript/issues/2536
            Object.defineProperties(is, {
                class: {
                    value: is.class_
                },
                function: {
                    value: is.function_
                },
                null: {
                    value: is.null_
                }
            })
            exports.default = is
            // For CommonJS default export support
            module.exports = is
            module.exports.default = is
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ '6sVZ': /***/ function(module, exports) {
            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /**
             * Checks if `value` is likely a prototype object.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
             */
            function isPrototype(value) {
                var Ctor = value && value.constructor,
                    proto =
                        (typeof Ctor == 'function' && Ctor.prototype) ||
                        objectProto

                return value === proto
            }

            module.exports = isPrototype

            /***/
        },

        /***/ '711d': /***/ function(module, exports) {
            /**
             * The base implementation of `_.property` without support for deep paths.
             *
             * @private
             * @param {string} key The key of the property to get.
             * @returns {Function} Returns the new accessor function.
             */
            function baseProperty(key) {
                return function(object) {
                    return object == null ? undefined : object[key]
                }
            }

            module.exports = baseProperty

            /***/
        },

        /***/ '73TM': /***/ function(module, exports) {
            module.exports = require('react-ssr-prepass')

            /***/
        },

        /***/ '77Zs': /***/ function(module, exports, __webpack_require__) {
            var ListCache = __webpack_require__('Xi7e')

            /**
             * Removes all key-value entries from the stack.
             *
             * @private
             * @name clear
             * @memberOf Stack
             */
            function stackClear() {
                this.__data__ = new ListCache()
                this.size = 0
            }

            module.exports = stackClear

            /***/
        },

        /***/ '781u': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Assert = __webpack_require__('GlC0')
            const DeepEqual = __webpack_require__('Cl1u')
            const EscapeRegex = __webpack_require__('zosA')
            const Utils = __webpack_require__('O0PD')

            const internals = {}

            module.exports = function(ref, values, options = {}) {
                // options: { deep, once, only, part, symbols }

                /*
        string -> string(s)
        array -> item(s)
        object -> key(s)
        object -> object (key:value)
    */

                if (typeof values !== 'object') {
                    values = [values]
                }

                Assert(
                    !Array.isArray(values) || values.length,
                    'Values array cannot be empty'
                )

                // String

                if (typeof ref === 'string') {
                    return internals.string(ref, values, options)
                }

                // Array

                if (Array.isArray(ref)) {
                    return internals.array(ref, values, options)
                }

                // Object

                Assert(
                    typeof ref === 'object',
                    'Reference must be string or an object'
                )
                return internals.object(ref, values, options)
            }

            internals.array = function(ref, values, options) {
                if (!Array.isArray(values)) {
                    values = [values]
                }

                if (!ref.length) {
                    return false
                }

                if (
                    options.only &&
                    options.once &&
                    ref.length !== values.length
                ) {
                    return false
                }

                let compare

                // Map values

                const map = new Map()
                for (const value of values) {
                    if (!options.deep || !value || typeof value !== 'object') {
                        const existing = map.get(value)
                        if (existing) {
                            ++existing.allowed
                        } else {
                            map.set(value, { allowed: 1, hits: 0 })
                        }
                    } else {
                        compare = compare || internals.compare(options)

                        let found = false
                        for (const [key, existing] of map.entries()) {
                            if (compare(key, value)) {
                                ++existing.allowed
                                found = true
                                break
                            }
                        }

                        if (!found) {
                            map.set(value, { allowed: 1, hits: 0 })
                        }
                    }
                }

                // Lookup values

                let hits = 0
                for (const item of ref) {
                    let match
                    if (!options.deep || !item || typeof item !== 'object') {
                        match = map.get(item)
                    } else {
                        for (const [key, existing] of map.entries()) {
                            if (compare(key, item)) {
                                match = existing
                                break
                            }
                        }
                    }

                    if (match) {
                        ++match.hits
                        ++hits

                        if (options.once && match.hits > match.allowed) {
                            return false
                        }
                    }
                }

                // Validate results

                if (options.only && hits !== ref.length) {
                    return false
                }

                for (const match of map.values()) {
                    if (match.hits === match.allowed) {
                        continue
                    }

                    if (match.hits < match.allowed && !options.part) {
                        return false
                    }
                }

                return !!hits
            }

            internals.object = function(ref, values, options) {
                Assert(
                    options.once === undefined,
                    'Cannot use option once with object'
                )

                const keys = Utils.keys(ref, options)
                if (!keys.length) {
                    return false
                }

                // Keys list

                if (Array.isArray(values)) {
                    return internals.array(keys, values, options)
                }

                // Key value pairs

                const symbols = Object.getOwnPropertySymbols(
                    values
                ).filter(sym => values.propertyIsEnumerable(sym))
                const targets = [...Object.keys(values), ...symbols]

                const compare = internals.compare(options)
                const set = new Set(targets)

                for (const key of keys) {
                    if (!set.has(key)) {
                        if (options.only) {
                            return false
                        }

                        continue
                    }

                    if (!compare(values[key], ref[key])) {
                        return false
                    }

                    set.delete(key)
                }

                if (set.size) {
                    return options.part ? set.size < targets.length : false
                }

                return true
            }

            internals.string = function(ref, values, options) {
                // Empty string

                if (ref === '') {
                    return (
                        (values.length === 1 && values[0] === '') || // '' contains ''
                        (!options.once && !values.some(v => v !== ''))
                    ) // '' contains multiple '' if !once
                }

                // Map values

                const map = new Map()
                const patterns = []

                for (const value of values) {
                    Assert(
                        typeof value === 'string',
                        'Cannot compare string reference to non-string value'
                    )

                    if (value) {
                        const existing = map.get(value)
                        if (existing) {
                            ++existing.allowed
                        } else {
                            map.set(value, { allowed: 1, hits: 0 })
                            patterns.push(EscapeRegex(value))
                        }
                    } else if (options.once || options.only) {
                        return false
                    }
                }

                if (!patterns.length) {
                    // Non-empty string contains unlimited empty string
                    return true
                }

                // Match patterns

                const regex = new RegExp(`(${patterns.join('|')})`, 'g')
                const leftovers = ref.replace(regex, ($0, $1) => {
                    ++map.get($1).hits
                    return '' // Remove from string
                })

                // Validate results

                if (options.only && leftovers) {
                    return false
                }

                let any = false
                for (const match of map.values()) {
                    if (match.hits) {
                        any = true
                    }

                    if (match.hits === match.allowed) {
                        continue
                    }

                    if (match.hits < match.allowed && !options.part) {
                        return false
                    }

                    // match.hits > match.allowed

                    if (options.once) {
                        return false
                    }
                }

                return !!any
            }

            internals.compare = function(options) {
                if (!options.deep) {
                    return internals.shallow
                }

                const hasOnly = options.only !== undefined
                const hasPart = options.part !== undefined

                const flags = {
                    prototype: hasOnly
                        ? options.only
                        : hasPart
                        ? !options.part
                        : false,
                    part: hasOnly
                        ? !options.only
                        : hasPart
                        ? options.part
                        : false
                }

                return (a, b) => DeepEqual(a, b, flags)
            }

            internals.shallow = function(a, b) {
                return a === b
            }

            /***/
        },

        /***/ '7GkX': /***/ function(module, exports, __webpack_require__) {
            var arrayLikeKeys = __webpack_require__('b80T'),
                baseKeys = __webpack_require__('A90E'),
                isArrayLike = __webpack_require__('MMmD')

            /**
             * Creates an array of the own enumerable property names of `object`.
             *
             * **Note:** Non-object values are coerced to objects. See the
             * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
             * for more details.
             *
             * @static
             * @since 0.1.0
             * @memberOf _
             * @category Object
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             * @example
             *
             * function Foo() {
             *   this.a = 1;
             *   this.b = 2;
             * }
             *
             * Foo.prototype.c = 3;
             *
             * _.keys(new Foo);
             * // => ['a', 'b'] (iteration order is not guaranteed)
             *
             * _.keys('hi');
             * // => ['0', '1']
             */
            function keys(object) {
                return isArrayLike(object)
                    ? arrayLikeKeys(object)
                    : baseKeys(object)
            }

            module.exports = keys

            /***/
        },

        /***/ '7Ix3': /***/ function(module, exports) {
            /**
             * This function is like
             * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
             * except that it includes inherited enumerable properties.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             */
            function nativeKeysIn(object) {
                var result = []
                if (object != null) {
                    for (var key in Object(object)) {
                        result.push(key)
                    }
                }
                return result
            }

            module.exports = nativeKeysIn

            /***/
        },

        /***/ '7TPF': /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('AUvm')
            module.exports = __webpack_require__(
                'WEpk'
            ).Object.getOwnPropertySymbols

            /***/
        },

        /***/ '7WL4': /***/ function(module, exports) {
            module.exports = require('https')

            /***/
        },

        /***/ '7cJT': /***/ function(
            module,
            __webpack_exports__,
            __webpack_require__
        ) {
            'use strict'

            // EXTERNAL MODULE: ./node_modules/styled-jsx/style.js
            var style = __webpack_require__('MX0m')
            var style_default = /*#__PURE__*/ __webpack_require__.n(style)

            // EXTERNAL MODULE: ./node_modules/react/index.js
            var react = __webpack_require__('q1tI')
            var react_default = /*#__PURE__*/ __webpack_require__.n(react)

            // EXTERNAL MODULE: ./src/context/index.tsx + 2 modules
            var context = __webpack_require__('2ZRA')

            // CONCATENATED MODULE: ./src/components/ItemForm/ItemForm.tsx

            var __jsx = react['createElement']

            const ItemForm = react['memo'](() => {
                const [shoppingItem, setShoppingItem] = react['useState']('')
                const { addItem } = react['useContext'](
                    context['a' /* ShoppingItemContext */]
                )

                const onSubmit = e => {
                    e.preventDefault()

                    if (!shoppingItem.length) {
                        return
                    }

                    setShoppingItem('')
                    addItem(shoppingItem)
                }

                return __jsx(
                    'form',
                    {
                        onSubmit: onSubmit,
                        className: 'jsx-3724366064'
                    },
                    __jsx(
                        'fieldset',
                        {
                            className: 'jsx-3724366064'
                        },
                        __jsx(
                            'label',
                            {
                                htmlFor: 'shoppingItem',
                                className: 'jsx-3724366064'
                            },
                            __jsx('input', {
                                id: 'shoppingItem',
                                value: shoppingItem,
                                onChange: e => setShoppingItem(e.target.value),
                                className: 'jsx-3724366064'
                            })
                        ),
                        __jsx(
                            'button',
                            {
                                id: 'shoppingSubmit',
                                type: 'submit',
                                className: 'jsx-3724366064'
                            },
                            'Submit'
                        )
                    ),
                    __jsx(
                        style_default.a,
                        {
                            id: '3724366064'
                        },
                        [
                            'fieldset.jsx-3724366064{border:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;margin:0;padding:0;}',
                            'label.jsx-3724366064{width:100%;}',
                            '#shoppingItem.jsx-3724366064{border-radius:10px;border:none;border:solid 1px #ccc;font-size:16px;height:25px;text-indent:10px;width:95%;}',
                            '#shoppingSubmit.jsx-3724366064{background-color:#63b3ed;border-radius:10px;border:none;border:solid 1px #ccc;color:#fff;padding:5px;width:20%;}',
                            '#shoppingSubmit.jsx-3724366064:hover{cursor:pointer;}'
                        ]
                    )
                )
            })
            // CONCATENATED MODULE: ./src/components/ItemList/Item/Item.tsx

            var Item_jsx = react['createElement']

            const Item = react['memo'](({ id, name, isPurchased }) => {
                const { deleteItem, editItem } = react['useContext'](
                    context['a' /* ShoppingItemContext */]
                )
                const crossedThrough = isPurchased ? 'checked' : ''
                return Item_jsx(
                    'li',
                    {
                        key: id,
                        className: 'jsx-3496037733'
                    },
                    Item_jsx(
                        'span',
                        {
                            className: 'jsx-3496037733' + ' ' + 'listContainter'
                        },
                        Item_jsx(
                            'span',
                            {
                                onClick: () => editItem(id),
                                className:
                                    'jsx-3496037733' +
                                    ' ' +
                                    `listTitle ${crossedThrough}`
                            },
                            name
                        ),
                        Item_jsx(
                            'button',
                            {
                                onClick: () => deleteItem(id),
                                className:
                                    'jsx-3496037733' + ' ' + 'listDeleteButton'
                            },
                            'X'
                        )
                    ),
                    Item_jsx(
                        style_default.a,
                        {
                            id: '3496037733'
                        },
                        [
                            '.checked.jsx-3496037733{-webkit-text-decoration:line-through;text-decoration:line-through;}',
                            '.listContainter.jsx-3496037733{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}',
                            '.listTitle.jsx-3496037733{font-size:20px;padding-left:5px;width:100%;}',
                            '.listDeleteButton.jsx-3496037733{border:none;background-color:#fff;font-size:14px;}',
                            'li.jsx-3496037733{list-style-type:none;padding:5px 0;width:100%;}',
                            '.listDeleteButton.jsx-3496037733:hover,li.jsx-3496037733:hover{cursor:pointer;}'
                        ]
                    )
                )
            })
            // CONCATENATED MODULE: ./src/components/ItemList/ItemList.tsx

            var ItemList_jsx = react['createElement']

            const ItemList = react['memo'](() => {
                const { items } = react['useContext'](
                    context['a' /* ShoppingItemContext */]
                )
                return (
                    items &&
                    ItemList_jsx(
                        'ul',
                        {
                            className: 'jsx-3182170991'
                        },
                        items.map(({ id, name, isPurchased }) =>
                            ItemList_jsx(Item, {
                                id: id,
                                name: name,
                                isPurchased: isPurchased
                            })
                        ),
                        ItemList_jsx(
                            style_default.a,
                            {
                                id: '3182170991'
                            },
                            ['ul.jsx-3182170991{padding:0;}']
                        )
                    )
                )
            })
            // EXTERNAL MODULE: ./node_modules/next/dist/next-server/lib/head.js
            var head = __webpack_require__('8Kt/')
            var head_default = /*#__PURE__*/ __webpack_require__.n(head)

            // EXTERNAL MODULE: ./node_modules/next/link.js
            var next_link = __webpack_require__('YFqc')
            var link_default = /*#__PURE__*/ __webpack_require__.n(next_link)

            // CONCATENATED MODULE: ./src/components/Nav/Nav.tsx

            var Nav_jsx = react['createElement']

            const Nav = () =>
                Nav_jsx(
                    'header',
                    {
                        className: 'jsx-3945473033'
                    },
                    Nav_jsx(
                        'nav',
                        {
                            className: 'jsx-3945473033'
                        },
                        Nav_jsx(
                            'ul',
                            {
                                className: 'jsx-3945473033'
                            },
                            Nav_jsx(
                                'li',
                                {
                                    className: 'jsx-3945473033'
                                },
                                Nav_jsx(
                                    link_default.a,
                                    {
                                        href: '/'
                                    },
                                    Nav_jsx(
                                        'a',
                                        {
                                            className: 'jsx-3945473033'
                                        },
                                        'Home'
                                    )
                                )
                            ),
                            Nav_jsx(
                                'li',
                                {
                                    className: 'jsx-3945473033'
                                },
                                Nav_jsx(
                                    link_default.a,
                                    {
                                        href: '/about'
                                    },
                                    Nav_jsx(
                                        'a',
                                        {
                                            className: 'jsx-3945473033'
                                        },
                                        'About'
                                    )
                                )
                            ),
                            Nav_jsx(
                                'li',
                                {
                                    className: 'jsx-3945473033'
                                },
                                Nav_jsx(
                                    link_default.a,
                                    {
                                        href: '/api/auth/login'
                                    },
                                    Nav_jsx(
                                        'a',
                                        {
                                            className: 'jsx-3945473033'
                                        },
                                        'Login'
                                    )
                                )
                            ),
                            Nav_jsx(
                                'li',
                                {
                                    className: 'jsx-3945473033'
                                },
                                Nav_jsx(
                                    link_default.a,
                                    {
                                        href: '/api/auth/logout'
                                    },
                                    Nav_jsx(
                                        'a',
                                        {
                                            className: 'jsx-3945473033'
                                        },
                                        'Logout'
                                    )
                                )
                            )
                        )
                    ),
                    Nav_jsx(
                        style_default.a,
                        {
                            id: '3945473033'
                        },
                        [
                            'header.jsx-3945473033{padding:0.2rem;color:#fff;background-color:#333;}',
                            'nav.jsx-3945473033{max-width:42rem;margin:1.5rem auto;}',
                            'ul.jsx-3945473033{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;list-style:none;margin-left:0;padding-left:0;}',
                            'li.jsx-3945473033{margin-right:1rem;}',
                            'li.jsx-3945473033:nth-child(2){margin-right:auto;}',
                            'a.jsx-3945473033{color:#fff;-webkit-text-decoration:none;text-decoration:none;}',
                            'button.jsx-3945473033{font-size:1rem;color:#fff;cursor:pointer;border:none;background:none;}'
                        ]
                    )
                )

            /* harmony default export */ var Nav_Nav = Nav
            // CONCATENATED MODULE: ./src/components/Layout/Layout.tsx

            var Layout_jsx = react_default.a.createElement

            const Layout = Object(react['memo'])(({ children }) =>
                Layout_jsx(
                    'div',
                    {
                        className: 'jsx-4125104203'
                    },
                    Layout_jsx(
                        head_default.a,
                        null,
                        Layout_jsx(
                            'title',
                            {
                                className: 'jsx-4125104203'
                            },
                            'Shopping List'
                        ),
                        Layout_jsx('link', {
                            rel: 'icon',
                            href: '/favicon.ico',
                            className: 'jsx-4125104203'
                        })
                    ),
                    Layout_jsx(Nav_Nav, null),
                    Layout_jsx(
                        'main',
                        {
                            className: 'jsx-4125104203'
                        },
                        children
                    ),
                    Layout_jsx(
                        style_default.a,
                        {
                            id: '4125104203'
                        },
                        ['body{padding:0;margin:0;}']
                    )
                )
            )
            // CONCATENATED MODULE: ./src/components/index.tsx
            /* concated harmony reexport ItemForm */ __webpack_require__.d(
                __webpack_exports__,
                'a',
                function() {
                    return ItemForm
                }
            )
            /* concated harmony reexport ItemList */ __webpack_require__.d(
                __webpack_exports__,
                'b',
                function() {
                    return ItemList
                }
            )
            /* concated harmony reexport Layout */ __webpack_require__.d(
                __webpack_exports__,
                'c',
                function() {
                    return Layout
                }
            )

            /***/
        },

        /***/ '7fqy': /***/ function(module, exports) {
            /**
             * Converts `map` to its key-value pairs.
             *
             * @private
             * @param {Object} map The map to convert.
             * @returns {Array} Returns the key-value pairs.
             */
            function mapToArray(map) {
                var index = -1,
                    result = Array(map.size)

                map.forEach(function(value, key) {
                    result[++index] = [key, value]
                })
                return result
            }

            module.exports = mapToArray

            /***/
        },

        /***/ '7m0m': /***/ function(module, exports, __webpack_require__) {
            // https://github.com/tc39/proposal-object-getownpropertydescriptors
            var $export = __webpack_require__('Y7ZC')
            var ownKeys = __webpack_require__('uplh')
            var toIObject = __webpack_require__('NsO/')
            var gOPD = __webpack_require__('vwuL')
            var createProperty = __webpack_require__('IP1Z')

            $export($export.S, 'Object', {
                getOwnPropertyDescriptors: function getOwnPropertyDescriptors(
                    object
                ) {
                    var O = toIObject(object)
                    var getDesc = gOPD.f
                    var keys = ownKeys(O)
                    var result = {}
                    var i = 0
                    var key, desc
                    while (keys.length > i) {
                        desc = getDesc(O, (key = keys[i++]))
                        if (desc !== undefined)
                            createProperty(result, key, desc)
                    }
                    return result
                }
            })

            /***/
        },

        /***/ '7o4N': /***/ function(module, exports, __webpack_require__) {
            const base64url = __webpack_require__('Xab3')
            const errors = __webpack_require__('yt7c')

            module.exports = (token, { complete = false } = {}) => {
                if (typeof token !== 'string' || !token) {
                    throw new TypeError('JWT must be a string')
                }

                const {
                    0: header,
                    1: payload,
                    2: signature,
                    length
                } = token.split('.')

                if (length === 5) {
                    throw new TypeError('JWTs must be decrypted first')
                }

                if (length !== 3) {
                    throw new errors.JWTMalformed(
                        'JWTs must have three components'
                    )
                }

                try {
                    const result = {
                        header: base64url.JSON.decode(header),
                        payload: base64url.JSON.decode(payload),
                        signature
                    }

                    return complete ? result : result.payload
                } catch (err) {
                    throw new errors.JWTMalformed('JWT is malformed')
                }
            }

            /***/
        },

        /***/ '88Gu': /***/ function(module, exports) {
            /** Used to detect hot functions by number of calls within a span of milliseconds. */
            var HOT_COUNT = 800,
                HOT_SPAN = 16

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeNow = Date.now

            /**
             * Creates a function that'll short out and invoke `identity` instead
             * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
             * milliseconds.
             *
             * @private
             * @param {Function} func The function to restrict.
             * @returns {Function} Returns the new shortable function.
             */
            function shortOut(func) {
                var count = 0,
                    lastCalled = 0

                return function() {
                    var stamp = nativeNow(),
                        remaining = HOT_SPAN - (stamp - lastCalled)

                    lastCalled = stamp
                    if (remaining > 0) {
                        if (++count >= HOT_COUNT) {
                            return arguments[0]
                        }
                    } else {
                        count = 0
                    }
                    return func.apply(undefined, arguments)
                }
            }

            module.exports = shortOut

            /***/
        },

        /***/ '8C61': /***/ function(module, exports) {
            module.exports = require('@ampproject/toolbox-optimizer')

            /***/
        },

        /***/ '8Kt/': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Set = __webpack_require__('ttDY')

            var _Object$defineProperty = __webpack_require__('hfKm')

            var __importDefault =
                (this && this.__importDefault) ||
                function(mod) {
                    return mod && mod.__esModule
                        ? mod
                        : {
                              default: mod
                          }
                }

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            const react_1 = __importDefault(__webpack_require__('q1tI'))

            const side_effect_1 = __importDefault(__webpack_require__('Xuae'))

            const amp_context_1 = __webpack_require__('lwAK')

            const head_manager_context_1 = __webpack_require__('FYa8')

            const amp_1 = __webpack_require__('/0+H')

            function defaultHead(inAmpMode = false) {
                const head = [
                    react_1.default.createElement('meta', {
                        key: 'charSet',
                        charSet: 'utf-8'
                    })
                ]

                if (!inAmpMode) {
                    head.push(
                        react_1.default.createElement('meta', {
                            key: 'viewport',
                            name: 'viewport',
                            content:
                                'width=device-width,minimum-scale=1,initial-scale=1'
                        })
                    )
                }

                return head
            }

            exports.defaultHead = defaultHead

            function onlyReactElement(list, child) {
                // React children can be "string" or "number" in this case we ignore them for backwards compat
                if (typeof child === 'string' || typeof child === 'number') {
                    return list
                } // Adds support for React.Fragment

                if (child.type === react_1.default.Fragment) {
                    return list.concat(
                        react_1.default.Children.toArray(
                            child.props.children
                        ).reduce((fragmentList, fragmentChild) => {
                            if (
                                typeof fragmentChild === 'string' ||
                                typeof fragmentChild === 'number'
                            ) {
                                return fragmentList
                            }

                            return fragmentList.concat(fragmentChild)
                        }, [])
                    )
                }

                return list.concat(child)
            }

            const METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp']
            /*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>
 Also adds support for deduplicated `key` properties
*/

            function unique() {
                const keys = new _Set()
                const tags = new _Set()
                const metaTypes = new _Set()
                const metaCategories = {}
                return h => {
                    if (
                        h.key &&
                        typeof h.key !== 'number' &&
                        h.key.indexOf('.$') === 0
                    ) {
                        if (keys.has(h.key)) return false
                        keys.add(h.key)
                        return true
                    } // If custom meta tag has been added the key will be prepended with `.$`, we can
                    // check for this and dedupe in favor of the custom one, so the default
                    // is not rendered as well

                    if (keys.has(`.$${h.key}`)) return false // eslint-disable-next-line default-case

                    switch (h.type) {
                        case 'title':
                        case 'base':
                            if (tags.has(h.type)) return false
                            tags.add(h.type)
                            break

                        case 'meta':
                            for (
                                let i = 0, len = METATYPES.length;
                                i < len;
                                i++
                            ) {
                                const metatype = METATYPES[i]
                                if (!h.props.hasOwnProperty(metatype)) continue

                                if (metatype === 'charSet') {
                                    if (metaTypes.has(metatype)) return false
                                    metaTypes.add(metatype)
                                } else {
                                    const category = h.props[metatype]
                                    const categories =
                                        metaCategories[metatype] || new _Set()
                                    if (categories.has(category)) return false
                                    categories.add(category)
                                    metaCategories[metatype] = categories
                                }
                            }

                            break
                    }

                    return true
                }
            }
            /**
             *
             * @param headElement List of multiple <Head> instances
             */

            function reduceComponents(headElements, props) {
                return headElements
                    .reduce((list, headElement) => {
                        const headElementChildren = react_1.default.Children.toArray(
                            headElement.props.children
                        )
                        return list.concat(headElementChildren)
                    }, [])
                    .reduce(onlyReactElement, [])
                    .reverse()
                    .concat(defaultHead(props.inAmpMode))
                    .filter(unique())
                    .reverse()
                    .map((c, i) => {
                        const key = c.key || i
                        return react_1.default.cloneElement(c, {
                            key
                        })
                    })
            }

            const Effect = side_effect_1.default()
            /**
             * This component injects elements to `<head>` of your page.
             * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
             */

            function Head({ children }) {
                return react_1.default.createElement(
                    amp_context_1.AmpStateContext.Consumer,
                    null,
                    ampState =>
                        react_1.default.createElement(
                            head_manager_context_1.HeadManagerContext.Consumer,
                            null,
                            updateHead =>
                                react_1.default.createElement(
                                    Effect,
                                    {
                                        reduceComponentsToState: reduceComponents,
                                        handleStateChange: updateHead,
                                        inAmpMode: amp_1.isInAmpMode(ampState)
                                    },
                                    children
                                )
                        )
                )
            }

            Head.rewind = Effect.rewind
            exports.default = Head

            /***/
        },

        /***/ '8L3h': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            if (true) {
                module.exports = __webpack_require__('f/k9')
            } else {
            }

            /***/
        },

        /***/ '8gHz': /***/ function(module, exports, __webpack_require__) {
            // 7.3.20 SpeciesConstructor(O, defaultConstructor)
            var anObject = __webpack_require__('5K7Z')
            var aFunction = __webpack_require__('eaoh')
            var SPECIES = __webpack_require__('UWiX')('species')
            module.exports = function(O, D) {
                var C = anObject(O).constructor
                var S
                return C === undefined ||
                    (S = anObject(C)[SPECIES]) == undefined
                    ? D
                    : aFunction(S)
            }

            /***/
        },

        /***/ '8iia': /***/ function(module, exports, __webpack_require__) {
            // https://github.com/DavidBruant/Map-Set.prototype.toJSON
            var classof = __webpack_require__('QMMT')
            var from = __webpack_require__('RRc/')
            module.exports = function(NAME) {
                return function toJSON() {
                    if (classof(this) != NAME)
                        throw TypeError(NAME + "#toJSON isn't generic")
                    return from(this)
                }
            }

            /***/
        },

        /***/ '8xkj': /***/ function(module, exports) {
            module.exports = require('querystring')

            /***/
        },

        /***/ '93I4': /***/ function(module, exports) {
            module.exports = function(it) {
                return typeof it === 'object'
                    ? it !== null
                    : typeof it === 'function'
            }

            /***/
        },

        /***/ '9AeD': /***/ function(module, exports, __webpack_require__) {
            const Encrypt = __webpack_require__('/hdj')
            const decrypt = __webpack_require__('33Iv')

            // TODO: in v2.x swap unprotectedHeader and aad
            const single = (
                serialization,
                cleartext,
                key,
                protectedHeader,
                unprotectedHeader,
                aad
            ) => {
                return new Encrypt(
                    cleartext,
                    protectedHeader,
                    unprotectedHeader,
                    aad
                )
                    .recipient(key)
                    .encrypt(serialization)
            }

            module.exports.Encrypt = Encrypt
            module.exports.encrypt = single.bind(undefined, 'compact')
            module.exports.encrypt.flattened = single.bind(
                undefined,
                'flattened'
            )
            module.exports.encrypt.general = single.bind(undefined, 'general')

            module.exports.decrypt = decrypt

            /***/
        },

        /***/ '9BDd': /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('GvbO')
            module.exports = __webpack_require__('WEpk').Array.isArray

            /***/
        },

        /***/ '9Fi5': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const urlLib = __webpack_require__('bzos')
            const http = __webpack_require__('KEll')
            const PCancelable = __webpack_require__('Qxd3')
            const is = __webpack_require__('6mOv')

            class GotError extends Error {
                constructor(message, error, options) {
                    super(message)
                    Error.captureStackTrace(this, this.constructor)
                    this.name = 'GotError'

                    if (!is.undefined(error.code)) {
                        this.code = error.code
                    }

                    Object.assign(this, {
                        host: options.host,
                        hostname: options.hostname,
                        method: options.method,
                        path: options.path,
                        socketPath: options.socketPath,
                        protocol: options.protocol,
                        url: options.href,
                        gotOptions: options
                    })
                }
            }

            module.exports.GotError = GotError

            module.exports.CacheError = class extends GotError {
                constructor(error, options) {
                    super(error.message, error, options)
                    this.name = 'CacheError'
                }
            }

            module.exports.RequestError = class extends GotError {
                constructor(error, options) {
                    super(error.message, error, options)
                    this.name = 'RequestError'
                }
            }

            module.exports.ReadError = class extends GotError {
                constructor(error, options) {
                    super(error.message, error, options)
                    this.name = 'ReadError'
                }
            }

            module.exports.ParseError = class extends GotError {
                constructor(error, statusCode, options, data) {
                    super(
                        `${error.message} in "${urlLib.format(
                            options
                        )}": \n${data.slice(0, 77)}...`,
                        error,
                        options
                    )
                    this.name = 'ParseError'
                    this.statusCode = statusCode
                    this.statusMessage = http.STATUS_CODES[this.statusCode]
                }
            }

            module.exports.HTTPError = class extends GotError {
                constructor(response, options) {
                    const { statusCode } = response
                    let { statusMessage } = response

                    if (statusMessage) {
                        statusMessage = statusMessage
                            .replace(/\r?\n/g, ' ')
                            .trim()
                    } else {
                        statusMessage = http.STATUS_CODES[statusCode]
                    }

                    super(
                        `Response code ${statusCode} (${statusMessage})`,
                        {},
                        options
                    )
                    this.name = 'HTTPError'
                    this.statusCode = statusCode
                    this.statusMessage = statusMessage
                    this.headers = response.headers
                    this.body = response.body
                }
            }

            module.exports.MaxRedirectsError = class extends GotError {
                constructor(statusCode, redirectUrls, options) {
                    super('Redirected 10 times. Aborting.', {}, options)
                    this.name = 'MaxRedirectsError'
                    this.statusCode = statusCode
                    this.statusMessage = http.STATUS_CODES[this.statusCode]
                    this.redirectUrls = redirectUrls
                }
            }

            module.exports.UnsupportedProtocolError = class extends GotError {
                constructor(options) {
                    super(
                        `Unsupported protocol "${options.protocol}"`,
                        {},
                        options
                    )
                    this.name = 'UnsupportedProtocolError'
                }
            }

            module.exports.TimeoutError = class extends GotError {
                constructor(error, options) {
                    super(error.message, { code: 'ETIMEDOUT' }, options)
                    this.name = 'TimeoutError'
                    this.event = error.event
                }
            }

            module.exports.CancelError = PCancelable.CancelError

            /***/
        },

        /***/ '9Jkg': /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('oh+g')

            /***/
        },

        /***/ '9Nap': /***/ function(module, exports, __webpack_require__) {
            var isSymbol = __webpack_require__('/9aa')

            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0

            /**
             * Converts `value` to a string key if it's not a string or symbol.
             *
             * @private
             * @param {*} value The value to inspect.
             * @returns {string|symbol} Returns the key.
             */
            function toKey(value) {
                if (typeof value == 'string' || isSymbol(value)) {
                    return value
                }
                var result = value + ''
                return result == '0' && 1 / value == -INFINITY ? '-0' : result
            }

            module.exports = toKey

            /***/
        },

        /***/ '9YuQ': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            function requireAuthentication(sessionStore) {
                return apiRoute => (req, res) =>
                    tslib_1.__awaiter(this, void 0, void 0, function*() {
                        if (!req) {
                            throw new Error('Request is not available')
                        }
                        if (!res) {
                            throw new Error('Response is not available')
                        }
                        const session = yield sessionStore.read(req)
                        if (!session || !session.user) {
                            res.status(401).json({
                                error: 'not_authenticated',
                                description:
                                    'The user does not have an active session or is not authenticated'
                            })
                            return
                        }
                        yield apiRoute(req, res)
                    })
            }
            exports.default = requireAuthentication
            //# sourceMappingURL=require-authentication.js.map

            /***/
        },

        /***/ '9ggG': /***/ function(module, exports, __webpack_require__) {
            var isArray = __webpack_require__('Z0cm'),
                isSymbol = __webpack_require__('/9aa')

            /** Used to match property names within property paths. */
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                reIsPlainProp = /^\w*$/

            /**
             * Checks if `value` is a property name and not a property path.
             *
             * @private
             * @param {*} value The value to check.
             * @param {Object} [object] The object to query keys on.
             * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
             */
            function isKey(value, object) {
                if (isArray(value)) {
                    return false
                }
                var type = typeof value
                if (
                    type == 'number' ||
                    type == 'symbol' ||
                    type == 'boolean' ||
                    value == null ||
                    isSymbol(value)
                ) {
                    return true
                }
                return (
                    reIsPlainProp.test(value) ||
                    !reIsDeepProp.test(value) ||
                    (object != null && value in Object(object))
                )
            }

            module.exports = isKey

            /***/
        },

        /***/ '9kyW': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            function hash(str) {
                var hash = 5381,
                    i = str.length

                while (i) {
                    hash = (hash * 33) ^ str.charCodeAt(--i)
                }

                /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
                 * integers. Since we want the results to be always positive, convert the
                 * signed int to an unsigned by doing an unsigned bitshift. */
                return hash >>> 0
            }

            module.exports = hash

            /***/
        },

        /***/ '9l6Z': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const url = __webpack_require__('bzos')
            const prependHttp = __webpack_require__('Tqu4')

            module.exports = (input, options) => {
                if (typeof input !== 'string') {
                    throw new TypeError(
                        `Expected \`url\` to be of type \`string\`, got \`${typeof input}\` instead.`
                    )
                }

                const finalUrl = prependHttp(
                    input,
                    Object.assign({ https: true }, options)
                )
                return url.parse(finalUrl)
            }

            /***/
        },

        /***/ '9ny7': /***/ function(module, exports, __webpack_require__) {
            const { define } = __webpack_require__('jUDV')
            const base = __webpack_require__('VZIC')
            const constants = __webpack_require__('h+i2')
            const decoders = __webpack_require__('zspo')
            const encoders = __webpack_require__('E8LI')

            module.exports = {
                base,
                constants,
                decoders,
                define,
                encoders
            }

            /***/
        },

        /***/ '9rSQ': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')

            function InterceptorManager() {
                this.handlers = []
            }

            /**
             * Add a new interceptor to the stack
             *
             * @param {Function} fulfilled The function to handle `then` for a `Promise`
             * @param {Function} rejected The function to handle `reject` for a `Promise`
             *
             * @return {Number} An ID used to remove interceptor later
             */
            InterceptorManager.prototype.use = function use(
                fulfilled,
                rejected
            ) {
                this.handlers.push({
                    fulfilled: fulfilled,
                    rejected: rejected
                })
                return this.handlers.length - 1
            }

            /**
             * Remove an interceptor from the stack
             *
             * @param {Number} id The ID that was returned by `use`
             */
            InterceptorManager.prototype.eject = function eject(id) {
                if (this.handlers[id]) {
                    this.handlers[id] = null
                }
            }

            /**
             * Iterate over all the registered interceptors
             *
             * This method is particularly useful for skipping over any
             * interceptors that may have become `null` calling `eject`.
             *
             * @param {Function} fn The function to call for each interceptor
             */
            InterceptorManager.prototype.forEach = function forEach(fn) {
                utils.forEach(this.handlers, function forEachHandler(h) {
                    if (h !== null) {
                        fn(h)
                    }
                })
            }

            module.exports = InterceptorManager

            /***/
        },

        /***/ '9rVn': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const os = __webpack_require__('jle/')

            const extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/
            const pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/
            const homeDir =
                typeof os.homedir === 'undefined' ? '' : os.homedir()

            module.exports = (stack, options) => {
                options = Object.assign({ pretty: false }, options)

                return stack
                    .replace(/\\/g, '/')
                    .split('\n')
                    .filter(line => {
                        const pathMatches = line.match(extractPathRegex)
                        if (pathMatches === null || !pathMatches[1]) {
                            return true
                        }

                        const match = pathMatches[1]

                        // Electron
                        if (
                            match.includes(
                                '.app/Contents/Resources/electron.asar'
                            ) ||
                            match.includes(
                                '.app/Contents/Resources/default_app.asar'
                            )
                        ) {
                            return false
                        }

                        return !pathRegex.test(match)
                    })
                    .filter(line => line.trim() !== '')
                    .map(line => {
                        if (options.pretty) {
                            return line.replace(extractPathRegex, (m, p1) =>
                                m.replace(p1, p1.replace(homeDir, '~'))
                            )
                        }

                        return line
                    })
                    .join('\n')
            }

            /***/
        },

        /***/ A5Xg: /***/ function(module, exports, __webpack_require__) {
            // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
            var toIObject = __webpack_require__('NsO/')
            var gOPN = __webpack_require__('ar/p').f
            var toString = {}.toString

            var windowNames =
                typeof window == 'object' &&
                window &&
                Object.getOwnPropertyNames
                    ? Object.getOwnPropertyNames(window)
                    : []

            var getWindowNames = function(it) {
                try {
                    return gOPN(it)
                } catch (e) {
                    return windowNames.slice()
                }
            }

            module.exports.f = function getOwnPropertyNames(it) {
                return windowNames && toString.call(it) == '[object Window]'
                    ? getWindowNames(it)
                    : gOPN(toIObject(it))
            }

            /***/
        },

        /***/ A90E: /***/ function(module, exports, __webpack_require__) {
            var isPrototype = __webpack_require__('6sVZ'),
                nativeKeys = __webpack_require__('V6Ve')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             */
            function baseKeys(object) {
                if (!isPrototype(object)) {
                    return nativeKeys(object)
                }
                var result = []
                for (var key in Object(object)) {
                    if (
                        hasOwnProperty.call(object, key) &&
                        key != 'constructor'
                    ) {
                        result.push(key)
                    }
                }
                return result
            }

            module.exports = baseKeys

            /***/
        },

        /***/ A93I: /***/ function(module, exports, __webpack_require__) {
            /* eslint-disable max-classes-per-file */

            const { inspect, deprecate } = __webpack_require__('jK02')
            const url = __webpack_require__('bzos')

            const jose = __webpack_require__('xZSz')
            const pAny = __webpack_require__('lN8I')
            const LRU = __webpack_require__('HyWp')
            const objectHash = __webpack_require__('RIp3')

            const { RPError } = __webpack_require__('L71r')
            const getClient = __webpack_require__('HrFp')
            const registry = __webpack_require__('0Aai')
            const processResponse = __webpack_require__('WeJA')
            const webfingerNormalize = __webpack_require__('HpSD')
            const instance = __webpack_require__('0pkK')
            const request = __webpack_require__('UwMm')
            const { assertIssuerConfiguration } = __webpack_require__('N+si')
            const {
                ISSUER_DEFAULTS,
                OIDC_DISCOVERY,
                OAUTH2_DISCOVERY,
                WEBFINGER,
                REL,
                AAD_MULTITENANT_DISCOVERY
            } = __webpack_require__('TJm8')

            const AAD_MULTITENANT = Symbol('AAD_MULTITENANT')

            class Issuer {
                /**
                 * @name constructor
                 * @api public
                 */
                constructor(meta = {}) {
                    const aadIssValidation = meta[AAD_MULTITENANT]
                    delete meta[AAD_MULTITENANT]

                    ;['introspection', 'revocation'].forEach(endpoint => {
                        // if intro/revocation endpoint auth specific meta is missing use the token ones if they
                        // are defined
                        if (
                            meta[`${endpoint}_endpoint`] &&
                            meta[
                                `${endpoint}_endpoint_auth_methods_supported`
                            ] === undefined &&
                            meta[
                                `${endpoint}_endpoint_auth_signing_alg_values_supported`
                            ] === undefined
                        ) {
                            if (meta.token_endpoint_auth_methods_supported) {
                                meta[
                                    `${endpoint}_endpoint_auth_methods_supported`
                                ] = meta.token_endpoint_auth_methods_supported
                            }
                            if (
                                meta.token_endpoint_auth_signing_alg_values_supported
                            ) {
                                meta[
                                    `${endpoint}_endpoint_auth_signing_alg_values_supported`
                                ] =
                                    meta.token_endpoint_auth_signing_alg_values_supported
                            }
                        }
                    })

                    Object.entries(meta).forEach(([key, value]) => {
                        instance(this)
                            .get('metadata')
                            .set(key, value)
                        if (!this[key]) {
                            Object.defineProperty(this, key, {
                                get() {
                                    return instance(this)
                                        .get('metadata')
                                        .get(key)
                                },
                                enumerable: true
                            })
                        }
                    })

                    instance(this).set('cache', new LRU({ max: 100 }))

                    registry.set(this.issuer, this)

                    Object.defineProperty(this, 'Client', {
                        value: getClient(this, aadIssValidation)
                    })

                    Object.defineProperty(this, 'FAPIClient', {
                        value: class FAPIClient extends this.Client {}
                    })
                }

                /**
                 * @name keystore
                 * @api public
                 */
                async keystore(reload = false) {
                    assertIssuerConfiguration(this, 'jwks_uri')

                    const keystore = instance(this).get('keystore')
                    const cache = instance(this).get('cache')

                    if (reload || !keystore) {
                        cache.reset()
                        const response = await request.call(this, {
                            method: 'GET',
                            json: true,
                            url: this.jwks_uri
                        })
                        const jwks = processResponse(response)

                        const joseKeyStore = jose.JWKS.asKeyStore(jwks, {
                            ignoreErrors: true
                        })
                        cache.set('throttle', true, 60 * 1000)
                        instance(this).set('keystore', joseKeyStore)
                        return joseKeyStore
                    }

                    return keystore
                }

                /**
                 * @name queryKeyStore
                 * @api private
                 */
                async queryKeyStore(
                    { kid, kty, alg, use, key_ops: ops },
                    { allowMulti = false } = {}
                ) {
                    const cache = instance(this).get('cache')

                    const def = {
                        kid,
                        kty,
                        alg,
                        use,
                        key_ops: ops
                    }

                    const defHash = objectHash(def, {
                        algorithm: 'sha256',
                        ignoreUnknown: true,
                        unorderedArrays: true,
                        unorderedSets: true
                    })

                    // refresh keystore on every unknown key but also only upto once every minute
                    const freshJwksUri =
                        cache.get(defHash) || cache.get('throttle')

                    const keystore = await this.keystore(!freshJwksUri)
                    const keys = keystore.all(def)

                    if (keys.length === 0) {
                        throw new RPError({
                            printf: [
                                "no valid key found in issuer's jwks_uri for key parameters %j",
                                def
                            ],
                            jwks: keystore
                        })
                    }

                    if (!allowMulti && keys.length > 1 && !kid) {
                        throw new RPError({
                            printf: [
                                "multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case",
                                def
                            ],
                            jwks: keystore
                        })
                    }

                    cache.set(defHash, true)

                    return new jose.JWKS.KeyStore(keys)
                }

                /**
                 * @name metadata
                 * @api public
                 */
                get metadata() {
                    const copy = {}
                    instance(this)
                        .get('metadata')
                        .forEach((value, key) => {
                            copy[key] = value
                        })
                    return copy
                }

                /**
                 * @name webfinger
                 * @api public
                 */
                static async webfinger(input) {
                    const resource = webfingerNormalize(input)
                    const { host } = url.parse(resource)
                    const webfingerUrl = `https://${host}${WEBFINGER}`

                    const response = await request.call(this, {
                        method: 'GET',
                        url: webfingerUrl,
                        json: true,
                        query: { resource, rel: REL },
                        followRedirect: true
                    })
                    const body = processResponse(response)

                    const location =
                        Array.isArray(body.links) &&
                        body.links.find(
                            link =>
                                typeof link === 'object' &&
                                link.rel === REL &&
                                link.href
                        )

                    if (!location) {
                        throw new RPError({
                            message: 'no issuer found in webfinger response',
                            body
                        })
                    }

                    if (
                        typeof location.href !== 'string' ||
                        !location.href.startsWith('https://')
                    ) {
                        throw new RPError({
                            printf: [
                                'invalid issuer location %s',
                                location.href
                            ],
                            body
                        })
                    }

                    const expectedIssuer = location.href
                    if (registry.has(expectedIssuer)) {
                        return registry.get(expectedIssuer)
                    }

                    const issuer = await this.discover(expectedIssuer)

                    if (issuer.issuer !== expectedIssuer) {
                        registry.delete(issuer.issuer)
                        throw new RPError(
                            'discovered issuer mismatch, expected %s, got: %s',
                            expectedIssuer,
                            issuer.issuer
                        )
                    }
                    return issuer
                }

                /**
                 * @name discover
                 * @api public
                 */
                static async discover(uri) {
                    const parsed = url.parse(uri)

                    if (parsed.pathname.includes('/.well-known/')) {
                        const response = await request.call(this, {
                            method: 'GET',
                            json: true,
                            url: uri
                        })
                        const body = processResponse(response)
                        return new Issuer({
                            ...ISSUER_DEFAULTS,
                            ...body,
                            [AAD_MULTITENANT]: AAD_MULTITENANT_DISCOVERY.has(
                                uri
                            )
                        })
                    }

                    const uris = []
                    if (parsed.pathname === '/') {
                        uris.push(`${OAUTH2_DISCOVERY}`)
                    } else {
                        uris.push(`${OAUTH2_DISCOVERY}${parsed.pathname}`)
                    }
                    if (parsed.pathname.endsWith('/')) {
                        uris.push(
                            `${parsed.pathname}${OIDC_DISCOVERY.substring(1)}`
                        )
                    } else {
                        uris.push(`${parsed.pathname}${OIDC_DISCOVERY}`)
                    }

                    return pAny(
                        uris.map(async pathname => {
                            const wellKnownUri = url.format({
                                ...parsed,
                                pathname
                            })
                            const response = await request.call(this, {
                                method: 'GET',
                                json: true,
                                url: wellKnownUri
                            })
                            const body = processResponse(response)
                            return new Issuer({
                                ...ISSUER_DEFAULTS,
                                ...body,
                                [AAD_MULTITENANT]: AAD_MULTITENANT_DISCOVERY.has(
                                    wellKnownUri
                                )
                            })
                        })
                    )
                }

                /* istanbul ignore next */
                [inspect.custom]() {
                    return `${this.constructor.name} ${inspect(this.metadata, {
                        depth: Infinity,
                        colors: process.stdout.isTTY,
                        compact: false,
                        sorted: true
                    })}`
                }
            }

            /**
             * @name key
             * @api private
             */
            Issuer.prototype.key = deprecate(async function key(
                { kid, kty, alg, use, key_ops: ops },
                allowMulti = false
            ) {
                const cache = instance(this).get('cache')

                const def = {
                    kid,
                    kty,
                    alg,
                    use,
                    key_ops: ops
                }

                const defHash = objectHash(def, {
                    algorithm: 'sha256',
                    ignoreUnknown: true,
                    unorderedArrays: true,
                    unorderedSets: true
                })

                // refresh keystore on every unknown key but also only upto once every minute
                const freshJwksUri = cache.get(defHash) || cache.get('throttle')

                const keystore = await this.keystore(!freshJwksUri)
                const keys = keystore.all(def)

                if (keys.length === 0) {
                    throw new RPError({
                        printf: [
                            "no valid key found in issuer's jwks_uri for key parameters %j",
                            def
                        ],
                        jwks: keystore
                    })
                }
                if (!allowMulti) {
                    if (keys.length !== 1) {
                        throw new RPError({
                            printf: [
                                "multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case",
                                def
                            ],
                            jwks: keystore
                        })
                    }
                    cache.set(defHash, true)
                }
                return keys[0]
            },
            'issuer.key is not only a private API, it is also deprecated')

            module.exports = Issuer

            /***/
        },

        /***/ AP2z: /***/ function(module, exports, __webpack_require__) {
            var Symbol = __webpack_require__('nmnc')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var nativeObjectToString = objectProto.toString

            /** Built-in value references. */
            var symToStringTag = Symbol ? Symbol.toStringTag : undefined

            /**
             * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
             *
             * @private
             * @param {*} value The value to query.
             * @returns {string} Returns the raw `toStringTag`.
             */
            function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag),
                    tag = value[symToStringTag]

                try {
                    value[symToStringTag] = undefined
                    var unmasked = true
                } catch (e) {}

                var result = nativeObjectToString.call(value)
                if (unmasked) {
                    if (isOwn) {
                        value[symToStringTag] = tag
                    } else {
                        delete value[symToStringTag]
                    }
                }
                return result
            }

            module.exports = getRawTag

            /***/
        },

        /***/ ARPQ: /***/ function(module, exports, __webpack_require__) {
            const isObject = __webpack_require__('kF1/')
            let validateCrit = __webpack_require__('urXW')

            const { JWEInvalid } = __webpack_require__('yt7c')

            validateCrit = validateCrit.bind(undefined, JWEInvalid)

            const compactSerializer = (final, [recipient]) => {
                return `${final.protected}.${recipient.encrypted_key}.${final.iv}.${final.ciphertext}.${final.tag}`
            }
            compactSerializer.validate = (
                protectedHeader,
                unprotectedHeader,
                aad,
                { 0: { header }, length }
            ) => {
                if (length !== 1 || aad || unprotectedHeader || header) {
                    throw new JWEInvalid(
                        "JWE Compact Serialization doesn't support multiple recipients, JWE unprotected headers or AAD"
                    )
                }
                validateCrit(
                    protectedHeader,
                    unprotectedHeader,
                    protectedHeader ? protectedHeader.crit : undefined
                )
            }

            const flattenedSerializer = (final, [recipient]) => {
                const { header, encrypted_key: encryptedKey } = recipient

                return {
                    ...(final.protected
                        ? { protected: final.protected }
                        : undefined),
                    ...(final.unprotected
                        ? { unprotected: final.unprotected }
                        : undefined),
                    ...(header ? { header } : undefined),
                    ...(encryptedKey
                        ? { encrypted_key: encryptedKey }
                        : undefined),
                    ...(final.aad ? { aad: final.aad } : undefined),
                    iv: final.iv,
                    ciphertext: final.ciphertext,
                    tag: final.tag
                }
            }
            flattenedSerializer.validate = (
                protectedHeader,
                unprotectedHeader,
                aad,
                { 0: { header }, length }
            ) => {
                if (length !== 1) {
                    throw new JWEInvalid(
                        "Flattened JWE JSON Serialization doesn't support multiple recipients"
                    )
                }
                validateCrit(
                    protectedHeader,
                    { ...unprotectedHeader, ...header },
                    protectedHeader ? protectedHeader.crit : undefined
                )
            }

            const generalSerializer = (final, recipients) => {
                const result = {
                    ...(final.protected
                        ? { protected: final.protected }
                        : undefined),
                    ...(final.unprotected
                        ? { unprotected: final.unprotected }
                        : undefined),
                    recipients: recipients
                        .map(
                            ({
                                header,
                                encrypted_key: encryptedKey,
                                generatedHeader
                            }) => {
                                if (
                                    !header &&
                                    !encryptedKey &&
                                    !generatedHeader
                                ) {
                                    return false
                                }

                                return {
                                    ...(header || generatedHeader
                                        ? {
                                              header: {
                                                  ...header,
                                                  ...generatedHeader
                                              }
                                          }
                                        : undefined),
                                    ...(encryptedKey
                                        ? { encrypted_key: encryptedKey }
                                        : undefined)
                                }
                            }
                        )
                        .filter(Boolean),
                    ...(final.aad ? { aad: final.aad } : undefined),
                    iv: final.iv,
                    ciphertext: final.ciphertext,
                    tag: final.tag
                }

                if (!result.recipients.length) {
                    delete result.recipients
                }

                return result
            }
            generalSerializer.validate = (
                protectedHeader,
                unprotectedHeader,
                aad,
                recipients
            ) => {
                recipients.forEach(({ header }) => {
                    validateCrit(
                        protectedHeader,
                        { ...header, ...unprotectedHeader },
                        protectedHeader ? protectedHeader.crit : undefined
                    )
                })
            }

            const isJSON = input => {
                return (
                    isObject(input) &&
                    typeof input.ciphertext === 'string' &&
                    typeof input.iv === 'string' &&
                    typeof input.tag === 'string' &&
                    (input.unprotected === undefined ||
                        isObject(input.unprotected)) &&
                    (input.protected === undefined ||
                        typeof input.protected === 'string') &&
                    (input.aad === undefined || typeof input.aad === 'string')
                )
            }

            const isSingleRecipient = input => {
                return (
                    (input.encrypted_key === undefined ||
                        typeof input.encrypted_key === 'string') &&
                    (input.header === undefined || isObject(input.header))
                )
            }

            const isValidRecipient = recipient => {
                return (
                    isObject(recipient) &&
                    typeof recipient.encrypted_key === 'string' &&
                    (recipient.header === undefined ||
                        isObject(recipient.header))
                )
            }

            const isMultiRecipient = input => {
                if (
                    Array.isArray(input.recipients) &&
                    input.recipients.every(isValidRecipient)
                ) {
                    return true
                }

                return false
            }

            const detect = input => {
                if (
                    typeof input === 'string' &&
                    input.split('.').length === 5
                ) {
                    return 'compact'
                }

                if (isJSON(input)) {
                    if (isMultiRecipient(input)) {
                        return 'general'
                    }

                    if (isSingleRecipient(input)) {
                        return 'flattened'
                    }
                }

                throw new JWEInvalid('JWE malformed or invalid serialization')
            }

            module.exports = {
                compact: compactSerializer,
                flattened: flattenedSerializer,
                general: generalSerializer,
                detect
            }

            /***/
        },

        /***/ AUvm: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // ECMAScript 6 symbols shim
            var global = __webpack_require__('5T2Y')
            var has = __webpack_require__('B+OT')
            var DESCRIPTORS = __webpack_require__('jmDH')
            var $export = __webpack_require__('Y7ZC')
            var redefine = __webpack_require__('kTiW')
            var META = __webpack_require__('6/1s').KEY
            var $fails = __webpack_require__('KUxP')
            var shared = __webpack_require__('29s/')
            var setToStringTag = __webpack_require__('RfKB')
            var uid = __webpack_require__('YqAc')
            var wks = __webpack_require__('UWiX')
            var wksExt = __webpack_require__('zLkG')
            var wksDefine = __webpack_require__('Zxgi')
            var enumKeys = __webpack_require__('R+7+')
            var isArray = __webpack_require__('kAMH')
            var anObject = __webpack_require__('5K7Z')
            var isObject = __webpack_require__('93I4')
            var toObject = __webpack_require__('JB68')
            var toIObject = __webpack_require__('NsO/')
            var toPrimitive = __webpack_require__('G8Mo')
            var createDesc = __webpack_require__('rr1i')
            var _create = __webpack_require__('oVml')
            var gOPNExt = __webpack_require__('A5Xg')
            var $GOPD = __webpack_require__('vwuL')
            var $GOPS = __webpack_require__('mqlF')
            var $DP = __webpack_require__('2faE')
            var $keys = __webpack_require__('w6GO')
            var gOPD = $GOPD.f
            var dP = $DP.f
            var gOPN = gOPNExt.f
            var $Symbol = global.Symbol
            var $JSON = global.JSON
            var _stringify = $JSON && $JSON.stringify
            var PROTOTYPE = 'prototype'
            var HIDDEN = wks('_hidden')
            var TO_PRIMITIVE = wks('toPrimitive')
            var isEnum = {}.propertyIsEnumerable
            var SymbolRegistry = shared('symbol-registry')
            var AllSymbols = shared('symbols')
            var OPSymbols = shared('op-symbols')
            var ObjectProto = Object[PROTOTYPE]
            var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f
            var QObject = global.QObject
            // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
            var setter =
                !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild

            // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
            var setSymbolDesc =
                DESCRIPTORS &&
                $fails(function() {
                    return (
                        _create(
                            dP({}, 'a', {
                                get: function() {
                                    return dP(this, 'a', { value: 7 }).a
                                }
                            })
                        ).a != 7
                    )
                })
                    ? function(it, key, D) {
                          var protoDesc = gOPD(ObjectProto, key)
                          if (protoDesc) delete ObjectProto[key]
                          dP(it, key, D)
                          if (protoDesc && it !== ObjectProto)
                              dP(ObjectProto, key, protoDesc)
                      }
                    : dP

            var wrap = function(tag) {
                var sym = (AllSymbols[tag] = _create($Symbol[PROTOTYPE]))
                sym._k = tag
                return sym
            }

            var isSymbol =
                USE_NATIVE && typeof $Symbol.iterator == 'symbol'
                    ? function(it) {
                          return typeof it == 'symbol'
                      }
                    : function(it) {
                          return it instanceof $Symbol
                      }

            var $defineProperty = function defineProperty(it, key, D) {
                if (it === ObjectProto) $defineProperty(OPSymbols, key, D)
                anObject(it)
                key = toPrimitive(key, true)
                anObject(D)
                if (has(AllSymbols, key)) {
                    if (!D.enumerable) {
                        if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}))
                        it[HIDDEN][key] = true
                    } else {
                        if (has(it, HIDDEN) && it[HIDDEN][key])
                            it[HIDDEN][key] = false
                        D = _create(D, { enumerable: createDesc(0, false) })
                    }
                    return setSymbolDesc(it, key, D)
                }
                return dP(it, key, D)
            }
            var $defineProperties = function defineProperties(it, P) {
                anObject(it)
                var keys = enumKeys((P = toIObject(P)))
                var i = 0
                var l = keys.length
                var key
                while (l > i) $defineProperty(it, (key = keys[i++]), P[key])
                return it
            }
            var $create = function create(it, P) {
                return P === undefined
                    ? _create(it)
                    : $defineProperties(_create(it), P)
            }
            var $propertyIsEnumerable = function propertyIsEnumerable(key) {
                var E = isEnum.call(this, (key = toPrimitive(key, true)))
                if (
                    this === ObjectProto &&
                    has(AllSymbols, key) &&
                    !has(OPSymbols, key)
                )
                    return false
                return E ||
                    !has(this, key) ||
                    !has(AllSymbols, key) ||
                    (has(this, HIDDEN) && this[HIDDEN][key])
                    ? E
                    : true
            }
            var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(
                it,
                key
            ) {
                it = toIObject(it)
                key = toPrimitive(key, true)
                if (
                    it === ObjectProto &&
                    has(AllSymbols, key) &&
                    !has(OPSymbols, key)
                )
                    return
                var D = gOPD(it, key)
                if (
                    D &&
                    has(AllSymbols, key) &&
                    !(has(it, HIDDEN) && it[HIDDEN][key])
                )
                    D.enumerable = true
                return D
            }
            var $getOwnPropertyNames = function getOwnPropertyNames(it) {
                var names = gOPN(toIObject(it))
                var result = []
                var i = 0
                var key
                while (names.length > i) {
                    if (
                        !has(AllSymbols, (key = names[i++])) &&
                        key != HIDDEN &&
                        key != META
                    )
                        result.push(key)
                }
                return result
            }
            var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
                var IS_OP = it === ObjectProto
                var names = gOPN(IS_OP ? OPSymbols : toIObject(it))
                var result = []
                var i = 0
                var key
                while (names.length > i) {
                    if (
                        has(AllSymbols, (key = names[i++])) &&
                        (IS_OP ? has(ObjectProto, key) : true)
                    )
                        result.push(AllSymbols[key])
                }
                return result
            }

            // 19.4.1.1 Symbol([description])
            if (!USE_NATIVE) {
                $Symbol = function Symbol() {
                    if (this instanceof $Symbol)
                        throw TypeError('Symbol is not a constructor!')
                    var tag = uid(
                        arguments.length > 0 ? arguments[0] : undefined
                    )
                    var $set = function(value) {
                        if (this === ObjectProto) $set.call(OPSymbols, value)
                        if (has(this, HIDDEN) && has(this[HIDDEN], tag))
                            this[HIDDEN][tag] = false
                        setSymbolDesc(this, tag, createDesc(1, value))
                    }
                    if (DESCRIPTORS && setter)
                        setSymbolDesc(ObjectProto, tag, {
                            configurable: true,
                            set: $set
                        })
                    return wrap(tag)
                }
                redefine($Symbol[PROTOTYPE], 'toString', function toString() {
                    return this._k
                })

                $GOPD.f = $getOwnPropertyDescriptor
                $DP.f = $defineProperty
                __webpack_require__('ar/p').f = gOPNExt.f = $getOwnPropertyNames
                __webpack_require__('NV0k').f = $propertyIsEnumerable
                $GOPS.f = $getOwnPropertySymbols

                if (DESCRIPTORS && !__webpack_require__('uOPS')) {
                    redefine(
                        ObjectProto,
                        'propertyIsEnumerable',
                        $propertyIsEnumerable,
                        true
                    )
                }

                wksExt.f = function(name) {
                    return wrap(wks(name))
                }
            }

            $export($export.G + $export.W + $export.F * !USE_NATIVE, {
                Symbol: $Symbol
            })

            for (
                var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
                    'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(
                        ','
                    ),
                    j = 0;
                es6Symbols.length > j;

            )
                wks(es6Symbols[j++])

            for (
                var wellKnownSymbols = $keys(wks.store), k = 0;
                wellKnownSymbols.length > k;

            )
                wksDefine(wellKnownSymbols[k++])

            $export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
                // 19.4.2.1 Symbol.for(key)
                for: function(key) {
                    return has(SymbolRegistry, (key += ''))
                        ? SymbolRegistry[key]
                        : (SymbolRegistry[key] = $Symbol(key))
                },
                // 19.4.2.5 Symbol.keyFor(sym)
                keyFor: function keyFor(sym) {
                    if (!isSymbol(sym))
                        throw TypeError(sym + ' is not a symbol!')
                    for (var key in SymbolRegistry)
                        if (SymbolRegistry[key] === sym) return key
                },
                useSetter: function() {
                    setter = true
                },
                useSimple: function() {
                    setter = false
                }
            })

            $export($export.S + $export.F * !USE_NATIVE, 'Object', {
                // 19.1.2.2 Object.create(O [, Properties])
                create: $create,
                // 19.1.2.4 Object.defineProperty(O, P, Attributes)
                defineProperty: $defineProperty,
                // 19.1.2.3 Object.defineProperties(O, Properties)
                defineProperties: $defineProperties,
                // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
                getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
                // 19.1.2.7 Object.getOwnPropertyNames(O)
                getOwnPropertyNames: $getOwnPropertyNames,
                // 19.1.2.8 Object.getOwnPropertySymbols(O)
                getOwnPropertySymbols: $getOwnPropertySymbols
            })

            // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
            // https://bugs.chromium.org/p/v8/issues/detail?id=3443
            var FAILS_ON_PRIMITIVES = $fails(function() {
                $GOPS.f(1)
            })

            $export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
                getOwnPropertySymbols: function getOwnPropertySymbols(it) {
                    return $GOPS.f(toObject(it))
                }
            })

            // 24.3.2 JSON.stringify(value [, replacer [, space]])
            $JSON &&
                $export(
                    $export.S +
                        $export.F *
                            (!USE_NATIVE ||
                                $fails(function() {
                                    var S = $Symbol()
                                    // MS Edge converts symbol values to JSON as {}
                                    // WebKit converts symbol values to JSON as null
                                    // V8 throws on boxed symbols
                                    return (
                                        _stringify([S]) != '[null]' ||
                                        _stringify({ a: S }) != '{}' ||
                                        _stringify(Object(S)) != '{}'
                                    )
                                })),
                    'JSON',
                    {
                        stringify: function stringify(it) {
                            var args = [it]
                            var i = 1
                            var replacer, $replacer
                            while (arguments.length > i)
                                args.push(arguments[i++])
                            $replacer = replacer = args[1]
                            if (
                                (!isObject(replacer) && it === undefined) ||
                                isSymbol(it)
                            )
                                return // IE8 returns string on undefined
                            if (!isArray(replacer))
                                replacer = function(key, value) {
                                    if (typeof $replacer == 'function')
                                        value = $replacer.call(this, key, value)
                                    if (!isSymbol(value)) return value
                                }
                            args[1] = replacer
                            return _stringify.apply($JSON, args)
                        }
                    }
                )

            // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
            $Symbol[PROTOTYPE][TO_PRIMITIVE] ||
                __webpack_require__('NegM')(
                    $Symbol[PROTOTYPE],
                    TO_PRIMITIVE,
                    $Symbol[PROTOTYPE].valueOf
                )
            // 19.4.3.5 Symbol.prototype[@@toStringTag]
            setToStringTag($Symbol, 'Symbol')
            // 20.2.1.9 Math[@@toStringTag]
            setToStringTag(Math, 'Math', true)
            // 24.3.3 JSON[@@toStringTag]
            setToStringTag(global.JSON, 'JSON', true)

            /***/
        },

        /***/ AW8e: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { URL } = __webpack_require__('bzos')
            const is = __webpack_require__('6mOv')
            const knownHookEvents = __webpack_require__('JlL/')

            const merge = (target, ...sources) => {
                for (const source of sources) {
                    for (const [key, sourceValue] of Object.entries(source)) {
                        if (is.undefined(sourceValue)) {
                            continue
                        }

                        const targetValue = target[key]
                        if (
                            is.urlInstance(targetValue) &&
                            (is.urlInstance(sourceValue) ||
                                is.string(sourceValue))
                        ) {
                            target[key] = new URL(sourceValue, targetValue)
                        } else if (is.plainObject(sourceValue)) {
                            if (is.plainObject(targetValue)) {
                                target[key] = merge(
                                    {},
                                    targetValue,
                                    sourceValue
                                )
                            } else {
                                target[key] = merge({}, sourceValue)
                            }
                        } else if (is.array(sourceValue)) {
                            target[key] = merge([], sourceValue)
                        } else {
                            target[key] = sourceValue
                        }
                    }
                }

                return target
            }

            const mergeOptions = (...sources) => {
                sources = sources.map(source => source || {})
                const merged = merge({}, ...sources)

                const hooks = {}
                for (const hook of knownHookEvents) {
                    hooks[hook] = []
                }

                for (const source of sources) {
                    if (source.hooks) {
                        for (const hook of knownHookEvents) {
                            hooks[hook] = hooks[hook].concat(source.hooks[hook])
                        }
                    }
                }

                merged.hooks = hooks

                return merged
            }

            const mergeInstances = (instances, methods) => {
                const handlers = instances.map(
                    instance => instance.defaults.handler
                )
                const size = instances.length - 1

                return {
                    methods,
                    options: mergeOptions(
                        ...instances.map(instance => instance.defaults.options)
                    ),
                    handler: (options, next) => {
                        let iteration = -1
                        const iterate = options =>
                            handlers[++iteration](
                                options,
                                iteration === size ? next : iterate
                            )

                        return iterate(options)
                    }
                }
            }

            module.exports = merge
            module.exports.options = mergeOptions
            module.exports.instances = mergeInstances

            /***/
        },

        /***/ AXZJ: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            exports.__esModule = true
            exports.htmlEscapeJsonString = htmlEscapeJsonString // This utility is based on https://github.com/zertosh/htmlescape
            // License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE
            const ESCAPE_LOOKUP = {
                '&': '\\u0026',
                '>': '\\u003e',
                '<': '\\u003c',
                '\u2028': '\\u2028',
                '\u2029': '\\u2029'
            }
            const ESCAPE_REGEX = /[&><\u2028\u2029]/g
            function htmlEscapeJsonString(str) {
                return str.replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match])
            }

            /***/
        },

        /***/ AfMj: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const pkg = __webpack_require__('tCGZ')
            const create = __webpack_require__('canG')

            const defaults = {
                options: {
                    retry: {
                        retries: 2,
                        methods: [
                            'GET',
                            'PUT',
                            'HEAD',
                            'DELETE',
                            'OPTIONS',
                            'TRACE'
                        ],
                        statusCodes: [408, 413, 429, 500, 502, 503, 504],
                        errorCodes: [
                            'ETIMEDOUT',
                            'ECONNRESET',
                            'EADDRINUSE',
                            'ECONNREFUSED',
                            'EPIPE',
                            'ENOTFOUND',
                            'ENETUNREACH',
                            'EAI_AGAIN'
                        ]
                    },
                    headers: {
                        'user-agent': `${pkg.name}/${pkg.version} (https://github.com/sindresorhus/got)`
                    },
                    hooks: {
                        beforeRequest: [],
                        beforeRedirect: [],
                        beforeRetry: [],
                        afterResponse: []
                    },
                    decompress: true,
                    throwHttpErrors: true,
                    followRedirect: true,
                    stream: false,
                    form: false,
                    json: false,
                    cache: false,
                    useElectronNet: false
                },
                mutableDefaults: false
            }

            const got = create(defaults)

            module.exports = got

            /***/
        },

        /***/ AlvL: /***/ function(module, exports) {
            const curves = new Set(['Ed25519'])

            if (!('electron' in process.versions)) {
                curves.add('Ed448')
                curves.add('X25519')
                curves.add('X448')
            }

            module.exports = curves

            /***/
        },

        /***/ 'B+OT': /***/ function(module, exports) {
            var hasOwnProperty = {}.hasOwnProperty
            module.exports = function(it, key) {
                return hasOwnProperty.call(it, key)
            }

            /***/
        },

        /***/ B5Ud: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _interopRequireDefault = __webpack_require__('KI45')

            exports.__esModule = true
            exports.Container = Container
            exports.createUrl = createUrl
            exports.default = void 0

            var _extends2 = _interopRequireDefault(__webpack_require__('htGi'))

            var _asyncToGenerator2 = _interopRequireDefault(
                __webpack_require__('+oT+')
            )

            var _react = _interopRequireDefault(__webpack_require__('q1tI'))

            var _utils = __webpack_require__('g/15')

            exports.AppInitialProps = _utils.AppInitialProps
            /**
             * `App` component is used for initialize of pages. It allows for overwriting and full control of the `page` initialization.
             * This allows for keeping state between navigation, custom error handling, injecting additional data.
             */

            function appGetInitialProps(_x) {
                return _appGetInitialProps.apply(this, arguments)
            }

            function _appGetInitialProps() {
                _appGetInitialProps = (0, _asyncToGenerator2.default)(function*(
                    _ref
                ) {
                    var { Component, ctx } = _ref
                    var pageProps = yield (0, _utils.loadGetInitialProps)(
                        Component,
                        ctx
                    )
                    return {
                        pageProps
                    }
                })
                return _appGetInitialProps.apply(this, arguments)
            }

            class App extends _react.default.Component {
                // Kept here for backwards compatibility.
                // When someone ended App they could call `super.componentDidCatch`.
                // @deprecated This method is no longer needed. Errors are caught at the top level
                componentDidCatch(error, _errorInfo) {
                    throw error
                }

                render() {
                    var { router, Component, pageProps } = this.props
                    var url = createUrl(router)
                    return _react.default.createElement(
                        Component,
                        (0, _extends2.default)({}, pageProps, {
                            url: url
                        })
                    )
                }
            }

            exports.default = App
            App.origGetInitialProps = appGetInitialProps
            App.getInitialProps = appGetInitialProps
            var warnContainer
            var warnUrl

            if (false) {
            } // @deprecated noop for now until removal

            function Container(p) {
                if (false) {
                }
                return p.children
            }

            function createUrl(router) {
                // This is to make sure we don't references the router object at call time
                var { pathname, asPath, query } = router
                return {
                    get query() {
                        if (false) {
                        }
                        return query
                    },

                    get pathname() {
                        if (false) {
                        }
                        return pathname
                    },

                    get asPath() {
                        if (false) {
                        }
                        return asPath
                    },

                    back: () => {
                        if (false) {
                        }
                        router.back()
                    },
                    push: (url, as) => {
                        if (false) {
                        }
                        return router.push(url, as)
                    },
                    pushTo: (href, as) => {
                        if (false) {
                        }
                        var pushRoute = as ? href : ''
                        var pushUrl = as || href
                        return router.push(pushRoute, pushUrl)
                    },
                    replace: (url, as) => {
                        if (false) {
                        }
                        return router.replace(url, as)
                    },
                    replaceTo: (href, as) => {
                        if (false) {
                        }
                        var replaceRoute = as ? href : ''
                        var replaceUrl = as || href
                        return router.replace(replaceRoute, replaceUrl)
                    }
                }
            }

            /***/
        },

        /***/ B8du: /***/ function(module, exports) {
            /**
             * This method returns `false`.
             *
             * @static
             * @memberOf _
             * @since 4.13.0
             * @category Util
             * @returns {boolean} Returns `false`.
             * @example
             *
             * _.times(2, _.stubFalse);
             * // => [false, false]
             */
            function stubFalse() {
                return false
            }

            module.exports = stubFalse

            /***/
        },

        /***/ B9jh: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var strong = __webpack_require__('Wu5q')
            var validate = __webpack_require__('n3ko')
            var SET = 'Set'

            // 23.2 Set Objects
            module.exports = __webpack_require__('raTm')(
                SET,
                function(get) {
                    return function Set() {
                        return get(
                            this,
                            arguments.length > 0 ? arguments[0] : undefined
                        )
                    }
                },
                {
                    // 23.2.3.1 Set.prototype.add(value)
                    add: function add(value) {
                        return strong.def(
                            validate(this, SET),
                            (value = value === 0 ? 0 : value),
                            value
                        )
                    }
                },
                strong
            )

            /***/
        },

        /***/ BBt9: /***/ function(module, exports, __webpack_require__) {
            const { randomBytes } = __webpack_require__('PJMN')

            const { createSecretKey } = __webpack_require__('1ALl')
            const base64url = __webpack_require__('Xab3')
            const {
                THUMBPRINT_MATERIAL,
                PUBLIC_MEMBERS,
                PRIVATE_MEMBERS,
                KEY_MANAGEMENT_DECRYPT,
                KEY_MANAGEMENT_ENCRYPT,
                KEYOBJECT
            } = __webpack_require__('ehsS')

            const Key = __webpack_require__('//Cd')

            const OCT_PUBLIC = new Set()
            Object.freeze(OCT_PUBLIC)
            const OCT_PRIVATE = new Set(['k'])
            Object.freeze(OCT_PRIVATE)

            // Octet sequence Key Type
            class OctKey extends Key {
                constructor(...args) {
                    super(...args)
                    Object.defineProperties(this, {
                        kty: {
                            value: 'oct',
                            enumerable: true
                        },
                        length: {
                            value: this[KEYOBJECT]
                                ? this[KEYOBJECT].symmetricKeySize * 8
                                : undefined
                        },
                        k: {
                            enumerable: false,
                            get() {
                                if (this[KEYOBJECT]) {
                                    Object.defineProperty(this, 'k', {
                                        value: base64url.encodeBuffer(
                                            this[KEYOBJECT].export()
                                        ),
                                        configurable: false
                                    })
                                } else {
                                    Object.defineProperty(this, 'k', {
                                        value: undefined,
                                        configurable: false
                                    })
                                }

                                return this.k
                            },
                            configurable: true
                        }
                    })
                }

                static get [PUBLIC_MEMBERS]() {
                    return OCT_PUBLIC
                }

                static get [PRIVATE_MEMBERS]() {
                    return OCT_PRIVATE
                }

                // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special
                // JSON.stringify handling in V8
                [THUMBPRINT_MATERIAL]() {
                    if (!this[KEYOBJECT]) {
                        throw new TypeError(
                            'reference "oct" keys without "k" cannot have their thumbprint calculated'
                        )
                    }
                    return { k: this.k, kty: 'oct' }
                }

                [KEY_MANAGEMENT_ENCRYPT]() {
                    return new Set([
                        ...this.algorithms('wrapKey'),
                        ...this.algorithms('deriveKey')
                    ])
                }

                [KEY_MANAGEMENT_DECRYPT]() {
                    return this[KEY_MANAGEMENT_ENCRYPT]()
                }

                algorithms(...args) {
                    if (!this[KEYOBJECT]) {
                        return new Set()
                    }

                    return Key.prototype.algorithms.call(this, ...args)
                }

                static async generate(...args) {
                    return this.generateSync(...args)
                }

                static generateSync(len = 256, privat = true) {
                    if (!privat) {
                        throw new TypeError(
                            '"oct" keys cannot be generated as public'
                        )
                    }
                    if (!Number.isSafeInteger(len) || !len || len % 8 !== 0) {
                        throw new TypeError('invalid bit length')
                    }

                    return createSecretKey(randomBytes(len / 8))
                }
            }

            module.exports = OctKey

            /***/
        },

        /***/ BJV5: /***/ function(module, exports, __webpack_require__) {
            const {
                createCipheriv,
                createDecipheriv,
                getCiphers
            } = __webpack_require__('PJMN')

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const { JWEInvalid, JWEDecryptionFailed } = __webpack_require__(
                'yt7c'
            )
            const { asInput } = __webpack_require__('1ALl')

            const checkInput = function(size, iv, tag) {
                if (iv.length !== 12) {
                    throw new JWEInvalid('invalid iv')
                }
                if (arguments.length === 3) {
                    if (tag.length !== 16) {
                        throw new JWEInvalid('invalid tag')
                    }
                }
            }

            const encrypt = (
                size,
                { [KEYOBJECT]: keyObject },
                cleartext,
                { iv, aad = Buffer.alloc(0) }
            ) => {
                const key = asInput(keyObject, false)
                checkInput(size, iv)

                const cipher = createCipheriv(`aes-${size}-gcm`, key, iv, {
                    authTagLength: 16
                })
                cipher.setAAD(aad)

                const ciphertext = Buffer.concat([
                    cipher.update(cleartext),
                    cipher.final()
                ])
                const tag = cipher.getAuthTag()

                return { ciphertext, tag }
            }

            const decrypt = (
                size,
                { [KEYOBJECT]: keyObject },
                ciphertext,
                { iv, tag = Buffer.alloc(0), aad = Buffer.alloc(0) }
            ) => {
                const key = asInput(keyObject, false)
                checkInput(size, iv, tag)

                try {
                    const cipher = createDecipheriv(
                        `aes-${size}-gcm`,
                        key,
                        iv,
                        { authTagLength: 16 }
                    )
                    cipher.setAuthTag(tag)
                    cipher.setAAD(aad)

                    return Buffer.concat([
                        cipher.update(ciphertext),
                        cipher.final()
                    ])
                } catch (err) {
                    throw new JWEDecryptionFailed()
                }
            }

            module.exports = (JWA, JWK) => {
                ;['A128GCM', 'A192GCM', 'A256GCM'].forEach(jwaAlg => {
                    const size = parseInt(jwaAlg.substr(1, 3), 10)
                    if (getCiphers().includes(`aes-${size}-gcm`)) {
                        JWA.encrypt.set(jwaAlg, encrypt.bind(undefined, size))
                        JWA.decrypt.set(jwaAlg, decrypt.bind(undefined, size))
                        JWK.oct.encrypt[jwaAlg] = JWK.oct.decrypt[
                            jwaAlg
                        ] = key =>
                            (key.use === 'enc' || key.use === undefined) &&
                            key.length === size
                    }
                })
            }

            /***/
        },

        /***/ BKKR: /***/ function(module, exports, __webpack_require__) {
            /**
             * This is the common logic for both the Node.js and web browser
             * implementations of `debug()`.
             *
             * Expose `debug()` as the module.
             */

            exports = module.exports = createDebug.debug = createDebug[
                'default'
            ] = createDebug
            exports.coerce = coerce
            exports.disable = disable
            exports.enable = enable
            exports.enabled = enabled
            exports.humanize = __webpack_require__('FGiv')

            /**
             * Active `debug` instances.
             */
            exports.instances = []

            /**
             * The currently active debug mode names, and names to skip.
             */

            exports.names = []
            exports.skips = []

            /**
             * Map of special "%n" handling functions, for the debug "format" argument.
             *
             * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
             */

            exports.formatters = {}

            /**
             * Select a color.
             * @param {String} namespace
             * @return {Number}
             * @api private
             */

            function selectColor(namespace) {
                var hash = 0,
                    i

                for (i in namespace) {
                    hash = (hash << 5) - hash + namespace.charCodeAt(i)
                    hash |= 0 // Convert to 32bit integer
                }

                return exports.colors[Math.abs(hash) % exports.colors.length]
            }

            /**
             * Create a debugger with the given `namespace`.
             *
             * @param {String} namespace
             * @return {Function}
             * @api public
             */

            function createDebug(namespace) {
                var prevTime

                function debug() {
                    // disabled?
                    if (!debug.enabled) return

                    var self = debug

                    // set `diff` timestamp
                    var curr = +new Date()
                    var ms = curr - (prevTime || curr)
                    self.diff = ms
                    self.prev = prevTime
                    self.curr = curr
                    prevTime = curr

                    // turn the `arguments` into a proper Array
                    var args = new Array(arguments.length)
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i]
                    }

                    args[0] = exports.coerce(args[0])

                    if ('string' !== typeof args[0]) {
                        // anything else let's inspect with %O
                        args.unshift('%O')
                    }

                    // apply any `formatters` transformations
                    var index = 0
                    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(
                        match,
                        format
                    ) {
                        // if we encounter an escaped % then don't increase the array index
                        if (match === '%%') return match
                        index++
                        var formatter = exports.formatters[format]
                        if ('function' === typeof formatter) {
                            var val = args[index]
                            match = formatter.call(self, val)

                            // now we need to remove `args[index]` since it's inlined in the `format`
                            args.splice(index, 1)
                            index--
                        }
                        return match
                    })

                    // apply env-specific formatting (colors, etc.)
                    exports.formatArgs.call(self, args)

                    var logFn =
                        debug.log || exports.log || console.log.bind(console)
                    logFn.apply(self, args)
                }

                debug.namespace = namespace
                debug.enabled = exports.enabled(namespace)
                debug.useColors = exports.useColors()
                debug.color = selectColor(namespace)
                debug.destroy = destroy

                // env-specific initialization logic for debug instances
                if ('function' === typeof exports.init) {
                    exports.init(debug)
                }

                exports.instances.push(debug)

                return debug
            }

            function destroy() {
                var index = exports.instances.indexOf(this)
                if (index !== -1) {
                    exports.instances.splice(index, 1)
                    return true
                } else {
                    return false
                }
            }

            /**
             * Enables a debug mode by namespaces. This can include modes
             * separated by a colon and wildcards.
             *
             * @param {String} namespaces
             * @api public
             */

            function enable(namespaces) {
                exports.save(namespaces)

                exports.names = []
                exports.skips = []

                var i
                var split = (typeof namespaces === 'string'
                    ? namespaces
                    : ''
                ).split(/[\s,]+/)
                var len = split.length

                for (i = 0; i < len; i++) {
                    if (!split[i]) continue // ignore empty strings
                    namespaces = split[i].replace(/\*/g, '.*?')
                    if (namespaces[0] === '-') {
                        exports.skips.push(
                            new RegExp('^' + namespaces.substr(1) + '$')
                        )
                    } else {
                        exports.names.push(new RegExp('^' + namespaces + '$'))
                    }
                }

                for (i = 0; i < exports.instances.length; i++) {
                    var instance = exports.instances[i]
                    instance.enabled = exports.enabled(instance.namespace)
                }
            }

            /**
             * Disable debug output.
             *
             * @api public
             */

            function disable() {
                exports.enable('')
            }

            /**
             * Returns true if the given mode name is enabled, false otherwise.
             *
             * @param {String} name
             * @return {Boolean}
             * @api public
             */

            function enabled(name) {
                if (name[name.length - 1] === '*') {
                    return true
                }
                var i, len
                for (i = 0, len = exports.skips.length; i < len; i++) {
                    if (exports.skips[i].test(name)) {
                        return false
                    }
                }
                for (i = 0, len = exports.names.length; i < len; i++) {
                    if (exports.names[i].test(name)) {
                        return true
                    }
                }
                return false
            }

            /**
             * Coerce `val`.
             *
             * @param {Mixed} val
             * @return {Mixed}
             * @api private
             */

            function coerce(val) {
                if (val instanceof Error) return val.stack || val.message
                return val
            }

            /***/
        },

        /***/ BMJj: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * fresh
             * Copyright(c) 2012 TJ Holowaychuk
             * Copyright(c) 2016-2017 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * RegExp to check for no-cache token in Cache-Control.
             * @private
             */

            var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/

            /**
             * Module exports.
             * @public
             */

            module.exports = fresh

            /**
             * Check freshness of the response using request and response headers.
             *
             * @param {Object} reqHeaders
             * @param {Object} resHeaders
             * @return {Boolean}
             * @public
             */

            function fresh(reqHeaders, resHeaders) {
                // fields
                var modifiedSince = reqHeaders['if-modified-since']
                var noneMatch = reqHeaders['if-none-match']

                // unconditional request
                if (!modifiedSince && !noneMatch) {
                    return false
                }

                // Always return stale when Cache-Control: no-cache
                // to support end-to-end reload requests
                // https://tools.ietf.org/html/rfc2616#section-14.9.4
                var cacheControl = reqHeaders['cache-control']
                if (
                    cacheControl &&
                    CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)
                ) {
                    return false
                }

                // if-none-match
                if (noneMatch && noneMatch !== '*') {
                    var etag = resHeaders['etag']

                    if (!etag) {
                        return false
                    }

                    var etagStale = true
                    var matches = parseTokenList(noneMatch)
                    for (var i = 0; i < matches.length; i++) {
                        var match = matches[i]
                        if (
                            match === etag ||
                            match === 'W/' + etag ||
                            'W/' + match === etag
                        ) {
                            etagStale = false
                            break
                        }
                    }

                    if (etagStale) {
                        return false
                    }
                }

                // if-modified-since
                if (modifiedSince) {
                    var lastModified = resHeaders['last-modified']
                    var modifiedStale =
                        !lastModified ||
                        !(
                            parseHttpDate(lastModified) <=
                            parseHttpDate(modifiedSince)
                        )

                    if (modifiedStale) {
                        return false
                    }
                }

                return true
            }

            /**
             * Parse an HTTP Date into a number.
             *
             * @param {string} date
             * @private
             */

            function parseHttpDate(date) {
                var timestamp = date && Date.parse(date)

                // istanbul ignore next: guard against date.js Date.parse patching
                return typeof timestamp === 'number' ? timestamp : NaN
            }

            /**
             * Parse a HTTP token list.
             *
             * @param {string} str
             * @private
             */

            function parseTokenList(str) {
                var end = 0
                var list = []
                var start = 0

                // gather tokens
                for (var i = 0, len = str.length; i < len; i++) {
                    switch (str.charCodeAt(i)) {
                        case 0x20 /*   */:
                            if (start === end) {
                                start = end = i + 1
                            }
                            break
                        case 0x2c /* , */:
                            list.push(str.substring(start, end))
                            start = end = i + 1
                            break
                        default:
                            end = i + 1
                            break
                    }
                }

                // final token
                list.push(str.substring(start, end))

                return list
            }

            /***/
        },

        /***/ BOd6: /***/ function(module, exports, __webpack_require__) {
            const isObject = __webpack_require__('kF1/')
            const epoch = __webpack_require__('F4x3')
            const secs = __webpack_require__('o156')
            const getKey = __webpack_require__('oGTz')
            const { bare: verify } = __webpack_require__('ZXG7')
            const { JWTClaimInvalid, JWTExpired } = __webpack_require__('yt7c')

            const { isString, isNotString } = __webpack_require__('mRrf')
            const decode = __webpack_require__('7o4N')

            const isPayloadString = isString.bind(undefined, JWTClaimInvalid)
            const isOptionString = isString.bind(undefined, TypeError)

            const IDTOKEN = 'id_token'
            const LOGOUTTOKEN = 'logout_token'
            const ATJWT = 'at+JWT'

            const isTimestamp = (value, label, required = false) => {
                if (required && value === undefined) {
                    throw new JWTClaimInvalid(
                        `"${label}" claim is missing`,
                        label,
                        'missing'
                    )
                }

                if (
                    value !== undefined &&
                    (typeof value !== 'number' || !Number.isSafeInteger(value))
                ) {
                    throw new JWTClaimInvalid(
                        `"${label}" claim must be a unix timestamp`,
                        label,
                        'invalid'
                    )
                }
            }

            const isStringOrArrayOfStrings = (
                value,
                label,
                required = false
            ) => {
                if (required && value === undefined) {
                    throw new JWTClaimInvalid(
                        `"${label}" claim is missing`,
                        label,
                        'missing'
                    )
                }

                if (
                    value !== undefined &&
                    isNotString(value) && isNotArrayOfStrings(value)
                ) {
                    throw new JWTClaimInvalid(
                        `"${label}" claim must be a string or array of strings`,
                        label,
                        'invalid'
                    )
                }
            }

            const isNotArrayOfStrings = val =>
                !Array.isArray(val) || val.length === 0 || val.some(isNotString)

            const validateOptions = ({
                algorithms,
                audience,
                clockTolerance,
                complete = false,
                crit,
                ignoreExp = false,
                ignoreIat = false,
                ignoreNbf = false,
                issuer,
                jti,
                maxAuthAge,
                maxTokenAge,
                nonce,
                now = new Date(),
                profile,
                subject
            }) => {
                isOptionString(profile, 'options.profile')

                if (typeof complete !== 'boolean') {
                    throw new TypeError('options.complete must be a boolean')
                }

                if (typeof ignoreExp !== 'boolean') {
                    throw new TypeError('options.ignoreExp must be a boolean')
                }

                if (typeof ignoreNbf !== 'boolean') {
                    throw new TypeError('options.ignoreNbf must be a boolean')
                }

                if (typeof ignoreIat !== 'boolean') {
                    throw new TypeError('options.ignoreIat must be a boolean')
                }

                isOptionString(maxTokenAge, 'options.maxTokenAge')
                isOptionString(subject, 'options.subject')
                isOptionString(issuer, 'options.issuer')
                isOptionString(maxAuthAge, 'options.maxAuthAge')
                isOptionString(jti, 'options.jti')
                isOptionString(clockTolerance, 'options.clockTolerance')

                if (
                    audience !== undefined &&
                    isNotString(audience) && isNotArrayOfStrings(audience)
                ) {
                    throw new TypeError(
                        'options.audience must be a string or an array of strings'
                    )
                }

                if (
                    algorithms !== undefined &&
                    isNotArrayOfStrings(algorithms)
                ) {
                    throw new TypeError(
                        'options.algorithms must be an array of strings'
                    )
                }

                isOptionString(nonce, 'options.nonce')

                if (!(now instanceof Date) || !now.getTime()) {
                    throw new TypeError(
                        'options.now must be a valid Date object'
                    )
                }

                if (ignoreIat && maxTokenAge !== undefined) {
                    throw new TypeError(
                        'options.ignoreIat and options.maxTokenAge cannot used together'
                    )
                }

                if (crit !== undefined && isNotArrayOfStrings(crit)) {
                    throw new TypeError(
                        'options.crit must be an array of strings'
                    )
                }

                switch (profile) {
                    case IDTOKEN:
                        if (!issuer) {
                            throw new TypeError(
                                '"issuer" option is required to validate an ID Token'
                            )
                        }

                        if (!audience) {
                            throw new TypeError(
                                '"audience" option is required to validate an ID Token'
                            )
                        }

                        break
                    case ATJWT:
                        if (!issuer) {
                            throw new TypeError(
                                '"issuer" option is required to validate a JWT Access Token'
                            )
                        }

                        if (!audience) {
                            throw new TypeError(
                                '"audience" option is required to validate a JWT Access Token'
                            )
                        }

                        break
                    case LOGOUTTOKEN:
                        if (!issuer) {
                            throw new TypeError(
                                '"issuer" option is required to validate a Logout Token'
                            )
                        }

                        if (!audience) {
                            throw new TypeError(
                                '"audience" option is required to validate a Logout Token'
                            )
                        }

                        break
                    case undefined:
                        break
                    default:
                        throw new TypeError(
                            `unsupported options.profile value "${profile}"`
                        )
                }

                return {
                    algorithms,
                    audience,
                    clockTolerance,
                    complete,
                    crit,
                    ignoreExp,
                    ignoreIat,
                    ignoreNbf,
                    issuer,
                    jti,
                    maxAuthAge,
                    maxTokenAge,
                    nonce,
                    now,
                    profile,
                    subject
                }
            }

            const validateTypes = ({ header, payload }, profile, options) => {
                isPayloadString(
                    header.alg,
                    '"alg" header parameter',
                    'alg',
                    true
                )

                isTimestamp(
                    payload.iat,
                    'iat',
                    profile === IDTOKEN ||
                        profile === LOGOUTTOKEN ||
                        !!options.maxTokenAge
                )
                isTimestamp(
                    payload.exp,
                    'exp',
                    profile === IDTOKEN || profile === ATJWT
                )
                isTimestamp(
                    payload.auth_time,
                    'auth_time',
                    !!options.maxAuthAge
                )
                isTimestamp(payload.nbf, 'nbf')
                isPayloadString(
                    payload.jti,
                    '"jti" claim',
                    'jti',
                    profile === LOGOUTTOKEN || !!options.jti
                )
                isPayloadString(payload.acr, '"acr" claim', 'acr')
                isPayloadString(
                    payload.nonce,
                    '"nonce" claim',
                    'nonce',
                    !!options.nonce
                )
                isPayloadString(
                    payload.iss,
                    '"iss" claim',
                    'iss',
                    profile === IDTOKEN ||
                        profile === ATJWT ||
                        profile === LOGOUTTOKEN ||
                        !!options.issuer
                )
                isPayloadString(
                    payload.sub,
                    '"sub" claim',
                    'sub',
                    profile === IDTOKEN ||
                        profile === ATJWT ||
                        !!options.subject
                )
                isStringOrArrayOfStrings(
                    payload.aud,
                    'aud',
                    profile === IDTOKEN ||
                        profile === ATJWT ||
                        profile === LOGOUTTOKEN ||
                        !!options.audience
                )
                isPayloadString(
                    payload.azp,
                    '"azp" claim',
                    'azp',
                    profile === IDTOKEN &&
                        Array.isArray(payload.aud) &&
                        payload.aud.length > 1
                )
                isStringOrArrayOfStrings(payload.amr, 'amr')

                if (profile === ATJWT) {
                    isPayloadString(
                        payload.client_id,
                        '"client_id" claim',
                        'client_id',
                        true
                    )
                    isPayloadString(
                        header.typ,
                        '"typ" header parameter',
                        'typ',
                        true
                    )
                }

                if (profile === LOGOUTTOKEN) {
                    isPayloadString(payload.sid, '"sid" claim', 'sid')

                    if (!('sid' in payload) && !('sub' in payload)) {
                        throw new JWTClaimInvalid(
                            'either "sid" or "sub" (or both) claims must be present'
                        )
                    }

                    if ('nonce' in payload) {
                        throw new JWTClaimInvalid(
                            '"nonce" claim is prohibited',
                            'nonce',
                            'prohibited'
                        )
                    }

                    if (!('events' in payload)) {
                        throw new JWTClaimInvalid(
                            '"events" claim is missing',
                            'events',
                            'missing'
                        )
                    }

                    if (!isObject(payload.events)) {
                        throw new JWTClaimInvalid(
                            '"events" claim must be an object',
                            'events',
                            'invalid'
                        )
                    }

                    if (
                        !(
                            'http://schemas.openid.net/event/backchannel-logout' in
                            payload.events
                        )
                    ) {
                        throw new JWTClaimInvalid(
                            '"http://schemas.openid.net/event/backchannel-logout" member is missing in the "events" claim',
                            'events',
                            'invalid'
                        )
                    }

                    if (
                        !isObject(
                            payload.events[
                                'http://schemas.openid.net/event/backchannel-logout'
                            ]
                        )
                    ) {
                        throw new JWTClaimInvalid(
                            '"http://schemas.openid.net/event/backchannel-logout" member in the "events" claim must be an object',
                            'events',
                            'invalid'
                        )
                    }
                }
            }

            const checkAudiencePresence = (audPayload, audOption, profile) => {
                if (typeof audPayload === 'string') {
                    return audOption.includes(audPayload)
                }

                if (profile === ATJWT) {
                    // reject if it contains additional audiences that are not known aliases of the resource
                    // indicator of the current resource server
                    audOption = new Set(audOption)
                    return audPayload.every(Set.prototype.has.bind(audOption))
                } else {
                    // Each principal intended to process the JWT MUST
                    // identify itself with a value in the audience claim
                    audPayload = new Set(audPayload)
                    return audOption.some(Set.prototype.has.bind(audPayload))
                }
            }

            module.exports = (token, key, options = {}) => {
                if (!isObject(options)) {
                    throw new TypeError('options must be an object')
                }

                const {
                    algorithms,
                    audience,
                    clockTolerance,
                    complete,
                    crit,
                    ignoreExp,
                    ignoreIat,
                    ignoreNbf,
                    issuer,
                    jti,
                    maxAuthAge,
                    maxTokenAge,
                    nonce,
                    now,
                    profile,
                    subject
                } = (options = validateOptions(options))

                const decoded = decode(token, { complete: true })
                key = getKey(key, true)

                if (complete) {
                    ;({ key } = verify(
                        true,
                        'preparsed',
                        { decoded, token },
                        key,
                        { crit, algorithms, complete: true }
                    ))
                    decoded.key = key
                } else {
                    verify(true, 'preparsed', { decoded, token }, key, {
                        crit,
                        algorithms
                    })
                }

                const unix = epoch(now)
                validateTypes(decoded, profile, options)

                if (issuer && decoded.payload.iss !== issuer) {
                    throw new JWTClaimInvalid(
                        'unexpected "iss" claim value',
                        'iss',
                        'check_failed'
                    )
                }

                if (nonce && decoded.payload.nonce !== nonce) {
                    throw new JWTClaimInvalid(
                        'unexpected "nonce" claim value',
                        'nonce',
                        'check_failed'
                    )
                }

                if (subject && decoded.payload.sub !== subject) {
                    throw new JWTClaimInvalid(
                        'unexpected "sub" claim value',
                        'sub',
                        'check_failed'
                    )
                }

                if (jti && decoded.payload.jti !== jti) {
                    throw new JWTClaimInvalid(
                        'unexpected "jti" claim value',
                        'jti',
                        'check_failed'
                    )
                }

                if (
                    audience &&
                    !checkAudiencePresence(
                        decoded.payload.aud,
                        typeof audience === 'string' ? [audience] : audience,
                        profile
                    )
                ) {
                    throw new JWTClaimInvalid(
                        'unexpected "aud" claim value',
                        'aud',
                        'check_failed'
                    )
                }

                const tolerance = clockTolerance ? secs(clockTolerance) : 0

                if (maxAuthAge) {
                    const maxAuthAgeSeconds = secs(maxAuthAge)
                    if (
                        decoded.payload.auth_time + maxAuthAgeSeconds <
                        unix - tolerance
                    ) {
                        throw new JWTClaimInvalid(
                            '"auth_time" claim timestamp check failed (too much time has elapsed since the last End-User authentication)',
                            'auth_time',
                            'check_failed'
                        )
                    }
                }

                if (
                    !ignoreIat &&
                    !('exp' in decoded.payload) &&
                    'iat' in decoded.payload &&
                    decoded.payload.iat > unix + tolerance
                ) {
                    throw new JWTClaimInvalid(
                        '"iat" claim timestamp check failed (it should be in the past)',
                        'iat',
                        'check_failed'
                    )
                }

                if (
                    !ignoreNbf &&
                    'nbf' in decoded.payload &&
                    decoded.payload.nbf > unix + tolerance
                ) {
                    throw new JWTClaimInvalid(
                        '"nbf" claim timestamp check failed',
                        'nbf',
                        'check_failed'
                    )
                }

                if (
                    !ignoreExp &&
                    'exp' in decoded.payload &&
                    decoded.payload.exp <= unix - tolerance
                ) {
                    throw new JWTExpired(
                        '"exp" claim timestamp check failed',
                        'exp',
                        'check_failed'
                    )
                }

                if (maxTokenAge) {
                    const age = unix - decoded.payload.iat
                    const max = secs(maxTokenAge)

                    if (age - tolerance > max) {
                        throw new JWTExpired(
                            '"iat" claim timestamp check failed (too far in the past)',
                            'iat',
                            'check_failed'
                        )
                    }

                    if (age < 0 - tolerance) {
                        throw new JWTClaimInvalid(
                            '"iat" claim timestamp check failed (it should be in the past)',
                            'iat',
                            'check_failed'
                        )
                    }
                }

                if (
                    profile === IDTOKEN &&
                    Array.isArray(decoded.payload.aud) &&
                    decoded.payload.aud.length > 1 &&
                    decoded.payload.azp !== audience
                ) {
                    throw new JWTClaimInvalid(
                        'unexpected "azp" claim value',
                        'azp',
                        'check_failed'
                    )
                }

                if (profile === ATJWT && decoded.header.typ !== ATJWT) {
                    throw new JWTClaimInvalid(
                        'invalid JWT typ header value for the used validation profile',
                        'typ',
                        'check_failed'
                    )
                }

                return complete ? decoded : decoded.payload
            }

            /***/
        },

        /***/ BURE: /***/ function(module, exports, __webpack_require__) {
            // https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
            __webpack_require__('cHUd')('WeakMap')

            /***/
        },

        /***/ BkRI: /***/ function(module, exports, __webpack_require__) {
            var baseClone = __webpack_require__('OBhP')

            /** Used to compose bitmasks for cloning. */
            var CLONE_DEEP_FLAG = 1,
                CLONE_SYMBOLS_FLAG = 4

            /**
             * This method is like `_.clone` except that it recursively clones `value`.
             *
             * @static
             * @memberOf _
             * @since 1.0.0
             * @category Lang
             * @param {*} value The value to recursively clone.
             * @returns {*} Returns the deep cloned value.
             * @see _.clone
             * @example
             *
             * var objects = [{ 'a': 1 }, { 'b': 2 }];
             *
             * var deep = _.cloneDeep(objects);
             * console.log(deep[0] === objects[0]);
             * // => false
             */
            function cloneDeep(value) {
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
            }

            module.exports = cloneDeep

            /***/
        },

        /***/ BzZA: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /*
    Encode functions adapted from:
    Version 1.0 12/25/99 Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
    http://www.onicos.com/staff/iz/amuse/javascript/expert/base64.txt
*/

            const Stream = __webpack_require__('msIP')

            const internals = {}

            exports.encode = function(buffer) {
                return Buffer.from(buffer.toString('base64'))
            }

            exports.Encoder = class Encoder extends Stream.Transform {
                constructor() {
                    super()
                    this._reminder = null
                }

                _transform(chunk, encoding, callback) {
                    let part = this._reminder
                        ? Buffer.concat([this._reminder, chunk])
                        : chunk
                    const remaining = part.length % 3
                    if (remaining) {
                        this._reminder = part.slice(part.length - remaining)
                        part = part.slice(0, part.length - remaining)
                    } else {
                        this._reminder = null
                    }

                    this.push(exports.encode(part))
                    return callback()
                }

                _flush(callback) {
                    if (this._reminder) {
                        this.push(exports.encode(this._reminder))
                    }

                    return callback()
                }
            }

            /***/
        },

        /***/ 'C/Kw': /***/ function(module, exports, __webpack_require__) {
            const { improvedDH } = __webpack_require__('pDDt')
            const { KEYLENGTHS } = __webpack_require__('N+nT')
            const { generateSync } = __webpack_require__('LDEB')
            const { name: secp256k1 } = __webpack_require__('F/JS')

            const derive = __webpack_require__('kZLX')

            const wrapKey = (key, payload, { enc }) => {
                const epk = generateSync(key.kty, key.crv)

                const derivedKey = derive(enc, KEYLENGTHS.get(enc), epk, key)

                return {
                    wrapped: derivedKey,
                    header: {
                        epk: { kty: key.kty, crv: key.crv, x: epk.x, y: epk.y }
                    }
                }
            }

            const unwrapKey = (key, payload, header) => {
                const { enc, epk } = header
                return derive(enc, KEYLENGTHS.get(enc), key, epk, header)
            }

            module.exports = (JWA, JWK) => {
                JWA.keyManagementEncrypt.set('ECDH-ES', wrapKey)
                JWA.keyManagementDecrypt.set('ECDH-ES', unwrapKey)
                JWK.EC.deriveKey['ECDH-ES'] = key =>
                    (key.use === 'enc' || key.use === undefined) &&
                    key.crv !== secp256k1

                if (improvedDH) {
                    JWK.OKP.deriveKey['ECDH-ES'] = key =>
                        (key.use === 'enc' || key.use === undefined) &&
                        key.keyObject.asymmetricKeyType.startsWith('x')
                }
            }

            /***/
        },

        /***/ C2SN: /***/ function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__('93I4')
            var isArray = __webpack_require__('kAMH')
            var SPECIES = __webpack_require__('UWiX')('species')

            module.exports = function(original) {
                var C
                if (isArray(original)) {
                    C = original.constructor
                    // cross-realm fallback
                    if (
                        typeof C == 'function' &&
                        (C === Array || isArray(C.prototype))
                    )
                        C = undefined
                    if (isObject(C)) {
                        C = C[SPECIES]
                        if (C === null) C = undefined
                    }
                }
                return C === undefined ? Array : C
            }

            /***/
        },

        /***/ CH3K: /***/ function(module, exports) {
            /**
             * Appends the elements of `values` to `array`.
             *
             * @private
             * @param {Array} array The array to modify.
             * @param {Array} values The values to append.
             * @returns {Array} Returns `array`.
             */
            function arrayPush(array, values) {
                var index = -1,
                    length = values.length,
                    offset = array.length

                while (++index < length) {
                    array[offset + index] = values[index]
                }
                return array
            }

            module.exports = arrayPush

            /***/
        },

        /***/ CMye: /***/ function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__('GoyQ')

            /**
             * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` if suitable for strict
             *  equality comparisons, else `false`.
             */
            function isStrictComparable(value) {
                return value === value && !isObject(value)
            }

            module.exports = isStrictComparable

            /***/
        },

        /***/ Cg2A: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('6CmU')

            /***/
        },

        /***/ CgaS: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')
            var buildURL = __webpack_require__('MLWZ')
            var InterceptorManager = __webpack_require__('9rSQ')
            var dispatchRequest = __webpack_require__('UnBK')
            var mergeConfig = __webpack_require__('SntB')

            /**
             * Create a new instance of Axios
             *
             * @param {Object} instanceConfig The default config for the instance
             */
            function Axios(instanceConfig) {
                this.defaults = instanceConfig
                this.interceptors = {
                    request: new InterceptorManager(),
                    response: new InterceptorManager()
                }
            }

            /**
             * Dispatch a request
             *
             * @param {Object} config The config specific for this request (merged with this.defaults)
             */
            Axios.prototype.request = function request(config) {
                /*eslint no-param-reassign:0*/
                // Allow for axios('example/url'[, config]) a la fetch API
                if (typeof config === 'string') {
                    config = arguments[1] || {}
                    config.url = arguments[0]
                } else {
                    config = config || {}
                }

                config = mergeConfig(this.defaults, config)

                // Set config.method
                if (config.method) {
                    config.method = config.method.toLowerCase()
                } else if (this.defaults.method) {
                    config.method = this.defaults.method.toLowerCase()
                } else {
                    config.method = 'get'
                }

                // Hook up interceptors middleware
                var chain = [dispatchRequest, undefined]
                var promise = Promise.resolve(config)

                this.interceptors.request.forEach(
                    function unshiftRequestInterceptors(interceptor) {
                        chain.unshift(
                            interceptor.fulfilled,
                            interceptor.rejected
                        )
                    }
                )

                this.interceptors.response.forEach(
                    function pushResponseInterceptors(interceptor) {
                        chain.push(interceptor.fulfilled, interceptor.rejected)
                    }
                )

                while (chain.length) {
                    promise = promise.then(chain.shift(), chain.shift())
                }

                return promise
            }

            Axios.prototype.getUri = function getUri(config) {
                config = mergeConfig(this.defaults, config)
                return buildURL(
                    config.url,
                    config.params,
                    config.paramsSerializer
                ).replace(/^\?/, '')
            }

            // Provide aliases for supported request methods
            utils.forEach(
                ['delete', 'get', 'head', 'options'],
                function forEachMethodNoData(method) {
                    /*eslint func-names:0*/
                    Axios.prototype[method] = function(url, config) {
                        return this.request(
                            utils.merge(config || {}, {
                                method: method,
                                url: url
                            })
                        )
                    }
                }
            )

            utils.forEach(
                ['post', 'put', 'patch'],
                function forEachMethodWithData(method) {
                    /*eslint func-names:0*/
                    Axios.prototype[method] = function(url, data, config) {
                        return this.request(
                            utils.merge(config || {}, {
                                method: method,
                                url: url,
                                data: data
                            })
                        )
                    }
                }
            )

            module.exports = Axios

            /***/
        },

        /***/ Cl1u: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Types = __webpack_require__('gdNv')

            const internals = {
                mismatched: null
            }

            module.exports = function(obj, ref, options) {
                options = Object.assign({ prototype: true }, options)

                return !!internals.isDeepEqual(obj, ref, options, [])
            }

            internals.isDeepEqual = function(obj, ref, options, seen) {
                if (obj === ref) {
                    // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
                    return obj !== 0 || 1 / obj === 1 / ref
                }

                const type = typeof obj

                if (type !== typeof ref) {
                    return false
                }

                if (obj === null || ref === null) {
                    return false
                }

                if (type === 'function') {
                    if (
                        !options.deepFunction ||
                        obj.toString() !== ref.toString()
                    ) {
                        return false
                    }

                    // Continue as object
                } else if (type !== 'object') {
                    return obj !== obj && ref !== ref // NaN
                }

                const instanceType = internals.getSharedType(
                    obj,
                    ref,
                    !!options.prototype
                )
                switch (instanceType) {
                    case Types.buffer:
                        return Buffer && Buffer.prototype.equals.call(obj, ref) // $lab:coverage:ignore$
                    case Types.promise:
                        return obj === ref
                    case Types.regex:
                        return obj.toString() === ref.toString()
                    case internals.mismatched:
                        return false
                }

                for (let i = seen.length - 1; i >= 0; --i) {
                    if (seen[i].isSame(obj, ref)) {
                        return true // If previous comparison failed, it would have stopped execution
                    }
                }

                seen.push(new internals.SeenEntry(obj, ref))

                try {
                    return !!internals.isDeepEqualObj(
                        instanceType,
                        obj,
                        ref,
                        options,
                        seen
                    )
                } finally {
                    seen.pop()
                }
            }

            internals.getSharedType = function(obj, ref, checkPrototype) {
                if (checkPrototype) {
                    if (
                        Object.getPrototypeOf(obj) !==
                        Object.getPrototypeOf(ref)
                    ) {
                        return internals.mismatched
                    }

                    return Types.getInternalProto(obj)
                }

                const type = Types.getInternalProto(obj)
                if (type !== Types.getInternalProto(ref)) {
                    return internals.mismatched
                }

                return type
            }

            internals.valueOf = function(obj) {
                const objValueOf = obj.valueOf
                if (objValueOf === undefined) {
                    return obj
                }

                try {
                    return objValueOf.call(obj)
                } catch (err) {
                    return err
                }
            }

            internals.hasOwnEnumerableProperty = function(obj, key) {
                return Object.prototype.propertyIsEnumerable.call(obj, key)
            }

            internals.isSetSimpleEqual = function(obj, ref) {
                for (const entry of obj) {
                    if (!ref.has(entry)) {
                        return false
                    }
                }

                return true
            }

            internals.isDeepEqualObj = function(
                instanceType,
                obj,
                ref,
                options,
                seen
            ) {
                const {
                    isDeepEqual,
                    valueOf,
                    hasOwnEnumerableProperty
                } = internals
                const { keys, getOwnPropertySymbols } = Object

                if (instanceType === Types.array) {
                    if (options.part) {
                        // Check if any index match any other index

                        for (const objValue of obj) {
                            for (const refValue of ref) {
                                if (
                                    isDeepEqual(
                                        objValue,
                                        refValue,
                                        options,
                                        seen
                                    )
                                ) {
                                    return true
                                }
                            }
                        }
                    } else {
                        if (obj.length !== ref.length) {
                            return false
                        }

                        for (let i = 0; i < obj.length; ++i) {
                            if (!isDeepEqual(obj[i], ref[i], options, seen)) {
                                return false
                            }
                        }

                        return true
                    }
                } else if (instanceType === Types.set) {
                    if (obj.size !== ref.size) {
                        return false
                    }

                    if (!internals.isSetSimpleEqual(obj, ref)) {
                        // Check for deep equality

                        const ref2 = new Set(ref)
                        for (const objEntry of obj) {
                            if (ref2.delete(objEntry)) {
                                continue
                            }

                            let found = false
                            for (const refEntry of ref2) {
                                if (
                                    isDeepEqual(
                                        objEntry,
                                        refEntry,
                                        options,
                                        seen
                                    )
                                ) {
                                    ref2.delete(refEntry)
                                    found = true
                                    break
                                }
                            }

                            if (!found) {
                                return false
                            }
                        }
                    }
                } else if (instanceType === Types.map) {
                    if (obj.size !== ref.size) {
                        return false
                    }

                    for (const [key, value] of obj) {
                        if (value === undefined && !ref.has(key)) {
                            return false
                        }

                        if (!isDeepEqual(value, ref.get(key), options, seen)) {
                            return false
                        }
                    }
                } else if (instanceType === Types.error) {
                    // Always check name and message

                    if (obj.name !== ref.name || obj.message !== ref.message) {
                        return false
                    }
                }

                // Check .valueOf()

                const valueOfObj = valueOf(obj)
                const valueOfRef = valueOf(ref)
                if (
                    (obj !== valueOfObj || ref !== valueOfRef) &&
                    !isDeepEqual(valueOfObj, valueOfRef, options, seen)
                ) {
                    return false
                }

                // Check properties

                const objKeys = keys(obj)
                if (
                    !options.part &&
                    objKeys.length !== keys(ref).length &&
                    !options.skip
                ) {
                    return false
                }

                let skipped = 0
                for (const key of objKeys) {
                    if (options.skip && options.skip.includes(key)) {
                        if (ref[key] === undefined) {
                            ++skipped
                        }

                        continue
                    }

                    if (!hasOwnEnumerableProperty(ref, key)) {
                        return false
                    }

                    if (!isDeepEqual(obj[key], ref[key], options, seen)) {
                        return false
                    }
                }

                if (
                    !options.part &&
                    objKeys.length - skipped !== keys(ref).length
                ) {
                    return false
                }

                // Check symbols

                if (options.symbols !== false) {
                    // Defaults to true
                    const objSymbols = getOwnPropertySymbols(obj)
                    const refSymbols = new Set(getOwnPropertySymbols(ref))

                    for (const key of objSymbols) {
                        if (!options.skip || !options.skip.includes(key)) {
                            if (hasOwnEnumerableProperty(obj, key)) {
                                if (!hasOwnEnumerableProperty(ref, key)) {
                                    return false
                                }

                                if (
                                    !isDeepEqual(
                                        obj[key],
                                        ref[key],
                                        options,
                                        seen
                                    )
                                ) {
                                    return false
                                }
                            } else if (hasOwnEnumerableProperty(ref, key)) {
                                return false
                            }
                        }

                        refSymbols.delete(key)
                    }

                    for (const key of refSymbols) {
                        if (hasOwnEnumerableProperty(ref, key)) {
                            return false
                        }
                    }
                }

                return true
            }

            internals.SeenEntry = class {
                constructor(obj, ref) {
                    this.obj = obj
                    this.ref = ref
                }

                isSame(obj, ref) {
                    return this.obj === obj && this.ref === ref
                }
            }

            /***/
        },

        /***/ ClL1: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Crypto = __webpack_require__('PJMN')

            const B64 = __webpack_require__('M8F5')
            const Boom = __webpack_require__('U3sn')
            const Bourne = __webpack_require__('5kZ8')
            const Cryptiles = __webpack_require__('ieHi')
            const Hoek = __webpack_require__('RXbi')

            const internals = {}

            exports.defaults = {
                encryption: {
                    saltBits: 256,
                    algorithm: 'aes-256-cbc',
                    iterations: 1,
                    minPasswordlength: 32
                },

                integrity: {
                    saltBits: 256,
                    algorithm: 'sha256',
                    iterations: 1,
                    minPasswordlength: 32
                },

                ttl: 0, // Milliseconds, 0 means forever
                timestampSkewSec: 60, // Seconds of permitted clock skew for incoming expirations
                localtimeOffsetMsec: 0 // Local clock time offset express in a number of milliseconds (positive or negative)
            }

            // Algorithm configuration

            exports.algorithms = {
                'aes-128-ctr': { keyBits: 128, ivBits: 128 },
                'aes-256-cbc': { keyBits: 256, ivBits: 128 },
                sha256: { keyBits: 256 }
            }

            // MAC normalization format version

            exports.macFormatVersion = '2' // Prevent comparison of mac values generated with different normalized string formats

            exports.macPrefix = 'Fe26.' + exports.macFormatVersion

            // Generate a unique encryption key

            /*
    const options =  {
        saltBits: 256,                                  // Ignored if salt is set
        salt: '4d8nr9q384nr9q384nr93q8nruq9348run',
        algorithm: 'aes-128-ctr',
        iterations: 10000,
        iv: 'sdfsdfsdfsdfscdrgercgesrcgsercg',          // Optional
        minPasswordlength: 32
    };
*/

            exports.generateKey = async function(password, options) {
                if (!password) {
                    throw new Boom('Empty password')
                }

                if (!options || typeof options !== 'object') {
                    throw new Boom('Bad options')
                }

                const algorithm = exports.algorithms[options.algorithm]
                if (!algorithm) {
                    throw new Boom('Unknown algorithm: ' + options.algorithm)
                }

                const result = {}

                if (Buffer.isBuffer(password)) {
                    if (password.length < algorithm.keyBits / 8) {
                        throw new Boom('Key buffer (password) too small')
                    }

                    result.key = password
                    result.salt = ''
                } else {
                    if (password.length < options.minPasswordlength) {
                        throw new Boom(
                            'Password string too short (min ' +
                                options.minPasswordlength +
                                ' characters required)'
                        )
                    }

                    let salt = options.salt
                    if (!salt) {
                        if (!options.saltBits) {
                            throw new Boom('Missing salt and saltBits options')
                        }

                        const randomSalt = Cryptiles.randomBits(
                            options.saltBits
                        )
                        salt = randomSalt.toString('hex')
                    }

                    const derivedKey = await internals.pbkdf2(
                        password,
                        salt,
                        options.iterations,
                        algorithm.keyBits / 8,
                        'sha1'
                    )

                    result.key = derivedKey
                    result.salt = salt
                }

                if (options.iv) {
                    result.iv = options.iv
                } else if (algorithm.ivBits) {
                    result.iv = Cryptiles.randomBits(algorithm.ivBits)
                }

                return result
            }

            // Encrypt data
            // options: see exports.generateKey()

            exports.encrypt = async function(password, options, data) {
                const key = await exports.generateKey(password, options)
                const cipher = Crypto.createCipheriv(
                    options.algorithm,
                    key.key,
                    key.iv
                )
                const encrypted = Buffer.concat([
                    cipher.update(data, 'utf8'),
                    cipher.final()
                ])

                return { encrypted, key }
            }

            // Decrypt data
            // options: see exports.generateKey()

            exports.decrypt = async function(password, options, data) {
                const key = await exports.generateKey(password, options)
                const decipher = Crypto.createDecipheriv(
                    options.algorithm,
                    key.key,
                    key.iv
                )
                let dec = decipher.update(data, null, 'utf8')
                dec = dec + decipher.final('utf8')

                return dec
            }

            // HMAC using a password
            // options: see exports.generateKey()

            exports.hmacWithPassword = async function(password, options, data) {
                const key = await exports.generateKey(password, options)
                const hmac = Crypto.createHmac(
                    options.algorithm,
                    key.key
                ).update(data)
                const digest = hmac
                    .digest('base64')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/\=/g, '')

                return {
                    digest,
                    salt: key.salt
                }
            }

            // Normalizes a password parameter into a { id, encryption, integrity } object
            // password: string, buffer or object with { id, secret } or { id, encryption, integrity }

            internals.normalizePassword = function(password) {
                if (
                    password &&
                    typeof password === 'object' &&
                    !Buffer.isBuffer(password)
                ) {
                    return {
                        id: password.id,
                        encryption: password.secret || password.encryption,
                        integrity: password.secret || password.integrity
                    }
                }

                return {
                    encryption: password,
                    integrity: password
                }
            }

            // Encrypt and HMAC an object
            // password: string, buffer or object with { id, secret } or { id, encryption, integrity }
            // options: see exports.defaults

            exports.seal = async function(object, password, options) {
                options = Object.assign({}, options) // Shallow cloned to prevent changes during async operations

                const now = Date.now() + (options.localtimeOffsetMsec || 0) // Measure now before any other processing

                // Serialize object

                const objectString = internals.stringify(object)

                // Obtain password

                let passwordId = ''
                password = internals.normalizePassword(password)
                if (password.id) {
                    if (!/^\w+$/.test(password.id)) {
                        throw new Boom('Invalid password id')
                    }

                    passwordId = password.id
                }

                // Encrypt object string

                const { encrypted, key } = await exports.encrypt(
                    password.encryption,
                    options.encryption,
                    objectString
                )

                // Base64url the encrypted value

                const encryptedB64 = B64.base64urlEncode(encrypted)
                const iv = B64.base64urlEncode(key.iv)
                const expiration = options.ttl ? now + options.ttl : ''
                const macBaseString =
                    exports.macPrefix +
                    '*' +
                    passwordId +
                    '*' +
                    key.salt +
                    '*' +
                    iv +
                    '*' +
                    encryptedB64 +
                    '*' +
                    expiration

                // Mac the combined values

                const mac = await exports.hmacWithPassword(
                    password.integrity,
                    options.integrity,
                    macBaseString
                )

                // Put it all together

                // prefix*[password-id]*encryption-salt*encryption-iv*encrypted*[expiration]*hmac-salt*hmac
                // Allowed URI query name/value characters: *-. \d \w

                const sealed = macBaseString + '*' + mac.salt + '*' + mac.digest
                return sealed
            }

            // Decrypt and validate sealed string
            // password: string, buffer or object with { id: secret } or { id: { encryption, integrity } }
            // options: see exports.defaults

            exports.unseal = async function(sealed, password, options) {
                options = Object.assign({}, options) // Shallow cloned to prevent changes during async operations

                const now = Date.now() + (options.localtimeOffsetMsec || 0) // Measure now before any other processing

                // Break string into components

                const parts = sealed.split('*')
                if (parts.length !== 8) {
                    throw new Boom('Incorrect number of sealed components')
                }

                const macPrefix = parts[0]
                const passwordId = parts[1]
                const encryptionSalt = parts[2]
                const encryptionIv = parts[3]
                const encryptedB64 = parts[4]
                const expiration = parts[5]
                const hmacSalt = parts[6]
                const hmac = parts[7]
                const macBaseString =
                    macPrefix +
                    '*' +
                    passwordId +
                    '*' +
                    encryptionSalt +
                    '*' +
                    encryptionIv +
                    '*' +
                    encryptedB64 +
                    '*' +
                    expiration

                // Check prefix

                if (macPrefix !== exports.macPrefix) {
                    throw new Boom('Wrong mac prefix')
                }

                // Check expiration

                if (expiration) {
                    if (!expiration.match(/^\d+$/)) {
                        throw new Boom('Invalid expiration')
                    }

                    const exp = parseInt(expiration, 10)
                    if (exp <= now - options.timestampSkewSec * 1000) {
                        throw new Boom('Expired seal')
                    }
                }

                // Obtain password

                if (!password) {
                    throw new Boom('Empty password')
                }

                if (
                    typeof password === 'object' &&
                    !Buffer.isBuffer(password)
                ) {
                    password = password[passwordId || 'default']
                    if (!password) {
                        throw new Boom('Cannot find password: ' + passwordId)
                    }
                }

                password = internals.normalizePassword(password)

                // Check hmac

                const macOptions = Hoek.clone(options.integrity)
                macOptions.salt = hmacSalt
                const mac = await exports.hmacWithPassword(
                    password.integrity,
                    macOptions,
                    macBaseString
                )

                if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
                    throw new Boom('Bad hmac value')
                }

                // Decrypt

                try {
                    var encrypted = B64.base64urlDecode(encryptedB64, 'buffer')
                } catch (err) {
                    throw Boom.boomify(err)
                }

                const decryptOptions = Hoek.clone(options.encryption)
                decryptOptions.salt = encryptionSalt

                try {
                    decryptOptions.iv = B64.base64urlDecode(
                        encryptionIv,
                        'buffer'
                    )
                } catch (err) {
                    throw Boom.boomify(err)
                }

                const decrypted = await exports.decrypt(
                    password.encryption,
                    decryptOptions,
                    encrypted
                )

                // Parse JSON

                try {
                    return Bourne.parse(decrypted)
                } catch (err) {
                    throw new Boom(
                        'Failed parsing sealed object JSON: ' + err.message
                    )
                }
            }

            internals.stringify = function(object) {
                try {
                    return JSON.stringify(object)
                } catch (err) {
                    throw new Boom('Failed to stringify object: ' + err.message)
                }
            }

            internals.pbkdf2 = function(...args) {
                return new Promise((resolve, reject) => {
                    const next = (err, result) => {
                        if (err) {
                            return reject(Boom.boomify(err))
                        }

                        resolve(result)
                    }

                    args.push(next)
                    Crypto.pbkdf2(...args)
                })
            }

            /***/
        },

        /***/ Cwc5: /***/ function(module, exports, __webpack_require__) {
            var baseIsNative = __webpack_require__('NKxu'),
                getValue = __webpack_require__('Npjl')

            /**
             * Gets the native function at `key` of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {string} key The key of the method to get.
             * @returns {*} Returns the function if it's native, else `undefined`.
             */
            function getNative(object, key) {
                var value = getValue(object, key)
                return baseIsNative(value) ? value : undefined
            }

            module.exports = getNative

            /***/
        },

        /***/ D5mk: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = object => {
                const result = {}

                for (const [key, value] of Object.entries(object)) {
                    result[key.toLowerCase()] = value
                }

                return result
            }

            /***/
        },

        /***/ D8kY: /***/ function(module, exports, __webpack_require__) {
            var toInteger = __webpack_require__('Ojgd')
            var max = Math.max
            var min = Math.min
            module.exports = function(index, length) {
                index = toInteger(index)
                return index < 0 ? max(index + length, 0) : min(index, length)
            }

            /***/
        },

        /***/ DSRE: /***/ function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */ ;(function(module) {
                var root = __webpack_require__('Kz5y'),
                    stubFalse = __webpack_require__('B8du')

                /** Detect free variable `exports`. */
                var freeExports =
                    true && exports && !exports.nodeType && exports

                /** Detect free variable `module`. */
                var freeModule =
                    freeExports &&
                    typeof module == 'object' &&
                    module &&
                    !module.nodeType &&
                    module

                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports =
                    freeModule && freeModule.exports === freeExports

                /** Built-in value references. */
                var Buffer = moduleExports ? root.Buffer : undefined

                /* Built-in method references for those with the same name as other `lodash` methods. */
                var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined

                /**
                 * Checks if `value` is a buffer.
                 *
                 * @static
                 * @memberOf _
                 * @since 4.3.0
                 * @category Lang
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                 * @example
                 *
                 * _.isBuffer(new Buffer(2));
                 * // => true
                 *
                 * _.isBuffer(new Uint8Array(2));
                 * // => false
                 */
                var isBuffer = nativeIsBuffer || stubFalse

                module.exports = isBuffer

                /* WEBPACK VAR INJECTION */
            }.call(this, __webpack_require__('YuTi')(module)))

            /***/
        },

        /***/ DTay: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('nWF0')

            /***/
        },

        /***/ DfZB: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /**
             * Syntactic sugar for invoking a function and expanding an array for arguments.
             *
             * Common use case would be to use `Function.prototype.apply`.
             *
             *  ```js
             *  function f(x, y, z) {}
             *  var args = [1, 2, 3];
             *  f.apply(null, args);
             *  ```
             *
             * With `spread` this example can be re-written.
             *
             *  ```js
             *  spread(function(x, y, z) {})([1, 2, 3]);
             *  ```
             *
             * @param {Function} callback
             * @returns {Function}
             */
            module.exports = function spread(callback) {
                return function wrap(arr) {
                    return callback.apply(null, arr)
                }
            }

            /***/
        },

        /***/ 'Dw+G': /***/ function(module, exports, __webpack_require__) {
            var copyObject = __webpack_require__('juv8'),
                keysIn = __webpack_require__('mTTR')

            /**
             * The base implementation of `_.assignIn` without support for multiple sources
             * or `customizer` functions.
             *
             * @private
             * @param {Object} object The destination object.
             * @param {Object} source The source object.
             * @returns {Object} Returns `object`.
             */
            function baseAssignIn(object, source) {
                return object && copyObject(source, keysIn(source), object)
            }

            module.exports = baseAssignIn

            /***/
        },

        /***/ E1OP: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { PassThrough } = __webpack_require__('msIP')

            module.exports = options => {
                options = Object.assign({}, options)

                const { array } = options
                let { encoding } = options
                const buffer = encoding === 'buffer'
                let objectMode = false

                if (array) {
                    objectMode = !(encoding || buffer)
                } else {
                    encoding = encoding || 'utf8'
                }

                if (buffer) {
                    encoding = null
                }

                let len = 0
                const ret = []
                const stream = new PassThrough({ objectMode })

                if (encoding) {
                    stream.setEncoding(encoding)
                }

                stream.on('data', chunk => {
                    ret.push(chunk)

                    if (objectMode) {
                        len = ret.length
                    } else {
                        len += chunk.length
                    }
                })

                stream.getBufferedValue = () => {
                    if (array) {
                        return ret
                    }

                    return buffer ? Buffer.concat(ret, len) : ret.join('')
                }

                stream.getBufferedLength = () => len

                return stream
            }

            /***/
        },

        /***/ E2jh: /***/ function(module, exports, __webpack_require__) {
            var coreJsData = __webpack_require__('2gN3')

            /** Used to detect methods masquerading as native. */
            var maskSrcKey = (function() {
                var uid = /[^.]+$/.exec(
                    (coreJsData &&
                        coreJsData.keys &&
                        coreJsData.keys.IE_PROTO) ||
                        ''
                )
                return uid ? 'Symbol(src)_1.' + uid : ''
            })()

            /**
             * Checks if `func` has its source masked.
             *
             * @private
             * @param {Function} func The function to check.
             * @returns {boolean} Returns `true` if `func` is masked, else `false`.
             */
            function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func
            }

            module.exports = isMasked

            /***/
        },

        /***/ E8LI: /***/ function(module, exports, __webpack_require__) {
            module.exports = {
                der: __webpack_require__('ZUdF'),
                pem: __webpack_require__('c1/D')
            }

            /***/
        },

        /***/ EA7m: /***/ function(module, exports, __webpack_require__) {
            var identity = __webpack_require__('zZ0H'),
                overRest = __webpack_require__('Ioao'),
                setToString = __webpack_require__('wclG')

            /**
             * The base implementation of `_.rest` which doesn't validate or coerce arguments.
             *
             * @private
             * @param {Function} func The function to apply a rest parameter to.
             * @param {number} [start=func.length-1] The start position of the rest parameter.
             * @returns {Function} Returns the new function.
             */
            function baseRest(func, start) {
                return setToString(overRest(func, start, identity), func + '')
            }

            module.exports = baseRest

            /***/
        },

        /***/ EB1F: /***/ function(module, exports) {
            module.exports = new Map([
                ['A128CBC-HS256', 256],
                ['A128GCM', 128],
                ['A192CBC-HS384', 384],
                ['A192GCM', 192],
                ['A256CBC-HS512', 512],
                ['A256GCM', 256]
            ])

            /***/
        },

        /***/ EEGq: /***/ function(module, exports, __webpack_require__) {
            var copyObject = __webpack_require__('juv8'),
                getSymbolsIn = __webpack_require__('oCl/')

            /**
             * Copies own and inherited symbols of `source` to `object`.
             *
             * @private
             * @param {Object} source The object to copy symbols from.
             * @param {Object} [object={}] The object to copy symbols to.
             * @returns {Object} Returns `object`.
             */
            function copySymbolsIn(source, object) {
                return copyObject(source, getSymbolsIn(source), object)
            }

            module.exports = copySymbolsIn

            /***/
        },

        /***/ EXMj: /***/ function(module, exports) {
            module.exports = function(it, Constructor, name, forbiddenField) {
                if (
                    !(it instanceof Constructor) ||
                    (forbiddenField !== undefined && forbiddenField in it)
                ) {
                    throw TypeError(name + ': incorrect invocation!')
                }
                return it
            }

            /***/
        },

        /***/ EpBk: /***/ function(module, exports) {
            /**
             * Checks if `value` is suitable for use as unique object key.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
             */
            function isKeyable(value) {
                var type = typeof value
                return type == 'string' ||
                    type == 'number' ||
                    type == 'symbol' ||
                    type == 'boolean'
                    ? value !== '__proto__'
                    : value === null
            }

            module.exports = isKeyable

            /***/
        },

        /***/ ExA7: /***/ function(module, exports) {
            /**
             * Checks if `value` is object-like. A value is object-like if it's not `null`
             * and has a `typeof` result of "object".
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
             * @example
             *
             * _.isObjectLike({});
             * // => true
             *
             * _.isObjectLike([1, 2, 3]);
             * // => true
             *
             * _.isObjectLike(_.noop);
             * // => false
             *
             * _.isObjectLike(null);
             * // => false
             */
            function isObjectLike(value) {
                return value != null && typeof value == 'object'
            }

            module.exports = isObjectLike

            /***/
        },

        /***/ 'F/5w': /***/ function(module, exports) {
            //TODO: handle reviver/dehydrate function like normal
            //and handle indentation, like normal.
            //if anyone needs this... please send pull request.

            exports.stringify = function stringify(o) {
                if ('undefined' == typeof o) return o

                if (o && Buffer.isBuffer(o))
                    return JSON.stringify(':base64:' + o.toString('base64'))

                if (o && o.toJSON) o = o.toJSON()

                if (o && 'object' === typeof o) {
                    var s = ''
                    var array = Array.isArray(o)
                    s = array ? '[' : '{'
                    var first = true

                    for (var k in o) {
                        var ignore =
                            'function' == typeof o[k] ||
                            (!array && 'undefined' === typeof o[k])
                        if (Object.hasOwnProperty.call(o, k) && !ignore) {
                            if (!first) s += ','
                            first = false
                            if (array) {
                                if (o[k] == undefined) s += 'null'
                                else s += stringify(o[k])
                            } else if (o[k] !== void 0) {
                                s += stringify(k) + ':' + stringify(o[k])
                            }
                        }
                    }

                    s += array ? ']' : '}'

                    return s
                } else if ('string' === typeof o) {
                    return JSON.stringify(/^:/.test(o) ? ':' + o : o)
                } else if ('undefined' === typeof o) {
                    return 'null'
                } else return JSON.stringify(o)
            }

            exports.parse = function(s) {
                return JSON.parse(s, function(key, value) {
                    if ('string' === typeof value) {
                        if (/^:base64:/.test(value))
                            return new Buffer(value.substring(8), 'base64')
                        else
                            return /^:/.test(value) ? value.substring(1) : value
                    }
                    return value
                })
            }

            /***/
        },

        /***/ 'F/JS': /***/ function(module, exports, __webpack_require__) {
            const { deprecate } = __webpack_require__('jK02')

            const deprecation = deprecate(() => {},
            '"P-256K" EC curve name is deprecated')

            module.exports = {
                name: 'secp256k1',
                rename(value) {
                    if (value !== 'secp256k1') {
                        deprecation()
                    }
                    module.exports.name = value
                }
            }

            /***/
        },

        /***/ F4x3: /***/ function(module, exports) {
            module.exports = date => Math.floor(date.getTime() / 1000)

            /***/
        },

        /***/ FDah: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /** @license React v16.12.0
             * react-dom-server.node.production.min.js
             *
             * Copyright (c) Facebook, Inc. and its affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */

            var k = __webpack_require__('MgzW'),
                m = __webpack_require__('q1tI'),
                aa = __webpack_require__('msIP')
            function r(a) {
                for (
                    var b =
                            'https://reactjs.org/docs/error-decoder.html?invariant=' +
                            a,
                        c = 1;
                    c < arguments.length;
                    c++
                )
                    b += '&args[]=' + encodeURIComponent(arguments[c])
                return (
                    'Minified React error #' +
                    a +
                    '; visit ' +
                    b +
                    ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
                )
            }
            var u = 'function' === typeof Symbol && Symbol.for,
                ba = u ? Symbol.for('react.portal') : 60106,
                v = u ? Symbol.for('react.fragment') : 60107,
                ca = u ? Symbol.for('react.strict_mode') : 60108,
                da = u ? Symbol.for('react.profiler') : 60114,
                x = u ? Symbol.for('react.provider') : 60109,
                ea = u ? Symbol.for('react.context') : 60110,
                fa = u ? Symbol.for('react.concurrent_mode') : 60111,
                ha = u ? Symbol.for('react.forward_ref') : 60112,
                B = u ? Symbol.for('react.suspense') : 60113,
                ia = u ? Symbol.for('react.suspense_list') : 60120,
                ja = u ? Symbol.for('react.memo') : 60115,
                ka = u ? Symbol.for('react.lazy') : 60116,
                la = u ? Symbol.for('react.fundamental') : 60117,
                ma = u ? Symbol.for('react.scope') : 60119,
                C = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
            C.hasOwnProperty('ReactCurrentDispatcher') ||
                (C.ReactCurrentDispatcher = { current: null })
            C.hasOwnProperty('ReactCurrentBatchConfig') ||
                (C.ReactCurrentBatchConfig = { suspense: null })
            function na(a) {
                if (-1 === a._status) {
                    a._status = 0
                    var b = a._ctor
                    b = b()
                    a._result = b
                    b.then(
                        function(c) {
                            0 === a._status &&
                                ((c = c.default),
                                (a._status = 1),
                                (a._result = c))
                        },
                        function(c) {
                            0 === a._status &&
                                ((a._status = 2), (a._result = c))
                        }
                    )
                }
            }
            function D(a) {
                if (null == a) return null
                if ('function' === typeof a)
                    return a.displayName || a.name || null
                if ('string' === typeof a) return a
                switch (a) {
                    case v:
                        return 'Fragment'
                    case ba:
                        return 'Portal'
                    case da:
                        return 'Profiler'
                    case ca:
                        return 'StrictMode'
                    case B:
                        return 'Suspense'
                    case ia:
                        return 'SuspenseList'
                }
                if ('object' === typeof a)
                    switch (a.$$typeof) {
                        case ea:
                            return 'Context.Consumer'
                        case x:
                            return 'Context.Provider'
                        case ha:
                            var b = a.render
                            b = b.displayName || b.name || ''
                            return (
                                a.displayName ||
                                ('' !== b
                                    ? 'ForwardRef(' + b + ')'
                                    : 'ForwardRef')
                            )
                        case ja:
                            return D(a.type)
                        case ka:
                            if ((a = 1 === a._status ? a._result : null))
                                return D(a)
                    }
                return null
            }
            var oa = {}
            function E(a, b) {
                for (var c = a._threadCount | 0; c <= b; c++)
                    (a[c] = a._currentValue2), (a._threadCount = c + 1)
            }
            function pa(a, b, c, d) {
                if (
                    d &&
                    ((d = a.contextType), 'object' === typeof d && null !== d)
                )
                    return E(d, c), d[c]
                if ((a = a.contextTypes)) {
                    c = {}
                    for (var f in a) c[f] = b[f]
                    b = c
                } else b = oa
                return b
            }
            for (var F = new Uint16Array(16), H = 0; 15 > H; H++) F[H] = H + 1
            F[15] = 0
            var qa = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
                ra = Object.prototype.hasOwnProperty,
                sa = {},
                ta = {}
            function ua(a) {
                if (ra.call(ta, a)) return !0
                if (ra.call(sa, a)) return !1
                if (qa.test(a)) return (ta[a] = !0)
                sa[a] = !0
                return !1
            }
            function va(a, b, c, d) {
                if (null !== c && 0 === c.type) return !1
                switch (typeof b) {
                    case 'function':
                    case 'symbol':
                        return !0
                    case 'boolean':
                        if (d) return !1
                        if (null !== c) return !c.acceptsBooleans
                        a = a.toLowerCase().slice(0, 5)
                        return 'data-' !== a && 'aria-' !== a
                    default:
                        return !1
                }
            }
            function wa(a, b, c, d) {
                if (null === b || 'undefined' === typeof b || va(a, b, c, d))
                    return !0
                if (d) return !1
                if (null !== c)
                    switch (c.type) {
                        case 3:
                            return !b
                        case 4:
                            return !1 === b
                        case 5:
                            return isNaN(b)
                        case 6:
                            return isNaN(b) || 1 > b
                    }
                return !1
            }
            function J(a, b, c, d, f, h) {
                this.acceptsBooleans = 2 === b || 3 === b || 4 === b
                this.attributeName = d
                this.attributeNamespace = f
                this.mustUseProperty = c
                this.propertyName = a
                this.type = b
                this.sanitizeURL = h
            }
            var K = {}
            'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
                .split(' ')
                .forEach(function(a) {
                    K[a] = new J(a, 0, !1, a, null, !1)
                })
            ;[
                ['acceptCharset', 'accept-charset'],
                ['className', 'class'],
                ['htmlFor', 'for'],
                ['httpEquiv', 'http-equiv']
            ].forEach(function(a) {
                var b = a[0]
                K[b] = new J(b, 1, !1, a[1], null, !1)
            })
            ;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(
                function(a) {
                    K[a] = new J(a, 2, !1, a.toLowerCase(), null, !1)
                }
            )
            ;[
                'autoReverse',
                'externalResourcesRequired',
                'focusable',
                'preserveAlpha'
            ].forEach(function(a) {
                K[a] = new J(a, 2, !1, a, null, !1)
            })
            'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
                .split(' ')
                .forEach(function(a) {
                    K[a] = new J(a, 3, !1, a.toLowerCase(), null, !1)
                })
            ;['checked', 'multiple', 'muted', 'selected'].forEach(function(a) {
                K[a] = new J(a, 3, !0, a, null, !1)
            })
            ;['capture', 'download'].forEach(function(a) {
                K[a] = new J(a, 4, !1, a, null, !1)
            })
            ;['cols', 'rows', 'size', 'span'].forEach(function(a) {
                K[a] = new J(a, 6, !1, a, null, !1)
            })
            ;['rowSpan', 'start'].forEach(function(a) {
                K[a] = new J(a, 5, !1, a.toLowerCase(), null, !1)
            })
            var L = /[\-:]([a-z])/g
            function M(a) {
                return a[1].toUpperCase()
            }
            'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
                .split(' ')
                .forEach(function(a) {
                    var b = a.replace(L, M)
                    K[b] = new J(b, 1, !1, a, null, !1)
                })
            'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
                .split(' ')
                .forEach(function(a) {
                    var b = a.replace(L, M)
                    K[b] = new J(
                        b,
                        1,
                        !1,
                        a,
                        'http://www.w3.org/1999/xlink',
                        !1
                    )
                })
            ;['xml:base', 'xml:lang', 'xml:space'].forEach(function(a) {
                var b = a.replace(L, M)
                K[b] = new J(
                    b,
                    1,
                    !1,
                    a,
                    'http://www.w3.org/XML/1998/namespace',
                    !1
                )
            })
            ;['tabIndex', 'crossOrigin'].forEach(function(a) {
                K[a] = new J(a, 1, !1, a.toLowerCase(), null, !1)
            })
            K.xlinkHref = new J(
                'xlinkHref',
                1,
                !1,
                'xlink:href',
                'http://www.w3.org/1999/xlink',
                !0
            )
            ;['src', 'href', 'action', 'formAction'].forEach(function(a) {
                K[a] = new J(a, 1, !1, a.toLowerCase(), null, !0)
            })
            var xa = /["'&<>]/
            function N(a) {
                if ('boolean' === typeof a || 'number' === typeof a)
                    return '' + a
                a = '' + a
                var b = xa.exec(a)
                if (b) {
                    var c = '',
                        d,
                        f = 0
                    for (d = b.index; d < a.length; d++) {
                        switch (a.charCodeAt(d)) {
                            case 34:
                                b = '&quot;'
                                break
                            case 38:
                                b = '&amp;'
                                break
                            case 39:
                                b = '&#x27;'
                                break
                            case 60:
                                b = '&lt;'
                                break
                            case 62:
                                b = '&gt;'
                                break
                            default:
                                continue
                        }
                        f !== d && (c += a.substring(f, d))
                        f = d + 1
                        c += b
                    }
                    a = f !== d ? c + a.substring(f, d) : c
                }
                return a
            }
            function ya(a, b) {
                var c = K.hasOwnProperty(a) ? K[a] : null
                var d
                if ((d = 'style' !== a))
                    d =
                        null !== c
                            ? 0 === c.type
                            : !(2 < a.length) ||
                              ('o' !== a[0] && 'O' !== a[0]) ||
                              ('n' !== a[1] && 'N' !== a[1])
                            ? !1
                            : !0
                if (d || wa(a, b, c, !1)) return ''
                if (null !== c) {
                    a = c.attributeName
                    d = c.type
                    if (3 === d || (4 === d && !0 === b)) return a + '=""'
                    c.sanitizeURL && (b = '' + b)
                    return a + '=' + ('"' + N(b) + '"')
                }
                return ua(a) ? a + '=' + ('"' + N(b) + '"') : ''
            }
            function za(a, b) {
                return (
                    (a === b && (0 !== a || 1 / a === 1 / b)) ||
                    (a !== a && b !== b)
                )
            }
            var Aa = 'function' === typeof Object.is ? Object.is : za,
                O = null,
                P = null,
                Q = null,
                R = !1,
                S = !1,
                U = null,
                V = 0
            function W() {
                if (null === O) throw Error(r(321))
                return O
            }
            function Ba() {
                if (0 < V) throw Error(r(312))
                return { memoizedState: null, queue: null, next: null }
            }
            function Ca() {
                null === Q
                    ? null === P
                        ? ((R = !1), (P = Q = Ba()))
                        : ((R = !0), (Q = P))
                    : null === Q.next
                    ? ((R = !1), (Q = Q.next = Ba()))
                    : ((R = !0), (Q = Q.next))
                return Q
            }
            function Da(a, b, c, d) {
                for (; S; ) (S = !1), (V += 1), (Q = null), (c = a(b, d))
                P = O = null
                V = 0
                Q = U = null
                return c
            }
            function Ea(a, b) {
                return 'function' === typeof b ? b(a) : b
            }
            function Fa(a, b, c) {
                O = W()
                Q = Ca()
                if (R) {
                    var d = Q.queue
                    b = d.dispatch
                    if (null !== U && ((c = U.get(d)), void 0 !== c)) {
                        U.delete(d)
                        d = Q.memoizedState
                        do (d = a(d, c.action)), (c = c.next)
                        while (null !== c)
                        Q.memoizedState = d
                        return [d, b]
                    }
                    return [Q.memoizedState, b]
                }
                a =
                    a === Ea
                        ? 'function' === typeof b
                            ? b()
                            : b
                        : void 0 !== c
                        ? c(b)
                        : b
                Q.memoizedState = a
                a = Q.queue = { last: null, dispatch: null }
                a = a.dispatch = Ga.bind(null, O, a)
                return [Q.memoizedState, a]
            }
            function Ga(a, b, c) {
                if (!(25 > V)) throw Error(r(301))
                if (a === O)
                    if (
                        ((S = !0),
                        (a = { action: c, next: null }),
                        null === U && (U = new Map()),
                        (c = U.get(b)),
                        void 0 === c)
                    )
                        U.set(b, a)
                    else {
                        for (b = c; null !== b.next; ) b = b.next
                        b.next = a
                    }
            }
            function Ha() {}
            var X = 0,
                Ia = {
                    readContext: function(a) {
                        var b = X
                        E(a, b)
                        return a[b]
                    },
                    useContext: function(a) {
                        W()
                        var b = X
                        E(a, b)
                        return a[b]
                    },
                    useMemo: function(a, b) {
                        O = W()
                        Q = Ca()
                        b = void 0 === b ? null : b
                        if (null !== Q) {
                            var c = Q.memoizedState
                            if (null !== c && null !== b) {
                                a: {
                                    var d = c[1]
                                    if (null === d) d = !1
                                    else {
                                        for (
                                            var f = 0;
                                            f < d.length && f < b.length;
                                            f++
                                        )
                                            if (!Aa(b[f], d[f])) {
                                                d = !1
                                                break a
                                            }
                                        d = !0
                                    }
                                }
                                if (d) return c[0]
                            }
                        }
                        a = a()
                        Q.memoizedState = [a, b]
                        return a
                    },
                    useReducer: Fa,
                    useRef: function(a) {
                        O = W()
                        Q = Ca()
                        var b = Q.memoizedState
                        return null === b
                            ? ((a = { current: a }), (Q.memoizedState = a))
                            : b
                    },
                    useState: function(a) {
                        return Fa(Ea, a)
                    },
                    useLayoutEffect: function() {},
                    useCallback: function(a) {
                        return a
                    },
                    useImperativeHandle: Ha,
                    useEffect: Ha,
                    useDebugValue: Ha,
                    useResponder: function(a, b) {
                        return { props: b, responder: a }
                    },
                    useDeferredValue: function(a) {
                        W()
                        return a
                    },
                    useTransition: function() {
                        W()
                        return [
                            function(a) {
                                a()
                            },
                            !1
                        ]
                    }
                },
                Ja = {
                    html: 'http://www.w3.org/1999/xhtml',
                    mathml: 'http://www.w3.org/1998/Math/MathML',
                    svg: 'http://www.w3.org/2000/svg'
                }
            function Ka(a) {
                switch (a) {
                    case 'svg':
                        return 'http://www.w3.org/2000/svg'
                    case 'math':
                        return 'http://www.w3.org/1998/Math/MathML'
                    default:
                        return 'http://www.w3.org/1999/xhtml'
                }
            }
            var La = {
                    area: !0,
                    base: !0,
                    br: !0,
                    col: !0,
                    embed: !0,
                    hr: !0,
                    img: !0,
                    input: !0,
                    keygen: !0,
                    link: !0,
                    meta: !0,
                    param: !0,
                    source: !0,
                    track: !0,
                    wbr: !0
                },
                Ma = k({ menuitem: !0 }, La),
                Y = {
                    animationIterationCount: !0,
                    borderImageOutset: !0,
                    borderImageSlice: !0,
                    borderImageWidth: !0,
                    boxFlex: !0,
                    boxFlexGroup: !0,
                    boxOrdinalGroup: !0,
                    columnCount: !0,
                    columns: !0,
                    flex: !0,
                    flexGrow: !0,
                    flexPositive: !0,
                    flexShrink: !0,
                    flexNegative: !0,
                    flexOrder: !0,
                    gridArea: !0,
                    gridRow: !0,
                    gridRowEnd: !0,
                    gridRowSpan: !0,
                    gridRowStart: !0,
                    gridColumn: !0,
                    gridColumnEnd: !0,
                    gridColumnSpan: !0,
                    gridColumnStart: !0,
                    fontWeight: !0,
                    lineClamp: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    tabSize: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0,
                    fillOpacity: !0,
                    floodOpacity: !0,
                    stopOpacity: !0,
                    strokeDasharray: !0,
                    strokeDashoffset: !0,
                    strokeMiterlimit: !0,
                    strokeOpacity: !0,
                    strokeWidth: !0
                },
                Na = ['Webkit', 'ms', 'Moz', 'O']
            Object.keys(Y).forEach(function(a) {
                Na.forEach(function(b) {
                    b = b + a.charAt(0).toUpperCase() + a.substring(1)
                    Y[b] = Y[a]
                })
            })
            var Oa = /([A-Z])/g,
                Pa = /^ms-/,
                Z = m.Children.toArray,
                Qa = C.ReactCurrentDispatcher,
                Ra = { listing: !0, pre: !0, textarea: !0 },
                Sa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/,
                Ta = {},
                Ua = {}
            function Va(a) {
                if (void 0 === a || null === a) return a
                var b = ''
                m.Children.forEach(a, function(a) {
                    null != a && (b += a)
                })
                return b
            }
            var Wa = Object.prototype.hasOwnProperty,
                Xa = {
                    children: null,
                    dangerouslySetInnerHTML: null,
                    suppressContentEditableWarning: null,
                    suppressHydrationWarning: null
                }
            function Ya(a, b) {
                if (void 0 === a) throw Error(r(152, D(b) || 'Component'))
            }
            function Za(a, b, c) {
                function d(d, h) {
                    var e = h.prototype && h.prototype.isReactComponent,
                        f = pa(h, b, c, e),
                        p = [],
                        g = !1,
                        l = {
                            isMounted: function() {
                                return !1
                            },
                            enqueueForceUpdate: function() {
                                if (null === p) return null
                            },
                            enqueueReplaceState: function(a, c) {
                                g = !0
                                p = [c]
                            },
                            enqueueSetState: function(a, c) {
                                if (null === p) return null
                                p.push(c)
                            }
                        }
                    if (e) {
                        if (
                            ((e = new h(d.props, f, l)),
                            'function' === typeof h.getDerivedStateFromProps)
                        ) {
                            var w = h.getDerivedStateFromProps.call(
                                null,
                                d.props,
                                e.state
                            )
                            null != w && (e.state = k({}, e.state, w))
                        }
                    } else if (
                        ((O = {}),
                        (e = h(d.props, f, l)),
                        (e = Da(h, d.props, e, f)),
                        null == e || null == e.render)
                    ) {
                        a = e
                        Ya(a, h)
                        return
                    }
                    e.props = d.props
                    e.context = f
                    e.updater = l
                    l = e.state
                    void 0 === l && (e.state = l = null)
                    if (
                        'function' === typeof e.UNSAFE_componentWillMount ||
                        'function' === typeof e.componentWillMount
                    )
                        if (
                            ('function' === typeof e.componentWillMount &&
                                'function' !==
                                    typeof h.getDerivedStateFromProps &&
                                e.componentWillMount(),
                            'function' === typeof e.UNSAFE_componentWillMount &&
                                'function' !==
                                    typeof h.getDerivedStateFromProps &&
                                e.UNSAFE_componentWillMount(),
                            p.length)
                        ) {
                            l = p
                            var t = g
                            p = null
                            g = !1
                            if (t && 1 === l.length) e.state = l[0]
                            else {
                                w = t ? l[0] : e.state
                                var y = !0
                                for (t = t ? 1 : 0; t < l.length; t++) {
                                    var q = l[t]
                                    q =
                                        'function' === typeof q
                                            ? q.call(e, w, d.props, f)
                                            : q
                                    null != q &&
                                        (y
                                            ? ((y = !1), (w = k({}, w, q)))
                                            : k(w, q))
                                }
                                e.state = w
                            }
                        } else p = null
                    a = e.render()
                    Ya(a, h)
                    if (
                        'function' === typeof e.getChildContext &&
                        ((d = h.childContextTypes), 'object' === typeof d)
                    ) {
                        var A = e.getChildContext()
                        for (var T in A)
                            if (!(T in d))
                                throw Error(r(108, D(h) || 'Unknown', T))
                    }
                    A && (b = k({}, b, A))
                }
                for (; m.isValidElement(a); ) {
                    var f = a,
                        h = f.type
                    if ('function' !== typeof h) break
                    d(f, h)
                }
                return { child: a, context: b }
            }
            var $a = (function() {
                function a(a, b) {
                    m.isValidElement(a)
                        ? a.type !== v
                            ? (a = [a])
                            : ((a = a.props.children),
                              (a = m.isValidElement(a) ? [a] : Z(a)))
                        : (a = Z(a))
                    a = {
                        type: null,
                        domNamespace: Ja.html,
                        children: a,
                        childIndex: 0,
                        context: oa,
                        footer: ''
                    }
                    var c = F[0]
                    if (0 === c) {
                        var d = F
                        c = d.length
                        var p = 2 * c
                        if (!(65536 >= p)) throw Error(r(304))
                        var g = new Uint16Array(p)
                        g.set(d)
                        F = g
                        F[0] = c + 1
                        for (d = c; d < p - 1; d++) F[d] = d + 1
                        F[p - 1] = 0
                    } else F[0] = F[c]
                    this.threadID = c
                    this.stack = [a]
                    this.exhausted = !1
                    this.currentSelectValue = null
                    this.previousWasTextNode = !1
                    this.makeStaticMarkup = b
                    this.suspenseDepth = 0
                    this.contextIndex = -1
                    this.contextStack = []
                    this.contextValueStack = []
                }
                var b = a.prototype
                b.destroy = function() {
                    if (!this.exhausted) {
                        this.exhausted = !0
                        this.clearProviders()
                        var a = this.threadID
                        F[a] = F[0]
                        F[0] = a
                    }
                }
                b.pushProvider = function(a) {
                    var b = ++this.contextIndex,
                        c = a.type._context,
                        h = this.threadID
                    E(c, h)
                    var p = c[h]
                    this.contextStack[b] = c
                    this.contextValueStack[b] = p
                    c[h] = a.props.value
                }
                b.popProvider = function() {
                    var a = this.contextIndex,
                        b = this.contextStack[a],
                        f = this.contextValueStack[a]
                    this.contextStack[a] = null
                    this.contextValueStack[a] = null
                    this.contextIndex--
                    b[this.threadID] = f
                }
                b.clearProviders = function() {
                    for (var a = this.contextIndex; 0 <= a; a--)
                        this.contextStack[a][
                            this.threadID
                        ] = this.contextValueStack[a]
                }
                b.read = function(a) {
                    if (this.exhausted) return null
                    var b = X
                    X = this.threadID
                    var c = Qa.current
                    Qa.current = Ia
                    try {
                        for (var h = [''], p = !1; h[0].length < a; ) {
                            if (0 === this.stack.length) {
                                this.exhausted = !0
                                var g = this.threadID
                                F[g] = F[0]
                                F[0] = g
                                break
                            }
                            var e = this.stack[this.stack.length - 1]
                            if (p || e.childIndex >= e.children.length) {
                                var I = e.footer
                                '' !== I && (this.previousWasTextNode = !1)
                                this.stack.pop()
                                if ('select' === e.type)
                                    this.currentSelectValue = null
                                else if (
                                    null != e.type &&
                                    null != e.type.type &&
                                    e.type.type.$$typeof === x
                                )
                                    this.popProvider(e.type)
                                else if (e.type === B) {
                                    this.suspenseDepth--
                                    var G = h.pop()
                                    if (p) {
                                        p = !1
                                        var n = e.fallbackFrame
                                        if (!n) throw Error(r(303))
                                        this.stack.push(n)
                                        h[this.suspenseDepth] +=
                                            '\x3c!--$!--\x3e'
                                        continue
                                    } else h[this.suspenseDepth] += G
                                }
                                h[this.suspenseDepth] += I
                            } else {
                                var l = e.children[e.childIndex++],
                                    w = ''
                                try {
                                    w += this.render(
                                        l,
                                        e.context,
                                        e.domNamespace
                                    )
                                } catch (t) {
                                    if (
                                        null != t &&
                                        'function' === typeof t.then
                                    )
                                        throw Error(r(294))
                                    throw t
                                } finally {
                                }
                                h.length <= this.suspenseDepth && h.push('')
                                h[this.suspenseDepth] += w
                            }
                        }
                        return h[0]
                    } finally {
                        ;(Qa.current = c), (X = b)
                    }
                }
                b.render = function(a, b, f) {
                    if ('string' === typeof a || 'number' === typeof a) {
                        f = '' + a
                        if ('' === f) return ''
                        if (this.makeStaticMarkup) return N(f)
                        if (this.previousWasTextNode)
                            return '\x3c!-- --\x3e' + N(f)
                        this.previousWasTextNode = !0
                        return N(f)
                    }
                    b = Za(a, b, this.threadID)
                    a = b.child
                    b = b.context
                    if (null === a || !1 === a) return ''
                    if (!m.isValidElement(a)) {
                        if (null != a && null != a.$$typeof) {
                            f = a.$$typeof
                            if (f === ba) throw Error(r(257))
                            throw Error(r(258, f.toString()))
                        }
                        a = Z(a)
                        this.stack.push({
                            type: null,
                            domNamespace: f,
                            children: a,
                            childIndex: 0,
                            context: b,
                            footer: ''
                        })
                        return ''
                    }
                    var c = a.type
                    if ('string' === typeof c) return this.renderDOM(a, b, f)
                    switch (c) {
                        case ca:
                        case fa:
                        case da:
                        case ia:
                        case v:
                            return (
                                (a = Z(a.props.children)),
                                this.stack.push({
                                    type: null,
                                    domNamespace: f,
                                    children: a,
                                    childIndex: 0,
                                    context: b,
                                    footer: ''
                                }),
                                ''
                            )
                        case B:
                            throw Error(r(294))
                    }
                    if ('object' === typeof c && null !== c)
                        switch (c.$$typeof) {
                            case ha:
                                O = {}
                                var d = c.render(a.props, a.ref)
                                d = Da(c.render, a.props, d, a.ref)
                                d = Z(d)
                                this.stack.push({
                                    type: null,
                                    domNamespace: f,
                                    children: d,
                                    childIndex: 0,
                                    context: b,
                                    footer: ''
                                })
                                return ''
                            case ja:
                                return (
                                    (a = [
                                        m.createElement(
                                            c.type,
                                            k({ ref: a.ref }, a.props)
                                        )
                                    ]),
                                    this.stack.push({
                                        type: null,
                                        domNamespace: f,
                                        children: a,
                                        childIndex: 0,
                                        context: b,
                                        footer: ''
                                    }),
                                    ''
                                )
                            case x:
                                return (
                                    (c = Z(a.props.children)),
                                    (f = {
                                        type: a,
                                        domNamespace: f,
                                        children: c,
                                        childIndex: 0,
                                        context: b,
                                        footer: ''
                                    }),
                                    this.pushProvider(a),
                                    this.stack.push(f),
                                    ''
                                )
                            case ea:
                                c = a.type
                                d = a.props
                                var g = this.threadID
                                E(c, g)
                                c = Z(d.children(c[g]))
                                this.stack.push({
                                    type: a,
                                    domNamespace: f,
                                    children: c,
                                    childIndex: 0,
                                    context: b,
                                    footer: ''
                                })
                                return ''
                            case la:
                                throw Error(r(338))
                            case ka:
                                switch (((c = a.type), na(c), c._status)) {
                                    case 1:
                                        return (
                                            (a = [
                                                m.createElement(
                                                    c._result,
                                                    k({ ref: a.ref }, a.props)
                                                )
                                            ]),
                                            this.stack.push({
                                                type: null,
                                                domNamespace: f,
                                                children: a,
                                                childIndex: 0,
                                                context: b,
                                                footer: ''
                                            }),
                                            ''
                                        )
                                    case 2:
                                        throw c._result
                                    default:
                                        throw Error(r(295))
                                }
                            case ma:
                                throw Error(r(343))
                        }
                    throw Error(r(130, null == c ? c : typeof c, ''))
                }
                b.renderDOM = function(a, b, f) {
                    var c = a.type.toLowerCase()
                    f === Ja.html && Ka(c)
                    if (!Ta.hasOwnProperty(c)) {
                        if (!Sa.test(c)) throw Error(r(65, c))
                        Ta[c] = !0
                    }
                    var d = a.props
                    if ('input' === c)
                        d = k({ type: void 0 }, d, {
                            defaultChecked: void 0,
                            defaultValue: void 0,
                            value: null != d.value ? d.value : d.defaultValue,
                            checked:
                                null != d.checked ? d.checked : d.defaultChecked
                        })
                    else if ('textarea' === c) {
                        var g = d.value
                        if (null == g) {
                            g = d.defaultValue
                            var e = d.children
                            if (null != e) {
                                if (null != g) throw Error(r(92))
                                if (Array.isArray(e)) {
                                    if (!(1 >= e.length)) throw Error(r(93))
                                    e = e[0]
                                }
                                g = '' + e
                            }
                            null == g && (g = '')
                        }
                        d = k({}, d, { value: void 0, children: '' + g })
                    } else if ('select' === c)
                        (this.currentSelectValue =
                            null != d.value ? d.value : d.defaultValue),
                            (d = k({}, d, { value: void 0 }))
                    else if ('option' === c) {
                        e = this.currentSelectValue
                        var I = Va(d.children)
                        if (null != e) {
                            var G = null != d.value ? d.value + '' : I
                            g = !1
                            if (Array.isArray(e))
                                for (var n = 0; n < e.length; n++) {
                                    if ('' + e[n] === G) {
                                        g = !0
                                        break
                                    }
                                }
                            else g = '' + e === G
                            d = k({ selected: void 0, children: void 0 }, d, {
                                selected: g,
                                children: I
                            })
                        }
                    }
                    if ((g = d)) {
                        if (
                            Ma[c] &&
                            (null != g.children ||
                                null != g.dangerouslySetInnerHTML)
                        )
                            throw Error(r(137, c, ''))
                        if (null != g.dangerouslySetInnerHTML) {
                            if (null != g.children) throw Error(r(60))
                            if (
                                !(
                                    'object' ===
                                        typeof g.dangerouslySetInnerHTML &&
                                    '__html' in g.dangerouslySetInnerHTML
                                )
                            )
                                throw Error(r(61))
                        }
                        if (null != g.style && 'object' !== typeof g.style)
                            throw Error(r(62, ''))
                    }
                    g = d
                    e = this.makeStaticMarkup
                    I = 1 === this.stack.length
                    G = '<' + a.type
                    for (z in g)
                        if (Wa.call(g, z)) {
                            var l = g[z]
                            if (null != l) {
                                if ('style' === z) {
                                    n = void 0
                                    var w = '',
                                        t = ''
                                    for (n in l)
                                        if (l.hasOwnProperty(n)) {
                                            var y = 0 === n.indexOf('--'),
                                                q = l[n]
                                            if (null != q) {
                                                if (y) var A = n
                                                else if (
                                                    ((A = n),
                                                    Ua.hasOwnProperty(A))
                                                )
                                                    A = Ua[A]
                                                else {
                                                    var T = A.replace(Oa, '-$1')
                                                        .toLowerCase()
                                                        .replace(Pa, '-ms-')
                                                    A = Ua[A] = T
                                                }
                                                w += t + A + ':'
                                                t = n
                                                y =
                                                    null == q ||
                                                    'boolean' === typeof q ||
                                                    '' === q
                                                        ? ''
                                                        : y ||
                                                          'number' !==
                                                              typeof q ||
                                                          0 === q ||
                                                          (Y.hasOwnProperty(
                                                              t
                                                          ) &&
                                                              Y[t])
                                                        ? ('' + q).trim()
                                                        : q + 'px'
                                                w += y
                                                t = ';'
                                            }
                                        }
                                    l = w || null
                                }
                                n = null
                                b: if (
                                    ((y = c), (q = g), -1 === y.indexOf('-'))
                                )
                                    y = 'string' === typeof q.is
                                else
                                    switch (y) {
                                        case 'annotation-xml':
                                        case 'color-profile':
                                        case 'font-face':
                                        case 'font-face-src':
                                        case 'font-face-uri':
                                        case 'font-face-format':
                                        case 'font-face-name':
                                        case 'missing-glyph':
                                            y = !1
                                            break b
                                        default:
                                            y = !0
                                    }
                                y
                                    ? Xa.hasOwnProperty(z) ||
                                      ((n = z),
                                      (n =
                                          ua(n) && null != l
                                              ? n + '=' + ('"' + N(l) + '"')
                                              : ''))
                                    : (n = ya(z, l))
                                n && (G += ' ' + n)
                            }
                        }
                    e || (I && (G += ' data-reactroot=""'))
                    var z = G
                    g = ''
                    La.hasOwnProperty(c)
                        ? (z += '/>')
                        : ((z += '>'), (g = '</' + a.type + '>'))
                    a: {
                        e = d.dangerouslySetInnerHTML
                        if (null != e) {
                            if (null != e.__html) {
                                e = e.__html
                                break a
                            }
                        } else if (
                            ((e = d.children),
                            'string' === typeof e || 'number' === typeof e)
                        ) {
                            e = N(e)
                            break a
                        }
                        e = null
                    }
                    null != e
                        ? ((d = []),
                          Ra[c] && '\n' === e.charAt(0) && (z += '\n'),
                          (z += e))
                        : (d = Z(d.children))
                    a = a.type
                    f =
                        null == f || 'http://www.w3.org/1999/xhtml' === f
                            ? Ka(a)
                            : 'http://www.w3.org/2000/svg' === f &&
                              'foreignObject' === a
                            ? 'http://www.w3.org/1999/xhtml'
                            : f
                    this.stack.push({
                        domNamespace: f,
                        type: c,
                        children: d,
                        childIndex: 0,
                        context: b,
                        footer: g
                    })
                    this.previousWasTextNode = !1
                    return z
                }
                return a
            })()
            function ab(a, b) {
                a.prototype = Object.create(b.prototype)
                a.prototype.constructor = a
                a.__proto__ = b
            }
            var bb = (function(a) {
                    function b(b, c) {
                        var d = a.call(this, {}) || this
                        d.partialRenderer = new $a(b, c)
                        return d
                    }
                    ab(b, a)
                    var c = b.prototype
                    c._destroy = function(a, b) {
                        this.partialRenderer.destroy()
                        b(a)
                    }
                    c._read = function(a) {
                        try {
                            this.push(this.partialRenderer.read(a))
                        } catch (f) {
                            this.destroy(f)
                        }
                    }
                    return b
                })(aa.Readable),
                cb = {
                    renderToString: function(a) {
                        a = new $a(a, !1)
                        try {
                            return a.read(Infinity)
                        } finally {
                            a.destroy()
                        }
                    },
                    renderToStaticMarkup: function(a) {
                        a = new $a(a, !0)
                        try {
                            return a.read(Infinity)
                        } finally {
                            a.destroy()
                        }
                    },
                    renderToNodeStream: function(a) {
                        return new bb(a, !1)
                    },
                    renderToStaticNodeStream: function(a) {
                        return new bb(a, !0)
                    },
                    version: '16.12.0'
                },
                db = { default: cb },
                eb = (db && cb) || db
            module.exports = eb.default || eb

            /***/
        },

        /***/ FGiv: /***/ function(module, exports) {
            /**
             * Helpers.
             */

            var s = 1000
            var m = s * 60
            var h = m * 60
            var d = h * 24
            var y = d * 365.25

            /**
             * Parse or format the given `val`.
             *
             * Options:
             *
             *  - `long` verbose formatting [false]
             *
             * @param {String|Number} val
             * @param {Object} [options]
             * @throws {Error} throw an error if val is not a non-empty string or a number
             * @return {String|Number}
             * @api public
             */

            module.exports = function(val, options) {
                options = options || {}
                var type = typeof val
                if (type === 'string' && val.length > 0) {
                    return parse(val)
                } else if (type === 'number' && isNaN(val) === false) {
                    return options.long ? fmtLong(val) : fmtShort(val)
                }
                throw new Error(
                    'val is not a non-empty string or a valid number. val=' +
                        JSON.stringify(val)
                )
            }

            /**
             * Parse the given `str` and return milliseconds.
             *
             * @param {String} str
             * @return {Number}
             * @api private
             */

            function parse(str) {
                str = String(str)
                if (str.length > 100) {
                    return
                }
                var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
                    str
                )
                if (!match) {
                    return
                }
                var n = parseFloat(match[1])
                var type = (match[2] || 'ms').toLowerCase()
                switch (type) {
                    case 'years':
                    case 'year':
                    case 'yrs':
                    case 'yr':
                    case 'y':
                        return n * y
                    case 'days':
                    case 'day':
                    case 'd':
                        return n * d
                    case 'hours':
                    case 'hour':
                    case 'hrs':
                    case 'hr':
                    case 'h':
                        return n * h
                    case 'minutes':
                    case 'minute':
                    case 'mins':
                    case 'min':
                    case 'm':
                        return n * m
                    case 'seconds':
                    case 'second':
                    case 'secs':
                    case 'sec':
                    case 's':
                        return n * s
                    case 'milliseconds':
                    case 'millisecond':
                    case 'msecs':
                    case 'msec':
                    case 'ms':
                        return n
                    default:
                        return undefined
                }
            }

            /**
             * Short format for `ms`.
             *
             * @param {Number} ms
             * @return {String}
             * @api private
             */

            function fmtShort(ms) {
                if (ms >= d) {
                    return Math.round(ms / d) + 'd'
                }
                if (ms >= h) {
                    return Math.round(ms / h) + 'h'
                }
                if (ms >= m) {
                    return Math.round(ms / m) + 'm'
                }
                if (ms >= s) {
                    return Math.round(ms / s) + 's'
                }
                return ms + 'ms'
            }

            /**
             * Long format for `ms`.
             *
             * @param {Number} ms
             * @return {String}
             * @api private
             */

            function fmtLong(ms) {
                return (
                    plural(ms, d, 'day') ||
                    plural(ms, h, 'hour') ||
                    plural(ms, m, 'minute') ||
                    plural(ms, s, 'second') ||
                    ms + ' ms'
                )
            }

            /**
             * Pluralization helper.
             */

            function plural(ms, n, name) {
                if (ms < n) {
                    return
                }
                if (ms < n * 1.5) {
                    return Math.floor(ms / n) + ' ' + name
                }
                return Math.ceil(ms / n) + ' ' + name + 's'
            }

            /***/
        },

        /***/ FMKJ: /***/ function(module, exports) {
            module.exports = require('zlib')

            /***/
        },

        /***/ 'FUB/': /***/ function(module, exports, __webpack_require__) {
            const { JWKKeySupport, JOSENotSupported } = __webpack_require__(
                'yt7c'
            )
            const {
                KEY_MANAGEMENT_ENCRYPT,
                KEY_MANAGEMENT_DECRYPT
            } = __webpack_require__('ehsS')

            const { JWA, JWK } = __webpack_require__('N+nT')

            // sign, verify
            __webpack_require__('IWF7')(JWA, JWK)
            __webpack_require__('/sST')(JWA, JWK)
            __webpack_require__('MoRj')(JWA, JWK)
            __webpack_require__('hnhG')(JWA, JWK)
            __webpack_require__('5fWB')(JWA, JWK)
            __webpack_require__('w8yO')(JWA)

            // encrypt, decrypt
            __webpack_require__('d4WF')(JWA, JWK)
            __webpack_require__('BJV5')(JWA, JWK)

            // wrapKey, unwrapKey
            __webpack_require__('hk9D')(JWA, JWK)
            __webpack_require__('bUME')(JWA, JWK)
            __webpack_require__('xfr8')(JWA, JWK)

            // deriveKey
            __webpack_require__('q2Us')(JWA, JWK)
            __webpack_require__('C/Kw')(JWA, JWK)
            __webpack_require__('n8pu')(JWA, JWK)

            const check = (key, op, alg) => {
                const cache = `_${op}_${alg}`

                let label
                let keyOp
                if (op === 'keyManagementEncrypt') {
                    label = 'key management (encryption)'
                    keyOp = KEY_MANAGEMENT_ENCRYPT
                } else if (op === 'keyManagementDecrypt') {
                    label = 'key management (decryption)'
                    keyOp = KEY_MANAGEMENT_DECRYPT
                }

                if (cache in key) {
                    if (key[cache]) {
                        return
                    }
                    throw new JWKKeySupport(
                        `the key does not support ${alg} ${label ||
                            op} algorithm`
                    )
                }

                let value = true
                if (!JWA[op].has(alg)) {
                    throw new JOSENotSupported(
                        `unsupported ${label || op} alg: ${alg}`
                    )
                } else if (!key.algorithms(keyOp).has(alg)) {
                    value = false
                }

                Object.defineProperty(key, cache, { value, enumerable: false })

                if (!value) {
                    return check(key, op, alg)
                }
            }

            module.exports = {
                check,
                sign: (alg, key, payload) => {
                    check(key, 'sign', alg)
                    return JWA.sign.get(alg)(key, payload)
                },
                verify: (alg, key, payload, signature) => {
                    check(key, 'verify', alg)
                    return JWA.verify.get(alg)(key, payload, signature)
                },
                keyManagementEncrypt: (alg, key, payload, opts) => {
                    check(key, 'keyManagementEncrypt', alg)
                    return JWA.keyManagementEncrypt.get(alg)(key, payload, opts)
                },
                keyManagementDecrypt: (alg, key, payload, opts) => {
                    check(key, 'keyManagementDecrypt', alg)
                    return JWA.keyManagementDecrypt.get(alg)(key, payload, opts)
                },
                encrypt: (alg, key, cleartext, opts) => {
                    check(key, 'encrypt', alg)
                    return JWA.encrypt.get(alg)(key, cleartext, opts)
                },
                decrypt: (alg, key, ciphertext, opts) => {
                    check(key, 'decrypt', alg)
                    return JWA.decrypt.get(alg)(key, ciphertext, opts)
                }
            }

            /***/
        },

        /***/ FYa8: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$defineProperty = __webpack_require__('hfKm')

            var __importStar =
                (this && this.__importStar) ||
                function(mod) {
                    if (mod && mod.__esModule) return mod
                    var result = {}
                    if (mod != null)
                        for (var k in mod)
                            if (Object.hasOwnProperty.call(mod, k))
                                result[k] = mod[k]
                    result['default'] = mod
                    return result
                }

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            const React = __importStar(__webpack_require__('q1tI'))

            exports.HeadManagerContext = React.createContext(null)

            /***/
        },

        /***/ FZoo: /***/ function(module, exports, __webpack_require__) {
            var assignValue = __webpack_require__('MrPd'),
                castPath = __webpack_require__('4uTw'),
                isIndex = __webpack_require__('wJg7'),
                isObject = __webpack_require__('GoyQ'),
                toKey = __webpack_require__('9Nap')

            /**
             * The base implementation of `_.set`.
             *
             * @private
             * @param {Object} object The object to modify.
             * @param {Array|string} path The path of the property to set.
             * @param {*} value The value to set.
             * @param {Function} [customizer] The function to customize path creation.
             * @returns {Object} Returns `object`.
             */
            function baseSet(object, path, value, customizer) {
                if (!isObject(object)) {
                    return object
                }
                path = castPath(path, object)

                var index = -1,
                    length = path.length,
                    lastIndex = length - 1,
                    nested = object

                while (nested != null && ++index < length) {
                    var key = toKey(path[index]),
                        newValue = value

                    if (index != lastIndex) {
                        var objValue = nested[key]
                        newValue = customizer
                            ? customizer(objValue, key, nested)
                            : undefined
                        if (newValue === undefined) {
                            newValue = isObject(objValue)
                                ? objValue
                                : isIndex(path[index + 1])
                                ? []
                                : {}
                        }
                    }
                    assignValue(nested, key, newValue)
                    nested = nested[key]
                }
                return object
            }

            module.exports = baseSet

            /***/
        },

        /***/ FlQf: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var $at = __webpack_require__('ccE7')(true)

            // 21.1.3.27 String.prototype[@@iterator]()
            __webpack_require__('MPFp')(
                String,
                'String',
                function(iterated) {
                    this._t = String(iterated) // target
                    this._i = 0 // next index
                    // 21.1.5.2.1 %StringIteratorPrototype%.next()
                },
                function() {
                    var O = this._t
                    var index = this._i
                    var point
                    if (index >= O.length)
                        return { value: undefined, done: true }
                    point = $at(O, index)
                    this._i += point.length
                    return { value: point, done: false }
                }
            )

            /***/
        },

        /***/ 'Fo+H': /***/ function(module, exports) {
            module.exports = {
                sign: new Map(),
                verify: new Map(),
                keyManagementEncrypt: new Map(),
                keyManagementDecrypt: new Map(),
                encrypt: new Map(),
                decrypt: new Map()
            }

            /***/
        },

        /***/ 'Fow+': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Stringify = __webpack_require__('VraX')

            const internals = {}

            module.exports = class extends Error {
                constructor(args) {
                    const msgs = args
                        .filter(arg => arg !== '')
                        .map(arg => {
                            return typeof arg === 'string'
                                ? arg
                                : arg instanceof Error
                                ? arg.message
                                : Stringify(arg)
                        })

                    super(msgs.join(' ') || 'Unknown error')

                    if (typeof Error.captureStackTrace === 'function') {
                        // $lab:coverage:ignore$
                        Error.captureStackTrace(this, exports.assert)
                    }
                }
            }

            /***/
        },

        /***/ FpHa: /***/ function(module, exports) {
            // IE 8- don't enum bug keys
            module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(
                ','
            )

            /***/
        },

        /***/ Fw1r: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = __webpack_require__('pV7Z')

            /***/
        },

        /***/ G4HQ: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('m5qO')

            /***/
        },

        /***/ G6z8: /***/ function(module, exports, __webpack_require__) {
            var baseGetAllKeys = __webpack_require__('fR/l'),
                getSymbolsIn = __webpack_require__('oCl/'),
                keysIn = __webpack_require__('mTTR')

            /**
             * Creates an array of own and inherited enumerable property names and
             * symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names and symbols.
             */
            function getAllKeysIn(object) {
                return baseGetAllKeys(object, keysIn, getSymbolsIn)
            }

            module.exports = getAllKeysIn

            /***/
        },

        /***/ G8Mo: /***/ function(module, exports, __webpack_require__) {
            // 7.1.1 ToPrimitive(input [, PreferredType])
            var isObject = __webpack_require__('93I4')
            // instead of the ES6 spec version, we didn't implement @@toPrimitive case
            // and the second argument - flag - preferred type is a string
            module.exports = function(it, S) {
                if (!isObject(it)) return it
                var fn, val
                if (
                    S &&
                    typeof (fn = it.toString) == 'function' &&
                    !isObject((val = fn.call(it)))
                )
                    return val
                if (
                    typeof (fn = it.valueOf) == 'function' &&
                    !isObject((val = fn.call(it)))
                )
                    return val
                if (
                    !S &&
                    typeof (fn = it.toString) == 'function' &&
                    !isObject((val = fn.call(it)))
                )
                    return val
                throw TypeError("Can't convert object to primitive value")
            }

            /***/
        },

        /***/ GCLL: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Assert = __webpack_require__('GlC0')

            const internals = {}

            module.exports = function(attribute) {
                // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

                Assert(
                    /^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(
                        attribute
                    ),
                    'Bad attribute value (' + attribute + ')'
                )

                return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"') // Escape quotes and slash
            }

            /***/
        },

        /***/ GDhZ: /***/ function(module, exports, __webpack_require__) {
            var baseIsEqual = __webpack_require__('wF/u'),
                get = __webpack_require__('mwIZ'),
                hasIn = __webpack_require__('hgQt'),
                isKey = __webpack_require__('9ggG'),
                isStrictComparable = __webpack_require__('CMye'),
                matchesStrictComparable = __webpack_require__('IOzZ'),
                toKey = __webpack_require__('9Nap')

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1,
                COMPARE_UNORDERED_FLAG = 2

            /**
             * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
             *
             * @private
             * @param {string} path The path of the property to get.
             * @param {*} srcValue The value to match.
             * @returns {Function} Returns the new spec function.
             */
            function baseMatchesProperty(path, srcValue) {
                if (isKey(path) && isStrictComparable(srcValue)) {
                    return matchesStrictComparable(toKey(path), srcValue)
                }
                return function(object) {
                    var objValue = get(object, path)
                    return objValue === undefined && objValue === srcValue
                        ? hasIn(object, path)
                        : baseIsEqual(
                              srcValue,
                              objValue,
                              COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG
                          )
                }
            }

            module.exports = baseMatchesProperty

            /***/
        },

        /***/ GNiM: /***/ function(module, exports, __webpack_require__) {
            var memoizeCapped = __webpack_require__('I01J')

            /** Used to match property names within property paths. */
            var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g

            /** Used to match backslashes in property paths. */
            var reEscapeChar = /\\(\\)?/g

            /**
             * Converts `string` to a property path array.
             *
             * @private
             * @param {string} string The string to convert.
             * @returns {Array} Returns the property path array.
             */
            var stringToPath = memoizeCapped(function(string) {
                var result = []
                if (string.charCodeAt(0) === 46 /* . */) {
                    result.push('')
                }
                string.replace(rePropName, function(
                    match,
                    number,
                    quote,
                    subString
                ) {
                    result.push(
                        quote
                            ? subString.replace(reEscapeChar, '$1')
                            : number || match
                    )
                })
                return result
            })

            module.exports = stringToPath

            /***/
        },

        /***/ GX0O: /***/ function(
            module,
            __webpack_exports__,
            __webpack_require__
        ) {
            'use strict'
            __webpack_require__.r(__webpack_exports__)

            /* harmony default export */ __webpack_exports__[
                'default'
            ] = function(ctx) {
                return Promise.all([])
            }

            /***/
        },

        /***/ GhER: /***/ function(module, exports, __webpack_require__) {
            const { deprecate } = __webpack_require__('jK02')

            const {
                createPublicKey,
                createPrivateKey,
                createSecretKey,
                KeyObject
            } = __webpack_require__('1ALl')
            const base64url = __webpack_require__('Xab3')
            const isObject = __webpack_require__('kF1/')
            const { jwkToPem } = __webpack_require__('gXwc')
            const errors = __webpack_require__('yt7c')

            const RSAKey = __webpack_require__('RoCg')
            const ECKey = __webpack_require__('3HlQ')
            const OKPKey = __webpack_require__('vC2k')
            const OctKey = __webpack_require__('BBt9')

            const importable = new Set(['string', 'buffer', 'object'])

            const mergedParameters = (target = {}, source = {}) => {
                return {
                    alg: source.alg,
                    key_ops: source.key_ops,
                    kid: source.kid,
                    use: source.use,
                    x5c: source.x5c,
                    x5t: source.x5t,
                    'x5t#S256': source['x5t#S256'],
                    ...target
                }
            }

            const openSSHpublicKey = /^[a-zA-Z0-9-]+ (?:[a-zA-Z0-9+/])*(?:==|=)?(?: .*)?$/

            const asKey = (
                key,
                parameters,
                { calculateMissingRSAPrimes = false } = {}
            ) => {
                let privateKey, publicKey, secret

                if (!importable.has(typeof key)) {
                    throw new TypeError(
                        'key argument must be a string, buffer or an object'
                    )
                }

                if (parameters !== undefined && !isObject(parameters)) {
                    throw new TypeError(
                        'parameters argument must be a plain object when provided'
                    )
                }

                if (key instanceof KeyObject) {
                    switch (key.type) {
                        case 'private':
                            privateKey = key
                            break
                        case 'public':
                            publicKey = key
                            break
                        case 'secret':
                            secret = key
                            break
                    }
                } else if (
                    typeof key === 'object' &&
                    key &&
                    'kty' in key &&
                    key.kty === 'oct'
                ) {
                    // symmetric key <Object>
                    try {
                        secret = createSecretKey(
                            base64url.decodeToBuffer(key.k)
                        )
                    } catch (err) {
                        if (!('k' in key)) {
                            secret = { type: 'secret' }
                        }
                    }
                    parameters = mergedParameters(parameters, key)
                } else if (typeof key === 'object' && key && 'kty' in key) {
                    // assume JWK formatted asymmetric key <Object>
                    ;({ calculateMissingRSAPrimes = false } = parameters || {
                        calculateMissingRSAPrimes
                    })
                    let pem

                    try {
                        pem = jwkToPem(key, { calculateMissingRSAPrimes })
                    } catch (err) {
                        if (err instanceof errors.JOSEError) {
                            throw err
                        }
                    }

                    if (pem && key.d) {
                        privateKey = createPrivateKey(pem)
                    } else if (pem) {
                        publicKey = createPublicKey(pem)
                    }

                    parameters = mergedParameters({}, key)
                } else if (
                    key &&
                    (typeof key === 'object' || typeof key === 'string')
                ) {
                    // <Object> | <string> | <Buffer> passed to crypto.createPrivateKey or crypto.createPublicKey or <Buffer> passed to crypto.createSecretKey
                    try {
                        privateKey = createPrivateKey(key)
                    } catch (err) {
                        if (err instanceof errors.JOSEError) {
                            throw err
                        }
                    }

                    try {
                        publicKey = createPublicKey(key)
                        if (
                            key.startsWith('-----BEGIN CERTIFICATE-----') &&
                            (!parameters || !('x5c' in parameters))
                        ) {
                            parameters = mergedParameters(parameters, {
                                x5c: [
                                    key.replace(
                                        /(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g,
                                        ''
                                    )
                                ]
                            })
                        }
                    } catch (err) {
                        if (err instanceof errors.JOSEError) {
                            throw err
                        }
                    }

                    try {
                        // this is to filter out invalid PEM keys and certs, i'll rather have them fail import then
                        // have them imported as symmetric "oct" keys
                        if (
                            !key.includes('-----BEGIN') &&
                            !openSSHpublicKey.test(
                                key.toString('ascii').replace(/[\r\n]/g, '')
                            )
                        ) {
                            secret = createSecretKey(
                                Buffer.isBuffer(key) ? key : Buffer.from(key)
                            )
                        }
                    } catch (err) {}
                }

                const keyObject = privateKey || publicKey || secret

                if (privateKey || publicKey) {
                    switch (keyObject.asymmetricKeyType) {
                        case 'rsa':
                            return new RSAKey(keyObject, parameters)
                        case 'ec':
                            return new ECKey(keyObject, parameters)
                        case 'ed25519':
                        case 'ed448':
                        case 'x25519':
                        case 'x448':
                            return new OKPKey(keyObject, parameters)
                        default:
                            throw new errors.JOSENotSupported(
                                'only RSA, EC and OKP asymmetric keys are supported'
                            )
                    }
                } else if (secret) {
                    return new OctKey(keyObject, parameters)
                }

                throw new errors.JWKImportFailed('key import failed')
            }

            module.exports = asKey
            Object.defineProperty(asKey, 'deprecated', {
                value: deprecate((key, parameters) => {
                    return asKey(key, parameters, {
                        calculateMissingRSAPrimes: true
                    })
                }, 'JWK.importKey() is deprecated, use JWK.asKey() instead'),
                enumerable: false
            })

            /***/
        },

        /***/ Gi0A: /***/ function(module, exports, __webpack_require__) {
            var getTag = __webpack_require__('QqLw'),
                isObjectLike = __webpack_require__('ExA7')

            /** `Object#toString` result references. */
            var mapTag = '[object Map]'

            /**
             * The base implementation of `_.isMap` without Node.js optimizations.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a map, else `false`.
             */
            function baseIsMap(value) {
                return isObjectLike(value) && getTag(value) == mapTag
            }

            module.exports = baseIsMap

            /***/
        },

        /***/ GlC0: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const AssertError = __webpack_require__('Fow+')

            const internals = {}

            module.exports = function(condition, ...args) {
                if (condition) {
                    return
                }

                if (args.length === 1 && args[0] instanceof Error) {
                    throw args[0]
                }

                throw new AssertError(args)
            }

            /***/
        },

        /***/ GoyQ: /***/ function(module, exports) {
            /**
             * Checks if `value` is the
             * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
             * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an object, else `false`.
             * @example
             *
             * _.isObject({});
             * // => true
             *
             * _.isObject([1, 2, 3]);
             * // => true
             *
             * _.isObject(_.noop);
             * // => true
             *
             * _.isObject(null);
             * // => false
             */
            function isObject(value) {
                var type = typeof value
                return value != null && (type == 'object' || type == 'function')
            }

            module.exports = isObject

            /***/
        },

        /***/ GvbO: /***/ function(module, exports, __webpack_require__) {
            // 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
            var $export = __webpack_require__('Y7ZC')

            $export($export.S, 'Array', {
                isArray: __webpack_require__('kAMH')
            })

            /***/
        },

        /***/ H8j4: /***/ function(module, exports, __webpack_require__) {
            var getMapData = __webpack_require__('QkVE')

            /**
             * Sets the map `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf MapCache
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the map cache instance.
             */
            function mapCacheSet(key, value) {
                var data = getMapData(this, key),
                    size = data.size

                data.set(key, value)
                this.size += data.size == size ? 0 : 1
                return this
            }

            module.exports = mapCacheSet

            /***/
        },

        /***/ HDyB: /***/ function(module, exports, __webpack_require__) {
            var Symbol = __webpack_require__('nmnc'),
                Uint8Array = __webpack_require__('JHRd'),
                eq = __webpack_require__('ljhN'),
                equalArrays = __webpack_require__('or5M'),
                mapToArray = __webpack_require__('7fqy'),
                setToArray = __webpack_require__('rEGp')

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1,
                COMPARE_UNORDERED_FLAG = 2

            /** `Object#toString` result references. */
            var boolTag = '[object Boolean]',
                dateTag = '[object Date]',
                errorTag = '[object Error]',
                mapTag = '[object Map]',
                numberTag = '[object Number]',
                regexpTag = '[object RegExp]',
                setTag = '[object Set]',
                stringTag = '[object String]',
                symbolTag = '[object Symbol]'

            var arrayBufferTag = '[object ArrayBuffer]',
                dataViewTag = '[object DataView]'

            /** Used to convert symbols to primitives and strings. */
            var symbolProto = Symbol ? Symbol.prototype : undefined,
                symbolValueOf = symbolProto ? symbolProto.valueOf : undefined

            /**
             * A specialized version of `baseIsEqualDeep` for comparing objects of
             * the same `toStringTag`.
             *
             * **Note:** This function only supports comparing values with tags of
             * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {string} tag The `toStringTag` of the objects to compare.
             * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
             * @param {Function} customizer The function to customize comparisons.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Object} stack Tracks traversed `object` and `other` objects.
             * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
             */
            function equalByTag(
                object,
                other,
                tag,
                bitmask,
                customizer,
                equalFunc,
                stack
            ) {
                switch (tag) {
                    case dataViewTag:
                        if (
                            object.byteLength != other.byteLength ||
                            object.byteOffset != other.byteOffset
                        ) {
                            return false
                        }
                        object = object.buffer
                        other = other.buffer

                    case arrayBufferTag:
                        if (
                            object.byteLength != other.byteLength ||
                            !equalFunc(
                                new Uint8Array(object),
                                new Uint8Array(other)
                            )
                        ) {
                            return false
                        }
                        return true

                    case boolTag:
                    case dateTag:
                    case numberTag:
                        // Coerce booleans to `1` or `0` and dates to milliseconds.
                        // Invalid dates are coerced to `NaN`.
                        return eq(+object, +other)

                    case errorTag:
                        return (
                            object.name == other.name &&
                            object.message == other.message
                        )

                    case regexpTag:
                    case stringTag:
                        // Coerce regexes to strings and treat strings, primitives and objects,
                        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                        // for more details.
                        return object == other + ''

                    case mapTag:
                        var convert = mapToArray

                    case setTag:
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG
                        convert || (convert = setToArray)

                        if (object.size != other.size && !isPartial) {
                            return false
                        }
                        // Assume cyclic values are equal.
                        var stacked = stack.get(object)
                        if (stacked) {
                            return stacked == other
                        }
                        bitmask |= COMPARE_UNORDERED_FLAG

                        // Recursively compare objects (susceptible to call stack limits).
                        stack.set(object, other)
                        var result = equalArrays(
                            convert(object),
                            convert(other),
                            bitmask,
                            customizer,
                            equalFunc,
                            stack
                        )
                        stack['delete'](object)
                        return result

                    case symbolTag:
                        if (symbolValueOf) {
                            return (
                                symbolValueOf.call(object) ==
                                symbolValueOf.call(other)
                            )
                        }
                }
                return false
            }

            module.exports = equalByTag

            /***/
        },

        /***/ HKOu: /***/ function(module, exports) {
            module.exports = function() {
                this.seq().obj(
                    this.key('version').int(),
                    this.key('privateKey').octstr(),
                    this.key('parameters')
                        .explicit(0)
                        .optional()
                        .choice({ namedCurve: this.objid() }),
                    this.key('publicKey')
                        .explicit(1)
                        .optional()
                        .bitstr()
                )
            }

            /***/
        },

        /***/ HOxn: /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5'),
                root = __webpack_require__('Kz5y')

            /* Built-in method references that are verified to be native. */
            var Promise = getNative(root, 'Promise')

            module.exports = Promise

            /***/
        },

        /***/ HSsa: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = function bind(fn, thisArg) {
                return function wrap() {
                    var args = new Array(arguments.length)
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i]
                    }
                    return fn.apply(thisArg, args)
                }
            }

            /***/
        },

        /***/ HpSD: /***/ function(module, exports) {
            // Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py

            // -- Normalization --
            // A string of any other type is interpreted as a URI either the form of scheme
            // "://" authority path-abempty [ "?" query ] [ "#" fragment ] or authority
            // path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986] and is
            // normalized according to the following rules:
            //
            // If the user input Identifier does not have an RFC 3986 [RFC3986] scheme
            // portion, the string is interpreted as [userinfo "@"] host [":" port]
            // path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986].
            // If the userinfo component is present and all of the path component, query
            // component, and port component are empty, the acct scheme is assumed. In this
            // case, the normalized URI is formed by prefixing acct: to the string as the
            // scheme. Per the 'acct' URI Scheme [I‑D.ietf‑appsawg‑acct‑uri], if there is an
            // at-sign character ('@') in the userinfo component, it needs to be
            // percent-encoded as described in RFC 3986 [RFC3986].
            // For all other inputs without a scheme portion, the https scheme is assumed,
            // and the normalized URI is formed by prefixing https:// to the string as the
            // scheme.
            // If the resulting URI contains a fragment portion, it MUST be stripped off
            // together with the fragment delimiter character "#".
            // The WebFinger [I‑D.ietf‑appsawg‑webfinger] Resource in this case is the
            // resulting URI, and the WebFinger Host is the authority component.
            //
            // Note: Since the definition of authority in RFC 3986 [RFC3986] is
            // [ userinfo "@" ] host [ ":" port ], it is legal to have a user input
            // identifier like userinfo@host:port, e.g., alice@example.com:8080.

            const PORT = /^\d+$/

            function hasScheme(input) {
                if (input.includes('://')) return true

                const authority = input.replace(/(\/|\?)/g, '#').split('#')[0]
                if (authority.includes(':')) {
                    const index = authority.indexOf(':')
                    const hostOrPort = authority.slice(index + 1)
                    if (!PORT.test(hostOrPort)) {
                        return true
                    }
                }

                return false
            }

            function acctSchemeAssumed(input) {
                if (!input.includes('@')) return false
                const parts = input.split('@')
                const host = parts[parts.length - 1]
                return !(
                    host.includes(':') ||
                    host.includes('/') ||
                    host.includes('?')
                )
            }

            function normalize(input) {
                if (typeof input !== 'string') {
                    throw new TypeError('input must be a string')
                }

                let output
                if (hasScheme(input)) {
                    output = input
                } else if (acctSchemeAssumed(input)) {
                    output = `acct:${input}`
                } else {
                    output = `https://${input}`
                }

                return output.split('#')[0]
            }

            module.exports = normalize

            /***/
        },

        /***/ HrFp: /***/ function(module, exports, __webpack_require__) {
            /* eslint-disable max-classes-per-file */

            const { inspect, deprecate } = __webpack_require__('jK02')
            const stdhttp = __webpack_require__('KEll')
            const crypto = __webpack_require__('PJMN')
            const { strict: assert } = __webpack_require__('Qs3B')
            const querystring = __webpack_require__('8xkj')
            const url = __webpack_require__('bzos')

            const { ParseError } = __webpack_require__('AfMj')
            const jose = __webpack_require__('xZSz')
            const base64url = __webpack_require__('+00W')
            const defaultsDeep = __webpack_require__('P4Tr')
            const defaults = __webpack_require__('la6v')
            const merge = __webpack_require__('QkVN')
            const isPlainObject = __webpack_require__('YO3V')
            const tokenHash = __webpack_require__('ZfBq')

            const {
                assertSigningAlgValuesSupport,
                assertIssuerConfiguration
            } = __webpack_require__('N+si')
            const pick = __webpack_require__('LZmR')
            const processResponse = __webpack_require__('WeJA')
            const TokenSet = __webpack_require__('IgmS')
            const { OPError, RPError } = __webpack_require__('L71r')
            const now = __webpack_require__('PbSP')
            const { random } = __webpack_require__('iAgo')
            const request = __webpack_require__('UwMm')
            const {
                CALLBACK_PROPERTIES,
                CLIENT_DEFAULTS,
                JWT_CONTENT,
                CLOCK_TOLERANCE
            } = __webpack_require__('TJm8')
            const issuerRegistry = __webpack_require__('0Aai')
            const instance = __webpack_require__('0pkK')
            const {
                authenticatedPost,
                resolveResponseType,
                resolveRedirectUri
            } = __webpack_require__('/JKO')
            const DeviceFlowHandle = __webpack_require__('LMPv')

            function pickCb(input) {
                return pick(input, ...CALLBACK_PROPERTIES)
            }

            function authorizationHeaderValue(token, tokenType = 'Bearer') {
                return `${tokenType} ${token}`
            }

            function cleanUpClaims(claims) {
                if (Object.keys(claims._claim_names).length === 0) {
                    delete claims._claim_names
                }
                if (Object.keys(claims._claim_sources).length === 0) {
                    delete claims._claim_sources
                }
            }

            function assignClaim(
                target,
                source,
                sourceName,
                throwOnMissing = true
            ) {
                return ([claim, inSource]) => {
                    if (inSource === sourceName) {
                        if (throwOnMissing && source[claim] === undefined) {
                            throw new RPError(
                                `expected claim "${claim}" in "${sourceName}"`
                            )
                        } else if (source[claim] !== undefined) {
                            target[claim] = source[claim]
                        }
                        delete target._claim_names[claim]
                    }
                }
            }

            function verifyPresence(payload, jwt, prop) {
                if (payload[prop] === undefined) {
                    throw new RPError({
                        message: `missing required JWT property ${prop}`,
                        jwt
                    })
                }
            }

            function authorizationParams(params) {
                const authParams = {
                    client_id: this.client_id,
                    scope: 'openid',
                    response_type: resolveResponseType.call(this),
                    redirect_uri: resolveRedirectUri.call(this),
                    ...params
                }

                Object.entries(authParams).forEach(([key, value]) => {
                    if (value === null || value === undefined) {
                        delete authParams[key]
                    } else if (key === 'claims' && typeof value === 'object') {
                        authParams[key] = JSON.stringify(value)
                    } else if (key === 'resource' && Array.isArray(value)) {
                        authParams[key] = value
                    } else if (typeof value !== 'string') {
                        authParams[key] = String(value)
                    }
                })

                return authParams
            }

            async function claimJWT(label, jwt) {
                try {
                    const { header, payload } = jose.JWT.decode(jwt, {
                        complete: true
                    })
                    const { iss } = payload

                    if (header.alg === 'none') {
                        return payload
                    }

                    let key
                    if (!iss || iss === this.issuer.issuer) {
                        key = await this.issuer.queryKeyStore(header)
                    } else if (issuerRegistry.has(iss)) {
                        key = await issuerRegistry
                            .get(iss)
                            .queryKeyStore(header)
                    } else {
                        const discovered = await this.issuer.constructor.discover(
                            iss
                        )
                        key = await discovered.queryKeyStore(header)
                    }
                    return jose.JWT.verify(jwt, key)
                } catch (err) {
                    if (
                        err instanceof RPError ||
                        err instanceof OPError ||
                        err.name === 'AggregateError'
                    ) {
                        throw err
                    } else {
                        throw new RPError({
                            printf: [
                                'failed to validate the %s JWT (%s: %s)',
                                label,
                                err.name,
                                err.message
                            ],
                            jwt
                        })
                    }
                }
            }

            function getKeystore(jwks) {
                const keystore = jose.JWKS.asKeyStore(jwks)
                if (keystore.all().some(key => key.type !== 'private')) {
                    throw new TypeError('jwks must only contain private keys')
                }
                return keystore
            }

            // if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead
            // this is in place to take care of most common pitfalls when first using discovered Issuers without
            // the support for default values defined by Discovery 1.0
            function checkBasicSupport(client, metadata, properties) {
                try {
                    const supported =
                        client.issuer.token_endpoint_auth_methods_supported
                    if (
                        !supported.includes(
                            properties.token_endpoint_auth_method
                        )
                    ) {
                        if (supported.includes('client_secret_post')) {
                            properties.token_endpoint_auth_method =
                                'client_secret_post'
                        }
                    }
                } catch (err) {}
            }

            function handleCommonMistakes(client, metadata, properties) {
                if (!metadata.token_endpoint_auth_method) {
                    // if no explicit value was provided
                    checkBasicSupport(client, metadata, properties)
                }

                // :fp: c'mon people... RTFM
                if (metadata.redirect_uri) {
                    if (metadata.redirect_uris) {
                        throw new TypeError(
                            'provide a redirect_uri or redirect_uris, not both'
                        )
                    }
                    properties.redirect_uris = [metadata.redirect_uri]
                    delete properties.redirect_uri
                }

                if (metadata.response_type) {
                    if (metadata.response_types) {
                        throw new TypeError(
                            'provide a response_type or response_types, not both'
                        )
                    }
                    properties.response_types = [metadata.response_type]
                    delete properties.response_type
                }
            }

            function getDefaultsForEndpoint(endpoint, issuer, properties) {
                if (!issuer[`${endpoint}_endpoint`]) return

                const tokenEndpointAuthMethod =
                    properties.token_endpoint_auth_method
                const tokenEndpointAuthSigningAlg =
                    properties.token_endpoint_auth_signing_alg

                const eam = `${endpoint}_endpoint_auth_method`
                const easa = `${endpoint}_endpoint_auth_signing_alg`

                if (
                    properties[eam] === undefined &&
                    properties[easa] === undefined
                ) {
                    if (tokenEndpointAuthMethod !== undefined) {
                        properties[eam] = tokenEndpointAuthMethod
                    }
                    if (tokenEndpointAuthSigningAlg !== undefined) {
                        properties[easa] = tokenEndpointAuthSigningAlg
                    }
                }
            }

            class BaseClient {}

            module.exports = (issuer, aadIssValidation = false) =>
                class Client extends BaseClient {
                    /**
                     * @name constructor
                     * @api public
                     */
                    constructor(metadata = {}, jwks) {
                        super()

                        if (
                            typeof metadata.client_id !== 'string' ||
                            !metadata.client_id
                        ) {
                            throw new TypeError('client_id is required')
                        }

                        const properties = { ...CLIENT_DEFAULTS, ...metadata }

                        handleCommonMistakes(this, metadata, properties)

                        assertSigningAlgValuesSupport(
                            'token',
                            this.issuer,
                            properties
                        )

                        ;['introspection', 'revocation'].forEach(endpoint => {
                            getDefaultsForEndpoint(
                                endpoint,
                                this.issuer,
                                properties
                            )
                            assertSigningAlgValuesSupport(
                                endpoint,
                                this.issuer,
                                properties
                            )
                        })

                        Object.entries(properties).forEach(([key, value]) => {
                            instance(this)
                                .get('metadata')
                                .set(key, value)
                            if (!this[key]) {
                                Object.defineProperty(this, key, {
                                    get() {
                                        return instance(this)
                                            .get('metadata')
                                            .get(key)
                                    },
                                    enumerable: true
                                })
                            }
                        })

                        if (jwks !== undefined) {
                            const keystore = getKeystore.call(this, jwks)
                            instance(this).set('keystore', keystore)
                        }

                        this[CLOCK_TOLERANCE] = 0
                    }

                    /**
                     * @name authorizationUrl
                     * @api public
                     */
                    authorizationUrl(params = {}) {
                        if (!isPlainObject(params)) {
                            throw new TypeError('params must be a plain object')
                        }
                        assertIssuerConfiguration(
                            this.issuer,
                            'authorization_endpoint'
                        )
                        const target = url.parse(
                            this.issuer.authorization_endpoint,
                            true
                        )
                        target.search = null
                        target.query = {
                            ...target.query,
                            ...authorizationParams.call(this, params)
                        }
                        return url.format(target)
                    }

                    /**
                     * @name authorizationPost
                     * @api public
                     */
                    authorizationPost(params = {}) {
                        if (!isPlainObject(params)) {
                            throw new TypeError('params must be a plain object')
                        }
                        const inputs = authorizationParams.call(this, params)
                        const formInputs = Object.keys(inputs)
                            .map(
                                name =>
                                    `<input type="hidden" name="${name}" value="${inputs[name]}"/>`
                            )
                            .join('\n')

                        return `<!DOCTYPE html>
<head>
  <title>Requesting Authorization</title>
</head>
<body onload="javascript:document.forms[0].submit()">
  <form method="post" action="${this.issuer.authorization_endpoint}">
    ${formInputs}
  </form>
</body>
</html>`
                    }

                    /**
                     * @name endSessionUrl
                     * @api public
                     */
                    endSessionUrl(params = {}) {
                        assertIssuerConfiguration(
                            this.issuer,
                            'end_session_endpoint'
                        )

                        const { 0: postLogout, length } =
                            this.post_logout_redirect_uris || []

                        const {
                            post_logout_redirect_uri = length === 1
                                ? postLogout
                                : undefined
                        } = params

                        let hint = params.id_token_hint

                        if (hint instanceof TokenSet) {
                            if (!hint.id_token) {
                                throw new TypeError(
                                    'id_token not present in TokenSet'
                                )
                            }
                            hint = hint.id_token
                        }

                        const target = url.parse(
                            this.issuer.end_session_endpoint,
                            true
                        )
                        target.search = null
                        target.query = {
                            ...params,
                            ...target.query,
                            ...{
                                post_logout_redirect_uri,
                                id_token_hint: hint
                            }
                        }

                        Object.entries(target.query).forEach(([key, value]) => {
                            if (value === null || value === undefined) {
                                delete target.query[key]
                            }
                        })

                        return url.format(target)
                    }

                    /**
                     * @name callbackParams
                     * @api public
                     */
                    callbackParams(input) {
                        // eslint-disable-line class-methods-use-this
                        const isIncomingMessage =
                            input instanceof stdhttp.IncomingMessage ||
                            (input && input.method && input.url)
                        const isString = typeof input === 'string'

                        if (!isString && !isIncomingMessage) {
                            throw new TypeError(
                                '#callbackParams only accepts string urls, http.IncomingMessage or a lookalike'
                            )
                        }

                        if (isIncomingMessage) {
                            switch (input.method) {
                                case 'GET':
                                    return pickCb(
                                        url.parse(input.url, true).query
                                    )
                                case 'POST':
                                    if (input.body === undefined) {
                                        throw new TypeError(
                                            'incoming message body missing, include a body parser prior to this method call'
                                        )
                                    }
                                    switch (typeof input.body) {
                                        case 'object':
                                        case 'string':
                                            if (Buffer.isBuffer(input.body)) {
                                                return pickCb(
                                                    querystring.parse(
                                                        input.body.toString(
                                                            'utf-8'
                                                        )
                                                    )
                                                )
                                            }
                                            if (
                                                typeof input.body === 'string'
                                            ) {
                                                return pickCb(
                                                    querystring.parse(
                                                        input.body
                                                    )
                                                )
                                            }

                                            return pickCb(input.body)
                                        default:
                                            throw new TypeError(
                                                'invalid IncomingMessage body object'
                                            )
                                    }
                                default:
                                    throw new TypeError(
                                        'invalid IncomingMessage method'
                                    )
                            }
                        } else {
                            return pickCb(url.parse(input, true).query)
                        }
                    }

                    /**
                     * @name callback
                     * @api public
                     */
                    async callback(
                        redirectUri,
                        parameters,
                        checks = {},
                        { exchangeBody, clientAssertionPayload } = {}
                    ) {
                        let params = pickCb(parameters)

                        if (checks.jarm && !('response' in parameters)) {
                            throw new RPError({
                                message: 'expected a JARM response',
                                checks,
                                params
                            })
                        } else if ('response' in parameters) {
                            const decrypted = await this.decryptJARM(
                                params.response
                            )
                            params = await this.validateJARM(decrypted)
                        }

                        if (this.default_max_age && !checks.max_age) {
                            checks.max_age = this.default_max_age
                        }

                        if (params.state && !checks.state) {
                            throw new TypeError(
                                'checks.state argument is missing'
                            )
                        }

                        if (!params.state && checks.state) {
                            throw new RPError({
                                message: 'state missing from the response',
                                checks,
                                params
                            })
                        }

                        if (checks.state !== params.state) {
                            throw new RPError({
                                printf: [
                                    'state mismatch, expected %s, got: %s',
                                    checks.state,
                                    params.state
                                ],
                                checks,
                                params
                            })
                        }

                        if (params.error) {
                            throw new OPError(params)
                        }

                        const RESPONSE_TYPE_REQUIRED_PARAMS = {
                            code: ['code'],
                            id_token: ['id_token'],
                            token: ['access_token', 'token_type']
                        }

                        if (checks.response_type) {
                            for (const type of checks.response_type.split(
                                ' '
                            )) {
                                // eslint-disable-line no-restricted-syntax
                                if (type === 'none') {
                                    if (
                                        params.code ||
                                        params.id_token ||
                                        params.access_token
                                    ) {
                                        throw new RPError({
                                            message:
                                                'unexpected params encountered for "none" response',
                                            checks,
                                            params
                                        })
                                    }
                                } else {
                                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[
                                        type
                                    ]) {
                                        // eslint-disable-line no-restricted-syntax, max-len
                                        if (!params[param]) {
                                            throw new RPError({
                                                message: `${param} missing from response`,
                                                checks,
                                                params
                                            })
                                        }
                                    }
                                }
                            }
                        }

                        if (params.id_token) {
                            const tokenset = new TokenSet(params)
                            await this.decryptIdToken(tokenset)
                            await this.validateIdToken(
                                tokenset,
                                checks.nonce,
                                'authorization',
                                checks.max_age,
                                checks.state
                            )

                            if (!params.code) {
                                return tokenset
                            }
                        }

                        if (params.code) {
                            const tokenset = await this.grant(
                                {
                                    ...exchangeBody,
                                    grant_type: 'authorization_code',
                                    code: params.code,
                                    redirect_uri: redirectUri,
                                    code_verifier: checks.code_verifier
                                },
                                { clientAssertionPayload }
                            )

                            await this.decryptIdToken(tokenset)
                            await this.validateIdToken(
                                tokenset,
                                checks.nonce,
                                'token',
                                checks.max_age
                            )

                            if (params.session_state) {
                                tokenset.session_state = params.session_state
                            }

                            return tokenset
                        }

                        return new TokenSet(params)
                    }

                    /**
                     * @name oauthCallback
                     * @api public
                     */
                    async oauthCallback(
                        redirectUri,
                        parameters,
                        checks = {},
                        { exchangeBody, clientAssertionPayload } = {}
                    ) {
                        let params = pickCb(parameters)

                        if (checks.jarm && !('response' in parameters)) {
                            throw new RPError({
                                message: 'expected a JARM response',
                                checks,
                                params
                            })
                        } else if ('response' in parameters) {
                            const decrypted = await this.decryptJARM(
                                params.response
                            )
                            params = await this.validateJARM(decrypted)
                        }

                        if (params.state && !checks.state) {
                            throw new TypeError(
                                'checks.state argument is missing'
                            )
                        }

                        if (!params.state && checks.state) {
                            throw new RPError({
                                message: 'state missing from the response',
                                checks,
                                params
                            })
                        }

                        if (checks.state !== params.state) {
                            throw new RPError({
                                printf: [
                                    'state mismatch, expected %s, got: %s',
                                    checks.state,
                                    params.state
                                ],
                                checks,
                                params
                            })
                        }

                        if (params.error) {
                            throw new OPError(params)
                        }

                        const RESPONSE_TYPE_REQUIRED_PARAMS = {
                            code: ['code'],
                            token: ['access_token', 'token_type']
                        }

                        if (checks.response_type) {
                            for (const type of checks.response_type.split(
                                ' '
                            )) {
                                // eslint-disable-line no-restricted-syntax
                                if (type === 'none') {
                                    if (
                                        params.code ||
                                        params.id_token ||
                                        params.access_token
                                    ) {
                                        throw new RPError({
                                            message:
                                                'unexpected params encountered for "none" response',
                                            checks,
                                            params
                                        })
                                    }
                                }

                                if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {
                                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[
                                        type
                                    ]) {
                                        // eslint-disable-line no-restricted-syntax, max-len
                                        if (!params[param]) {
                                            throw new RPError({
                                                message: `${param} missing from response`,
                                                checks,
                                                params
                                            })
                                        }
                                    }
                                }
                            }
                        }

                        if (params.code) {
                            return this.grant(
                                {
                                    ...exchangeBody,
                                    grant_type: 'authorization_code',
                                    code: params.code,
                                    redirect_uri: redirectUri,
                                    code_verifier: checks.code_verifier
                                },
                                { clientAssertionPayload }
                            )
                        }

                        return new TokenSet(params)
                    }

                    /**
                     * @name decryptIdToken
                     * @api private
                     */
                    async decryptIdToken(token) {
                        if (!this.id_token_encrypted_response_alg) {
                            return token
                        }

                        let idToken = token

                        if (idToken instanceof TokenSet) {
                            if (!idToken.id_token) {
                                throw new TypeError(
                                    'id_token not present in TokenSet'
                                )
                            }
                            idToken = idToken.id_token
                        }

                        const expectedAlg = this.id_token_encrypted_response_alg
                        const expectedEnc = this.id_token_encrypted_response_enc

                        const result = await this.decryptJWE(
                            idToken,
                            expectedAlg,
                            expectedEnc
                        )

                        if (token instanceof TokenSet) {
                            token.id_token = result
                            return token
                        }

                        return result
                    }

                    async validateJWTUserinfo(body) {
                        const expectedAlg = this.userinfo_signed_response_alg

                        return this.validateJWT(body, expectedAlg, [])
                    }

                    /**
                     * @name decryptJARM
                     * @api private
                     */
                    async decryptJARM(response) {
                        if (!this.authorization_encrypted_response_alg) {
                            return response
                        }

                        const expectedAlg = this
                            .authorization_encrypted_response_alg
                        const expectedEnc = this
                            .authorization_encrypted_response_enc

                        return this.decryptJWE(
                            response,
                            expectedAlg,
                            expectedEnc
                        )
                    }

                    /**
                     * @name validateJARM
                     * @api private
                     */
                    async validateJARM(response) {
                        const expectedAlg = this
                            .authorization_signed_response_alg
                        const { payload } = await this.validateJWT(
                            response,
                            expectedAlg,
                            ['iss', 'exp', 'aud']
                        )
                        return pickCb(payload)
                    }

                    /**
                     * @name decryptJWTUserinfo
                     * @api private
                     */
                    async decryptJWTUserinfo(body) {
                        if (!this.userinfo_encrypted_response_alg) {
                            return body
                        }

                        const expectedAlg = this.userinfo_encrypted_response_alg
                        const expectedEnc = this.userinfo_encrypted_response_enc

                        return this.decryptJWE(body, expectedAlg, expectedEnc)
                    }

                    /**
                     * @name decryptJWE
                     * @api private
                     */
                    async decryptJWE(
                        jwe,
                        expectedAlg,
                        expectedEnc = 'A128CBC-HS256'
                    ) {
                        const header = JSON.parse(
                            base64url.decode(jwe.split('.')[0])
                        )

                        if (header.alg !== expectedAlg) {
                            throw new RPError({
                                printf: [
                                    'unexpected JWE alg received, expected %s, got: %s',
                                    expectedAlg,
                                    header.alg
                                ],
                                jwt: jwe
                            })
                        }

                        if (header.enc !== expectedEnc) {
                            throw new RPError({
                                printf: [
                                    'unexpected JWE enc received, expected %s, got: %s',
                                    expectedEnc,
                                    header.enc
                                ],
                                jwt: jwe
                            })
                        }

                        let keyOrStore

                        if (expectedAlg.match(/^(?:RSA|ECDH)/)) {
                            keyOrStore = instance(this).get('keystore')
                        } else {
                            keyOrStore = await this.joseSecret(
                                expectedAlg === 'dir'
                                    ? expectedEnc
                                    : expectedAlg
                            )
                        }

                        const payload = jose.JWE.decrypt(jwe, keyOrStore)
                        return payload.toString('utf8')
                    }

                    /**
                     * @name validateIdToken
                     * @api private
                     */
                    async validateIdToken(
                        tokenSet,
                        nonce,
                        returnedBy,
                        maxAge,
                        state
                    ) {
                        let idToken = tokenSet

                        const expectedAlg = this.id_token_signed_response_alg

                        const isTokenSet = idToken instanceof TokenSet

                        if (isTokenSet) {
                            if (!idToken.id_token) {
                                throw new TypeError(
                                    'id_token not present in TokenSet'
                                )
                            }
                            idToken = idToken.id_token
                        }

                        idToken = String(idToken)

                        const timestamp = now()
                        const {
                            protected: header,
                            payload,
                            key
                        } = await this.validateJWT(idToken, expectedAlg)

                        if (
                            maxAge ||
                            (maxAge !== null && this.require_auth_time)
                        ) {
                            if (!payload.auth_time) {
                                throw new RPError({
                                    message:
                                        'missing required JWT property auth_time',
                                    jwt: idToken
                                })
                            }
                            if (!Number.isInteger(payload.auth_time)) {
                                throw new RPError({
                                    message:
                                        'JWT auth_time claim must be a JSON number integer',
                                    jwt: idToken
                                })
                            }
                        }

                        if (
                            maxAge &&
                            payload.auth_time + maxAge <
                                timestamp - this[CLOCK_TOLERANCE]
                        ) {
                            throw new RPError({
                                printf: [
                                    'too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i',
                                    maxAge,
                                    payload.auth_time,
                                    timestamp - this[CLOCK_TOLERANCE]
                                ],
                                jwt: idToken
                            })
                        }

                        if (
                            nonce !== null &&
                            (payload.nonce || nonce !== undefined) &&
                            payload.nonce !== nonce
                        ) {
                            throw new RPError({
                                printf: [
                                    'nonce mismatch, expected %s, got: %s',
                                    nonce,
                                    payload.nonce
                                ],
                                jwt: idToken
                            })
                        }

                        if (returnedBy === 'authorization') {
                            if (!payload.at_hash && tokenSet.access_token) {
                                throw new RPError({
                                    message:
                                        'missing required property at_hash',
                                    jwt: idToken
                                })
                            }

                            if (!payload.c_hash && tokenSet.code) {
                                throw new RPError({
                                    message: 'missing required property c_hash',
                                    jwt: idToken
                                })
                            }

                            const fapi = this.constructor.name === 'FAPIClient'

                            if (fapi) {
                                if (payload.iat < timestamp - 3600) {
                                    throw new RPError({
                                        printf: [
                                            'JWT issued too far in the past, now %i, iat %i',
                                            timestamp,
                                            payload.iat
                                        ],
                                        jwt: idToken
                                    })
                                }

                                if (
                                    !payload.s_hash &&
                                    (tokenSet.state || state)
                                ) {
                                    throw new RPError({
                                        message:
                                            'missing required property s_hash',
                                        jwt: idToken
                                    })
                                }
                            }

                            if (payload.s_hash) {
                                if (!state) {
                                    throw new TypeError(
                                        'cannot verify s_hash, "checks.state" property not provided'
                                    )
                                }

                                try {
                                    tokenHash.validate(
                                        { claim: 's_hash', source: 'state' },
                                        payload.s_hash,
                                        state,
                                        header.alg,
                                        key && key.crv
                                    )
                                } catch (err) {
                                    throw new RPError({
                                        message: err.message,
                                        jwt: idToken
                                    })
                                }
                            }
                        }

                        if (
                            tokenSet.access_token &&
                            payload.at_hash !== undefined
                        ) {
                            try {
                                tokenHash.validate(
                                    {
                                        claim: 'at_hash',
                                        source: 'access_token'
                                    },
                                    payload.at_hash,
                                    tokenSet.access_token,
                                    header.alg,
                                    key && key.crv
                                )
                            } catch (err) {
                                throw new RPError({
                                    message: err.message,
                                    jwt: idToken
                                })
                            }
                        }

                        if (tokenSet.code && payload.c_hash !== undefined) {
                            try {
                                tokenHash.validate(
                                    { claim: 'c_hash', source: 'code' },
                                    payload.c_hash,
                                    tokenSet.code,
                                    header.alg,
                                    key && key.crv
                                )
                            } catch (err) {
                                throw new RPError({
                                    message: err.message,
                                    jwt: idToken
                                })
                            }
                        }

                        return tokenSet
                    }

                    /**
                     * @name validateJWT
                     * @api private
                     */
                    async validateJWT(
                        jwt,
                        expectedAlg,
                        required = ['iss', 'sub', 'aud', 'exp', 'iat']
                    ) {
                        const isSelfIssued =
                            this.issuer.issuer === 'https://self-issued.me'
                        const timestamp = now()
                        let header
                        let payload
                        try {
                            ;({ header, payload } = jose.JWT.decode(jwt, {
                                complete: true
                            }))
                        } catch (err) {
                            throw new RPError({
                                printf: [
                                    'failed to decode JWT (%s: %s)',
                                    err.name,
                                    err.message
                                ],
                                jwt
                            })
                        }

                        if (header.alg !== expectedAlg) {
                            throw new RPError({
                                printf: [
                                    'unexpected JWT alg received, expected %s, got: %s',
                                    expectedAlg,
                                    header.alg
                                ],
                                jwt
                            })
                        }

                        if (isSelfIssued) {
                            required = [...required, 'sub_jwk'] // eslint-disable-line no-param-reassign
                        }

                        required.forEach(
                            verifyPresence.bind(undefined, payload, jwt)
                        )

                        if (payload.iss !== undefined) {
                            let expectedIss = this.issuer.issuer

                            if (aadIssValidation) {
                                expectedIss = this.issuer.issuer.replace(
                                    '{tenantid}',
                                    payload.tid
                                )
                            }

                            if (payload.iss !== expectedIss) {
                                throw new RPError({
                                    printf: [
                                        'unexpected iss value, expected %s, got: %s',
                                        expectedIss,
                                        payload.iss
                                    ],
                                    jwt
                                })
                            }
                        }

                        if (payload.iat !== undefined) {
                            if (!Number.isInteger(payload.iat)) {
                                throw new RPError({
                                    message:
                                        'JWT iat claim must be a JSON number integer',
                                    jwt
                                })
                            }
                        }

                        if (payload.nbf !== undefined) {
                            if (!Number.isInteger(payload.nbf)) {
                                throw new RPError({
                                    message:
                                        'JWT nbf claim must be a JSON number integer',
                                    jwt
                                })
                            }
                            if (
                                payload.nbf >
                                timestamp + this[CLOCK_TOLERANCE]
                            ) {
                                throw new RPError({
                                    printf: [
                                        'JWT not active yet, now %i, nbf %i',
                                        timestamp + this[CLOCK_TOLERANCE],
                                        payload.nbf
                                    ],
                                    jwt
                                })
                            }
                        }

                        if (payload.exp !== undefined) {
                            if (!Number.isInteger(payload.exp)) {
                                throw new RPError({
                                    message:
                                        'JWT exp claim must be a JSON number integer',
                                    jwt
                                })
                            }
                            if (
                                timestamp - this[CLOCK_TOLERANCE] >=
                                payload.exp
                            ) {
                                throw new RPError({
                                    printf: [
                                        'JWT expired, now %i, exp %i',
                                        timestamp - this[CLOCK_TOLERANCE],
                                        payload.exp
                                    ],
                                    jwt
                                })
                            }
                        }

                        if (payload.aud !== undefined) {
                            if (Array.isArray(payload.aud)) {
                                if (payload.aud.length > 1 && !payload.azp) {
                                    throw new RPError({
                                        message:
                                            'missing required JWT property azp',
                                        jwt
                                    })
                                }

                                if (!payload.aud.includes(this.client_id)) {
                                    throw new RPError({
                                        printf: [
                                            'aud is missing the client_id, expected %s to be included in %j',
                                            this.client_id,
                                            payload.aud
                                        ],
                                        jwt
                                    })
                                }
                            } else if (payload.aud !== this.client_id) {
                                throw new RPError({
                                    printf: [
                                        'aud mismatch, expected %s, got: %s',
                                        this.client_id,
                                        payload.aud
                                    ],
                                    jwt
                                })
                            }
                        }

                        if (
                            payload.azp !== undefined &&
                            payload.azp !== this.client_id
                        ) {
                            throw new RPError({
                                printf: [
                                    'azp must be the client_id, expected %s, got: %s',
                                    this.client_id,
                                    payload.azp
                                ],
                                jwt
                            })
                        }

                        let key

                        if (isSelfIssued) {
                            try {
                                assert(isPlainObject(payload.sub_jwk))
                                key = jose.JWK.asKey(payload.sub_jwk)
                                assert.equal(key.type, 'public')
                            } catch (err) {
                                throw new RPError({
                                    message:
                                        'failed to use sub_jwk claim as an asymmetric JSON Web Key',
                                    jwt
                                })
                            }
                            if (key.thumbprint !== payload.sub) {
                                throw new RPError({
                                    message:
                                        'failed to match the subject with sub_jwk',
                                    jwt
                                })
                            }
                        } else if (header.alg.startsWith('HS')) {
                            key = await this.joseSecret()
                        } else if (header.alg !== 'none') {
                            key = await this.issuer.queryKeyStore(header)
                        }

                        if (!key && header.alg === 'none') {
                            return { protected: header, payload }
                        }

                        try {
                            return jose.JWS.verify(jwt, key, { complete: true })
                        } catch (err) {
                            throw new RPError({
                                message: 'failed to validate JWT signature',
                                jwt
                            })
                        }
                    }

                    /**
                     * @name refresh
                     * @api public
                     */
                    async refresh(
                        refreshToken,
                        { exchangeBody, clientAssertionPayload } = {}
                    ) {
                        let token = refreshToken

                        if (token instanceof TokenSet) {
                            if (!token.refresh_token) {
                                throw new TypeError(
                                    'refresh_token not present in TokenSet'
                                )
                            }
                            token = token.refresh_token
                        }

                        const tokenset = await this.grant(
                            {
                                ...exchangeBody,
                                grant_type: 'refresh_token',
                                refresh_token: String(token)
                            },
                            { clientAssertionPayload }
                        )

                        if (tokenset.id_token) {
                            await this.decryptIdToken(tokenset)
                            await this.validateIdToken(
                                tokenset,
                                null,
                                'token',
                                null
                            )
                        }

                        return tokenset
                    }

                    async requestResource(
                        resourceUrl,
                        accessToken,
                        {
                            method,
                            headers,
                            body,
                            tokenType = accessToken instanceof TokenSet
                                ? accessToken.token_type
                                : 'Bearer'
                        } = {}
                    ) {
                        if (accessToken instanceof TokenSet) {
                            if (!accessToken.access_token) {
                                throw new TypeError(
                                    'access_token not present in TokenSet'
                                )
                            }
                            accessToken = accessToken.access_token // eslint-disable-line no-param-reassign
                        }

                        const requestOpts = {
                            headers: {
                                Authorization: authorizationHeaderValue(
                                    accessToken,
                                    tokenType
                                ),
                                ...headers
                            },
                            body
                        }

                        const mTLS = !!this
                            .tls_client_certificate_bound_access_tokens

                        return request.call(
                            this,
                            {
                                ...requestOpts,
                                encoding: null,
                                method,
                                url: resourceUrl
                            },
                            { mTLS }
                        )
                    }

                    /**
                     * @name userinfo
                     * @api public
                     */
                    async userinfo(
                        accessToken,
                        { verb = 'GET', via = 'header', tokenType, params } = {}
                    ) {
                        // TODO: in v4.x remove verb in favour of method
                        assertIssuerConfiguration(
                            this.issuer,
                            'userinfo_endpoint'
                        )
                        const options = {
                            tokenType,
                            method: String(verb).toUpperCase()
                        }

                        if (
                            options.method !== 'GET' &&
                            options.method !== 'POST'
                        ) {
                            throw new TypeError(
                                '#userinfo() verb can only be POST or a GET'
                            )
                        }

                        if (via === 'query' && options.method !== 'GET') {
                            throw new TypeError(
                                'userinfo endpoints will only parse query strings for GET requests'
                            )
                        } else if (
                            via === 'body' &&
                            options.method !== 'POST'
                        ) {
                            throw new TypeError('can only send body on POST')
                        }

                        const jwt = !!(
                            this.userinfo_signed_response_alg ||
                            this.userinfo_encrypted_response_alg
                        )

                        if (jwt) {
                            options.headers = { Accept: 'application/jwt' }
                        } else {
                            options.headers = { Accept: 'application/json' }
                        }

                        const mTLS = !!this
                            .tls_client_certificate_bound_access_tokens

                        let targetUrl
                        if (mTLS && this.issuer.mtls_endpoint_aliases) {
                            targetUrl = this.issuer.mtls_endpoint_aliases
                                .userinfo_endpoint
                        }

                        targetUrl = new url.URL(
                            targetUrl || this.issuer.userinfo_endpoint
                        )

                        // when via is not header we clear the Authorization header and add either
                        // query string parameters or urlencoded body access_token parameter
                        if (via === 'query') {
                            options.headers.Authorization = undefined
                            targetUrl.searchParams.append(
                                'access_token',
                                accessToken instanceof TokenSet
                                    ? accessToken.access_token
                                    : accessToken
                            )
                        } else if (via === 'body') {
                            options.headers.Authorization = undefined
                            options.headers['Content-Type'] =
                                'application/x-www-form-urlencoded'
                            options.body = new url.URLSearchParams()
                            options.body.append(
                                'access_token',
                                accessToken instanceof TokenSet
                                    ? accessToken.access_token
                                    : accessToken
                            )
                        }

                        // handle additional parameters, GET via querystring, POST via urlencoded body
                        if (params) {
                            if (options.method === 'GET') {
                                Object.entries(params).forEach(
                                    ([key, value]) => {
                                        targetUrl.searchParams.append(
                                            key,
                                            value
                                        )
                                    }
                                )
                            } else if (options.body) {
                                // POST && via body
                                Object.entries(params).forEach(
                                    ([key, value]) => {
                                        options.body.append(key, value)
                                    }
                                )
                            } else {
                                // POST && via header
                                options.body = new url.URLSearchParams()
                                options.headers['Content-Type'] =
                                    'application/x-www-form-urlencoded'
                                Object.entries(params).forEach(
                                    ([key, value]) => {
                                        options.body.append(key, value)
                                    }
                                )
                            }
                        }

                        if (options.body) {
                            options.body = options.body.toString()
                        }

                        const response = await this.requestResource(
                            targetUrl,
                            accessToken,
                            options
                        )

                        let parsed = processResponse(response, { bearer: true })

                        if (jwt) {
                            if (
                                !JWT_CONTENT.test(
                                    response.headers['content-type']
                                )
                            ) {
                                throw new RPError({
                                    message:
                                        'expected application/jwt response from the userinfo_endpoint',
                                    response
                                })
                            }

                            const body = response.body.toString()
                            const userinfo = await this.decryptJWTUserinfo(body)
                            if (!this.userinfo_signed_response_alg) {
                                try {
                                    parsed = JSON.parse(userinfo)
                                    assert(isPlainObject(parsed))
                                } catch (err) {
                                    throw new RPError({
                                        message:
                                            'failed to parse userinfo JWE payload as JSON',
                                        jwt: userinfo
                                    })
                                }
                            } else {
                                ;({
                                    payload: parsed
                                } = await this.validateJWTUserinfo(userinfo))
                            }
                        } else {
                            try {
                                parsed = JSON.parse(response.body)
                            } catch (error) {
                                const parseError = new ParseError(
                                    error,
                                    response.statusCode,
                                    response.request.gotOptions,
                                    response.body
                                )
                                Object.defineProperty(parseError, 'response', {
                                    value: response
                                })
                                throw parseError
                            }
                        }

                        if (
                            accessToken instanceof TokenSet &&
                            accessToken.id_token
                        ) {
                            const expectedSub = accessToken.claims().sub
                            if (parsed.sub !== expectedSub) {
                                throw new RPError({
                                    printf: [
                                        'userinfo sub mismatch, expected %s, got: %s',
                                        expectedSub,
                                        parsed.sub
                                    ],
                                    body: parsed,
                                    jwt: accessToken.id_token
                                })
                            }
                        }

                        return parsed
                    }

                    /**
                     * @name derivedKey
                     * @api private
                     */
                    async derivedKey(len) {
                        const cacheKey = `${len}_key`
                        if (instance(this).has(cacheKey)) {
                            return instance(this).get(cacheKey)
                        }

                        const derivedBuffer = crypto
                            .createHash('sha256')
                            .update(this.client_secret)
                            .digest()
                            .slice(0, len / 8)

                        const key = jose.JWK.asKey({
                            k: base64url.encode(derivedBuffer),
                            kty: 'oct'
                        })
                        instance(this).set(cacheKey, key)

                        return key
                    }

                    /**
                     * @name joseSecret
                     * @api private
                     */
                    async joseSecret(alg) {
                        if (!this.client_secret) {
                            throw new TypeError('client_secret is required')
                        }
                        if (/^A(\d{3})(?:GCM)?KW$/.test(alg)) {
                            return this.derivedKey(parseInt(RegExp.$1, 10))
                        }

                        if (/^A(\d{3})(?:GCM|CBC-HS(\d{3}))$/.test(alg)) {
                            return this.derivedKey(
                                parseInt(RegExp.$2 || RegExp.$1, 10)
                            )
                        }

                        if (instance(this).has('jose_secret')) {
                            return instance(this).get('jose_secret')
                        }

                        const key = jose.JWK.asKey({
                            k: base64url.encode(this.client_secret),
                            kty: 'oct'
                        })
                        instance(this).set('jose_secret', key)

                        return key
                    }

                    /**
                     * @name grant
                     * @api public
                     */
                    async grant(body, { clientAssertionPayload } = {}) {
                        assertIssuerConfiguration(this.issuer, 'token_endpoint')
                        const response = await authenticatedPost.call(
                            this,
                            'token',
                            {
                                form: true,
                                body,
                                json: true
                            },
                            { clientAssertionPayload }
                        )
                        const responseBody = processResponse(response)

                        return new TokenSet(responseBody)
                    }

                    /**
                     * @name deviceAuthorization
                     * @api public
                     */
                    async deviceAuthorization(
                        params = {},
                        { exchangeBody, clientAssertionPayload } = {}
                    ) {
                        assertIssuerConfiguration(
                            this.issuer,
                            'device_authorization_endpoint'
                        )
                        assertIssuerConfiguration(this.issuer, 'token_endpoint')

                        const body = authorizationParams.call(this, {
                            client_id: this.client_id,
                            redirect_uri: null,
                            response_type: null,
                            ...params
                        })

                        const response = await authenticatedPost.call(
                            this,
                            'device_authorization',
                            {
                                form: true,
                                body,
                                json: true
                            },
                            {
                                clientAssertionPayload,
                                endpointAuthMethod: 'token'
                            }
                        )
                        const responseBody = processResponse(response)

                        return new DeviceFlowHandle({
                            client: this,
                            exchangeBody,
                            clientAssertionPayload,
                            response: responseBody,
                            maxAge: params.max_age
                        })
                    }

                    /**
                     * @name revoke
                     * @api public
                     */
                    async revoke(
                        token,
                        hint,
                        { revokeBody, clientAssertionPayload } = {}
                    ) {
                        assertIssuerConfiguration(
                            this.issuer,
                            'revocation_endpoint'
                        )
                        if (hint !== undefined && typeof hint !== 'string') {
                            throw new TypeError('hint must be a string')
                        }

                        const body = { ...revokeBody, token }

                        if (hint) {
                            body.token_type_hint = hint
                        }

                        const response = await authenticatedPost.call(
                            this,
                            'revocation',
                            {
                                body,
                                form: true
                            },
                            { clientAssertionPayload }
                        )
                        processResponse(response, { body: false })
                    }

                    /**
                     * @name introspect
                     * @api public
                     */
                    async introspect(
                        token,
                        hint,
                        { introspectBody, clientAssertionPayload } = {}
                    ) {
                        assertIssuerConfiguration(
                            this.issuer,
                            'introspection_endpoint'
                        )
                        if (hint !== undefined && typeof hint !== 'string') {
                            throw new TypeError('hint must be a string')
                        }

                        const body = { ...introspectBody, token }
                        if (hint) {
                            body.token_type_hint = hint
                        }

                        const response = await authenticatedPost.call(
                            this,
                            'introspection',
                            { body, form: true, json: true },
                            { clientAssertionPayload }
                        )

                        const responseBody = processResponse(response)

                        return responseBody
                    }

                    /**
                     * @name fetchDistributedClaims
                     * @api public
                     */
                    async fetchDistributedClaims(claims, tokens = {}) {
                        if (!isPlainObject(claims)) {
                            throw new TypeError(
                                'claims argument must be a plain object'
                            )
                        }

                        if (!isPlainObject(claims._claim_sources)) {
                            return claims
                        }

                        if (!isPlainObject(claims._claim_names)) {
                            return claims
                        }

                        const distributedSources = Object.entries(
                            claims._claim_sources
                        ).filter(([, value]) => value && value.endpoint)

                        await Promise.all(
                            distributedSources.map(
                                async ([sourceName, def]) => {
                                    try {
                                        const requestOpts = {
                                            headers: {
                                                Accept: 'application/jwt',
                                                Authorization: authorizationHeaderValue(
                                                    def.access_token ||
                                                        tokens[sourceName]
                                                )
                                            }
                                        }

                                        const response = await request.call(
                                            this,
                                            {
                                                ...requestOpts,
                                                method: 'GET',
                                                url: def.endpoint
                                            }
                                        )
                                        const body = processResponse(response, {
                                            bearer: true
                                        })

                                        const decoded = await claimJWT.call(
                                            this,
                                            'distributed',
                                            body
                                        )
                                        delete claims._claim_sources[sourceName]
                                        Object.entries(
                                            claims._claim_names
                                        ).forEach(
                                            assignClaim(
                                                claims,
                                                decoded,
                                                sourceName,
                                                false
                                            )
                                        )
                                    } catch (err) {
                                        err.src = sourceName
                                        throw err
                                    }
                                }
                            )
                        )

                        cleanUpClaims(claims)
                        return claims
                    }

                    /**
                     * @name unpackAggregatedClaims
                     * @api public
                     */
                    async unpackAggregatedClaims(claims) {
                        if (!isPlainObject(claims)) {
                            throw new TypeError(
                                'claims argument must be a plain object'
                            )
                        }

                        if (!isPlainObject(claims._claim_sources)) {
                            return claims
                        }

                        if (!isPlainObject(claims._claim_names)) {
                            return claims
                        }

                        const aggregatedSources = Object.entries(
                            claims._claim_sources
                        ).filter(([, value]) => value && value.JWT)

                        await Promise.all(
                            aggregatedSources.map(async ([sourceName, def]) => {
                                try {
                                    const decoded = await claimJWT.call(
                                        this,
                                        'aggregated',
                                        def.JWT
                                    )
                                    delete claims._claim_sources[sourceName]
                                    Object.entries(claims._claim_names).forEach(
                                        assignClaim(claims, decoded, sourceName)
                                    )
                                } catch (err) {
                                    err.src = sourceName
                                    throw err
                                }
                            })
                        )

                        cleanUpClaims(claims)
                        return claims
                    }

                    /**
                     * @name register
                     * @api public
                     */
                    static async register(
                        properties,
                        { initialAccessToken, jwks } = {}
                    ) {
                        assertIssuerConfiguration(
                            this.issuer,
                            'registration_endpoint'
                        )

                        if (
                            jwks !== undefined &&
                            !(properties.jwks || properties.jwks_uri)
                        ) {
                            const keystore = getKeystore.call(this, jwks)
                            properties.jwks = keystore.toJWKS(false)
                        }

                        const response = await request.call(this, {
                            headers: initialAccessToken
                                ? {
                                      Authorization: authorizationHeaderValue(
                                          initialAccessToken
                                      )
                                  }
                                : undefined,
                            json: true,
                            body: properties,
                            url: this.issuer.registration_endpoint,
                            method: 'POST'
                        })
                        const responseBody = processResponse(response, {
                            statusCode: 201,
                            bearer: true
                        })

                        return new this(responseBody, jwks)
                    }

                    /**
                     * @name metadata
                     * @api public
                     */
                    get metadata() {
                        const copy = {}
                        instance(this)
                            .get('metadata')
                            .forEach((value, key) => {
                                copy[key] = value
                            })
                        return copy
                    }

                    /**
                     * @name fromUri
                     * @api public
                     */
                    static async fromUri(
                        registrationClientUri,
                        registrationAccessToken,
                        jwks
                    ) {
                        const response = await request.call(this, {
                            method: 'GET',
                            url: registrationClientUri,
                            json: true,
                            headers: {
                                Authorization: authorizationHeaderValue(
                                    registrationAccessToken
                                )
                            }
                        })
                        const responseBody = processResponse(response, {
                            bearer: true
                        })

                        return new this(responseBody, jwks)
                    }

                    /**
                     * @name requestObject
                     * @api public
                     */
                    async requestObject(requestObject = {}, algorithms = {}) {
                        if (!isPlainObject(requestObject)) {
                            throw new TypeError(
                                'requestObject must be a plain object'
                            )
                        }

                        defaults(
                            algorithms,
                            {
                                sign: this.request_object_signing_alg,
                                encrypt: {
                                    alg: this.request_object_encryption_alg,
                                    enc:
                                        this.request_object_encryption_enc ||
                                        'A128CBC-HS256'
                                }
                            },
                            {
                                sign: 'none'
                            }
                        )

                        let signed
                        let key

                        const alg = algorithms.sign
                        const header = { alg, typ: 'JWT' }
                        const payload = JSON.stringify(
                            defaults({}, requestObject, {
                                iss: this.client_id,
                                aud: this.issuer.issuer,
                                client_id: this.client_id,
                                jti: random(),
                                iat: now(),
                                exp: now() + 300
                            })
                        )

                        if (alg === 'none') {
                            signed = [
                                base64url.encode(JSON.stringify(header)),
                                base64url.encode(payload),
                                ''
                            ].join('.')
                        } else {
                            const symmetric = alg.startsWith('HS')
                            if (symmetric) {
                                key = await this.joseSecret()
                            } else {
                                const keystore = instance(this).get('keystore')

                                if (!keystore) {
                                    throw new TypeError(
                                        `no keystore present for client, cannot sign using alg ${alg}`
                                    )
                                }
                                key = keystore.get({ alg, use: 'sig' })
                                if (!key) {
                                    throw new TypeError(
                                        `no key to sign with found for alg ${alg}`
                                    )
                                }
                            }

                            signed = jose.JWS.sign(payload, key, {
                                ...header,
                                kid: symmetric ? undefined : key.kid
                            })
                        }

                        if (!algorithms.encrypt.alg) {
                            return signed
                        }

                        const fields = {
                            alg: algorithms.encrypt.alg,
                            enc: algorithms.encrypt.enc,
                            cty: 'JWT'
                        }

                        if (fields.alg.match(/^(RSA|ECDH)/)) {
                            ;[key] = await this.issuer.queryKeyStore(
                                {
                                    alg: fields.alg,
                                    enc: fields.enc,
                                    use: 'enc'
                                },
                                { allowMulti: true }
                            )
                        } else {
                            key = await this.joseSecret(
                                fields.alg === 'dir' ? fields.enc : fields.alg
                            )
                        }

                        return jose.JWE.encrypt(signed, key, {
                            ...fields,
                            kid: key.kty === 'oct' ? undefined : key.kid
                        })
                    }

                    /**
                     * @name issuer
                     * @api public
                     */
                    static get issuer() {
                        return issuer
                    }

                    /**
                     * @name issuer
                     * @api public
                     */
                    get issuer() {
                        // eslint-disable-line class-methods-use-this
                        return issuer
                    }

                    /* istanbul ignore next */
                    [inspect.custom]() {
                        return `${this.constructor.name} ${inspect(
                            this.metadata,
                            {
                                depth: Infinity,
                                colors: process.stdout.isTTY,
                                compact: false,
                                sorted: true
                            }
                        )}`
                    }
                }

            // TODO: remove in 4.x
            BaseClient.prototype.resource = deprecate(
                /* istanbul ignore next */
                async function resource(resourceUrl, accessToken, options) {
                    let token = accessToken
                    const opts = merge(
                        {
                            verb: 'GET',
                            via: 'header'
                        },
                        options
                    )

                    if (token instanceof TokenSet) {
                        if (!token.access_token) {
                            throw new TypeError(
                                'access_token not present in TokenSet'
                            )
                        }
                        opts.tokenType = opts.tokenType || token.token_type
                        token = token.access_token
                    }

                    const verb = String(opts.verb).toUpperCase()
                    let requestOpts

                    switch (opts.via) {
                        case 'query':
                            if (verb !== 'GET') {
                                throw new TypeError(
                                    'resource servers should only parse query strings for GET requests'
                                )
                            }
                            requestOpts = { query: { access_token: token } }
                            break
                        case 'body':
                            if (verb !== 'POST') {
                                throw new TypeError(
                                    'can only send body on POST'
                                )
                            }
                            requestOpts = {
                                form: true,
                                body: { access_token: token }
                            }
                            break
                        default:
                            requestOpts = {
                                headers: {
                                    Authorization: authorizationHeaderValue(
                                        token,
                                        opts.tokenType
                                    )
                                }
                            }
                    }

                    if (opts.params) {
                        if (verb === 'POST') {
                            defaultsDeep(requestOpts, { body: opts.params })
                        } else {
                            defaultsDeep(requestOpts, { query: opts.params })
                        }
                    }

                    if (opts.headers) {
                        defaultsDeep(requestOpts, { headers: opts.headers })
                    }

                    const mTLS = !!this
                        .tls_client_certificate_bound_access_tokens

                    return request.call(
                        this,
                        {
                            ...requestOpts,
                            encoding: null,
                            method: verb,
                            url: resourceUrl
                        },
                        { mTLS }
                    )
                },
                'client.resource() is deprecated, use client.requestResource() instead, see docs for API details'
            )

            module.exports.BaseClient = BaseClient

            /***/
        },

        /***/ Hsns: /***/ function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__('93I4')
            var document = __webpack_require__('5T2Y').document
            // typeof document.createElement is 'object' in old IE
            var is = isObject(document) && isObject(document.createElement)
            module.exports = function(it) {
                return is ? document.createElement(it) : {}
            }

            /***/
        },

        /***/ Hvzi: /***/ function(module, exports) {
            /**
             * Removes `key` and its value from the hash.
             *
             * @private
             * @name delete
             * @memberOf Hash
             * @param {Object} hash The hash to modify.
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key]
                this.size -= result ? 1 : 0
                return result
            }

            module.exports = hashDelete

            /***/
        },

        /***/ HwNo: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = function(Yallist) {
                Yallist.prototype[Symbol.iterator] = function*() {
                    for (let walker = this.head; walker; walker = walker.next) {
                        yield walker.value
                    }
                }
            }

            /***/
        },

        /***/ HyWp: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // A linked list to keep track of recently-used-ness
            const Yallist = __webpack_require__('XPeR')

            const MAX = Symbol('max')
            const LENGTH = Symbol('length')
            const LENGTH_CALCULATOR = Symbol('lengthCalculator')
            const ALLOW_STALE = Symbol('allowStale')
            const MAX_AGE = Symbol('maxAge')
            const DISPOSE = Symbol('dispose')
            const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
            const LRU_LIST = Symbol('lruList')
            const CACHE = Symbol('cache')
            const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

            const naiveLength = () => 1

            // lruList is a yallist where the head is the youngest
            // item, and the tail is the oldest.  the list contains the Hit
            // objects as the entries.
            // Each Hit object has a reference to its Yallist.Node.  This
            // never changes.
            //
            // cache is a Map (or PseudoMap) that matches the keys to
            // the Yallist.Node object.
            class LRUCache {
                constructor(options) {
                    if (typeof options === 'number') options = { max: options }

                    if (!options) options = {}

                    if (
                        options.max &&
                        (typeof options.max !== 'number' || options.max < 0)
                    )
                        throw new TypeError('max must be a non-negative number')
                    // Kind of weird to have a default max of Infinity, but oh well.
                    const max = (this[MAX] = options.max || Infinity)

                    const lc = options.length || naiveLength
                    this[LENGTH_CALCULATOR] =
                        typeof lc !== 'function' ? naiveLength : lc
                    this[ALLOW_STALE] = options.stale || false
                    if (options.maxAge && typeof options.maxAge !== 'number')
                        throw new TypeError('maxAge must be a number')
                    this[MAX_AGE] = options.maxAge || 0
                    this[DISPOSE] = options.dispose
                    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
                    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
                    this.reset()
                }

                // resize the cache when the max changes.
                set max(mL) {
                    if (typeof mL !== 'number' || mL < 0)
                        throw new TypeError('max must be a non-negative number')

                    this[MAX] = mL || Infinity
                    trim(this)
                }
                get max() {
                    return this[MAX]
                }

                set allowStale(allowStale) {
                    this[ALLOW_STALE] = !!allowStale
                }
                get allowStale() {
                    return this[ALLOW_STALE]
                }

                set maxAge(mA) {
                    if (typeof mA !== 'number')
                        throw new TypeError(
                            'maxAge must be a non-negative number'
                        )

                    this[MAX_AGE] = mA
                    trim(this)
                }
                get maxAge() {
                    return this[MAX_AGE]
                }

                // resize the cache when the lengthCalculator changes.
                set lengthCalculator(lC) {
                    if (typeof lC !== 'function') lC = naiveLength

                    if (lC !== this[LENGTH_CALCULATOR]) {
                        this[LENGTH_CALCULATOR] = lC
                        this[LENGTH] = 0
                        this[LRU_LIST].forEach(hit => {
                            hit.length = this[LENGTH_CALCULATOR](
                                hit.value,
                                hit.key
                            )
                            this[LENGTH] += hit.length
                        })
                    }
                    trim(this)
                }
                get lengthCalculator() {
                    return this[LENGTH_CALCULATOR]
                }

                get length() {
                    return this[LENGTH]
                }
                get itemCount() {
                    return this[LRU_LIST].length
                }

                rforEach(fn, thisp) {
                    thisp = thisp || this
                    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
                        const prev = walker.prev
                        forEachStep(this, fn, walker, thisp)
                        walker = prev
                    }
                }

                forEach(fn, thisp) {
                    thisp = thisp || this
                    for (let walker = this[LRU_LIST].head; walker !== null; ) {
                        const next = walker.next
                        forEachStep(this, fn, walker, thisp)
                        walker = next
                    }
                }

                keys() {
                    return this[LRU_LIST].toArray().map(k => k.key)
                }

                values() {
                    return this[LRU_LIST].toArray().map(k => k.value)
                }

                reset() {
                    if (
                        this[DISPOSE] &&
                        this[LRU_LIST] &&
                        this[LRU_LIST].length
                    ) {
                        this[LRU_LIST].forEach(hit =>
                            this[DISPOSE](hit.key, hit.value)
                        )
                    }

                    this[CACHE] = new Map() // hash of items by key
                    this[LRU_LIST] = new Yallist() // list of items in order of use recency
                    this[LENGTH] = 0 // length of items in the list
                }

                dump() {
                    return this[LRU_LIST].map(hit =>
                        isStale(this, hit)
                            ? false
                            : {
                                  k: hit.key,
                                  v: hit.value,
                                  e: hit.now + (hit.maxAge || 0)
                              }
                    )
                        .toArray()
                        .filter(h => h)
                }

                dumpLru() {
                    return this[LRU_LIST]
                }

                set(key, value, maxAge) {
                    maxAge = maxAge || this[MAX_AGE]

                    if (maxAge && typeof maxAge !== 'number')
                        throw new TypeError('maxAge must be a number')

                    const now = maxAge ? Date.now() : 0
                    const len = this[LENGTH_CALCULATOR](value, key)

                    if (this[CACHE].has(key)) {
                        if (len > this[MAX]) {
                            del(this, this[CACHE].get(key))
                            return false
                        }

                        const node = this[CACHE].get(key)
                        const item = node.value

                        // dispose of the old one before overwriting
                        // split out into 2 ifs for better coverage tracking
                        if (this[DISPOSE]) {
                            if (!this[NO_DISPOSE_ON_SET])
                                this[DISPOSE](key, item.value)
                        }

                        item.now = now
                        item.maxAge = maxAge
                        item.value = value
                        this[LENGTH] += len - item.length
                        item.length = len
                        this.get(key)
                        trim(this)
                        return true
                    }

                    const hit = new Entry(key, value, len, now, maxAge)

                    // oversized objects fall out of cache automatically.
                    if (hit.length > this[MAX]) {
                        if (this[DISPOSE]) this[DISPOSE](key, value)

                        return false
                    }

                    this[LENGTH] += hit.length
                    this[LRU_LIST].unshift(hit)
                    this[CACHE].set(key, this[LRU_LIST].head)
                    trim(this)
                    return true
                }

                has(key) {
                    if (!this[CACHE].has(key)) return false
                    const hit = this[CACHE].get(key).value
                    return !isStale(this, hit)
                }

                get(key) {
                    return get(this, key, true)
                }

                peek(key) {
                    return get(this, key, false)
                }

                pop() {
                    const node = this[LRU_LIST].tail
                    if (!node) return null

                    del(this, node)
                    return node.value
                }

                del(key) {
                    del(this, this[CACHE].get(key))
                }

                load(arr) {
                    // reset the cache
                    this.reset()

                    const now = Date.now()
                    // A previous serialized cache has the most recent items first
                    for (let l = arr.length - 1; l >= 0; l--) {
                        const hit = arr[l]
                        const expiresAt = hit.e || 0
                        if (expiresAt === 0)
                            // the item was created without expiration in a non aged cache
                            this.set(hit.k, hit.v)
                        else {
                            const maxAge = expiresAt - now
                            // dont add already expired items
                            if (maxAge > 0) {
                                this.set(hit.k, hit.v, maxAge)
                            }
                        }
                    }
                }

                prune() {
                    this[CACHE].forEach((value, key) => get(this, key, false))
                }
            }

            const get = (self, key, doUse) => {
                const node = self[CACHE].get(key)
                if (node) {
                    const hit = node.value
                    if (isStale(self, hit)) {
                        del(self, node)
                        if (!self[ALLOW_STALE]) return undefined
                    } else {
                        if (doUse) {
                            if (self[UPDATE_AGE_ON_GET])
                                node.value.now = Date.now()
                            self[LRU_LIST].unshiftNode(node)
                        }
                    }
                    return hit.value
                }
            }

            const isStale = (self, hit) => {
                if (!hit || (!hit.maxAge && !self[MAX_AGE])) return false

                const diff = Date.now() - hit.now
                return hit.maxAge
                    ? diff > hit.maxAge
                    : self[MAX_AGE] && diff > self[MAX_AGE]
            }

            const trim = self => {
                if (self[LENGTH] > self[MAX]) {
                    for (
                        let walker = self[LRU_LIST].tail;
                        self[LENGTH] > self[MAX] && walker !== null;

                    ) {
                        // We know that we're about to delete this one, and also
                        // what the next least recently used key will be, so just
                        // go ahead and set it now.
                        const prev = walker.prev
                        del(self, walker)
                        walker = prev
                    }
                }
            }

            const del = (self, node) => {
                if (node) {
                    const hit = node.value
                    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value)

                    self[LENGTH] -= hit.length
                    self[CACHE].delete(hit.key)
                    self[LRU_LIST].removeNode(node)
                }
            }

            class Entry {
                constructor(key, value, length, now, maxAge) {
                    this.key = key
                    this.value = value
                    this.length = length
                    this.now = now
                    this.maxAge = maxAge || 0
                }
            }

            const forEachStep = (self, fn, node, thisp) => {
                let hit = node.value
                if (isStale(self, hit)) {
                    del(self, node)
                    if (!self[ALLOW_STALE]) hit = undefined
                }
                if (hit) fn.call(thisp, hit.value, hit.key, self)
            }

            module.exports = LRUCache

            /***/
        },

        /***/ I01J: /***/ function(module, exports, __webpack_require__) {
            var memoize = __webpack_require__('44Ds')

            /** Used as the maximum memoize cache size. */
            var MAX_MEMOIZE_SIZE = 500

            /**
             * A specialized version of `_.memoize` which clears the memoized function's
             * cache when it exceeds `MAX_MEMOIZE_SIZE`.
             *
             * @private
             * @param {Function} func The function to have its output memoized.
             * @returns {Function} Returns the new memoized function.
             */
            function memoizeCapped(func) {
                var result = memoize(func, function(key) {
                    if (cache.size === MAX_MEMOIZE_SIZE) {
                        cache.clear()
                    }
                    return key
                })

                var cache = result.cache
                return result
            }

            module.exports = memoizeCapped

            /***/
        },

        /***/ IOzZ: /***/ function(module, exports) {
            /**
             * A specialized version of `matchesProperty` for source values suitable
             * for strict equality comparisons, i.e. `===`.
             *
             * @private
             * @param {string} key The key of the property to get.
             * @param {*} srcValue The value to match.
             * @returns {Function} Returns the new spec function.
             */
            function matchesStrictComparable(key, srcValue) {
                return function(object) {
                    if (object == null) {
                        return false
                    }
                    return (
                        object[key] === srcValue &&
                        (srcValue !== undefined || key in Object(object))
                    )
                }
            }

            module.exports = matchesStrictComparable

            /***/
        },

        /***/ IP1Z: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var $defineProperty = __webpack_require__('2faE')
            var createDesc = __webpack_require__('rr1i')

            module.exports = function(object, index, value) {
                if (index in object)
                    $defineProperty.f(object, index, createDesc(0, value))
                else object[index] = value
            }

            /***/
        },

        /***/ IWF7: /***/ function(module, exports, __webpack_require__) {
            const { createHmac } = __webpack_require__('PJMN')

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const timingSafeEqual = __webpack_require__('kuaU')
            const resolveNodeAlg = __webpack_require__('uGJc')
            const { asInput } = __webpack_require__('1ALl')

            const sign = (
                jwaAlg,
                hmacAlg,
                { [KEYOBJECT]: keyObject },
                payload
            ) => {
                const hmac = createHmac(hmacAlg, asInput(keyObject, false))
                hmac.update(payload)
                return hmac.digest()
            }

            const verify = (jwaAlg, hmacAlg, key, payload, signature) => {
                const expected = sign(jwaAlg, hmacAlg, key, payload)
                const actual = signature

                return timingSafeEqual(actual, expected)
            }

            module.exports = (JWA, JWK) => {
                ;['HS256', 'HS384', 'HS512'].forEach(jwaAlg => {
                    const hmacAlg = resolveNodeAlg(jwaAlg)
                    JWA.sign.set(jwaAlg, sign.bind(undefined, jwaAlg, hmacAlg))
                    JWA.verify.set(
                        jwaAlg,
                        verify.bind(undefined, jwaAlg, hmacAlg)
                    )
                    JWK.oct.sign[jwaAlg] = JWK.oct.verify[jwaAlg] = key =>
                        key.use === 'sig' || key.use === undefined
                })
            }

            /***/
        },

        /***/ IgmS: /***/ function(module, exports, __webpack_require__) {
            const base64url = __webpack_require__('+00W')
            const assign = __webpack_require__('3OWR')

            const now = __webpack_require__('PbSP')

            class TokenSet {
                /**
                 * @name constructor
                 * @api public
                 */
                constructor(values) {
                    assign(this, values)
                }

                /**
                 * @name expires_in=
                 * @api public
                 */
                set expires_in(value) {
                    // eslint-disable-line camelcase
                    this.expires_at = now() + Number(value)
                }

                /**
                 * @name expires_in
                 * @api public
                 */
                get expires_in() {
                    // eslint-disable-line camelcase
                    return Math.max.apply(null, [this.expires_at - now(), 0])
                }

                /**
                 * @name expired
                 * @api public
                 */
                expired() {
                    return this.expires_in === 0
                }

                /**
                 * @name claims
                 * @api public
                 */
                claims() {
                    if (!this.id_token) {
                        throw new TypeError('id_token not present in TokenSet')
                    }

                    return JSON.parse(
                        base64url.decode(this.id_token.split('.')[1])
                    )
                }
            }

            module.exports = TokenSet

            /***/
        },

        /***/ Ioao: /***/ function(module, exports, __webpack_require__) {
            var apply = __webpack_require__('heNW')

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeMax = Math.max

            /**
             * A specialized version of `baseRest` which transforms the rest array.
             *
             * @private
             * @param {Function} func The function to apply a rest parameter to.
             * @param {number} [start=func.length-1] The start position of the rest parameter.
             * @param {Function} transform The rest array transform.
             * @returns {Function} Returns the new function.
             */
            function overRest(func, start, transform) {
                start = nativeMax(
                    start === undefined ? func.length - 1 : start,
                    0
                )
                return function() {
                    var args = arguments,
                        index = -1,
                        length = nativeMax(args.length - start, 0),
                        array = Array(length)

                    while (++index < length) {
                        array[index] = args[start + index]
                    }
                    index = -1
                    var otherArgs = Array(start + 1)
                    while (++index < start) {
                        otherArgs[index] = args[index]
                    }
                    otherArgs[start] = transform(array)
                    return apply(func, this, otherArgs)
                }
            }

            module.exports = overRest

            /***/
        },

        /***/ J0Hf: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            function sessionHandler(sessionStore) {
                return req => {
                    if (!req) {
                        throw new Error('Request is not available')
                    }
                    return sessionStore.read(req)
                }
            }
            exports.default = sessionHandler
            //# sourceMappingURL=session.js.map

            /***/
        },

        /***/ JB68: /***/ function(module, exports, __webpack_require__) {
            // 7.1.13 ToObject(argument)
            var defined = __webpack_require__('Jes0')
            module.exports = function(it) {
                return Object(defined(it))
            }

            /***/
        },

        /***/ JBE3: /***/ function(module, exports, __webpack_require__) {
            var baseMerge = __webpack_require__('+Qka'),
                createAssigner = __webpack_require__('LsHQ')

            /**
             * This method is like `_.merge` except that it accepts `customizer` which
             * is invoked to produce the merged values of the destination and source
             * properties. If `customizer` returns `undefined`, merging is handled by the
             * method instead. The `customizer` is invoked with six arguments:
             * (objValue, srcValue, key, object, source, stack).
             *
             * **Note:** This method mutates `object`.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Object
             * @param {Object} object The destination object.
             * @param {...Object} sources The source objects.
             * @param {Function} customizer The function to customize assigned values.
             * @returns {Object} Returns `object`.
             * @example
             *
             * function customizer(objValue, srcValue) {
             *   if (_.isArray(objValue)) {
             *     return objValue.concat(srcValue);
             *   }
             * }
             *
             * var object = { 'a': [1], 'b': [2] };
             * var other = { 'a': [3], 'b': [4] };
             *
             * _.mergeWith(object, other, customizer);
             * // => { 'a': [1, 3], 'b': [2, 4] }
             */
            var mergeWith = createAssigner(function(
                object,
                source,
                srcIndex,
                customizer
            ) {
                baseMerge(object, source, srcIndex, customizer)
            })

            module.exports = mergeWith

            /***/
        },

        /***/ JEQr: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')
            var normalizeHeaderName = __webpack_require__('yK9s')

            var DEFAULT_CONTENT_TYPE = {
                'Content-Type': 'application/x-www-form-urlencoded'
            }

            function setContentTypeIfUnset(headers, value) {
                if (
                    !utils.isUndefined(headers) &&
                    utils.isUndefined(headers['Content-Type'])
                ) {
                    headers['Content-Type'] = value
                }
            }

            function getDefaultAdapter() {
                var adapter
                if (typeof XMLHttpRequest !== 'undefined') {
                    // For browsers use XHR adapter
                    adapter = __webpack_require__('tQ2B')
                } else if (
                    typeof process !== 'undefined' &&
                    Object.prototype.toString.call(process) ===
                        '[object process]'
                ) {
                    // For node use HTTP adapter
                    adapter = __webpack_require__('maZv')
                }
                return adapter
            }

            var defaults = {
                adapter: getDefaultAdapter(),

                transformRequest: [
                    function transformRequest(data, headers) {
                        normalizeHeaderName(headers, 'Accept')
                        normalizeHeaderName(headers, 'Content-Type')
                        if (
                            utils.isFormData(data) ||
                            utils.isArrayBuffer(data) ||
                            utils.isBuffer(data) ||
                            utils.isStream(data) ||
                            utils.isFile(data) ||
                            utils.isBlob(data)
                        ) {
                            return data
                        }
                        if (utils.isArrayBufferView(data)) {
                            return data.buffer
                        }
                        if (utils.isURLSearchParams(data)) {
                            setContentTypeIfUnset(
                                headers,
                                'application/x-www-form-urlencoded;charset=utf-8'
                            )
                            return data.toString()
                        }
                        if (utils.isObject(data)) {
                            setContentTypeIfUnset(
                                headers,
                                'application/json;charset=utf-8'
                            )
                            return JSON.stringify(data)
                        }
                        return data
                    }
                ],

                transformResponse: [
                    function transformResponse(data) {
                        /*eslint no-param-reassign:0*/
                        if (typeof data === 'string') {
                            try {
                                data = JSON.parse(data)
                            } catch (e) {
                                /* Ignore */
                            }
                        }
                        return data
                    }
                ],

                /**
                 * A timeout in milliseconds to abort a request. If set to 0 (default) a
                 * timeout is not created.
                 */
                timeout: 0,

                xsrfCookieName: 'XSRF-TOKEN',
                xsrfHeaderName: 'X-XSRF-TOKEN',

                maxContentLength: -1,

                validateStatus: function validateStatus(status) {
                    return status >= 200 && status < 300
                }
            }

            defaults.headers = {
                common: {
                    Accept: 'application/json, text/plain, */*'
                }
            }

            utils.forEach(
                ['delete', 'get', 'head'],
                function forEachMethodNoData(method) {
                    defaults.headers[method] = {}
                }
            )

            utils.forEach(
                ['post', 'put', 'patch'],
                function forEachMethodWithData(method) {
                    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE)
                }
            )

            module.exports = defaults

            /***/
        },

        /***/ JHRd: /***/ function(module, exports, __webpack_require__) {
            var root = __webpack_require__('Kz5y')

            /** Built-in value references. */
            var Uint8Array = root.Uint8Array

            module.exports = Uint8Array

            /***/
        },

        /***/ JHgL: /***/ function(module, exports, __webpack_require__) {
            var getMapData = __webpack_require__('QkVE')

            /**
             * Gets the map value for `key`.
             *
             * @private
             * @name get
             * @memberOf MapCache
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function mapCacheGet(key) {
                return getMapData(this, key).get(key)
            }

            module.exports = mapCacheGet

            /***/
        },

        /***/ 'JMW+': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var LIBRARY = __webpack_require__('uOPS')
            var global = __webpack_require__('5T2Y')
            var ctx = __webpack_require__('2GTP')
            var classof = __webpack_require__('QMMT')
            var $export = __webpack_require__('Y7ZC')
            var isObject = __webpack_require__('93I4')
            var aFunction = __webpack_require__('eaoh')
            var anInstance = __webpack_require__('EXMj')
            var forOf = __webpack_require__('oioR')
            var speciesConstructor = __webpack_require__('8gHz')
            var task = __webpack_require__('QXhf').set
            var microtask = __webpack_require__('q6LJ')()
            var newPromiseCapabilityModule = __webpack_require__('ZW5q')
            var perform = __webpack_require__('RDmV')
            var userAgent = __webpack_require__('vBP9')
            var promiseResolve = __webpack_require__('zXhZ')
            var PROMISE = 'Promise'
            var TypeError = global.TypeError
            var process = global.process
            var versions = process && process.versions
            var v8 = (versions && versions.v8) || ''
            var $Promise = global[PROMISE]
            var isNode = classof(process) == 'process'
            var empty = function() {
                /* empty */
            }
            var Internal,
                newGenericPromiseCapability,
                OwnPromiseCapability,
                Wrapper
            var newPromiseCapability = (newGenericPromiseCapability =
                newPromiseCapabilityModule.f)

            var USE_NATIVE = !!(function() {
                try {
                    // correct subclassing with @@species support
                    var promise = $Promise.resolve(1)
                    var FakePromise = ((promise.constructor = {})[
                        __webpack_require__('UWiX')('species')
                    ] = function(exec) {
                        exec(empty, empty)
                    })
                    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
                    return (
                        (isNode ||
                            typeof PromiseRejectionEvent == 'function') &&
                        promise.then(empty) instanceof FakePromise &&
                        // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
                        // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
                        // we can't detect it synchronously, so just check versions
                        v8.indexOf('6.6') !== 0 &&
                        userAgent.indexOf('Chrome/66') === -1
                    )
                } catch (e) {
                    /* empty */
                }
            })()

            // helpers
            var isThenable = function(it) {
                var then
                return isObject(it) && typeof (then = it.then) == 'function'
                    ? then
                    : false
            }
            var notify = function(promise, isReject) {
                if (promise._n) return
                promise._n = true
                var chain = promise._c
                microtask(function() {
                    var value = promise._v
                    var ok = promise._s == 1
                    var i = 0
                    var run = function(reaction) {
                        var handler = ok ? reaction.ok : reaction.fail
                        var resolve = reaction.resolve
                        var reject = reaction.reject
                        var domain = reaction.domain
                        var result, then, exited
                        try {
                            if (handler) {
                                if (!ok) {
                                    if (promise._h == 2)
                                        onHandleUnhandled(promise)
                                    promise._h = 1
                                }
                                if (handler === true) result = value
                                else {
                                    if (domain) domain.enter()
                                    result = handler(value) // may throw
                                    if (domain) {
                                        domain.exit()
                                        exited = true
                                    }
                                }
                                if (result === reaction.promise) {
                                    reject(TypeError('Promise-chain cycle'))
                                } else if ((then = isThenable(result))) {
                                    then.call(result, resolve, reject)
                                } else resolve(result)
                            } else reject(value)
                        } catch (e) {
                            if (domain && !exited) domain.exit()
                            reject(e)
                        }
                    }
                    while (chain.length > i) run(chain[i++]) // variable length - can't use forEach
                    promise._c = []
                    promise._n = false
                    if (isReject && !promise._h) onUnhandled(promise)
                })
            }
            var onUnhandled = function(promise) {
                task.call(global, function() {
                    var value = promise._v
                    var unhandled = isUnhandled(promise)
                    var result, handler, console
                    if (unhandled) {
                        result = perform(function() {
                            if (isNode) {
                                process.emit(
                                    'unhandledRejection',
                                    value,
                                    promise
                                )
                            } else if (
                                (handler = global.onunhandledrejection)
                            ) {
                                handler({ promise: promise, reason: value })
                            } else if (
                                (console = global.console) &&
                                console.error
                            ) {
                                console.error(
                                    'Unhandled promise rejection',
                                    value
                                )
                            }
                        })
                        // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
                        promise._h = isNode || isUnhandled(promise) ? 2 : 1
                    }
                    promise._a = undefined
                    if (unhandled && result.e) throw result.v
                })
            }
            var isUnhandled = function(promise) {
                return (
                    promise._h !== 1 && (promise._a || promise._c).length === 0
                )
            }
            var onHandleUnhandled = function(promise) {
                task.call(global, function() {
                    var handler
                    if (isNode) {
                        process.emit('rejectionHandled', promise)
                    } else if ((handler = global.onrejectionhandled)) {
                        handler({ promise: promise, reason: promise._v })
                    }
                })
            }
            var $reject = function(value) {
                var promise = this
                if (promise._d) return
                promise._d = true
                promise = promise._w || promise // unwrap
                promise._v = value
                promise._s = 2
                if (!promise._a) promise._a = promise._c.slice()
                notify(promise, true)
            }
            var $resolve = function(value) {
                var promise = this
                var then
                if (promise._d) return
                promise._d = true
                promise = promise._w || promise // unwrap
                try {
                    if (promise === value)
                        throw TypeError("Promise can't be resolved itself")
                    if ((then = isThenable(value))) {
                        microtask(function() {
                            var wrapper = { _w: promise, _d: false } // wrap
                            try {
                                then.call(
                                    value,
                                    ctx($resolve, wrapper, 1),
                                    ctx($reject, wrapper, 1)
                                )
                            } catch (e) {
                                $reject.call(wrapper, e)
                            }
                        })
                    } else {
                        promise._v = value
                        promise._s = 1
                        notify(promise, false)
                    }
                } catch (e) {
                    $reject.call({ _w: promise, _d: false }, e) // wrap
                }
            }

            // constructor polyfill
            if (!USE_NATIVE) {
                // 25.4.3.1 Promise(executor)
                $Promise = function Promise(executor) {
                    anInstance(this, $Promise, PROMISE, '_h')
                    aFunction(executor)
                    Internal.call(this)
                    try {
                        executor(ctx($resolve, this, 1), ctx($reject, this, 1))
                    } catch (err) {
                        $reject.call(this, err)
                    }
                }
                // eslint-disable-next-line no-unused-vars
                Internal = function Promise(executor) {
                    this._c = [] // <- awaiting reactions
                    this._a = undefined // <- checked in isUnhandled reactions
                    this._s = 0 // <- state
                    this._d = false // <- done
                    this._v = undefined // <- value
                    this._h = 0 // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
                    this._n = false // <- notify
                }
                Internal.prototype = __webpack_require__('XJU/')(
                    $Promise.prototype,
                    {
                        // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
                        then: function then(onFulfilled, onRejected) {
                            var reaction = newPromiseCapability(
                                speciesConstructor(this, $Promise)
                            )
                            reaction.ok =
                                typeof onFulfilled == 'function'
                                    ? onFulfilled
                                    : true
                            reaction.fail =
                                typeof onRejected == 'function' && onRejected
                            reaction.domain = isNode
                                ? process.domain
                                : undefined
                            this._c.push(reaction)
                            if (this._a) this._a.push(reaction)
                            if (this._s) notify(this, false)
                            return reaction.promise
                        },
                        // 25.4.5.1 Promise.prototype.catch(onRejected)
                        catch: function(onRejected) {
                            return this.then(undefined, onRejected)
                        }
                    }
                )
                OwnPromiseCapability = function() {
                    var promise = new Internal()
                    this.promise = promise
                    this.resolve = ctx($resolve, promise, 1)
                    this.reject = ctx($reject, promise, 1)
                }
                newPromiseCapabilityModule.f = newPromiseCapability = function(
                    C
                ) {
                    return C === $Promise || C === Wrapper
                        ? new OwnPromiseCapability(C)
                        : newGenericPromiseCapability(C)
                }
            }

            $export($export.G + $export.W + $export.F * !USE_NATIVE, {
                Promise: $Promise
            })
            __webpack_require__('RfKB')($Promise, PROMISE)
            __webpack_require__('TJWN')(PROMISE)
            Wrapper = __webpack_require__('WEpk')[PROMISE]

            // statics
            $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
                // 25.4.4.5 Promise.reject(r)
                reject: function reject(r) {
                    var capability = newPromiseCapability(this)
                    var $$reject = capability.reject
                    $$reject(r)
                    return capability.promise
                }
            })
            $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
                // 25.4.4.6 Promise.resolve(x)
                resolve: function resolve(x) {
                    return promiseResolve(
                        LIBRARY && this === Wrapper ? $Promise : this,
                        x
                    )
                }
            })
            $export(
                $export.S +
                    $export.F *
                        !(
                            USE_NATIVE &&
                            __webpack_require__('TuGD')(function(iter) {
                                $Promise.all(iter)['catch'](empty)
                            })
                        ),
                PROMISE,
                {
                    // 25.4.4.1 Promise.all(iterable)
                    all: function all(iterable) {
                        var C = this
                        var capability = newPromiseCapability(C)
                        var resolve = capability.resolve
                        var reject = capability.reject
                        var result = perform(function() {
                            var values = []
                            var index = 0
                            var remaining = 1
                            forOf(iterable, false, function(promise) {
                                var $index = index++
                                var alreadyCalled = false
                                values.push(undefined)
                                remaining++
                                C.resolve(promise).then(function(value) {
                                    if (alreadyCalled) return
                                    alreadyCalled = true
                                    values[$index] = value
                                    --remaining || resolve(values)
                                }, reject)
                            })
                            --remaining || resolve(values)
                        })
                        if (result.e) reject(result.v)
                        return capability.promise
                    },
                    // 25.4.4.4 Promise.race(iterable)
                    race: function race(iterable) {
                        var C = this
                        var capability = newPromiseCapability(C)
                        var reject = capability.reject
                        var result = perform(function() {
                            forOf(iterable, false, function(promise) {
                                C.resolve(promise).then(
                                    capability.resolve,
                                    reject
                                )
                            })
                        })
                        if (result.e) reject(result.v)
                        return capability.promise
                    }
                }
            )

            /***/
        },

        /***/ JSQU: /***/ function(module, exports, __webpack_require__) {
            var nativeCreate = __webpack_require__('YESw')

            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__'

            /**
             * Sets the hash `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf Hash
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the hash instance.
             */
            function hashSet(key, value) {
                var data = this.__data__
                this.size += this.has(key) ? 0 : 1
                data[key] =
                    nativeCreate && value === undefined ? HASH_UNDEFINED : value
                return this
            }

            module.exports = hashSet

            /***/
        },

        /***/ JTzB: /***/ function(module, exports, __webpack_require__) {
            var baseGetTag = __webpack_require__('NykK'),
                isObjectLike = __webpack_require__('ExA7')

            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]'

            /**
             * The base implementation of `_.isArguments`.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an `arguments` object,
             */
            function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag
            }

            module.exports = baseIsArguments

            /***/
        },

        /***/ Jes0: /***/ function(module, exports) {
            // 7.2.1 RequireObjectCoercible(argument)
            module.exports = function(it) {
                if (it == undefined)
                    throw TypeError("Can't call method on  " + it)
                return it
            }

            /***/
        },

        /***/ 'JlL/': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = [
                'beforeError',
                'init',
                'beforeRequest',
                'beforeRedirect',
                'beforeRetry',
                'afterResponse'
            ]

            /***/
        },

        /***/ 'Jo+v': /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('/eQG')

            /***/
        },

        /***/ Juji: /***/ function(module, exports) {
            /**
             * The base implementation of `_.hasIn` without support for deep paths.
             *
             * @private
             * @param {Object} [object] The object to query.
             * @param {Array|string} key The key to check.
             * @returns {boolean} Returns `true` if `key` exists, else `false`.
             */
            function baseHasIn(object, key) {
                return object != null && key in Object(object)
            }

            module.exports = baseHasIn

            /***/
        },

        /***/ K0QS: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { Transform } = __webpack_require__('msIP')

            module.exports = {
                download(response, emitter, downloadBodySize) {
                    let downloaded = 0

                    return new Transform({
                        transform(chunk, encoding, callback) {
                            downloaded += chunk.length

                            const percent = downloadBodySize
                                ? downloaded / downloadBodySize
                                : 0

                            // Let `flush()` be responsible for emitting the last event
                            if (percent < 1) {
                                emitter.emit('downloadProgress', {
                                    percent,
                                    transferred: downloaded,
                                    total: downloadBodySize
                                })
                            }

                            callback(null, chunk)
                        },

                        flush(callback) {
                            emitter.emit('downloadProgress', {
                                percent: 1,
                                transferred: downloaded,
                                total: downloadBodySize
                            })

                            callback()
                        }
                    })
                },

                upload(request, emitter, uploadBodySize) {
                    const uploadEventFrequency = 150
                    let uploaded = 0
                    let progressInterval

                    emitter.emit('uploadProgress', {
                        percent: 0,
                        transferred: 0,
                        total: uploadBodySize
                    })

                    request.once('error', () => {
                        clearInterval(progressInterval)
                    })

                    request.once('response', () => {
                        clearInterval(progressInterval)

                        emitter.emit('uploadProgress', {
                            percent: 1,
                            transferred: uploaded,
                            total: uploadBodySize
                        })
                    })

                    request.once('socket', socket => {
                        const onSocketConnect = () => {
                            progressInterval = setInterval(() => {
                                const lastUploaded = uploaded
                                /* istanbul ignore next: see #490 (occurs randomly!) */
                                const headersSize = request._header
                                    ? Buffer.byteLength(request._header)
                                    : 0
                                uploaded = socket.bytesWritten - headersSize

                                // Don't emit events with unchanged progress and
                                // prevent last event from being emitted, because
                                // it's emitted when `response` is emitted
                                if (
                                    uploaded === lastUploaded ||
                                    uploaded === uploadBodySize
                                ) {
                                    return
                                }

                                emitter.emit('uploadProgress', {
                                    percent: uploadBodySize
                                        ? uploaded / uploadBodySize
                                        : 0,
                                    transferred: uploaded,
                                    total: uploadBodySize
                                })
                            }, uploadEventFrequency)
                        }

                        /* istanbul ignore next: hard to test */
                        if (socket.connecting) {
                            socket.once('connect', onSocketConnect)
                        } else if (socket.writable) {
                            // The socket is being reused from pool,
                            // so the connect event will not be emitted
                            onSocketConnect()
                        }
                    })
                }
            }

            /***/
        },

        /***/ KEll: /***/ function(module, exports) {
            module.exports = require('http')

            /***/
        },

        /***/ KI45: /***/ function(module, exports) {
            function _interopRequireDefault(obj) {
                return obj && obj.__esModule
                    ? obj
                    : {
                          default: obj
                      }
            }

            module.exports = _interopRequireDefault

            /***/
        },

        /***/ KMkd: /***/ function(module, exports) {
            /**
             * Removes all key-value entries from the list cache.
             *
             * @private
             * @name clear
             * @memberOf ListCache
             */
            function listCacheClear() {
                this.__data__ = []
                this.size = 0
            }

            module.exports = listCacheClear

            /***/
        },

        /***/ KQbz: /***/ function(module, exports) {
            module.exports = (a = {}, b = {}) => {
                const keysA = Object.keys(a)
                const keysB = new Set(Object.keys(b))
                return !keysA.some(ka => keysB.has(ka))
            }

            /***/
        },

        /***/ KUxP: /***/ function(module, exports) {
            module.exports = function(exec) {
                try {
                    return !!exec()
                } catch (e) {
                    return true
                }
            }

            /***/
        },

        /***/ KfNM: /***/ function(module, exports) {
            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /**
             * Used to resolve the
             * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
             * of values.
             */
            var nativeObjectToString = objectProto.toString

            /**
             * Converts `value` to a string using `Object.prototype.toString`.
             *
             * @private
             * @param {*} value The value to convert.
             * @returns {string} Returns the converted string.
             */
            function objectToString(value) {
                return nativeObjectToString.call(value)
            }

            module.exports = objectToString

            /***/
        },

        /***/ KqAr: /***/ function(
            module,
            __webpack_exports__,
            __webpack_require__
        ) {
            'use strict'
            __webpack_require__.r(__webpack_exports__)

            /* harmony default export */ __webpack_exports__[
                'default'
            ] = function(ctx) {
                return Promise.all([])
            }

            /***/
        },

        /***/ KqF2: /***/ function(module, exports) {
            module.exports = new Map([
                ['A128CBC-HS256', 128],
                ['A128GCM', 96],
                ['A128GCMKW', 96],
                ['A192CBC-HS384', 128],
                ['A192GCM', 96],
                ['A192GCMKW', 96],
                ['A256CBC-HS512', 128],
                ['A256GCM', 96],
                ['A256GCMKW', 96]
            ])

            /***/
        },

        /***/ Kz5y: /***/ function(module, exports, __webpack_require__) {
            var freeGlobal = __webpack_require__('WFqU')

            /** Detect free variable `self`. */
            var freeSelf =
                typeof self == 'object' &&
                self &&
                self.Object === Object &&
                self

            /** Used as a reference to the global object. */
            var root = freeGlobal || freeSelf || Function('return this')()

            module.exports = root

            /***/
        },

        /***/ L71r: /***/ function(module, exports, __webpack_require__) {
            /* eslint-disable camelcase */
            const { format } = __webpack_require__('jK02')

            const assign = __webpack_require__('3OWR')
            const makeError = __webpack_require__('b1HN')

            function OPError(
                {
                    error_description,
                    error,
                    error_uri,
                    session_state,
                    state,
                    scope
                },
                response
            ) {
                OPError.super.call(
                    this,
                    !error_description
                        ? error
                        : `${error} (${error_description})`
                )

                assign(
                    this,
                    { error },
                    error_description && { error_description },
                    error_uri && { error_uri },
                    state && { state },
                    scope && { scope },
                    session_state && { session_state }
                )

                if (response) {
                    Object.defineProperty(this, 'response', {
                        value: response
                    })
                }
            }

            makeError(OPError)

            function RPError(...args) {
                if (typeof args[0] === 'string') {
                    RPError.super.call(this, format(...args))
                } else {
                    const { message, printf, response, ...rest } = args[0]
                    if (printf) {
                        RPError.super.call(this, format(...printf))
                    } else {
                        RPError.super.call(this, message)
                    }
                    assign(this, rest)
                    if (response) {
                        Object.defineProperty(this, 'response', {
                            value: response
                        })
                    }
                }
            }

            makeError(RPError)

            module.exports = {
                OPError,
                RPError
            }

            /***/
        },

        /***/ L8xA: /***/ function(module, exports) {
            /**
             * Removes `key` and its value from the stack.
             *
             * @private
             * @name delete
             * @memberOf Stack
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function stackDelete(key) {
                var data = this.__data__,
                    result = data['delete'](key)

                this.size = data.size
                return result
            }

            module.exports = stackDelete

            /***/
        },

        /***/ LDEB: /***/ function(module, exports, __webpack_require__) {
            const errors = __webpack_require__('yt7c')

            const importKey = __webpack_require__('GhER')

            const RSAKey = __webpack_require__('RoCg')
            const ECKey = __webpack_require__('3HlQ')
            const OKPKey = __webpack_require__('vC2k')
            const OctKey = __webpack_require__('BBt9')

            const generate = async (
                kty,
                crvOrSize,
                params,
                generatePrivate = true
            ) => {
                switch (kty) {
                    case 'RSA':
                        return importKey(
                            await RSAKey.generate(crvOrSize, generatePrivate),
                            params
                        )
                    case 'EC':
                        return importKey(
                            await ECKey.generate(crvOrSize, generatePrivate),
                            params
                        )
                    case 'OKP':
                        return importKey(
                            await OKPKey.generate(crvOrSize, generatePrivate),
                            params
                        )
                    case 'oct':
                        return importKey(
                            await OctKey.generate(crvOrSize, generatePrivate),
                            params
                        )
                    default:
                        throw new errors.JOSENotSupported(
                            `unsupported key type: ${kty}`
                        )
                }
            }

            const generateSync = (
                kty,
                crvOrSize,
                params,
                generatePrivate = true
            ) => {
                switch (kty) {
                    case 'RSA':
                        return importKey(
                            RSAKey.generateSync(crvOrSize, generatePrivate),
                            params
                        )
                    case 'EC':
                        return importKey(
                            ECKey.generateSync(crvOrSize, generatePrivate),
                            params
                        )
                    case 'OKP':
                        return importKey(
                            OKPKey.generateSync(crvOrSize, generatePrivate),
                            params
                        )
                    case 'oct':
                        return importKey(
                            OctKey.generateSync(crvOrSize, generatePrivate),
                            params
                        )
                    default:
                        throw new errors.JOSENotSupported(
                            `unsupported key type: ${kty}`
                        )
                }
            }

            module.exports.generate = generate
            module.exports.generateSync = generateSync

            /***/
        },

        /***/ LMPv: /***/ function(module, exports, __webpack_require__) {
            /* eslint-disable camelcase */
            const { inspect } = __webpack_require__('jK02')

            const { RPError, OPError } = __webpack_require__('L71r')
            const instance = __webpack_require__('0pkK')
            const now = __webpack_require__('PbSP')
            const { authenticatedPost } = __webpack_require__('/JKO')
            const processResponse = __webpack_require__('WeJA')
            const TokenSet = __webpack_require__('IgmS')

            class DeviceFlowHandle {
                constructor({
                    client,
                    exchangeBody,
                    clientAssertionPayload,
                    response,
                    maxAge
                }) {
                    ;['verification_uri', 'user_code', 'device_code'].forEach(
                        prop => {
                            if (
                                typeof response[prop] !== 'string' ||
                                !response[prop]
                            ) {
                                throw new RPError(
                                    `expected ${prop} string to be returned by Device Authorization Response, got %j`,
                                    response[prop]
                                )
                            }
                        }
                    )

                    if (!Number.isSafeInteger(response.expires_in)) {
                        throw new RPError(
                            'expected expires_in number to be returned by Device Authorization Response, got %j',
                            response.expires_in
                        )
                    }

                    instance(this).expires_at = now() + response.expires_in
                    instance(this).client = client
                    instance(this).maxAge = maxAge
                    instance(this).exchangeBody = exchangeBody
                    instance(
                        this
                    ).clientAssertionPayload = clientAssertionPayload
                    instance(this).response = response
                    instance(this).interval = response.interval * 1000 || 5000
                }

                async poll() {
                    if (this.expired()) {
                        throw new RPError(
                            'the device code %j has expired and the device authorization session has concluded',
                            this.device_code
                        )
                    }

                    await new Promise(resolve =>
                        setTimeout(resolve, instance(this).interval)
                    )

                    const response = await authenticatedPost.call(
                        instance(this).client,
                        'token',
                        {
                            form: true,
                            body: {
                                ...instance(this).exchangeBody,
                                grant_type:
                                    'urn:ietf:params:oauth:grant-type:device_code',
                                device_code: this.device_code
                            },
                            json: true
                        },
                        {
                            clientAssertionPayload: instance(this)
                                .clientAssertionPayload
                        }
                    )

                    let responseBody
                    try {
                        responseBody = processResponse(response)
                    } catch (err) {
                        switch (err instanceof OPError && err.error) {
                            case 'slow_down':
                                instance(this).interval += 5000
                            case 'authorization_pending': // eslint-disable-line no-fallthrough
                                return this.poll()
                            default:
                                throw err
                        }
                    }

                    const tokenset = new TokenSet(responseBody)

                    if ('id_token' in tokenset) {
                        await instance(this).client.decryptIdToken(tokenset)
                        await instance(this).client.validateIdToken(
                            tokenset,
                            undefined,
                            'token',
                            instance(this).maxAge
                        )
                    }

                    return tokenset
                }

                get device_code() {
                    return instance(this).response.device_code
                }

                get user_code() {
                    return instance(this).response.user_code
                }

                get verification_uri() {
                    return instance(this).response.verification_uri
                }

                get verification_uri_complete() {
                    return instance(this).response.verification_uri_complete
                }

                get expires_in() {
                    return Math.max.apply(null, [
                        instance(this).expires_at - now(),
                        0
                    ])
                }

                expired() {
                    return this.expires_in === 0
                }

                /* istanbul ignore next */
                [inspect.custom]() {
                    return `${this.constructor.name} ${inspect(
                        instance(this).response,
                        {
                            depth: Infinity,
                            colors: process.stdout.isTTY,
                            compact: false,
                            sorted: true
                        }
                    )}`
                }
            }

            module.exports = DeviceFlowHandle

            /***/
        },

        /***/ LX0d: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('UDep')

            /***/
        },

        /***/ LXxW: /***/ function(module, exports) {
            /**
             * A specialized version of `_.filter` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {Array} Returns the new filtered array.
             */
            function arrayFilter(array, predicate) {
                var index = -1,
                    length = array == null ? 0 : array.length,
                    resIndex = 0,
                    result = []

                while (++index < length) {
                    var value = array[index]
                    if (predicate(value, index, array)) {
                        result[resIndex++] = value
                    }
                }
                return result
            }

            module.exports = arrayFilter

            /***/
        },

        /***/ LYNF: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var enhanceError = __webpack_require__('OH9c')

            /**
             * Create an Error with the specified message, config, error code, request and response.
             *
             * @param {string} message The error message.
             * @param {Object} config The config.
             * @param {string} [code] The error code (for example, 'ECONNABORTED').
             * @param {Object} [request] The request.
             * @param {Object} [response] The response.
             * @returns {Error} The created error.
             */
            module.exports = function createError(
                message,
                config,
                code,
                request,
                response
            ) {
                var error = new Error(message)
                return enhanceError(error, config, code, request, response)
            }

            /***/
        },

        /***/ LZ9C: /***/ function(module) {
            module.exports = JSON.parse(
                '{"devFiles":[],"pages":{"/":["static/runtime/webpack-08f7b238829422e3b9b2.js","static/chunks/commons.2fcab6cb699fd2a2f0fc.js","static/runtime/main-8bedfe204fbe9606c247.js"],"/_app":["static/runtime/webpack-08f7b238829422e3b9b2.js","static/chunks/commons.2fcab6cb699fd2a2f0fc.js","static/runtime/main-8bedfe204fbe9606c247.js"],"/_error":["static/runtime/webpack-08f7b238829422e3b9b2.js","static/chunks/commons.2fcab6cb699fd2a2f0fc.js","static/runtime/main-8bedfe204fbe9606c247.js"],"/_polyfills":["static/runtime/polyfills-e16a3c6fbdef155ac22e.js"],"/app":["static/runtime/webpack-08f7b238829422e3b9b2.js","static/chunks/commons.2fcab6cb699fd2a2f0fc.js","static/runtime/main-8bedfe204fbe9606c247.js"],"/index":["static/runtime/webpack-08f7b238829422e3b9b2.js","static/chunks/commons.2fcab6cb699fd2a2f0fc.js","static/runtime/main-8bedfe204fbe9606c247.js"]}}'
            )

            /***/
        },

        /***/ LZmR: /***/ function(module, exports) {
            module.exports = function pick(object, ...paths) {
                const obj = {}
                for (const path of paths) {
                    // eslint-disable-line no-restricted-syntax
                    if (object[path]) {
                        obj[path] = object[path]
                    }
                }
                return obj
            }

            /***/
        },

        /***/ LcsW: /***/ function(module, exports, __webpack_require__) {
            var overArg = __webpack_require__('kekF')

            /** Built-in value references. */
            var getPrototype = overArg(Object.getPrototypeOf, Object)

            module.exports = getPrototype

            /***/
        },

        /***/ Lmem: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = function isCancel(value) {
                return !!(value && value.__CANCEL__)
            }

            /***/
        },

        /***/ LsHQ: /***/ function(module, exports, __webpack_require__) {
            var baseRest = __webpack_require__('EA7m'),
                isIterateeCall = __webpack_require__('mv/X')

            /**
             * Creates a function like `_.assign`.
             *
             * @private
             * @param {Function} assigner The function to assign values.
             * @returns {Function} Returns the new assigner function.
             */
            function createAssigner(assigner) {
                return baseRest(function(object, sources) {
                    var index = -1,
                        length = sources.length,
                        customizer =
                            length > 1 ? sources[length - 1] : undefined,
                        guard = length > 2 ? sources[2] : undefined

                    customizer =
                        assigner.length > 3 && typeof customizer == 'function'
                            ? (length--, customizer)
                            : undefined

                    if (
                        guard &&
                        isIterateeCall(sources[0], sources[1], guard)
                    ) {
                        customizer = length < 3 ? undefined : customizer
                        length = 1
                    }
                    object = Object(object)
                    while (++index < length) {
                        var source = sources[index]
                        if (source) {
                            assigner(object, source, index, customizer)
                        }
                    }
                    return object
                })
            }

            module.exports = createAssigner

            /***/
        },

        /***/ LuNM: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var __importDefault =
                (this && this.__importDefault) ||
                function(mod) {
                    return mod && mod.__esModule ? mod : { default: mod }
                }
            Object.defineProperty(exports, '__esModule', { value: true })
            const etag_1 = __importDefault(__webpack_require__('Y4gF'))
            const fresh_1 = __importDefault(__webpack_require__('BMJj'))
            const utils_1 = __webpack_require__('g/15')
            function sendHTML(
                req,
                res,
                html,
                { generateEtags, poweredByHeader }
            ) {
                if (utils_1.isResSent(res)) return
                const etag = generateEtags ? etag_1.default(html) : undefined
                if (poweredByHeader) {
                    res.setHeader('X-Powered-By', 'Next.js')
                }
                if (fresh_1.default(req.headers, { etag })) {
                    res.statusCode = 304
                    res.end()
                    return
                }
                if (etag) {
                    res.setHeader('ETag', etag)
                }
                if (!res.getHeader('Content-Type')) {
                    res.setHeader('Content-Type', 'text/html; charset=utf-8')
                }
                res.setHeader('Content-Length', Buffer.byteLength(html))
                res.end(req.method === 'HEAD' ? null : html)
            }
            exports.sendHTML = sendHTML

            /***/
        },

        /***/ LzdP: /***/ function(module, exports, __webpack_require__) {
            // 20.3.3.1 / 15.9.4.4 Date.now()
            var $export = __webpack_require__('Y7ZC')

            $export($export.S, 'Date', {
                now: function() {
                    return new Date().getTime()
                }
            })

            /***/
        },

        /***/ M1xp: /***/ function(module, exports, __webpack_require__) {
            // fallback for non-array-like ES3 and non-enumerable old V8 strings
            var cof = __webpack_require__('a0xu')
            // eslint-disable-next-line no-prototype-builtins
            module.exports = Object('z').propertyIsEnumerable(0)
                ? Object
                : function(it) {
                      return cof(it) == 'String' ? it.split('') : Object(it)
                  }

            /***/
        },

        /***/ M8F5: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Hoek = __webpack_require__('RXbi')

            const Decoder = __webpack_require__('ONme')
            const Encoder = __webpack_require__('BzZA')

            exports.decode = Decoder.decode

            exports.encode = Encoder.encode

            exports.Decoder = Decoder.Decoder

            exports.Encoder = Encoder.Encoder

            // Base64url (RFC 4648) encode

            exports.base64urlEncode = function(value, encoding) {
                Hoek.assert(
                    typeof value === 'string' || Buffer.isBuffer(value),
                    'value must be string or buffer'
                )
                const buf = Buffer.isBuffer(value)
                    ? value
                    : Buffer.from(value, encoding || 'binary')
                return buf
                    .toString('base64')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/\=/g, '')
            }

            // Base64url (RFC 4648) decode

            exports.base64urlDecode = function(value, encoding) {
                if (typeof value !== 'string') {
                    throw new Error('Value not a string')
                }

                if (!/^[\w\-]*$/.test(value)) {
                    throw new Error('Invalid character')
                }

                const buf = Buffer.from(value, 'base64')
                return encoding === 'buffer'
                    ? buf
                    : buf.toString(encoding || 'binary')
            }

            /***/
        },

        /***/ MCSJ: /***/ function(module, exports) {
            // fast apply, http://jsperf.lnkit.com/fast-apply/5
            module.exports = function(fn, args, that) {
                var un = that === undefined
                switch (args.length) {
                    case 0:
                        return un ? fn() : fn.call(that)
                    case 1:
                        return un ? fn(args[0]) : fn.call(that, args[0])
                    case 2:
                        return un
                            ? fn(args[0], args[1])
                            : fn.call(that, args[0], args[1])
                    case 3:
                        return un
                            ? fn(args[0], args[1], args[2])
                            : fn.call(that, args[0], args[1], args[2])
                    case 4:
                        return un
                            ? fn(args[0], args[1], args[2], args[3])
                            : fn.call(that, args[0], args[1], args[2], args[3])
                }
                return fn.apply(that, args)
            }

            /***/
        },

        /***/ MLWZ: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')

            function encode(val) {
                return encodeURIComponent(val)
                    .replace(/%40/gi, '@')
                    .replace(/%3A/gi, ':')
                    .replace(/%24/g, '$')
                    .replace(/%2C/gi, ',')
                    .replace(/%20/g, '+')
                    .replace(/%5B/gi, '[')
                    .replace(/%5D/gi, ']')
            }

            /**
             * Build a URL by appending params to the end
             *
             * @param {string} url The base of the url (e.g., http://www.google.com)
             * @param {object} [params] The params to be appended
             * @returns {string} The formatted url
             */
            module.exports = function buildURL(url, params, paramsSerializer) {
                /*eslint no-param-reassign:0*/
                if (!params) {
                    return url
                }

                var serializedParams
                if (paramsSerializer) {
                    serializedParams = paramsSerializer(params)
                } else if (utils.isURLSearchParams(params)) {
                    serializedParams = params.toString()
                } else {
                    var parts = []

                    utils.forEach(params, function serialize(val, key) {
                        if (val === null || typeof val === 'undefined') {
                            return
                        }

                        if (utils.isArray(val)) {
                            key = key + '[]'
                        } else {
                            val = [val]
                        }

                        utils.forEach(val, function parseValue(v) {
                            if (utils.isDate(v)) {
                                v = v.toISOString()
                            } else if (utils.isObject(v)) {
                                v = JSON.stringify(v)
                            }
                            parts.push(encode(key) + '=' + encode(v))
                        })
                    })

                    serializedParams = parts.join('&')
                }

                if (serializedParams) {
                    var hashmarkIndex = url.indexOf('#')
                    if (hashmarkIndex !== -1) {
                        url = url.slice(0, hashmarkIndex)
                    }

                    url +=
                        (url.indexOf('?') === -1 ? '?' : '&') + serializedParams
                }

                return url
            }

            /***/
        },

        /***/ MMmD: /***/ function(module, exports, __webpack_require__) {
            var isFunction = __webpack_require__('lSCD'),
                isLength = __webpack_require__('shjB')

            /**
             * Checks if `value` is array-like. A value is considered array-like if it's
             * not a function and has a `value.length` that's an integer greater than or
             * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
             * @example
             *
             * _.isArrayLike([1, 2, 3]);
             * // => true
             *
             * _.isArrayLike(document.body.children);
             * // => true
             *
             * _.isArrayLike('abc');
             * // => true
             *
             * _.isArrayLike(_.noop);
             * // => false
             */
            function isArrayLike(value) {
                return (
                    value != null &&
                    isLength(value.length) &&
                    !isFunction(value)
                )
            }

            module.exports = isArrayLike

            /***/
        },

        /***/ MPFp: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var LIBRARY = __webpack_require__('uOPS')
            var $export = __webpack_require__('Y7ZC')
            var redefine = __webpack_require__('kTiW')
            var hide = __webpack_require__('NegM')
            var Iterators = __webpack_require__('SBuE')
            var $iterCreate = __webpack_require__('j2DC')
            var setToStringTag = __webpack_require__('RfKB')
            var getPrototypeOf = __webpack_require__('U+KD')
            var ITERATOR = __webpack_require__('UWiX')('iterator')
            var BUGGY = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
            var FF_ITERATOR = '@@iterator'
            var KEYS = 'keys'
            var VALUES = 'values'

            var returnThis = function() {
                return this
            }

            module.exports = function(
                Base,
                NAME,
                Constructor,
                next,
                DEFAULT,
                IS_SET,
                FORCED
            ) {
                $iterCreate(Constructor, NAME, next)
                var getMethod = function(kind) {
                    if (!BUGGY && kind in proto) return proto[kind]
                    switch (kind) {
                        case KEYS:
                            return function keys() {
                                return new Constructor(this, kind)
                            }
                        case VALUES:
                            return function values() {
                                return new Constructor(this, kind)
                            }
                    }
                    return function entries() {
                        return new Constructor(this, kind)
                    }
                }
                var TAG = NAME + ' Iterator'
                var DEF_VALUES = DEFAULT == VALUES
                var VALUES_BUG = false
                var proto = Base.prototype
                var $native =
                    proto[ITERATOR] ||
                    proto[FF_ITERATOR] ||
                    (DEFAULT && proto[DEFAULT])
                var $default = $native || getMethod(DEFAULT)
                var $entries = DEFAULT
                    ? !DEF_VALUES
                        ? $default
                        : getMethod('entries')
                    : undefined
                var $anyNative =
                    NAME == 'Array' ? proto.entries || $native : $native
                var methods, key, IteratorPrototype
                // Fix native
                if ($anyNative) {
                    IteratorPrototype = getPrototypeOf(
                        $anyNative.call(new Base())
                    )
                    if (
                        IteratorPrototype !== Object.prototype &&
                        IteratorPrototype.next
                    ) {
                        // Set @@toStringTag to native iterators
                        setToStringTag(IteratorPrototype, TAG, true)
                        // fix for some old engines
                        if (
                            !LIBRARY &&
                            typeof IteratorPrototype[ITERATOR] != 'function'
                        )
                            hide(IteratorPrototype, ITERATOR, returnThis)
                    }
                }
                // fix Array#{values, @@iterator}.name in V8 / FF
                if (DEF_VALUES && $native && $native.name !== VALUES) {
                    VALUES_BUG = true
                    $default = function values() {
                        return $native.call(this)
                    }
                }
                // Define iterator
                if (
                    (!LIBRARY || FORCED) &&
                    (BUGGY || VALUES_BUG || !proto[ITERATOR])
                ) {
                    hide(proto, ITERATOR, $default)
                }
                // Plug for library
                Iterators[NAME] = $default
                Iterators[TAG] = returnThis
                if (DEFAULT) {
                    methods = {
                        values: DEF_VALUES ? $default : getMethod(VALUES),
                        keys: IS_SET ? $default : getMethod(KEYS),
                        entries: $entries
                    }
                    if (FORCED)
                        for (key in methods) {
                            if (!(key in proto))
                                redefine(proto, key, methods[key])
                        }
                    else
                        $export(
                            $export.P + $export.F * (BUGGY || VALUES_BUG),
                            NAME,
                            methods
                        )
                }
                return methods
            }

            /***/
        },

        /***/ MX0m: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('3niX')

            /***/
        },

        /***/ MgzW: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*
object-assign
(c) Sindre Sorhus
@license MIT
*/

            /* eslint-disable no-unused-vars */
            var getOwnPropertySymbols = Object.getOwnPropertySymbols
            var hasOwnProperty = Object.prototype.hasOwnProperty
            var propIsEnumerable = Object.prototype.propertyIsEnumerable

            function toObject(val) {
                if (val === null || val === undefined) {
                    throw new TypeError(
                        'Object.assign cannot be called with null or undefined'
                    )
                }

                return Object(val)
            }

            function shouldUseNative() {
                try {
                    if (!Object.assign) {
                        return false
                    }

                    // Detect buggy property enumeration order in older V8 versions.

                    // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                    var test1 = new String('abc') // eslint-disable-line no-new-wrappers
                    test1[5] = 'de'
                    if (Object.getOwnPropertyNames(test1)[0] === '5') {
                        return false
                    }

                    // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                    var test2 = {}
                    for (var i = 0; i < 10; i++) {
                        test2['_' + String.fromCharCode(i)] = i
                    }
                    var order2 = Object.getOwnPropertyNames(test2).map(function(
                        n
                    ) {
                        return test2[n]
                    })
                    if (order2.join('') !== '0123456789') {
                        return false
                    }

                    // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                    var test3 = {}
                    'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
                        test3[letter] = letter
                    })
                    if (
                        Object.keys(Object.assign({}, test3)).join('') !==
                        'abcdefghijklmnopqrst'
                    ) {
                        return false
                    }

                    return true
                } catch (err) {
                    // We don't expect any of the above to throw, but better to be safe.
                    return false
                }
            }

            module.exports = shouldUseNative()
                ? Object.assign
                : function(target, source) {
                      var from
                      var to = toObject(target)
                      var symbols

                      for (var s = 1; s < arguments.length; s++) {
                          from = Object(arguments[s])

                          for (var key in from) {
                              if (hasOwnProperty.call(from, key)) {
                                  to[key] = from[key]
                              }
                          }

                          if (getOwnPropertySymbols) {
                              symbols = getOwnPropertySymbols(from)
                              for (var i = 0; i < symbols.length; i++) {
                                  if (propIsEnumerable.call(from, symbols[i])) {
                                      to[symbols[i]] = from[symbols[i]]
                                  }
                              }
                          }
                      }

                      return to
                  }

            /***/
        },

        /***/ MoRj: /***/ function(module, exports, __webpack_require__) {
            const {
                sign: signOneShot,
                verify: verifyOneShot
            } = __webpack_require__('PJMN')

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const { edDSASupported } = __webpack_require__('pDDt')

            const sign = ({ [KEYOBJECT]: keyObject }, payload) => {
                if (typeof payload === 'string') {
                    payload = Buffer.from(payload)
                }
                return signOneShot(undefined, payload, keyObject)
            }

            const verify = ({ [KEYOBJECT]: keyObject }, payload, signature) => {
                return verifyOneShot(undefined, payload, keyObject, signature)
            }

            module.exports = (JWA, JWK) => {
                if (edDSASupported) {
                    JWA.sign.set('EdDSA', sign)
                    JWA.verify.set('EdDSA', verify)
                    JWK.OKP.sign.EdDSA = key =>
                        key.private && JWK.OKP.verify.EdDSA(key)
                    JWK.OKP.verify.EdDSA = key =>
                        (key.use === 'sig' || key.use === undefined) &&
                        key.keyObject.asymmetricKeyType.startsWith('ed')
                }
            }

            /***/
        },

        /***/ Mqbl: /***/ function(module, exports, __webpack_require__) {
            // 19.1.2.14 Object.keys(O)
            var toObject = __webpack_require__('JB68')
            var $keys = __webpack_require__('w6GO')

            __webpack_require__('zn7N')('keys', function() {
                return function keys(it) {
                    return $keys(toObject(it))
                }
            })

            /***/
        },

        /***/ MrPd: /***/ function(module, exports, __webpack_require__) {
            var baseAssignValue = __webpack_require__('hypo'),
                eq = __webpack_require__('ljhN')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Assigns `value` to `key` of `object` if the existing value is not equivalent
             * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
             * for equality comparisons.
             *
             * @private
             * @param {Object} object The object to modify.
             * @param {string} key The key of the property to assign.
             * @param {*} value The value to assign.
             */
            function assignValue(object, key, value) {
                var objValue = object[key]
                if (
                    !(
                        hasOwnProperty.call(object, key) && eq(objValue, value)
                    ) ||
                    (value === undefined && !(key in object))
                ) {
                    baseAssignValue(object, key, value)
                }
            }

            module.exports = assignValue

            /***/
        },

        /***/ MrQC: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { Readable } = __webpack_require__('msIP')

            module.exports = input =>
                new Readable({
                    read() {
                        this.push(input)
                        this.push(null)
                    }
                })

            /***/
        },

        /***/ Mu3n: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            class CookieSessionStoreSettings {
                constructor(settings) {
                    this.cookieSecret = settings.cookieSecret
                    if (!this.cookieSecret || !this.cookieSecret.length) {
                        throw new Error(
                            'The cookieSecret setting is empty or null'
                        )
                    }
                    if (this.cookieSecret.length < 32) {
                        throw new Error(
                            'The cookieSecret should be at least 32 characters long'
                        )
                    }
                    this.cookieName = settings.cookieName || 'a0:session'
                    if (!this.cookieName || !this.cookieName.length) {
                        throw new Error(
                            'The cookieName setting is empty or null'
                        )
                    }
                    this.cookieLifetime = settings.cookieLifetime || 60 * 60 * 8
                    this.cookiePath = settings.cookiePath || '/'
                    if (!this.cookiePath || !this.cookiePath.length) {
                        throw new Error(
                            'The cookiePath setting is empty or null'
                        )
                    }
                    this.storeIdToken = settings.storeIdToken || false
                    this.storeAccessToken = settings.storeAccessToken || false
                    this.storeRefreshToken = settings.storeRefreshToken || false
                }
            }
            exports.default = CookieSessionStoreSettings
            //# sourceMappingURL=settings.js.map

            /***/
        },

        /***/ MvSz: /***/ function(module, exports, __webpack_require__) {
            var arrayFilter = __webpack_require__('LXxW'),
                stubArray = __webpack_require__('0ycA')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Built-in value references. */
            var propertyIsEnumerable = objectProto.propertyIsEnumerable

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeGetSymbols = Object.getOwnPropertySymbols

            /**
             * Creates an array of the own enumerable symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of symbols.
             */
            var getSymbols = !nativeGetSymbols
                ? stubArray
                : function(object) {
                      if (object == null) {
                          return []
                      }
                      object = Object(object)
                      return arrayFilter(nativeGetSymbols(object), function(
                          symbol
                      ) {
                          return propertyIsEnumerable.call(object, symbol)
                      })
                  }

            module.exports = getSymbols

            /***/
        },

        /***/ MvwC: /***/ function(module, exports, __webpack_require__) {
            var document = __webpack_require__('5T2Y').document
            module.exports = document && document.documentElement

            /***/
        },

        /***/ 'N+nT': /***/ function(module, exports, __webpack_require__) {
            const EC_CURVES = __webpack_require__('b9eJ')
            const IVLENGTHS = __webpack_require__('KqF2')
            const JWA = __webpack_require__('Fo+H')
            const JWK = __webpack_require__('OgAF')
            const KEYLENGTHS = __webpack_require__('EB1F')
            const OKP_CURVES = __webpack_require__('AlvL')
            const ECDH_DERIVE_LENGTHS = __webpack_require__('aOmh')

            module.exports = {
                EC_CURVES,
                ECDH_DERIVE_LENGTHS,
                IVLENGTHS,
                JWA,
                JWK,
                KEYLENGTHS,
                OKP_CURVES
            }

            /***/
        },

        /***/ 'N+si': /***/ function(module, exports) {
            function assertSigningAlgValuesSupport(
                endpoint,
                issuer,
                properties
            ) {
                if (!issuer[`${endpoint}_endpoint`]) return

                const eam = `${endpoint}_endpoint_auth_method`
                const easa = `${endpoint}_endpoint_auth_signing_alg`
                const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`

                if (
                    properties[eam] &&
                    properties[eam].endsWith('_jwt') &&
                    !properties[easa] &&
                    !issuer[easavs]
                ) {
                    throw new TypeError(
                        `${easavs} must be configured on the issuer if ${easa} is not defined on a client`
                    )
                }
            }

            function assertIssuerConfiguration(issuer, endpoint) {
                if (!issuer[endpoint]) {
                    throw new TypeError(
                        `${endpoint} must be configured on the issuer`
                    )
                }
            }

            module.exports = {
                assertSigningAlgValuesSupport,
                assertIssuerConfiguration
            }

            /***/
        },

        /***/ NCJl: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // TODO: Use the `URL` global when targeting Node.js 10
            const URLParser =
                typeof URL === 'undefined'
                    ? __webpack_require__('bzos').URL
                    : URL

            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
            const DATA_URL_DEFAULT_MIME_TYPE = 'text/plain'
            const DATA_URL_DEFAULT_CHARSET = 'us-ascii'

            const testParameter = (name, filters) => {
                return filters.some(filter =>
                    filter instanceof RegExp
                        ? filter.test(name)
                        : filter === name
                )
            }

            const normalizeDataURL = (urlString, { stripHash }) => {
                const parts = urlString.match(/^data:(.*?),(.*?)(?:#(.*))?$/)

                if (!parts) {
                    throw new Error(`Invalid URL: ${urlString}`)
                }

                const mediaType = parts[1].split(';')
                const body = parts[2]
                const hash = stripHash ? '' : parts[3]

                let base64 = false

                if (mediaType[mediaType.length - 1] === 'base64') {
                    mediaType.pop()
                    base64 = true
                }

                // Lowercase MIME type
                const mimeType = (mediaType.shift() || '').toLowerCase()
                const attributes = mediaType
                    .map(attribute => {
                        let [key, value = ''] = attribute
                            .split('=')
                            .map(string => string.trim())

                        // Lowercase `charset`
                        if (key === 'charset') {
                            value = value.toLowerCase()

                            if (value === DATA_URL_DEFAULT_CHARSET) {
                                return ''
                            }
                        }

                        return `${key}${value ? `=${value}` : ''}`
                    })
                    .filter(Boolean)

                const normalizedMediaType = [...attributes]

                if (base64) {
                    normalizedMediaType.push('base64')
                }

                if (
                    normalizedMediaType.length !== 0 ||
                    (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)
                ) {
                    normalizedMediaType.unshift(mimeType)
                }

                return `data:${normalizedMediaType.join(';')},${
                    base64 ? body.trim() : body
                }${hash ? `#${hash}` : ''}`
            }

            const normalizeUrl = (urlString, options) => {
                options = {
                    defaultProtocol: 'http:',
                    normalizeProtocol: true,
                    forceHttp: false,
                    forceHttps: false,
                    stripAuthentication: true,
                    stripHash: false,
                    stripWWW: true,
                    removeQueryParameters: [/^utm_\w+/i],
                    removeTrailingSlash: true,
                    removeDirectoryIndex: false,
                    sortQueryParameters: true,
                    ...options
                }

                // TODO: Remove this at some point in the future
                if (Reflect.has(options, 'normalizeHttps')) {
                    throw new Error(
                        'options.normalizeHttps is renamed to options.forceHttp'
                    )
                }

                if (Reflect.has(options, 'normalizeHttp')) {
                    throw new Error(
                        'options.normalizeHttp is renamed to options.forceHttps'
                    )
                }

                if (Reflect.has(options, 'stripFragment')) {
                    throw new Error(
                        'options.stripFragment is renamed to options.stripHash'
                    )
                }

                urlString = urlString.trim()

                // Data URL
                if (/^data:/i.test(urlString)) {
                    return normalizeDataURL(urlString, options)
                }

                const hasRelativeProtocol = urlString.startsWith('//')
                const isRelativeUrl =
                    !hasRelativeProtocol && /^\.*\//.test(urlString)

                // Prepend protocol
                if (!isRelativeUrl) {
                    urlString = urlString.replace(
                        /^(?!(?:\w+:)?\/\/)|^\/\//,
                        options.defaultProtocol
                    )
                }

                const urlObj = new URLParser(urlString)

                if (options.forceHttp && options.forceHttps) {
                    throw new Error(
                        'The `forceHttp` and `forceHttps` options cannot be used together'
                    )
                }

                if (options.forceHttp && urlObj.protocol === 'https:') {
                    urlObj.protocol = 'http:'
                }

                if (options.forceHttps && urlObj.protocol === 'http:') {
                    urlObj.protocol = 'https:'
                }

                // Remove auth
                if (options.stripAuthentication) {
                    urlObj.username = ''
                    urlObj.password = ''
                }

                // Remove hash
                if (options.stripHash) {
                    urlObj.hash = ''
                }

                // Remove duplicate slashes if not preceded by a protocol
                if (urlObj.pathname) {
                    // TODO: Use the following instead when targeting Node.js 10
                    // `urlObj.pathname = urlObj.pathname.replace(/(?<!https?:)\/{2,}/g, '/');`
                    urlObj.pathname = urlObj.pathname.replace(
                        /((?!:).|^)\/{2,}/g,
                        (_, p1) => {
                            if (/^(?!\/)/g.test(p1)) {
                                return `${p1}/`
                            }

                            return '/'
                        }
                    )
                }

                // Decode URI octets
                if (urlObj.pathname) {
                    urlObj.pathname = decodeURI(urlObj.pathname)
                }

                // Remove directory index
                if (options.removeDirectoryIndex === true) {
                    options.removeDirectoryIndex = [/^index\.[a-z]+$/]
                }

                if (
                    Array.isArray(options.removeDirectoryIndex) &&
                    options.removeDirectoryIndex.length > 0
                ) {
                    let pathComponents = urlObj.pathname.split('/')
                    const lastComponent =
                        pathComponents[pathComponents.length - 1]

                    if (
                        testParameter(
                            lastComponent,
                            options.removeDirectoryIndex
                        )
                    ) {
                        pathComponents = pathComponents.slice(
                            0,
                            pathComponents.length - 1
                        )
                        urlObj.pathname =
                            pathComponents.slice(1).join('/') + '/'
                    }
                }

                if (urlObj.hostname) {
                    // Remove trailing dot
                    urlObj.hostname = urlObj.hostname.replace(/\.$/, '')

                    // Remove `www.`
                    if (
                        options.stripWWW &&
                        /^www\.([a-z\-\d]{2,63})\.([a-z.]{2,5})$/.test(
                            urlObj.hostname
                        )
                    ) {
                        // Each label should be max 63 at length (min: 2).
                        // The extension should be max 5 at length (min: 2).
                        // Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
                        urlObj.hostname = urlObj.hostname.replace(/^www\./, '')
                    }
                }

                // Remove query unwanted parameters
                if (Array.isArray(options.removeQueryParameters)) {
                    for (const key of [...urlObj.searchParams.keys()]) {
                        if (testParameter(key, options.removeQueryParameters)) {
                            urlObj.searchParams.delete(key)
                        }
                    }
                }

                // Sort query parameters
                if (options.sortQueryParameters) {
                    urlObj.searchParams.sort()
                }

                if (options.removeTrailingSlash) {
                    urlObj.pathname = urlObj.pathname.replace(/\/$/, '')
                }

                // Take advantage of many of the Node `url` normalizations
                urlString = urlObj.toString()

                // Remove ending `/`
                if (
                    (options.removeTrailingSlash || urlObj.pathname === '/') &&
                    urlObj.hash === ''
                ) {
                    urlString = urlString.replace(/\/$/, '')
                }

                // Restore relative protocol, if applicable
                if (hasRelativeProtocol && !options.normalizeProtocol) {
                    urlString = urlString.replace(/^http:\/\//, '//')
                }

                // Remove http/https
                if (options.stripProtocol) {
                    urlString = urlString.replace(/^(?:https?:)?\/\//, '')
                }

                return urlString
            }

            module.exports = normalizeUrl
            // TODO: Remove this for the next major release
            module.exports.default = normalizeUrl

            /***/
        },

        /***/ NFjz: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const pump = __webpack_require__('b1mx')
            const bufferStream = __webpack_require__('E1OP')

            class MaxBufferError extends Error {
                constructor() {
                    super('maxBuffer exceeded')
                    this.name = 'MaxBufferError'
                }
            }

            function getStream(inputStream, options) {
                if (!inputStream) {
                    return Promise.reject(new Error('Expected a stream'))
                }

                options = Object.assign({ maxBuffer: Infinity }, options)

                const { maxBuffer } = options

                let stream
                return new Promise((resolve, reject) => {
                    const rejectPromise = error => {
                        if (error) {
                            // A null check
                            error.bufferedData = stream.getBufferedValue()
                        }
                        reject(error)
                    }

                    stream = pump(inputStream, bufferStream(options), error => {
                        if (error) {
                            rejectPromise(error)
                            return
                        }

                        resolve()
                    })

                    stream.on('data', () => {
                        if (stream.getBufferedLength() > maxBuffer) {
                            rejectPromise(new MaxBufferError())
                        }
                    })
                }).then(() => stream.getBufferedValue())
            }

            module.exports = getStream
            module.exports.buffer = (stream, options) =>
                getStream(
                    stream,
                    Object.assign({}, options, { encoding: 'buffer' })
                )
            module.exports.array = (stream, options) =>
                getStream(stream, Object.assign({}, options, { array: true }))
            module.exports.MaxBufferError = MaxBufferError

            /***/
        },

        /***/ NHoT: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const is = __webpack_require__('6mOv')

            module.exports = url => {
                const options = {
                    protocol: url.protocol,
                    hostname: url.hostname.startsWith('[')
                        ? url.hostname.slice(1, -1)
                        : url.hostname,
                    hash: url.hash,
                    search: url.search,
                    pathname: url.pathname,
                    href: url.href
                }

                if (is.string(url.port) && url.port.length > 0) {
                    options.port = Number(url.port)
                }

                if (url.username || url.password) {
                    options.auth = `${url.username}:${url.password}`
                }

                options.path = is.null(url.search)
                    ? url.pathname
                    : `${url.pathname}${url.search}`

                return options
            }

            /***/
        },

        /***/ NKxu: /***/ function(module, exports, __webpack_require__) {
            var isFunction = __webpack_require__('lSCD'),
                isMasked = __webpack_require__('E2jh'),
                isObject = __webpack_require__('GoyQ'),
                toSource = __webpack_require__('3Fdi')

            /**
             * Used to match `RegExp`
             * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
             */
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g

            /** Used to detect host constructors (Safari). */
            var reIsHostCtor = /^\[object .+?Constructor\]$/

            /** Used for built-in method references. */
            var funcProto = Function.prototype,
                objectProto = Object.prototype

            /** Used to resolve the decompiled source of functions. */
            var funcToString = funcProto.toString

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /** Used to detect if a method is native. */
            var reIsNative = RegExp(
                '^' +
                    funcToString
                        .call(hasOwnProperty)
                        .replace(reRegExpChar, '\\$&')
                        .replace(
                            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                            '$1.*?'
                        ) +
                    '$'
            )

            /**
             * The base implementation of `_.isNative` without bad shim checks.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a native function,
             *  else `false`.
             */
            function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                    return false
                }
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor
                return pattern.test(toSource(value))
            }

            module.exports = baseIsNative

            /***/
        },

        /***/ NV0k: /***/ function(module, exports) {
            exports.f = {}.propertyIsEnumerable

            /***/
        },

        /***/ Ndh8: /***/ function(module, exports, __webpack_require__) {
            const url = __webpack_require__('bzos')
            const { strict: assert } = __webpack_require__('Qs3B')

            module.exports = target => {
                try {
                    const { protocol } = new url.URL(target)
                    assert(protocol.match(/^(https?:)$/))
                    return true
                } catch (err) {
                    throw new TypeError(
                        'only valid absolute URLs can be requested'
                    )
                }
            }

            /***/
        },

        /***/ NegM: /***/ function(module, exports, __webpack_require__) {
            var dP = __webpack_require__('2faE')
            var createDesc = __webpack_require__('rr1i')
            module.exports = __webpack_require__('jmDH')
                ? function(object, key, value) {
                      return dP.f(object, key, createDesc(1, value))
                  }
                : function(object, key, value) {
                      object[key] = value
                      return object
                  }

            /***/
        },

        /***/ Nndd: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            exports.default = '0.4.0'
            //# sourceMappingURL=version.js.map

            /***/
        },

        /***/ Npjl: /***/ function(module, exports) {
            /**
             * Gets the value at `key` of `object`.
             *
             * @private
             * @param {Object} [object] The object to query.
             * @param {string} key The key of the property to get.
             * @returns {*} Returns the property value.
             */
            function getValue(object, key) {
                return object == null ? undefined : object[key]
            }

            module.exports = getValue

            /***/
        },

        /***/ 'NsO/': /***/ function(module, exports, __webpack_require__) {
            // to indexed object, toObject with fallback for non-array-like ES3 strings
            var IObject = __webpack_require__('M1xp')
            var defined = __webpack_require__('Jes0')
            module.exports = function(it) {
                return IObject(defined(it))
            }

            /***/
        },

        /***/ NwJ3: /***/ function(module, exports, __webpack_require__) {
            // check on default Array iterator
            var Iterators = __webpack_require__('SBuE')
            var ITERATOR = __webpack_require__('UWiX')('iterator')
            var ArrayProto = Array.prototype

            module.exports = function(it) {
                return (
                    it !== undefined &&
                    (Iterators.Array === it || ArrayProto[ITERATOR] === it)
                )
            }

            /***/
        },

        /***/ NykK: /***/ function(module, exports, __webpack_require__) {
            var Symbol = __webpack_require__('nmnc'),
                getRawTag = __webpack_require__('AP2z'),
                objectToString = __webpack_require__('KfNM')

            /** `Object#toString` result references. */
            var nullTag = '[object Null]',
                undefinedTag = '[object Undefined]'

            /** Built-in value references. */
            var symToStringTag = Symbol ? Symbol.toStringTag : undefined

            /**
             * The base implementation of `getTag` without fallbacks for buggy environments.
             *
             * @private
             * @param {*} value The value to query.
             * @returns {string} Returns the `toStringTag`.
             */
            function baseGetTag(value) {
                if (value == null) {
                    return value === undefined ? undefinedTag : nullTag
                }
                return symToStringTag && symToStringTag in Object(value)
                    ? getRawTag(value)
                    : objectToString(value)
            }

            module.exports = baseGetTag

            /***/
        },

        /***/ O0PD: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Reach = __webpack_require__('mmuM')

            const internals = {}

            exports.keys = function(obj, options = {}) {
                return options.symbols !== false
                    ? Reflect.ownKeys(obj)
                    : Object.getOwnPropertyNames(obj) // Defaults to true
            }

            exports.store = function(source, keys) {
                const storage = new Map()
                for (let i = 0; i < keys.length; ++i) {
                    const key = keys[i]
                    const value = Reach(source, key)
                    if (
                        typeof value === 'object' ||
                        typeof value === 'function'
                    ) {
                        storage.set(key, value)
                        internals.reachSet(source, key, undefined)
                    }
                }

                return storage
            }

            exports.restore = function(copy, source, storage) {
                for (const [key, value] of storage) {
                    internals.reachSet(copy, key, value)
                    internals.reachSet(source, key, value)
                }
            }

            internals.reachSet = function(obj, key, value) {
                const path = Array.isArray(key) ? key : key.split('.')
                let ref = obj
                for (let i = 0; i < path.length; ++i) {
                    const segment = path[i]
                    if (i + 1 === path.length) {
                        ref[segment] = value
                    }

                    ref = ref[segment]
                }
            }

            /***/
        },

        /***/ O0oS: /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5')

            var defineProperty = (function() {
                try {
                    var func = getNative(Object, 'defineProperty')
                    func({}, '', {})
                    return func
                } catch (e) {}
            })()

            module.exports = defineProperty

            /***/
        },

        /***/ O3E8: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const openid_client_1 = __webpack_require__('ecj1')
            function getClient(settings) {
                let client = null
                const clientSettings = settings.oidcClient || {
                    httpTimeout: 2500
                }
                return () =>
                    tslib_1.__awaiter(this, void 0, void 0, function*() {
                        if (client) {
                            return client
                        }
                        const issuer = yield openid_client_1.Issuer.discover(
                            `https://${settings.domain}/`
                        )
                        client = new issuer.Client({
                            client_id: settings.clientId,
                            client_secret: settings.clientSecret,
                            redirect_uris: [settings.redirectUri],
                            response_types: ['code']
                        })
                        if (clientSettings.httpTimeout) {
                            const timeout = clientSettings.httpTimeout
                            client[
                                openid_client_1.custom.http_options
                            ] = function setHttpOptions(options) {
                                return Object.assign(
                                    Object.assign({}, options),
                                    { timeout }
                                )
                            }
                        }
                        if (clientSettings.clockTolerance) {
                            client[openid_client_1.custom.clock_tolerance] =
                                clientSettings.clockTolerance / 1000
                        }
                        return client
                    })
            }
            exports.default = getClient
            //# sourceMappingURL=oidc-client.js.map

            /***/
        },

        /***/ O7RO: /***/ function(module, exports, __webpack_require__) {
            var isStrictComparable = __webpack_require__('CMye'),
                keys = __webpack_require__('7GkX')

            /**
             * Gets the property names, values, and compare flags of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the match data of `object`.
             */
            function getMatchData(object) {
                var result = keys(object),
                    length = result.length

                while (length--) {
                    var key = result[length],
                        value = object[key]

                    result[length] = [key, value, isStrictComparable(value)]
                }
                return result
            }

            module.exports = getMatchData

            /***/
        },

        /***/ O9d4: /***/ function(module, exports) {
            module.exports = obj => JSON.parse(JSON.stringify(obj))

            /***/
        },

        /***/ O9zF: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Readable = __webpack_require__('msIP').Readable
            const lowercaseKeys = __webpack_require__('y1+z')

            class Response extends Readable {
                constructor(statusCode, headers, body, url) {
                    if (typeof statusCode !== 'number') {
                        throw new TypeError(
                            'Argument `statusCode` should be a number'
                        )
                    }
                    if (typeof headers !== 'object') {
                        throw new TypeError(
                            'Argument `headers` should be an object'
                        )
                    }
                    if (!(body instanceof Buffer)) {
                        throw new TypeError(
                            'Argument `body` should be a buffer'
                        )
                    }
                    if (typeof url !== 'string') {
                        throw new TypeError('Argument `url` should be a string')
                    }

                    super()
                    this.statusCode = statusCode
                    this.headers = lowercaseKeys(headers)
                    this.body = body
                    this.url = url
                }

                _read() {
                    this.push(this.body)
                    this.push(null)
                }
            }

            module.exports = Response

            /***/
        },

        /***/ OBhP: /***/ function(module, exports, __webpack_require__) {
            var Stack = __webpack_require__('fmRc'),
                arrayEach = __webpack_require__('gFfm'),
                assignValue = __webpack_require__('MrPd'),
                baseAssign = __webpack_require__('WwFo'),
                baseAssignIn = __webpack_require__('Dw+G'),
                cloneBuffer = __webpack_require__('5Tg0'),
                copyArray = __webpack_require__('Q1l4'),
                copySymbols = __webpack_require__('VOtZ'),
                copySymbolsIn = __webpack_require__('EEGq'),
                getAllKeys = __webpack_require__('qZTm'),
                getAllKeysIn = __webpack_require__('G6z8'),
                getTag = __webpack_require__('QqLw'),
                initCloneArray = __webpack_require__('yHx3'),
                initCloneByTag = __webpack_require__('wrZu'),
                initCloneObject = __webpack_require__('+iFO'),
                isArray = __webpack_require__('Z0cm'),
                isBuffer = __webpack_require__('DSRE'),
                isMap = __webpack_require__('zEVN'),
                isObject = __webpack_require__('GoyQ'),
                isSet = __webpack_require__('1+5i'),
                keys = __webpack_require__('7GkX')

            /** Used to compose bitmasks for cloning. */
            var CLONE_DEEP_FLAG = 1,
                CLONE_FLAT_FLAG = 2,
                CLONE_SYMBOLS_FLAG = 4

            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]',
                arrayTag = '[object Array]',
                boolTag = '[object Boolean]',
                dateTag = '[object Date]',
                errorTag = '[object Error]',
                funcTag = '[object Function]',
                genTag = '[object GeneratorFunction]',
                mapTag = '[object Map]',
                numberTag = '[object Number]',
                objectTag = '[object Object]',
                regexpTag = '[object RegExp]',
                setTag = '[object Set]',
                stringTag = '[object String]',
                symbolTag = '[object Symbol]',
                weakMapTag = '[object WeakMap]'

            var arrayBufferTag = '[object ArrayBuffer]',
                dataViewTag = '[object DataView]',
                float32Tag = '[object Float32Array]',
                float64Tag = '[object Float64Array]',
                int8Tag = '[object Int8Array]',
                int16Tag = '[object Int16Array]',
                int32Tag = '[object Int32Array]',
                uint8Tag = '[object Uint8Array]',
                uint8ClampedTag = '[object Uint8ClampedArray]',
                uint16Tag = '[object Uint16Array]',
                uint32Tag = '[object Uint32Array]'

            /** Used to identify `toStringTag` values supported by `_.clone`. */
            var cloneableTags = {}
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[
                arrayBufferTag
            ] = cloneableTags[dataViewTag] = cloneableTags[
                boolTag
            ] = cloneableTags[dateTag] = cloneableTags[
                float32Tag
            ] = cloneableTags[float64Tag] = cloneableTags[
                int8Tag
            ] = cloneableTags[int16Tag] = cloneableTags[
                int32Tag
            ] = cloneableTags[mapTag] = cloneableTags[
                numberTag
            ] = cloneableTags[objectTag] = cloneableTags[
                regexpTag
            ] = cloneableTags[setTag] = cloneableTags[
                stringTag
            ] = cloneableTags[symbolTag] = cloneableTags[
                uint8Tag
            ] = cloneableTags[uint8ClampedTag] = cloneableTags[
                uint16Tag
            ] = cloneableTags[uint32Tag] = true
            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[
                weakMapTag
            ] = false

            /**
             * The base implementation of `_.clone` and `_.cloneDeep` which tracks
             * traversed objects.
             *
             * @private
             * @param {*} value The value to clone.
             * @param {boolean} bitmask The bitmask flags.
             *  1 - Deep clone
             *  2 - Flatten inherited properties
             *  4 - Clone symbols
             * @param {Function} [customizer] The function to customize cloning.
             * @param {string} [key] The key of `value`.
             * @param {Object} [object] The parent object of `value`.
             * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
             * @returns {*} Returns the cloned value.
             */
            function baseClone(value, bitmask, customizer, key, object, stack) {
                var result,
                    isDeep = bitmask & CLONE_DEEP_FLAG,
                    isFlat = bitmask & CLONE_FLAT_FLAG,
                    isFull = bitmask & CLONE_SYMBOLS_FLAG

                if (customizer) {
                    result = object
                        ? customizer(value, key, object, stack)
                        : customizer(value)
                }
                if (result !== undefined) {
                    return result
                }
                if (!isObject(value)) {
                    return value
                }
                var isArr = isArray(value)
                if (isArr) {
                    result = initCloneArray(value)
                    if (!isDeep) {
                        return copyArray(value, result)
                    }
                } else {
                    var tag = getTag(value),
                        isFunc = tag == funcTag || tag == genTag

                    if (isBuffer(value)) {
                        return cloneBuffer(value, isDeep)
                    }
                    if (
                        tag == objectTag ||
                        tag == argsTag ||
                        (isFunc && !object)
                    ) {
                        result = isFlat || isFunc ? {} : initCloneObject(value)
                        if (!isDeep) {
                            return isFlat
                                ? copySymbolsIn(
                                      value,
                                      baseAssignIn(result, value)
                                  )
                                : copySymbols(value, baseAssign(result, value))
                        }
                    } else {
                        if (!cloneableTags[tag]) {
                            return object ? value : {}
                        }
                        result = initCloneByTag(value, tag, isDeep)
                    }
                }
                // Check for circular references and return its corresponding clone.
                stack || (stack = new Stack())
                var stacked = stack.get(value)
                if (stacked) {
                    return stacked
                }
                stack.set(value, result)

                if (isSet(value)) {
                    value.forEach(function(subValue) {
                        result.add(
                            baseClone(
                                subValue,
                                bitmask,
                                customizer,
                                subValue,
                                value,
                                stack
                            )
                        )
                    })
                } else if (isMap(value)) {
                    value.forEach(function(subValue, key) {
                        result.set(
                            key,
                            baseClone(
                                subValue,
                                bitmask,
                                customizer,
                                key,
                                value,
                                stack
                            )
                        )
                    })
                }

                var keysFunc = isFull
                    ? isFlat
                        ? getAllKeysIn
                        : getAllKeys
                    : isFlat
                    ? keysIn
                    : keys

                var props = isArr ? undefined : keysFunc(value)
                arrayEach(props || value, function(subValue, key) {
                    if (props) {
                        key = subValue
                        subValue = value[key]
                    }
                    // Recursively populate clone (susceptible to call stack limits).
                    assignValue(
                        result,
                        key,
                        baseClone(
                            subValue,
                            bitmask,
                            customizer,
                            key,
                            value,
                            stack
                        )
                    )
                })
                return result
            }

            module.exports = baseClone

            /***/
        },

        /***/ OH9c: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /**
             * Update an Error with the specified config, error code, and response.
             *
             * @param {Error} error The error to update.
             * @param {Object} config The config.
             * @param {string} [code] The error code (for example, 'ECONNABORTED').
             * @param {Object} [request] The request.
             * @param {Object} [response] The response.
             * @returns {Error} The error.
             */
            module.exports = function enhanceError(
                error,
                config,
                code,
                request,
                response
            ) {
                error.config = config
                if (code) {
                    error.code = code
                }

                error.request = request
                error.response = response
                error.isAxiosError = true

                error.toJSON = function() {
                    return {
                        // Standard
                        message: this.message,
                        name: this.name,
                        // Microsoft
                        description: this.description,
                        number: this.number,
                        // Mozilla
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        // Axios
                        config: this.config,
                        code: this.code
                    }
                }
                return error
            }

            /***/
        },

        /***/ OHZa: /***/ function(module, exports, __webpack_require__) {
            const isDisjoint = __webpack_require__('KQbz')
            const base64url = __webpack_require__('Xab3')
            let validateCrit = __webpack_require__('urXW')
            const { JWEInvalid, JOSENotSupported } = __webpack_require__('yt7c')

            validateCrit = validateCrit.bind(undefined, JWEInvalid)

            module.exports = (
                prot,
                unprotected,
                recipients,
                checkAlgorithms,
                crit
            ) => {
                if (typeof prot === 'string') {
                    try {
                        prot = base64url.JSON.decode(prot)
                    } catch (err) {
                        throw new JWEInvalid(
                            'could not parse JWE protected header'
                        )
                    }
                }

                let alg = []
                const enc = new Set()
                if (
                    !isDisjoint(prot, unprotected) ||
                    !recipients.every(({ header }) => {
                        if (typeof header === 'object') {
                            alg.push(header.alg)
                            enc.add(header.enc)
                        }
                        const combined = { ...unprotected, ...header }
                        validateCrit(prot, combined, crit)
                        if ('zip' in combined) {
                            throw new JWEInvalid(
                                '"zip" Header Parameter MUST be integrity protected'
                            )
                        } else if (
                            prot &&
                            'zip' in prot &&
                            prot.zip !== 'DEF'
                        ) {
                            throw new JOSENotSupported(
                                'only "DEF" compression algorithm is supported'
                            )
                        }
                        return (
                            isDisjoint(header, prot) &&
                            isDisjoint(header, unprotected)
                        )
                    })
                ) {
                    throw new JWEInvalid(
                        'JWE Shared Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint'
                    )
                }

                if (typeof prot === 'object') {
                    alg.push(prot.alg)
                    enc.add(prot.enc)
                }
                if (typeof unprotected === 'object') {
                    alg.push(unprotected.alg)
                    enc.add(unprotected.enc)
                }

                alg = alg.filter(Boolean)
                enc.delete(undefined)

                if (recipients.length !== 1) {
                    if (alg.includes('dir') || alg.includes('ECDH-ES')) {
                        throw new JWEInvalid(
                            'dir and ECDH-ES alg may only be used with a single recipient'
                        )
                    }
                }

                if (checkAlgorithms) {
                    if (alg.length !== recipients.length) {
                        throw new JWEInvalid('missing Key Management algorithm')
                    }
                    if (enc.size === 0) {
                        throw new JWEInvalid(
                            'missing Content Encryption algorithm'
                        )
                    } else if (enc.size !== 1) {
                        throw new JWEInvalid(
                            'there must only be one Content Encryption algorithm'
                        )
                    }
                } else {
                    if (enc.size > 1) {
                        throw new JWEInvalid(
                            'there must only be one Content Encryption algorithm'
                        )
                    }
                }

                return [...enc][0]
            }

            /***/
        },

        /***/ ONme: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /*
    Decode functions adapted from:
    Version 1.0 12/25/99 Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
    http://www.onicos.com/staff/iz/amuse/javascript/expert/base64.txt
*/

            const Stream = __webpack_require__('msIP')

            const internals = {
                decodeChars: [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    62,
                    -1,
                    -1,
                    -1,
                    63,
                    52,
                    53,
                    54,
                    55,
                    56,
                    57,
                    58,
                    59,
                    60,
                    61,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                    32,
                    33,
                    34,
                    35,
                    36,
                    37,
                    38,
                    39,
                    40,
                    41,
                    42,
                    43,
                    44,
                    45,
                    46,
                    47,
                    48,
                    49,
                    50,
                    51,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1
                ]
            }

            exports.decode = function(buffer) {
                const decodeChars = internals.decodeChars
                const len = buffer.length
                const allocated = Math.ceil(len / 4) * 3
                const result = Buffer.alloc(allocated)

                let c1
                let c2
                let c3
                let c4
                let j = 0

                for (let i = 0; i < len; ) {
                    do {
                        c1 = decodeChars[buffer[i++] & 0xff]
                    } while (i < len && c1 === -1)

                    if (c1 === -1) {
                        break
                    }

                    do {
                        c2 = decodeChars[buffer[i++] & 0xff]
                    } while (i < len && c2 === -1)

                    if (c2 === -1) {
                        break
                    }

                    result[j++] = (c1 << 2) | ((c2 & 0x30) >> 4)

                    do {
                        c3 = buffer[i++] & 0xff
                        if (c3 === 61) {
                            // =
                            return result.slice(0, j)
                        }

                        c3 = decodeChars[c3]
                    } while (i < len && c3 === -1)

                    if (c3 === -1) {
                        break
                    }

                    result[j++] = ((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2)

                    do {
                        c4 = buffer[i++] & 0xff
                        if (c4 === 61) {
                            // =
                            return result.slice(0, j)
                        }

                        c4 = decodeChars[c4]
                    } while (i < len && c4 === -1)

                    if (c4 !== -1) {
                        result[j++] = ((c3 & 0x03) << 6) | c4
                    }
                }

                return j === allocated ? result : result.slice(0, j)
            }

            exports.Decoder = class Decoder extends Stream.Transform {
                constructor() {
                    super()
                    this._reminder = null
                }

                _transform(chunk, encoding, callback) {
                    let part = this._reminder
                        ? Buffer.concat([this._reminder, chunk])
                        : chunk
                    const remaining = part.length % 4
                    if (remaining) {
                        this._reminder = part.slice(part.length - remaining)
                        part = part.slice(0, part.length - remaining)
                    } else {
                        this._reminder = null
                    }

                    this.push(exports.decode(part))
                    return callback()
                }

                _flush(callback) {
                    if (this._reminder) {
                        this.push(exports.decode(this._reminder))
                    }

                    return callback()
                }
            }

            /***/
        },

        /***/ OTTw: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')

            module.exports = utils.isStandardBrowserEnv()
                ? // Standard browser envs have full support of the APIs needed to test
                  // whether the request URL is of the same origin as current location.
                  (function standardBrowserEnv() {
                      var msie = /(msie|trident)/i.test(navigator.userAgent)
                      var urlParsingNode = document.createElement('a')
                      var originURL

                      /**
                       * Parse a URL to discover it's components
                       *
                       * @param {String} url The URL to be parsed
                       * @returns {Object}
                       */
                      function resolveURL(url) {
                          var href = url

                          if (msie) {
                              // IE needs attribute set twice to normalize properties
                              urlParsingNode.setAttribute('href', href)
                              href = urlParsingNode.href
                          }

                          urlParsingNode.setAttribute('href', href)

                          // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
                          return {
                              href: urlParsingNode.href,
                              protocol: urlParsingNode.protocol
                                  ? urlParsingNode.protocol.replace(/:$/, '')
                                  : '',
                              host: urlParsingNode.host,
                              search: urlParsingNode.search
                                  ? urlParsingNode.search.replace(/^\?/, '')
                                  : '',
                              hash: urlParsingNode.hash
                                  ? urlParsingNode.hash.replace(/^#/, '')
                                  : '',
                              hostname: urlParsingNode.hostname,
                              port: urlParsingNode.port,
                              pathname:
                                  urlParsingNode.pathname.charAt(0) === '/'
                                      ? urlParsingNode.pathname
                                      : '/' + urlParsingNode.pathname
                          }
                      }

                      originURL = resolveURL(window.location.href)

                      /**
                       * Determine if a URL shares the same origin as the current location
                       *
                       * @param {String} requestURL The URL to test
                       * @returns {boolean} True if URL shares the same origin, otherwise false
                       */
                      return function isURLSameOrigin(requestURL) {
                          var parsed = utils.isString(requestURL)
                              ? resolveURL(requestURL)
                              : requestURL
                          return (
                              parsed.protocol === originURL.protocol &&
                              parsed.host === originURL.host
                          )
                      }
                  })()
                : // Non standard browser envs (web workers, react-native) lack needed support.
                  (function nonStandardBrowserEnv() {
                      return function isURLSameOrigin() {
                          return true
                      }
                  })()

            /***/
        },

        /***/ OaTm: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            async function optimize(html) {
                let AmpOptimizer
                try {
                    AmpOptimizer = __webpack_require__('8C61')
                } catch (_) {
                    return html
                }
                const optimizer = AmpOptimizer.create()
                return optimizer.transformHtml(html)
            }
            exports.default = optimize

            /***/
        },

        /***/ Oc8Q: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var global = __webpack_require__('5T2Y')
            var each = __webpack_require__('V7Et')(0)
            var redefine = __webpack_require__('kTiW')
            var meta = __webpack_require__('6/1s')
            var assign = __webpack_require__('kwZ1')
            var weak = __webpack_require__('kB4c')
            var isObject = __webpack_require__('93I4')
            var validate = __webpack_require__('n3ko')
            var NATIVE_WEAK_MAP = __webpack_require__('n3ko')
            var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global
            var WEAK_MAP = 'WeakMap'
            var getWeak = meta.getWeak
            var isExtensible = Object.isExtensible
            var uncaughtFrozenStore = weak.ufstore
            var InternalMap

            var wrapper = function(get) {
                return function WeakMap() {
                    return get(
                        this,
                        arguments.length > 0 ? arguments[0] : undefined
                    )
                }
            }

            var methods = {
                // 23.3.3.3 WeakMap.prototype.get(key)
                get: function get(key) {
                    if (isObject(key)) {
                        var data = getWeak(key)
                        if (data === true)
                            return uncaughtFrozenStore(
                                validate(this, WEAK_MAP)
                            ).get(key)
                        return data ? data[this._i] : undefined
                    }
                },
                // 23.3.3.5 WeakMap.prototype.set(key, value)
                set: function set(key, value) {
                    return weak.def(validate(this, WEAK_MAP), key, value)
                }
            }

            // 23.3 WeakMap Objects
            var $WeakMap = (module.exports = __webpack_require__('raTm')(
                WEAK_MAP,
                wrapper,
                methods,
                weak,
                true,
                true
            ))

            // IE11 WeakMap frozen keys fix
            if (NATIVE_WEAK_MAP && IS_IE11) {
                InternalMap = weak.getConstructor(wrapper, WEAK_MAP)
                assign(InternalMap.prototype, methods)
                meta.NEED = true
                each(['delete', 'has', 'get', 'set'], function(key) {
                    var proto = $WeakMap.prototype
                    var method = proto[key]
                    redefine(proto, key, function(a, b) {
                        // store frozen objects on internal weakmap shim
                        if (isObject(a) && !isExtensible(a)) {
                            if (!this._f) this._f = new InternalMap()
                            var result = this._f[key](a, b)
                            return key == 'set' ? this : result
                            // store all the rest on native weakmap
                        }
                        return method.call(this, a, b)
                    })
                })
            }

            /***/
        },

        /***/ 'Of+w': /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5'),
                root = __webpack_require__('Kz5y')

            /* Built-in method references that are verified to be native. */
            var WeakMap = getNative(root, 'WeakMap')

            module.exports = WeakMap

            /***/
        },

        /***/ OgAF: /***/ function(module, exports) {
            module.exports = {
                oct: {
                    decrypt: {},
                    deriveKey: {},
                    encrypt: {},
                    sign: {},
                    unwrapKey: {},
                    verify: {},
                    wrapKey: {}
                },
                EC: {
                    decrypt: {},
                    deriveKey: {},
                    encrypt: {},
                    sign: {},
                    unwrapKey: {},
                    verify: {},
                    wrapKey: {}
                },
                RSA: {
                    decrypt: {},
                    deriveKey: {},
                    encrypt: {},
                    sign: {},
                    unwrapKey: {},
                    verify: {},
                    wrapKey: {}
                },
                OKP: {
                    decrypt: {},
                    deriveKey: {},
                    encrypt: {},
                    sign: {},
                    unwrapKey: {},
                    verify: {},
                    wrapKey: {}
                }
            }

            /***/
        },

        /***/ Ojgd: /***/ function(module, exports) {
            // 7.1.4 ToInteger
            var ceil = Math.ceil
            var floor = Math.floor
            module.exports = function(it) {
                return isNaN((it = +it)) ? 0 : (it > 0 ? floor : ceil)(it)
            }

            /***/
        },

        /***/ P4Tr: /***/ function(module, exports, __webpack_require__) {
            var apply = __webpack_require__('heNW'),
                baseRest = __webpack_require__('EA7m'),
                customDefaultsMerge = __webpack_require__('4DFU'),
                mergeWith = __webpack_require__('JBE3')

            /**
             * This method is like `_.defaults` except that it recursively assigns
             * default properties.
             *
             * **Note:** This method mutates `object`.
             *
             * @static
             * @memberOf _
             * @since 3.10.0
             * @category Object
             * @param {Object} object The destination object.
             * @param {...Object} [sources] The source objects.
             * @returns {Object} Returns `object`.
             * @see _.defaults
             * @example
             *
             * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
             * // => { 'a': { 'b': 2, 'c': 3 } }
             */
            var defaultsDeep = baseRest(function(args) {
                args.push(undefined, customDefaultsMerge)
                return apply(mergeWith, undefined, args)
            })

            module.exports = defaultsDeep

            /***/
        },

        /***/ P5f7: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$defineProperty = __webpack_require__('hfKm')

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            function rewriteUrlForNextExport(url) {
                const [pathname, hash] = url.split('#') // tslint:disable-next-line

                let [path, qs] = pathname.split('?')
                path = path.replace(/\/$/, '') // Append a trailing slash if this path does not have an extension

                if (!/\.[^/]+\/?$/.test(path)) path += `/`
                if (qs) path += '?' + qs
                if (hash) path += '#' + hash
                return path
            }

            exports.rewriteUrlForNextExport = rewriteUrlForNextExport

            /***/
        },

        /***/ PBE1: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            // https://github.com/tc39/proposal-promise-finally

            var $export = __webpack_require__('Y7ZC')
            var core = __webpack_require__('WEpk')
            var global = __webpack_require__('5T2Y')
            var speciesConstructor = __webpack_require__('8gHz')
            var promiseResolve = __webpack_require__('zXhZ')

            $export($export.P + $export.R, 'Promise', {
                finally: function(onFinally) {
                    var C = speciesConstructor(
                        this,
                        core.Promise || global.Promise
                    )
                    var isFunction = typeof onFinally == 'function'
                    return this.then(
                        isFunction
                            ? function(x) {
                                  return promiseResolve(C, onFinally()).then(
                                      function() {
                                          return x
                                      }
                                  )
                              }
                            : onFinally,
                        isFunction
                            ? function(e) {
                                  return promiseResolve(C, onFinally()).then(
                                      function() {
                                          throw e
                                      }
                                  )
                              }
                            : onFinally
                    )
                }
            })

            /***/
        },

        /***/ 'PC/d': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const login_1 = tslib_1.__importDefault(__webpack_require__('1gXH'))
            const logout_1 = tslib_1.__importDefault(
                __webpack_require__('m2VO')
            )
            const callback_1 = tslib_1.__importDefault(
                __webpack_require__('5sNo')
            )
            const profile_1 = tslib_1.__importDefault(
                __webpack_require__('2KX+')
            )
            const session_1 = tslib_1.__importDefault(
                __webpack_require__('J0Hf')
            )
            const require_authentication_1 = tslib_1.__importDefault(
                __webpack_require__('9YuQ')
            )
            exports.default = {
                CallbackHandler: callback_1.default,
                LoginHandler: login_1.default,
                LogoutHandler: logout_1.default,
                ProfileHandler: profile_1.default,
                SessionHandler: session_1.default,
                RequireAuthentication: require_authentication_1.default
            }
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ PJMN: /***/ function(module, exports) {
            module.exports = require('crypto')

            /***/
        },

        /***/ PRL6: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const constants_1 = __webpack_require__('w7wo')
            function isBlockedPage(pathname) {
                return constants_1.BLOCKED_PAGES.indexOf(pathname) !== -1
            }
            exports.isBlockedPage = isBlockedPage
            function cleanAmpPath(pathname) {
                if (pathname.match(/\?amp=(y|yes|true|1)/)) {
                    pathname = pathname.replace(/\?amp=(y|yes|true|1)&?/, '?')
                }
                if (pathname.match(/&amp=(y|yes|true|1)/)) {
                    pathname = pathname.replace(/&amp=(y|yes|true|1)/, '')
                }
                pathname = pathname.replace(/\?$/, '')
                return pathname
            }
            exports.cleanAmpPath = cleanAmpPath

            /***/
        },

        /***/ PbSP: /***/ function(module, exports) {
            module.exports = () => Math.floor(Date.now() / 1000)

            /***/
        },

        /***/ PsWn: /***/ function(module, exports) {
            const MAX_INT32 = Math.pow(2, 32)

            module.exports = (value, buf = Buffer.allocUnsafe(8)) => {
                const high = Math.floor(value / MAX_INT32)
                const low = value % MAX_INT32

                buf.writeUInt32BE(high, 0)
                buf.writeUInt32BE(low, 4)
                return buf
            }

            /***/
        },

        /***/ Pxi6: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Reach = __webpack_require__('mmuM')

            const internals = {}

            module.exports = function(obj, template, options) {
                return template.replace(/{([^}]+)}/g, ($0, chain) => {
                    const value = Reach(obj, chain, options)
                    return value === undefined || value === null ? '' : value
                })
            }

            /***/
        },

        /***/ 'Q/yX': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // https://github.com/tc39/proposal-promise-try
            var $export = __webpack_require__('Y7ZC')
            var newPromiseCapability = __webpack_require__('ZW5q')
            var perform = __webpack_require__('RDmV')

            $export($export.S, 'Promise', {
                try: function(callbackfn) {
                    var promiseCapability = newPromiseCapability.f(this)
                    var result = perform(callbackfn)
                    ;(result.e
                        ? promiseCapability.reject
                        : promiseCapability.resolve)(result.v)
                    return promiseCapability.promise
                }
            })

            /***/
        },

        /***/ Q1l4: /***/ function(module, exports) {
            /**
             * Copies the values of `source` to `array`.
             *
             * @private
             * @param {Array} source The array to copy values from.
             * @param {Array} [array=[]] The array to copy values to.
             * @returns {Array} Returns `array`.
             */
            function copyArray(source, array) {
                var index = -1,
                    length = source.length

                array || (array = Array(length))
                while (++index < length) {
                    array[index] = source[index]
                }
                return array
            }

            module.exports = copyArray

            /***/
        },

        /***/ QMMT: /***/ function(module, exports, __webpack_require__) {
            // getting tag from 19.1.3.6 Object.prototype.toString()
            var cof = __webpack_require__('a0xu')
            var TAG = __webpack_require__('UWiX')('toStringTag')
            // ES3 wrong here
            var ARG =
                cof(
                    (function() {
                        return arguments
                    })()
                ) == 'Arguments'

            // fallback for IE11 Script Access Denied error
            var tryGet = function(it, key) {
                try {
                    return it[key]
                } catch (e) {
                    /* empty */
                }
            }

            module.exports = function(it) {
                var O, T, B
                return it === undefined
                    ? 'Undefined'
                    : it === null
                    ? 'Null'
                    : // @@toStringTag case
                    typeof (T = tryGet((O = Object(it)), TAG)) == 'string'
                    ? T
                    : // builtinTag case
                    ARG
                    ? cof(O)
                    : // ES3 arguments fallback
                    (B = cof(O)) == 'Object' && typeof O.callee == 'function'
                    ? 'Arguments'
                    : B
            }

            /***/
        },

        /***/ QQHG: /***/ function(module, exports, __webpack_require__) {
            const { inherits } = __webpack_require__('jK02')

            const DERDecoder = __webpack_require__('R7nf')

            function PEMDecoder(entity) {
                DERDecoder.call(this, entity)
                this.enc = 'pem'
            }
            inherits(PEMDecoder, DERDecoder)

            PEMDecoder.prototype.decode = function decode(data, options) {
                const lines = data.toString().split(/[\r\n]+/g)

                const label = options.label.toUpperCase()

                const re = /^-----(BEGIN|END) ([^-]+)-----$/
                let start = -1
                let end = -1
                for (let i = 0; i < lines.length; i++) {
                    const match = lines[i].match(re)
                    if (match === null) {
                        continue
                    }

                    if (match[2] !== label) {
                        continue
                    }

                    if (start === -1) {
                        if (match[1] !== 'BEGIN') {
                            break
                        }
                        start = i
                    } else {
                        if (match[1] !== 'END') {
                            break
                        }
                        end = i
                        break
                    }
                }
                if (start === -1 || end === -1) {
                    throw new Error(`PEM section not found for: ${label}`)
                }

                const base64 = lines.slice(start + 1, end).join('')
                // Remove excessive symbols
                base64.replace(/[^a-z0-9+/=]+/gi, '')

                const input = Buffer.from(base64, 'base64')
                return DERDecoder.prototype.decode.call(this, input, options)
            }

            module.exports = PEMDecoder

            /***/
        },

        /***/ QXhf: /***/ function(module, exports, __webpack_require__) {
            var ctx = __webpack_require__('2GTP')
            var invoke = __webpack_require__('MCSJ')
            var html = __webpack_require__('MvwC')
            var cel = __webpack_require__('Hsns')
            var global = __webpack_require__('5T2Y')
            var process = global.process
            var setTask = global.setImmediate
            var clearTask = global.clearImmediate
            var MessageChannel = global.MessageChannel
            var Dispatch = global.Dispatch
            var counter = 0
            var queue = {}
            var ONREADYSTATECHANGE = 'onreadystatechange'
            var defer, channel, port
            var run = function() {
                var id = +this
                // eslint-disable-next-line no-prototype-builtins
                if (queue.hasOwnProperty(id)) {
                    var fn = queue[id]
                    delete queue[id]
                    fn()
                }
            }
            var listener = function(event) {
                run.call(event.data)
            }
            // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
            if (!setTask || !clearTask) {
                setTask = function setImmediate(fn) {
                    var args = []
                    var i = 1
                    while (arguments.length > i) args.push(arguments[i++])
                    queue[++counter] = function() {
                        // eslint-disable-next-line no-new-func
                        invoke(
                            typeof fn == 'function' ? fn : Function(fn),
                            args
                        )
                    }
                    defer(counter)
                    return counter
                }
                clearTask = function clearImmediate(id) {
                    delete queue[id]
                }
                // Node.js 0.8-
                if (__webpack_require__('a0xu')(process) == 'process') {
                    defer = function(id) {
                        process.nextTick(ctx(run, id, 1))
                    }
                    // Sphere (JS game engine) Dispatch API
                } else if (Dispatch && Dispatch.now) {
                    defer = function(id) {
                        Dispatch.now(ctx(run, id, 1))
                    }
                    // Browsers with MessageChannel, includes WebWorkers
                } else if (MessageChannel) {
                    channel = new MessageChannel()
                    port = channel.port2
                    channel.port1.onmessage = listener
                    defer = ctx(port.postMessage, port, 1)
                    // Browsers with postMessage, skip WebWorkers
                    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
                } else if (
                    global.addEventListener &&
                    typeof postMessage == 'function' &&
                    !global.importScripts
                ) {
                    defer = function(id) {
                        global.postMessage(id + '', '*')
                    }
                    global.addEventListener('message', listener, false)
                    // IE8-
                } else if (ONREADYSTATECHANGE in cel('script')) {
                    defer = function(id) {
                        html.appendChild(cel('script'))[
                            ONREADYSTATECHANGE
                        ] = function() {
                            html.removeChild(this)
                            run.call(id)
                        }
                    }
                    // Rest old browsers
                } else {
                    defer = function(id) {
                        setTimeout(ctx(run, id, 1), 0)
                    }
                }
            }
            module.exports = {
                set: setTask,
                clear: clearTask
            }

            /***/
        },

        /***/ QcOe: /***/ function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__('GoyQ'),
                isPrototype = __webpack_require__('6sVZ'),
                nativeKeysIn = __webpack_require__('7Ix3')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             */
            function baseKeysIn(object) {
                if (!isObject(object)) {
                    return nativeKeysIn(object)
                }
                var isProto = isPrototype(object),
                    result = []

                for (var key in object) {
                    if (
                        !(
                            key == 'constructor' &&
                            (isProto || !hasOwnProperty.call(object, key))
                        )
                    ) {
                        result.push(key)
                    }
                }
                return result
            }

            module.exports = baseKeysIn

            /***/
        },

        /***/ QkVE: /***/ function(module, exports, __webpack_require__) {
            var isKeyable = __webpack_require__('EpBk')

            /**
             * Gets the data for `map`.
             *
             * @private
             * @param {Object} map The map to query.
             * @param {string} key The reference key.
             * @returns {*} Returns the map data.
             */
            function getMapData(map, key) {
                var data = map.__data__
                return isKeyable(key)
                    ? data[typeof key == 'string' ? 'string' : 'hash']
                    : data.map
            }

            module.exports = getMapData

            /***/
        },

        /***/ QkVN: /***/ function(module, exports, __webpack_require__) {
            var baseMerge = __webpack_require__('+Qka'),
                createAssigner = __webpack_require__('LsHQ')

            /**
             * This method is like `_.assign` except that it recursively merges own and
             * inherited enumerable string keyed properties of source objects into the
             * destination object. Source properties that resolve to `undefined` are
             * skipped if a destination value exists. Array and plain object properties
             * are merged recursively. Other objects and value types are overridden by
             * assignment. Source objects are applied from left to right. Subsequent
             * sources overwrite property assignments of previous sources.
             *
             * **Note:** This method mutates `object`.
             *
             * @static
             * @memberOf _
             * @since 0.5.0
             * @category Object
             * @param {Object} object The destination object.
             * @param {...Object} [sources] The source objects.
             * @returns {Object} Returns `object`.
             * @example
             *
             * var object = {
             *   'a': [{ 'b': 2 }, { 'd': 4 }]
             * };
             *
             * var other = {
             *   'a': [{ 'c': 3 }, { 'e': 5 }]
             * };
             *
             * _.merge(object, other);
             * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
             */
            var merge = createAssigner(function(object, source, srcIndex) {
                baseMerge(object, source, srcIndex)
            })

            module.exports = merge

            /***/
        },

        /***/ QoRX: /***/ function(module, exports) {
            /**
             * A specialized version of `_.some` for arrays without support for iteratee
             * shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {boolean} Returns `true` if any element passes the predicate check,
             *  else `false`.
             */
            function arraySome(array, predicate) {
                var index = -1,
                    length = array == null ? 0 : array.length

                while (++index < length) {
                    if (predicate(array[index], index, array)) {
                        return true
                    }
                }
                return false
            }

            module.exports = arraySome

            /***/
        },

        /***/ QqLw: /***/ function(module, exports, __webpack_require__) {
            var DataView = __webpack_require__('tadb'),
                Map = __webpack_require__('ebwN'),
                Promise = __webpack_require__('HOxn'),
                Set = __webpack_require__('yGk4'),
                WeakMap = __webpack_require__('Of+w'),
                baseGetTag = __webpack_require__('NykK'),
                toSource = __webpack_require__('3Fdi')

            /** `Object#toString` result references. */
            var mapTag = '[object Map]',
                objectTag = '[object Object]',
                promiseTag = '[object Promise]',
                setTag = '[object Set]',
                weakMapTag = '[object WeakMap]'

            var dataViewTag = '[object DataView]'

            /** Used to detect maps, sets, and weakmaps. */
            var dataViewCtorString = toSource(DataView),
                mapCtorString = toSource(Map),
                promiseCtorString = toSource(Promise),
                setCtorString = toSource(Set),
                weakMapCtorString = toSource(WeakMap)

            /**
             * Gets the `toStringTag` of `value`.
             *
             * @private
             * @param {*} value The value to query.
             * @returns {string} Returns the `toStringTag`.
             */
            var getTag = baseGetTag

            // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
            if (
                (DataView &&
                    getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
                (Map && getTag(new Map()) != mapTag) ||
                (Promise && getTag(Promise.resolve()) != promiseTag) ||
                (Set && getTag(new Set()) != setTag) ||
                (WeakMap && getTag(new WeakMap()) != weakMapTag)
            ) {
                getTag = function(value) {
                    var result = baseGetTag(value),
                        Ctor =
                            result == objectTag ? value.constructor : undefined,
                        ctorString = Ctor ? toSource(Ctor) : ''

                    if (ctorString) {
                        switch (ctorString) {
                            case dataViewCtorString:
                                return dataViewTag
                            case mapCtorString:
                                return mapTag
                            case promiseCtorString:
                                return promiseTag
                            case setCtorString:
                                return setTag
                            case weakMapCtorString:
                                return weakMapTag
                        }
                    }
                    return result
                }
            }

            module.exports = getTag

            /***/
        },

        /***/ Qs2e: /***/ function(module, exports) {
            module.exports = require('net')

            /***/
        },

        /***/ Qs3B: /***/ function(module, exports) {
            module.exports = require('assert')

            /***/
        },

        /***/ Qxd3: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            class CancelError extends Error {
                constructor(reason) {
                    super(reason || 'Promise was canceled')
                    this.name = 'CancelError'
                }

                get isCanceled() {
                    return true
                }
            }

            class PCancelable {
                static fn(userFn) {
                    return (...args) => {
                        return new PCancelable((resolve, reject, onCancel) => {
                            args.push(onCancel)
                            userFn(...args).then(resolve, reject)
                        })
                    }
                }

                constructor(executor) {
                    this._cancelHandlers = []
                    this._isPending = true
                    this._isCanceled = false
                    this._rejectOnCancel = true

                    this._promise = new Promise((resolve, reject) => {
                        this._reject = reject

                        const onResolve = value => {
                            this._isPending = false
                            resolve(value)
                        }

                        const onReject = error => {
                            this._isPending = false
                            reject(error)
                        }

                        const onCancel = handler => {
                            this._cancelHandlers.push(handler)
                        }

                        Object.defineProperties(onCancel, {
                            shouldReject: {
                                get: () => this._rejectOnCancel,
                                set: bool => {
                                    this._rejectOnCancel = bool
                                }
                            }
                        })

                        return executor(onResolve, onReject, onCancel)
                    })
                }

                then(onFulfilled, onRejected) {
                    return this._promise.then(onFulfilled, onRejected)
                }

                catch(onRejected) {
                    return this._promise.catch(onRejected)
                }

                finally(onFinally) {
                    return this._promise.finally(onFinally)
                }

                cancel(reason) {
                    if (!this._isPending || this._isCanceled) {
                        return
                    }

                    if (this._cancelHandlers.length > 0) {
                        try {
                            for (const handler of this._cancelHandlers) {
                                handler()
                            }
                        } catch (error) {
                            this._reject(error)
                        }
                    }

                    this._isCanceled = true
                    if (this._rejectOnCancel) {
                        this._reject(new CancelError(reason))
                    }
                }

                get isCanceled() {
                    return this._isCanceled
                }
            }

            Object.setPrototypeOf(PCancelable.prototype, Promise.prototype)

            module.exports = PCancelable
            module.exports.default = PCancelable

            module.exports.CancelError = CancelError

            /***/
        },

        /***/ 'R+7+': /***/ function(module, exports, __webpack_require__) {
            // all enumerable object keys, includes symbols
            var getKeys = __webpack_require__('w6GO')
            var gOPS = __webpack_require__('mqlF')
            var pIE = __webpack_require__('NV0k')
            module.exports = function(it) {
                var result = getKeys(it)
                var getSymbols = gOPS.f
                if (getSymbols) {
                    var symbols = getSymbols(it)
                    var isEnum = pIE.f
                    var i = 0
                    var key
                    while (symbols.length > i)
                        if (isEnum.call(it, (key = symbols[i++])))
                            result.push(key)
                }
                return result
            }

            /***/
        },

        /***/ R7nf: /***/ function(module, exports, __webpack_require__) {
            /* global BigInt */
            const { inherits } = __webpack_require__('jK02')

            const { DecoderBuffer } = __webpack_require__('Z9M3')
            const Node = __webpack_require__('k+0e')

            // Import DER constants
            const der = __webpack_require__('1Gj5')

            function DERDecoder(entity) {
                this.enc = 'der'
                this.name = entity.name
                this.entity = entity

                // Construct base tree
                this.tree = new DERNode()
                this.tree._init(entity.body)
            }

            DERDecoder.prototype.decode = function decode(data, options) {
                if (!DecoderBuffer.isDecoderBuffer(data)) {
                    data = new DecoderBuffer(data, options)
                }

                return this.tree._decode(data, options)
            }

            // Tree methods

            function DERNode(parent) {
                Node.call(this, 'der', parent)
            }
            inherits(DERNode, Node)

            DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
                if (buffer.isEmpty()) {
                    return false
                }

                const state = buffer.save()
                const decodedTag = derDecodeTag(
                    buffer,
                    `Failed to peek tag: "${tag}"`
                )
                if (buffer.isError(decodedTag)) {
                    return decodedTag
                }

                buffer.restore(state)

                return (
                    decodedTag.tag === tag ||
                    decodedTag.tagStr === tag ||
                    decodedTag.tagStr + 'of' === tag ||
                    any
                )
            }

            DERNode.prototype._decodeTag = function decodeTag(
                buffer,
                tag,
                any
            ) {
                const decodedTag = derDecodeTag(
                    buffer,
                    `Failed to decode tag of "${tag}"`
                )
                if (buffer.isError(decodedTag)) {
                    return decodedTag
                }

                let len = derDecodeLen(
                    buffer,
                    decodedTag.primitive,
                    `Failed to get length of "${tag}"`
                )

                // Failure
                if (buffer.isError(len)) {
                    return len
                }

                if (
                    !any &&
                    decodedTag.tag !== tag &&
                    decodedTag.tagStr !== tag &&
                    decodedTag.tagStr + 'of' !== tag
                ) {
                    return buffer.error(`Failed to match tag: "${tag}"`)
                }

                if (decodedTag.primitive || len !== null) {
                    return buffer.skip(len, `Failed to match body of: "${tag}"`)
                }

                // Indefinite length... find END tag
                const state = buffer.save()
                const res = this._skipUntilEnd(
                    buffer,
                    `Failed to skip indefinite length body: "${this.tag}"`
                )
                if (buffer.isError(res)) {
                    return res
                }

                len = buffer.offset - state.offset
                buffer.restore(state)
                return buffer.skip(len, `Failed to match body of: "${tag}"`)
            }

            DERNode.prototype._skipUntilEnd = function skipUntilEnd(
                buffer,
                fail
            ) {
                for (;;) {
                    const tag = derDecodeTag(buffer, fail)
                    if (buffer.isError(tag)) {
                        return tag
                    }
                    const len = derDecodeLen(buffer, tag.primitive, fail)
                    if (buffer.isError(len)) {
                        return len
                    }

                    let res
                    if (tag.primitive || len !== null) {
                        res = buffer.skip(len)
                    } else {
                        res = this._skipUntilEnd(buffer, fail)
                    }

                    // Failure
                    if (buffer.isError(res)) {
                        return res
                    }

                    if (tag.tagStr === 'end') {
                        break
                    }
                }
            }

            DERNode.prototype._decodeList = function decodeList(
                buffer,
                tag,
                decoder,
                options
            ) {
                const result = []
                while (!buffer.isEmpty()) {
                    const possibleEnd = this._peekTag(buffer, 'end')
                    if (buffer.isError(possibleEnd)) {
                        return possibleEnd
                    }

                    const res = decoder.decode(buffer, 'der', options)
                    if (buffer.isError(res) && possibleEnd) {
                        break
                    }
                    result.push(res)
                }
                return result
            }

            DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
                if (tag === 'bitstr') {
                    const unused = buffer.readUInt8()
                    if (buffer.isError(unused)) {
                        return unused
                    }
                    return { unused: unused, data: buffer.raw() }
                } else if (tag === 'bmpstr') {
                    const raw = buffer.raw()
                    if (raw.length % 2 === 1) {
                        return buffer.error(
                            'Decoding of string type: bmpstr length mismatch'
                        )
                    }

                    let str = ''
                    for (let i = 0; i < raw.length / 2; i++) {
                        str += String.fromCharCode(raw.readUInt16BE(i * 2))
                    }
                    return str
                } else if (tag === 'numstr') {
                    const numstr = buffer.raw().toString('ascii')
                    if (!this._isNumstr(numstr)) {
                        return buffer.error(
                            'Decoding of string type: numstr unsupported characters'
                        )
                    }
                    return numstr
                } else if (tag === 'octstr') {
                    return buffer.raw()
                } else if (tag === 'objDesc') {
                    return buffer.raw()
                } else if (tag === 'printstr') {
                    const printstr = buffer.raw().toString('ascii')
                    if (!this._isPrintstr(printstr)) {
                        return buffer.error(
                            'Decoding of string type: printstr unsupported characters'
                        )
                    }
                    return printstr
                } else if (/str$/.test(tag)) {
                    return buffer.raw().toString()
                } else {
                    return buffer.error(
                        `Decoding of string type: ${tag} unsupported`
                    )
                }
            }

            DERNode.prototype._decodeObjid = function decodeObjid(
                buffer,
                values,
                relative
            ) {
                let result
                const identifiers = []
                let ident = 0
                let subident = 0
                while (!buffer.isEmpty()) {
                    subident = buffer.readUInt8()
                    ident <<= 7
                    ident |= subident & 0x7f
                    if ((subident & 0x80) === 0) {
                        identifiers.push(ident)
                        ident = 0
                    }
                }
                if (subident & 0x80) {
                    identifiers.push(ident)
                }

                const first = (identifiers[0] / 40) | 0
                const second = identifiers[0] % 40

                if (relative) {
                    result = identifiers
                } else {
                    result = [first, second].concat(identifiers.slice(1))
                }

                if (values) {
                    let tmp = values[result.join(' ')]
                    if (tmp === undefined) {
                        tmp = values[result.join('.')]
                    }
                    if (tmp !== undefined) {
                        result = tmp
                    }
                }

                return result
            }

            DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
                const str = buffer.raw().toString()

                let year
                let mon
                let day
                let hour
                let min
                let sec
                if (tag === 'gentime') {
                    year = str.slice(0, 4) | 0
                    mon = str.slice(4, 6) | 0
                    day = str.slice(6, 8) | 0
                    hour = str.slice(8, 10) | 0
                    min = str.slice(10, 12) | 0
                    sec = str.slice(12, 14) | 0
                } else if (tag === 'utctime') {
                    year = str.slice(0, 2) | 0
                    mon = str.slice(2, 4) | 0
                    day = str.slice(4, 6) | 0
                    hour = str.slice(6, 8) | 0
                    min = str.slice(8, 10) | 0
                    sec = str.slice(10, 12) | 0
                    if (year < 70) {
                        year = 2000 + year
                    } else {
                        year = 1900 + year
                    }
                } else {
                    return buffer.error(
                        `Decoding ${tag} time is not supported yet`
                    )
                }

                return Date.UTC(year, mon - 1, day, hour, min, sec, 0)
            }

            DERNode.prototype._decodeNull = function decodeNull() {
                return null
            }

            DERNode.prototype._decodeBool = function decodeBool(buffer) {
                const res = buffer.readUInt8()
                if (buffer.isError(res)) {
                    return res
                } else {
                    return res !== 0
                }
            }

            DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
                // Bigint, return as it is (assume big endian)
                const raw = buffer.raw()
                let res = BigInt(`0x${raw.toString('hex')}`)

                if (values) {
                    res = values[res.toString(10)] || res
                }

                return res
            }

            DERNode.prototype._use = function use(entity, obj) {
                if (typeof entity === 'function') {
                    entity = entity(obj)
                }
                return entity._getDecoder('der').tree
            }

            // Utility methods

            function derDecodeTag(buf, fail) {
                let tag = buf.readUInt8(fail)
                if (buf.isError(tag)) {
                    return tag
                }

                const cls = der.tagClass[tag >> 6]
                const primitive = (tag & 0x20) === 0

                // Multi-octet tag - load
                if ((tag & 0x1f) === 0x1f) {
                    let oct = tag
                    tag = 0
                    while ((oct & 0x80) === 0x80) {
                        oct = buf.readUInt8(fail)
                        if (buf.isError(oct)) {
                            return oct
                        }

                        tag <<= 7
                        tag |= oct & 0x7f
                    }
                } else {
                    tag &= 0x1f
                }
                const tagStr = der.tag[tag]

                return {
                    cls: cls,
                    primitive: primitive,
                    tag: tag,
                    tagStr: tagStr
                }
            }

            function derDecodeLen(buf, primitive, fail) {
                let len = buf.readUInt8(fail)
                if (buf.isError(len)) {
                    return len
                }

                // Indefinite form
                if (!primitive && len === 0x80) {
                    return null
                }

                // Definite form
                if ((len & 0x80) === 0) {
                    // Short form
                    return len
                }

                // Long form
                const num = len & 0x7f
                if (num > 4) {
                    return buf.error('length octect is too long')
                }

                len = 0
                for (let i = 0; i < num; i++) {
                    len <<= 8
                    const j = buf.readUInt8(fail)
                    if (buf.isError(j)) {
                        return j
                    }
                    len |= j
                }

                return len
            }

            module.exports = DERDecoder

            /***/
        },

        /***/ RDmV: /***/ function(module, exports) {
            module.exports = function(exec) {
                try {
                    return { e: false, v: exec() }
                } catch (e) {
                    return { e: true, v: e }
                }
            }

            /***/
        },

        /***/ RF0s: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            var pad_string_1 = __webpack_require__('vUsp')
            function encode(input, encoding) {
                if (encoding === void 0) {
                    encoding = 'utf8'
                }
                if (Buffer.isBuffer(input)) {
                    return fromBase64(input.toString('base64'))
                }
                return fromBase64(
                    Buffer.from(input, encoding).toString('base64')
                )
            }
            function decode(base64url, encoding) {
                if (encoding === void 0) {
                    encoding = 'utf8'
                }
                return Buffer.from(toBase64(base64url), 'base64').toString(
                    encoding
                )
            }
            function toBase64(base64url) {
                base64url = base64url.toString()
                return pad_string_1
                    .default(base64url)
                    .replace(/\-/g, '+')
                    .replace(/_/g, '/')
            }
            function fromBase64(base64) {
                return base64
                    .replace(/=/g, '')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
            }
            function toBuffer(base64url) {
                return Buffer.from(toBase64(base64url), 'base64')
            }
            var base64url = encode
            base64url.encode = encode
            base64url.decode = decode
            base64url.toBase64 = toBase64
            base64url.fromBase64 = fromBase64
            base64url.toBuffer = toBuffer
            exports.default = base64url

            /***/
        },

        /***/ RFts: /***/ function(module, exports, __webpack_require__) {
            const { improvedDH } = __webpack_require__('pDDt')

            if (improvedDH) {
                const { diffieHellman } = __webpack_require__('PJMN')

                const { KeyObject } = __webpack_require__('1ALl')
                const importKey = __webpack_require__('GhER')

                module.exports = ({ keyObject: privateKey }, publicKey) => {
                    if (!(publicKey instanceof KeyObject)) {
                        ;({ keyObject: publicKey } = importKey(publicKey))
                    }

                    return diffieHellman({ privateKey, publicKey })
                }
            } else {
                const {
                    createECDH,
                    constants: { POINT_CONVERSION_UNCOMPRESSED }
                } = __webpack_require__('PJMN')

                const base64url = __webpack_require__('Xab3')

                const crvToCurve = crv => {
                    switch (crv) {
                        case 'P-256':
                            return 'prime256v1'
                        case 'P-384':
                            return 'secp384r1'
                        case 'P-521':
                            return 'secp521r1'
                    }
                }

                const UNCOMPRESSED = Buffer.alloc(
                    1,
                    POINT_CONVERSION_UNCOMPRESSED
                )
                const pubToBuffer = (x, y) =>
                    Buffer.concat([
                        UNCOMPRESSED,
                        base64url.decodeToBuffer(x),
                        base64url.decodeToBuffer(y)
                    ])

                module.exports = ({ crv, d }, { x, y }) => {
                    const curve = crvToCurve(crv)
                    const exchange = createECDH(curve)

                    exchange.setPrivateKey(base64url.decodeToBuffer(d))

                    return exchange.computeSecret(pubToBuffer(x, y))
                }
            }

            /***/
        },

        /***/ RGIU: /***/ function(module, exports, __webpack_require__) {
            const { randomBytes } = __webpack_require__('PJMN')

            const { createSecretKey } = __webpack_require__('1ALl')
            const { KEYLENGTHS } = __webpack_require__('N+nT')
            const Key = __webpack_require__('BBt9')

            module.exports = alg => {
                const keyLength = KEYLENGTHS.get(alg)

                if (!keyLength) {
                    return new Key({ type: 'secret' })
                }

                return new Key(createSecretKey(randomBytes(keyLength / 8)), {
                    use: 'enc',
                    alg
                })
            }

            /***/
        },

        /***/ RIp3: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var crypto = __webpack_require__('PJMN')

            /**
             * Exported function
             *
             * Options:
             *
             *  - `algorithm` hash algo to be used by this instance: *'sha1', 'md5'
             *  - `excludeValues` {true|*false} hash object keys, values ignored
             *  - `encoding` hash encoding, supports 'buffer', '*hex', 'binary', 'base64'
             *  - `ignoreUnknown` {true|*false} ignore unknown object types
             *  - `replacer` optional function that replaces values before hashing
             *  - `respectFunctionProperties` {*true|false} consider function properties when hashing
             *  - `respectFunctionNames` {*true|false} consider 'name' property of functions for hashing
             *  - `respectType` {*true|false} Respect special properties (prototype, constructor)
             *    when hashing to distinguish between types
             *  - `unorderedArrays` {true|*false} Sort all arrays before hashing
             *  - `unorderedSets` {*true|false} Sort `Set` and `Map` instances before hashing
             *  * = default
             *
             * @param {object} object value to hash
             * @param {object} options hashing options
             * @return {string} hash value
             * @api public
             */
            exports = module.exports = objectHash

            function objectHash(object, options) {
                options = applyDefaults(object, options)

                return hash(object, options)
            }

            /**
             * Exported sugar methods
             *
             * @param {object} object value to hash
             * @return {string} hash value
             * @api public
             */
            exports.sha1 = function(object) {
                return objectHash(object)
            }
            exports.keys = function(object) {
                return objectHash(object, {
                    excludeValues: true,
                    algorithm: 'sha1',
                    encoding: 'hex'
                })
            }
            exports.MD5 = function(object) {
                return objectHash(object, { algorithm: 'md5', encoding: 'hex' })
            }
            exports.keysMD5 = function(object) {
                return objectHash(object, {
                    algorithm: 'md5',
                    encoding: 'hex',
                    excludeValues: true
                })
            }

            // Internals
            var hashes = crypto.getHashes
                ? crypto.getHashes().slice()
                : ['sha1', 'md5']
            hashes.push('passthrough')
            var encodings = ['buffer', 'hex', 'binary', 'base64']

            function applyDefaults(object, sourceOptions) {
                sourceOptions = sourceOptions || {}

                // create a copy rather than mutating
                var options = {}
                options.algorithm = sourceOptions.algorithm || 'sha1'
                options.encoding = sourceOptions.encoding || 'hex'
                options.excludeValues = sourceOptions.excludeValues
                    ? true
                    : false
                options.algorithm = options.algorithm.toLowerCase()
                options.encoding = options.encoding.toLowerCase()
                options.ignoreUnknown =
                    sourceOptions.ignoreUnknown !== true ? false : true // default to false
                options.respectType =
                    sourceOptions.respectType === false ? false : true // default to true
                options.respectFunctionNames =
                    sourceOptions.respectFunctionNames === false ? false : true
                options.respectFunctionProperties =
                    sourceOptions.respectFunctionProperties === false
                        ? false
                        : true
                options.unorderedArrays =
                    sourceOptions.unorderedArrays !== true ? false : true // default to false
                options.unorderedSets =
                    sourceOptions.unorderedSets === false ? false : true // default to false
                options.unorderedObjects =
                    sourceOptions.unorderedObjects === false ? false : true // default to true
                options.replacer = sourceOptions.replacer || undefined
                options.excludeKeys = sourceOptions.excludeKeys || undefined

                if (typeof object === 'undefined') {
                    throw new Error('Object argument required.')
                }

                // if there is a case-insensitive match in the hashes list, accept it
                // (i.e. SHA256 for sha256)
                for (var i = 0; i < hashes.length; ++i) {
                    if (
                        hashes[i].toLowerCase() ===
                        options.algorithm.toLowerCase()
                    ) {
                        options.algorithm = hashes[i]
                    }
                }

                if (hashes.indexOf(options.algorithm) === -1) {
                    throw new Error(
                        'Algorithm "' +
                            options.algorithm +
                            '"  not supported. ' +
                            'supported values: ' +
                            hashes.join(', ')
                    )
                }

                if (
                    encodings.indexOf(options.encoding) === -1 &&
                    options.algorithm !== 'passthrough'
                ) {
                    throw new Error(
                        'Encoding "' +
                            options.encoding +
                            '"  not supported. ' +
                            'supported values: ' +
                            encodings.join(', ')
                    )
                }

                return options
            }

            /** Check if the given function is a native function */
            function isNativeFunction(f) {
                if (typeof f !== 'function') {
                    return false
                }
                var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i
                return exp.exec(Function.prototype.toString.call(f)) != null
            }

            function hash(object, options) {
                var hashingStream

                if (options.algorithm !== 'passthrough') {
                    hashingStream = crypto.createHash(options.algorithm)
                } else {
                    hashingStream = new PassThrough()
                }

                if (typeof hashingStream.write === 'undefined') {
                    hashingStream.write = hashingStream.update
                    hashingStream.end = hashingStream.update
                }

                var hasher = typeHasher(options, hashingStream)
                hasher.dispatch(object)
                if (!hashingStream.update) {
                    hashingStream.end('')
                }

                if (hashingStream.digest) {
                    return hashingStream.digest(
                        options.encoding === 'buffer'
                            ? undefined
                            : options.encoding
                    )
                }

                var buf = hashingStream.read()
                if (options.encoding === 'buffer') {
                    return buf
                }

                return buf.toString(options.encoding)
            }

            /**
             * Expose streaming API
             *
             * @param {object} object  Value to serialize
             * @param {object} options  Options, as for hash()
             * @param {object} stream  A stream to write the serializiation to
             * @api public
             */
            exports.writeToStream = function(object, options, stream) {
                if (typeof stream === 'undefined') {
                    stream = options
                    options = {}
                }

                options = applyDefaults(object, options)

                return typeHasher(options, stream).dispatch(object)
            }

            function typeHasher(options, writeTo, context) {
                context = context || []
                var write = function(str) {
                    if (writeTo.update) {
                        return writeTo.update(str, 'utf8')
                    } else {
                        return writeTo.write(str, 'utf8')
                    }
                }

                return {
                    dispatch: function(value) {
                        if (options.replacer) {
                            value = options.replacer(value)
                        }

                        var type = typeof value
                        if (value === null) {
                            type = 'null'
                        }

                        //console.log("[DEBUG] Dispatch: ", value, "->", type, " -> ", "_" + type);

                        return this['_' + type](value)
                    },
                    _object: function(object) {
                        var pattern = /\[object (.*)\]/i
                        var objString = Object.prototype.toString.call(object)
                        var objType = pattern.exec(objString)
                        if (!objType) {
                            // object type did not match [object ...]
                            objType = 'unknown:[' + objString + ']'
                        } else {
                            objType = objType[1] // take only the class name
                        }

                        objType = objType.toLowerCase()

                        var objectNumber = null

                        if ((objectNumber = context.indexOf(object)) >= 0) {
                            return this.dispatch(
                                '[CIRCULAR:' + objectNumber + ']'
                            )
                        } else {
                            context.push(object)
                        }

                        if (
                            typeof Buffer !== 'undefined' &&
                            Buffer.isBuffer &&
                            Buffer.isBuffer(object)
                        ) {
                            write('buffer:')
                            return write(object)
                        }

                        if (
                            objType !== 'object' &&
                            objType !== 'function' &&
                            objType !== 'asyncfunction'
                        ) {
                            if (this['_' + objType]) {
                                this['_' + objType](object)
                            } else if (options.ignoreUnknown) {
                                return write('[' + objType + ']')
                            } else {
                                throw new Error(
                                    'Unknown object type "' + objType + '"'
                                )
                            }
                        } else {
                            var keys = Object.keys(object)
                            if (options.unorderedObjects) {
                                keys = keys.sort()
                            }
                            // Make sure to incorporate special properties, so
                            // Types with different prototypes will produce
                            // a different hash and objects derived from
                            // different functions (`new Foo`, `new Bar`) will
                            // produce different hashes.
                            // We never do this for native functions since some
                            // seem to break because of that.
                            if (
                                options.respectType !== false &&
                                !isNativeFunction(object)
                            ) {
                                keys.splice(
                                    0,
                                    0,
                                    'prototype',
                                    '__proto__',
                                    'constructor'
                                )
                            }

                            if (options.excludeKeys) {
                                keys = keys.filter(function(key) {
                                    return !options.excludeKeys(key)
                                })
                            }

                            write('object:' + keys.length + ':')
                            var self = this
                            return keys.forEach(function(key) {
                                self.dispatch(key)
                                write(':')
                                if (!options.excludeValues) {
                                    self.dispatch(object[key])
                                }
                                write(',')
                            })
                        }
                    },
                    _array: function(arr, unordered) {
                        unordered =
                            typeof unordered !== 'undefined'
                                ? unordered
                                : options.unorderedArrays !== false // default to options.unorderedArrays

                        var self = this
                        write('array:' + arr.length + ':')
                        if (!unordered || arr.length <= 1) {
                            return arr.forEach(function(entry) {
                                return self.dispatch(entry)
                            })
                        }

                        // the unordered case is a little more complicated:
                        // since there is no canonical ordering on objects,
                        // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,
                        // we first serialize each entry using a PassThrough stream
                        // before sorting.
                        // also: we can’t use the same context array for all entries
                        // since the order of hashing should *not* matter. instead,
                        // we keep track of the additions to a copy of the context array
                        // and add all of them to the global context array when we’re done
                        var contextAdditions = []
                        var entries = arr.map(function(entry) {
                            var strm = new PassThrough()
                            var localContext = context.slice() // make copy
                            var hasher = typeHasher(options, strm, localContext)
                            hasher.dispatch(entry)
                            // take only what was added to localContext and append it to contextAdditions
                            contextAdditions = contextAdditions.concat(
                                localContext.slice(context.length)
                            )
                            return strm.read().toString()
                        })
                        context = context.concat(contextAdditions)
                        entries.sort()
                        return this._array(entries, false)
                    },
                    _date: function(date) {
                        return write('date:' + date.toJSON())
                    },
                    _symbol: function(sym) {
                        return write('symbol:' + sym.toString())
                    },
                    _error: function(err) {
                        return write('error:' + err.toString())
                    },
                    _boolean: function(bool) {
                        return write('bool:' + bool.toString())
                    },
                    _string: function(string) {
                        write('string:' + string.length + ':')
                        write(string.toString())
                    },
                    _function: function(fn) {
                        write('fn:')
                        if (isNativeFunction(fn)) {
                            this.dispatch('[native]')
                        } else {
                            this.dispatch(fn.toString())
                        }

                        if (options.respectFunctionNames !== false) {
                            // Make sure we can still distinguish native functions
                            // by their name, otherwise String and Function will
                            // have the same hash
                            this.dispatch('function-name:' + String(fn.name))
                        }

                        if (options.respectFunctionProperties) {
                            this._object(fn)
                        }
                    },
                    _number: function(number) {
                        return write('number:' + number.toString())
                    },
                    _xml: function(xml) {
                        return write('xml:' + xml.toString())
                    },
                    _null: function() {
                        return write('Null')
                    },
                    _undefined: function() {
                        return write('Undefined')
                    },
                    _regexp: function(regex) {
                        return write('regex:' + regex.toString())
                    },
                    _uint8array: function(arr) {
                        write('uint8array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _uint8clampedarray: function(arr) {
                        write('uint8clampedarray:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _int8array: function(arr) {
                        write('uint8array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _uint16array: function(arr) {
                        write('uint16array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _int16array: function(arr) {
                        write('uint16array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _uint32array: function(arr) {
                        write('uint32array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _int32array: function(arr) {
                        write('uint32array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _float32array: function(arr) {
                        write('float32array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _float64array: function(arr) {
                        write('float64array:')
                        return this.dispatch(Array.prototype.slice.call(arr))
                    },
                    _arraybuffer: function(arr) {
                        write('arraybuffer:')
                        return this.dispatch(new Uint8Array(arr))
                    },
                    _url: function(url) {
                        return write('url:' + url.toString(), 'utf8')
                    },
                    _map: function(map) {
                        write('map:')
                        var arr = Array.from(map)
                        return this._array(arr, options.unorderedSets !== false)
                    },
                    _set: function(set) {
                        write('set:')
                        var arr = Array.from(set)
                        return this._array(arr, options.unorderedSets !== false)
                    },
                    _blob: function() {
                        if (options.ignoreUnknown) {
                            return write('[blob]')
                        }

                        throw Error(
                            'Hashing Blob objects is currently not supported\n' +
                                '(see https://github.com/puleos/object-hash/issues/26)\n' +
                                'Use "options.replacer" or "options.ignoreUnknown"\n'
                        )
                    },
                    _domwindow: function() {
                        return write('domwindow')
                    },
                    /* Node.js standard native objects */
                    _process: function() {
                        return write('process')
                    },
                    _timer: function() {
                        return write('timer')
                    },
                    _pipe: function() {
                        return write('pipe')
                    },
                    _tcp: function() {
                        return write('tcp')
                    },
                    _udp: function() {
                        return write('udp')
                    },
                    _tty: function() {
                        return write('tty')
                    },
                    _statwatcher: function() {
                        return write('statwatcher')
                    },
                    _securecontext: function() {
                        return write('securecontext')
                    },
                    _connection: function() {
                        return write('connection')
                    },
                    _zlib: function() {
                        return write('zlib')
                    },
                    _context: function() {
                        return write('context')
                    },
                    _nodescript: function() {
                        return write('nodescript')
                    },
                    _httpparser: function() {
                        return write('httpparser')
                    },
                    _dataview: function() {
                        return write('dataview')
                    },
                    _signal: function() {
                        return write('signal')
                    },
                    _fsevent: function() {
                        return write('fsevent')
                    },
                    _tlswrap: function() {
                        return write('tlswrap')
                    }
                }
            }

            // Mini-implementation of stream.PassThrough
            // We are far from having need for the full implementation, and we can
            // make assumptions like "many writes, then only one final read"
            // and we can ignore encoding specifics
            function PassThrough() {
                return {
                    buf: '',

                    write: function(b) {
                        this.buf += b
                    },

                    end: function(b) {
                        this.buf += b
                    },

                    read: function() {
                        return this.buf
                    }
                }
            }

            /***/
        },

        /***/ 'RRc/': /***/ function(module, exports, __webpack_require__) {
            var forOf = __webpack_require__('oioR')

            module.exports = function(iter, ITERATOR) {
                var result = []
                forOf(iter, false, result.push, result, ITERATOR)
                return result
            }

            /***/
        },

        /***/ 'RU/L': /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('Rqdy')
            var $Object = __webpack_require__('WEpk').Object
            module.exports = function defineProperty(it, key, desc) {
                return $Object.defineProperty(it, key, desc)
            }

            /***/
        },

        /***/ RXbi: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = {
                applyToDefaults: __webpack_require__('Rsz9'),
                assert: __webpack_require__('GlC0'),
                Bench: __webpack_require__('rMgD'),
                block: __webpack_require__('RsAt'),
                clone: __webpack_require__('qnp3'),
                contain: __webpack_require__('781u'),
                deepEqual: __webpack_require__('Cl1u'),
                Error: __webpack_require__('Fow+'),
                escapeHeaderAttribute: __webpack_require__('GCLL'),
                escapeHtml: __webpack_require__('3Zki'),
                escapeJson: __webpack_require__('zCb7'),
                escapeRegex: __webpack_require__('zosA'),
                flatten: __webpack_require__('s8OG'),
                ignore: __webpack_require__('kl4A'),
                intersect: __webpack_require__('uWJx'),
                isPromise: __webpack_require__('hpEj'),
                merge: __webpack_require__('5ZhA'),
                once: __webpack_require__('i8G8'),
                reach: __webpack_require__('mmuM'),
                reachTemplate: __webpack_require__('Pxi6'),
                stringify: __webpack_require__('VraX'),
                wait: __webpack_require__('gAB1')
            }

            /***/
        },

        /***/ Ra3S: /***/ function(module, exports) {
            module.exports = function() {
                this.seq().obj(
                    this.key('version').int({ 0: 'two-prime', 1: 'multi' }),
                    this.key('n').int(),
                    this.key('e').int(),
                    this.key('d').int(),
                    this.key('p').int(),
                    this.key('q').int(),
                    this.key('dp').int(),
                    this.key('dq').int(),
                    this.key('qi').int()
                )
            }

            /***/
        },

        /***/ RfKB: /***/ function(module, exports, __webpack_require__) {
            var def = __webpack_require__('2faE').f
            var has = __webpack_require__('B+OT')
            var TAG = __webpack_require__('UWiX')('toStringTag')

            module.exports = function(it, tag, stat) {
                if (it && !has((it = stat ? it : it.prototype), TAG))
                    def(it, TAG, { configurable: true, value: tag })
            }

            /***/
        },

        /***/ 'Rn+g': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var createError = __webpack_require__('LYNF')

            /**
             * Resolve or reject a Promise based on response status.
             *
             * @param {Function} resolve A function that resolves the promise.
             * @param {Function} reject A function that rejects the promise.
             * @param {object} response The response.
             */
            module.exports = function settle(resolve, reject, response) {
                var validateStatus = response.config.validateStatus
                if (!validateStatus || validateStatus(response.status)) {
                    resolve(response)
                } else {
                    reject(
                        createError(
                            'Request failed with status code ' +
                                response.status,
                            response.config,
                            null,
                            response.request,
                            response
                        )
                    )
                }
            }

            /***/
        },

        /***/ RoCg: /***/ function(module, exports, __webpack_require__) {
            const {
                generateKeyPairSync,
                generateKeyPair: async
            } = __webpack_require__('PJMN')
            const { promisify } = __webpack_require__('jK02')

            const {
                THUMBPRINT_MATERIAL,
                JWK_MEMBERS,
                PUBLIC_MEMBERS,
                PRIVATE_MEMBERS,
                KEY_MANAGEMENT_DECRYPT,
                KEY_MANAGEMENT_ENCRYPT
            } = __webpack_require__('ehsS')
            const { keyObjectSupported } = __webpack_require__('pDDt')
            const { createPublicKey, createPrivateKey } = __webpack_require__(
                '1ALl'
            )

            const Key = __webpack_require__('//Cd')

            const generateKeyPair = promisify(async)

            const RSA_PUBLIC = new Set(['e', 'n'])
            Object.freeze(RSA_PUBLIC)
            const RSA_PRIVATE = new Set([
                ...RSA_PUBLIC,
                'd',
                'p',
                'q',
                'dp',
                'dq',
                'qi'
            ])
            Object.freeze(RSA_PRIVATE)

            // RSA Key Type
            class RSAKey extends Key {
                constructor(...args) {
                    super(...args)
                    this[JWK_MEMBERS]()
                    Object.defineProperties(this, {
                        kty: {
                            value: 'RSA',
                            enumerable: true
                        },
                        length: {
                            get() {
                                Object.defineProperty(this, 'length', {
                                    value:
                                        Buffer.byteLength(this.n, 'base64') * 8,
                                    configurable: false
                                })

                                return this.length
                            },
                            configurable: true
                        }
                    })
                }

                static get [PUBLIC_MEMBERS]() {
                    return RSA_PUBLIC
                }

                static get [PRIVATE_MEMBERS]() {
                    return RSA_PRIVATE
                }

                // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special
                // JSON.stringify handling in V8
                [THUMBPRINT_MATERIAL]() {
                    return { e: this.e, kty: 'RSA', n: this.n }
                }

                [KEY_MANAGEMENT_ENCRYPT]() {
                    return this.algorithms('wrapKey')
                }

                [KEY_MANAGEMENT_DECRYPT]() {
                    return this.algorithms('unwrapKey')
                }

                static async generate(len = 2048, privat = true) {
                    if (
                        !Number.isSafeInteger(len) ||
                        len < 512 ||
                        len % 8 !== 0 ||
                        ('electron' in process.versions && len % 128 !== 0)
                    ) {
                        throw new TypeError('invalid bit length')
                    }

                    let privateKey, publicKey

                    if (keyObjectSupported) {
                        ;({
                            privateKey,
                            publicKey
                        } = await generateKeyPair('rsa', {
                            modulusLength: len
                        }))
                        return privat ? privateKey : publicKey
                    }

                    ;({ privateKey, publicKey } = await generateKeyPair('rsa', {
                        modulusLength: len,
                        publicKeyEncoding: { type: 'spki', format: 'pem' },
                        privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
                    }))

                    if (privat) {
                        return createPrivateKey(privateKey)
                    } else {
                        return createPublicKey(publicKey)
                    }
                }

                static generateSync(len = 2048, privat = true) {
                    if (
                        !Number.isSafeInteger(len) ||
                        len < 512 ||
                        len % 8 !== 0 ||
                        ('electron' in process.versions && len % 128 !== 0)
                    ) {
                        throw new TypeError('invalid bit length')
                    }

                    let privateKey, publicKey

                    if (keyObjectSupported) {
                        ;({ privateKey, publicKey } = generateKeyPairSync(
                            'rsa',
                            { modulusLength: len }
                        ))
                        return privat ? privateKey : publicKey
                    }

                    ;({ privateKey, publicKey } = generateKeyPairSync('rsa', {
                        modulusLength: len,
                        publicKeyEncoding: { type: 'spki', format: 'pem' },
                        privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
                    }))

                    if (privat) {
                        return createPrivateKey(privateKey)
                    } else {
                        return createPublicKey(publicKey)
                    }
                }
            }

            module.exports = RSAKey

            /***/
        },

        /***/ Rqdy: /***/ function(module, exports, __webpack_require__) {
            var $export = __webpack_require__('Y7ZC')
            // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
            $export(
                $export.S + $export.F * !__webpack_require__('jmDH'),
                'Object',
                { defineProperty: __webpack_require__('2faE').f }
            )

            /***/
        },

        /***/ RsAt: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Ignore = __webpack_require__('kl4A')

            const internals = {}

            module.exports = function() {
                return new Promise(Ignore) // $lab:coverage:ignore$
            }

            /***/
        },

        /***/ Rsz9: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Assert = __webpack_require__('GlC0')
            const Clone = __webpack_require__('qnp3')
            const Merge = __webpack_require__('5ZhA')
            const Utils = __webpack_require__('O0PD')

            const internals = {}

            module.exports = function(defaults, source, options = {}) {
                Assert(
                    defaults && typeof defaults === 'object',
                    'Invalid defaults value: must be an object'
                )
                Assert(
                    !source || source === true || typeof source === 'object',
                    'Invalid source value: must be true, falsy or an object'
                )
                Assert(
                    typeof options === 'object',
                    'Invalid options: must be an object'
                )

                if (!source) {
                    // If no source, return null
                    return null
                }

                if (options.shallow) {
                    return internals.applyToDefaultsWithShallow(
                        defaults,
                        source,
                        options
                    )
                }

                const copy = Clone(defaults)

                if (source === true) {
                    // If source is set to true, use defaults
                    return copy
                }

                const nullOverride =
                    options.nullOverride !== undefined
                        ? options.nullOverride
                        : false
                return Merge(copy, source, { nullOverride, mergeArrays: false })
            }

            internals.applyToDefaultsWithShallow = function(
                defaults,
                source,
                options
            ) {
                const keys = options.shallow
                Assert(Array.isArray(keys), 'Invalid keys')

                options = Object.assign({}, options)
                options.shallow = false

                const copy = Clone(defaults, { shallow: keys })

                if (source === true) {
                    // If source is set to true, use defaults
                    return copy
                }

                const storage = Utils.store(source, keys) // Move shallow copy items to storage
                Merge(copy, source, { mergeArrays: false, nullOverride: false }) // Deep copy the rest
                Utils.restore(copy, source, storage) // Shallow copy the stored items and restore
                return copy
            }

            /***/
        },

        /***/ S6im: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = (string, count = 1, options) => {
                options = {
                    indent: ' ',
                    includeEmptyLines: false,
                    ...options
                }

                if (typeof string !== 'string') {
                    throw new TypeError(
                        `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
                    )
                }

                if (typeof count !== 'number') {
                    throw new TypeError(
                        `Expected \`count\` to be a \`number\`, got \`${typeof count}\``
                    )
                }

                if (typeof options.indent !== 'string') {
                    throw new TypeError(
                        `Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``
                    )
                }

                if (count === 0) {
                    return string
                }

                const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm

                return string.replace(regex, options.indent.repeat(count))
            }

            /***/
        },

        /***/ SBuE: /***/ function(module, exports) {
            module.exports = {}

            /***/
        },

        /***/ SevZ: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            exports.__esModule = true
            exports['default'] = void 0

            var _stringHash = _interopRequireDefault(
                __webpack_require__('9kyW')
            )

            var _stylesheet = _interopRequireDefault(
                __webpack_require__('bVZc')
            )

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj }
            }

            var sanitize = function sanitize(rule) {
                return rule.replace(/\/style/gi, '\\/style')
            }

            var StyleSheetRegistry =
                /*#__PURE__*/
                (function() {
                    function StyleSheetRegistry(_temp) {
                        var _ref = _temp === void 0 ? {} : _temp,
                            _ref$styleSheet = _ref.styleSheet,
                            styleSheet =
                                _ref$styleSheet === void 0
                                    ? null
                                    : _ref$styleSheet,
                            _ref$optimizeForSpeed = _ref.optimizeForSpeed,
                            optimizeForSpeed =
                                _ref$optimizeForSpeed === void 0
                                    ? false
                                    : _ref$optimizeForSpeed,
                            _ref$isBrowser = _ref.isBrowser,
                            isBrowser =
                                _ref$isBrowser === void 0
                                    ? typeof window !== 'undefined'
                                    : _ref$isBrowser

                        this._sheet =
                            styleSheet ||
                            new _stylesheet['default']({
                                name: 'styled-jsx',
                                optimizeForSpeed: optimizeForSpeed
                            })

                        this._sheet.inject()

                        if (
                            styleSheet &&
                            typeof optimizeForSpeed === 'boolean'
                        ) {
                            this._sheet.setOptimizeForSpeed(optimizeForSpeed)

                            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed()
                        }

                        this._isBrowser = isBrowser
                        this._fromServer = undefined
                        this._indices = {}
                        this._instancesCounts = {}
                        this.computeId = this.createComputeId()
                        this.computeSelector = this.createComputeSelector()
                    }

                    var _proto = StyleSheetRegistry.prototype

                    _proto.add = function add(props) {
                        var _this = this

                        if (undefined === this._optimizeForSpeed) {
                            this._optimizeForSpeed = Array.isArray(
                                props.children
                            )

                            this._sheet.setOptimizeForSpeed(
                                this._optimizeForSpeed
                            )

                            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed()
                        }

                        if (this._isBrowser && !this._fromServer) {
                            this._fromServer = this.selectFromServer()
                            this._instancesCounts = Object.keys(
                                this._fromServer
                            ).reduce(function(acc, tagName) {
                                acc[tagName] = 0
                                return acc
                            }, {})
                        }

                        var _this$getIdAndRules = this.getIdAndRules(props),
                            styleId = _this$getIdAndRules.styleId,
                            rules = _this$getIdAndRules.rules // Deduping: just increase the instances count.

                        if (styleId in this._instancesCounts) {
                            this._instancesCounts[styleId] += 1
                            return
                        }

                        var indices = rules
                            .map(function(rule) {
                                return _this._sheet.insertRule(rule)
                            }) // Filter out invalid rules
                            .filter(function(index) {
                                return index !== -1
                            })
                        this._indices[styleId] = indices
                        this._instancesCounts[styleId] = 1
                    }

                    _proto.remove = function remove(props) {
                        var _this2 = this

                        var _this$getIdAndRules2 = this.getIdAndRules(props),
                            styleId = _this$getIdAndRules2.styleId

                        invariant(
                            styleId in this._instancesCounts,
                            'styleId: `' + styleId + '` not found'
                        )
                        this._instancesCounts[styleId] -= 1

                        if (this._instancesCounts[styleId] < 1) {
                            var tagFromServer =
                                this._fromServer && this._fromServer[styleId]

                            if (tagFromServer) {
                                tagFromServer.parentNode.removeChild(
                                    tagFromServer
                                )
                                delete this._fromServer[styleId]
                            } else {
                                this._indices[styleId].forEach(function(index) {
                                    return _this2._sheet.deleteRule(index)
                                })

                                delete this._indices[styleId]
                            }

                            delete this._instancesCounts[styleId]
                        }
                    }

                    _proto.update = function update(props, nextProps) {
                        this.add(nextProps)
                        this.remove(props)
                    }

                    _proto.flush = function flush() {
                        this._sheet.flush()

                        this._sheet.inject()

                        this._fromServer = undefined
                        this._indices = {}
                        this._instancesCounts = {}
                        this.computeId = this.createComputeId()
                        this.computeSelector = this.createComputeSelector()
                    }

                    _proto.cssRules = function cssRules() {
                        var _this3 = this

                        var fromServer = this._fromServer
                            ? Object.keys(this._fromServer).map(function(
                                  styleId
                              ) {
                                  return [styleId, _this3._fromServer[styleId]]
                              })
                            : []

                        var cssRules = this._sheet.cssRules()

                        return fromServer.concat(
                            Object.keys(this._indices)
                                .map(function(styleId) {
                                    return [
                                        styleId,
                                        _this3._indices[styleId]
                                            .map(function(index) {
                                                return cssRules[index].cssText
                                            })
                                            .join(
                                                _this3._optimizeForSpeed
                                                    ? ''
                                                    : '\n'
                                            )
                                    ]
                                }) // filter out empty rules
                                .filter(function(rule) {
                                    return Boolean(rule[1])
                                })
                        )
                    }
                    /**
                     * createComputeId
                     *
                     * Creates a function to compute and memoize a jsx id from a basedId and optionally props.
                     */

                    _proto.createComputeId = function createComputeId() {
                        var cache = {}
                        return function(baseId, props) {
                            if (!props) {
                                return 'jsx-' + baseId
                            }

                            var propsToString = String(props)
                            var key = baseId + propsToString // return `jsx-${hashString(`${baseId}-${propsToString}`)}`

                            if (!cache[key]) {
                                cache[key] =
                                    'jsx-' +
                                    (0, _stringHash['default'])(
                                        baseId + '-' + propsToString
                                    )
                            }

                            return cache[key]
                        }
                    }
                    /**
                     * createComputeSelector
                     *
                     * Creates a function to compute and memoize dynamic selectors.
                     */

                    _proto.createComputeSelector = function createComputeSelector(
                        selectoPlaceholderRegexp
                    ) {
                        if (selectoPlaceholderRegexp === void 0) {
                            selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g
                        }

                        var cache = {}
                        return function(id, css) {
                            // Sanitize SSR-ed CSS.
                            // Client side code doesn't need to be sanitized since we use
                            // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).
                            if (!this._isBrowser) {
                                css = sanitize(css)
                            }

                            var idcss = id + css

                            if (!cache[idcss]) {
                                cache[idcss] = css.replace(
                                    selectoPlaceholderRegexp,
                                    id
                                )
                            }

                            return cache[idcss]
                        }
                    }

                    _proto.getIdAndRules = function getIdAndRules(props) {
                        var _this4 = this

                        var css = props.children,
                            dynamic = props.dynamic,
                            id = props.id

                        if (dynamic) {
                            var styleId = this.computeId(id, dynamic)
                            return {
                                styleId: styleId,
                                rules: Array.isArray(css)
                                    ? css.map(function(rule) {
                                          return _this4.computeSelector(
                                              styleId,
                                              rule
                                          )
                                      })
                                    : [this.computeSelector(styleId, css)]
                            }
                        }

                        return {
                            styleId: this.computeId(id),
                            rules: Array.isArray(css) ? css : [css]
                        }
                    }
                    /**
                     * selectFromServer
                     *
                     * Collects style tags from the document with id __jsx-XXX
                     */

                    _proto.selectFromServer = function selectFromServer() {
                        var elements = Array.prototype.slice.call(
                            document.querySelectorAll('[id^="__jsx-"]')
                        )
                        return elements.reduce(function(acc, element) {
                            var id = element.id.slice(2)
                            acc[id] = element
                            return acc
                        }, {})
                    }

                    return StyleSheetRegistry
                })()

            exports['default'] = StyleSheetRegistry

            function invariant(condition, message) {
                if (!condition) {
                    throw new Error('StyleSheetRegistry: ' + message + '.')
                }
            }

            /***/
        },

        /***/ SfRM: /***/ function(module, exports, __webpack_require__) {
            var nativeCreate = __webpack_require__('YESw')

            /**
             * Removes all key-value entries from the hash.
             *
             * @private
             * @name clear
             * @memberOf Hash
             */
            function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {}
                this.size = 0
            }

            module.exports = hashClear

            /***/
        },

        /***/ SgzI: /***/ function(module) {
            module.exports = JSON.parse(
                '{"name":"axios","version":"0.19.2","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test && bundlesize","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://github.com/axios/axios","devDependencies":{"bundlesize":"^0.17.0","coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.0.2","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^20.1.0","grunt-karma":"^2.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^1.0.18","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^1.3.0","karma-chrome-launcher":"^2.2.0","karma-coverage":"^1.1.1","karma-firefox-launcher":"^1.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-opera-launcher":"^1.0.0","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^1.2.0","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.7","karma-webpack":"^1.7.0","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^5.2.0","sinon":"^4.5.0","typescript":"^2.8.1","url-search-params":"^0.10.0","webpack":"^1.13.1","webpack-dev-server":"^1.14.1"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"typings":"./index.d.ts","dependencies":{"follow-redirects":"1.5.10"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}'
            )

            /***/
        },

        /***/ SntB: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')

            /**
             * Config-specific merge-function which creates a new config-object
             * by merging two configuration objects together.
             *
             * @param {Object} config1
             * @param {Object} config2
             * @returns {Object} New object resulting from merging config2 to config1
             */
            module.exports = function mergeConfig(config1, config2) {
                // eslint-disable-next-line no-param-reassign
                config2 = config2 || {}
                var config = {}

                var valueFromConfig2Keys = ['url', 'method', 'params', 'data']
                var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy']
                var defaultToConfig2Keys = [
                    'baseURL',
                    'url',
                    'transformRequest',
                    'transformResponse',
                    'paramsSerializer',
                    'timeout',
                    'withCredentials',
                    'adapter',
                    'responseType',
                    'xsrfCookieName',
                    'xsrfHeaderName',
                    'onUploadProgress',
                    'onDownloadProgress',
                    'maxContentLength',
                    'validateStatus',
                    'maxRedirects',
                    'httpAgent',
                    'httpsAgent',
                    'cancelToken',
                    'socketPath'
                ]

                utils.forEach(valueFromConfig2Keys, function valueFromConfig2(
                    prop
                ) {
                    if (typeof config2[prop] !== 'undefined') {
                        config[prop] = config2[prop]
                    }
                })

                utils.forEach(
                    mergeDeepPropertiesKeys,
                    function mergeDeepProperties(prop) {
                        if (utils.isObject(config2[prop])) {
                            config[prop] = utils.deepMerge(
                                config1[prop],
                                config2[prop]
                            )
                        } else if (typeof config2[prop] !== 'undefined') {
                            config[prop] = config2[prop]
                        } else if (utils.isObject(config1[prop])) {
                            config[prop] = utils.deepMerge(config1[prop])
                        } else if (typeof config1[prop] !== 'undefined') {
                            config[prop] = config1[prop]
                        }
                    }
                )

                utils.forEach(defaultToConfig2Keys, function defaultToConfig2(
                    prop
                ) {
                    if (typeof config2[prop] !== 'undefined') {
                        config[prop] = config2[prop]
                    } else if (typeof config1[prop] !== 'undefined') {
                        config[prop] = config1[prop]
                    }
                })

                var axiosKeys = valueFromConfig2Keys
                    .concat(mergeDeepPropertiesKeys)
                    .concat(defaultToConfig2Keys)

                var otherKeys = Object.keys(config2).filter(
                    function filterAxiosKeys(key) {
                        return axiosKeys.indexOf(key) === -1
                    }
                )

                utils.forEach(otherKeys, function otherKeysDefaultToConfig2(
                    prop
                ) {
                    if (typeof config2[prop] !== 'undefined') {
                        config[prop] = config2[prop]
                    } else if (typeof config1[prop] !== 'undefined') {
                        config[prop] = config1[prop]
                    }
                })

                return config
            }

            /***/
        },

        /***/ SqZg: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('3GJH')

            /***/
        },

        /***/ SwXk: /***/ function(module, exports, __webpack_require__) {
            const isObject = __webpack_require__('kF1/')
            let validateCrit = __webpack_require__('urXW')
            const { JWSInvalid } = __webpack_require__('yt7c')

            validateCrit = validateCrit.bind(undefined, JWSInvalid)

            const compactSerializer = (payload, [recipient]) => {
                return `${recipient.protected}.${payload}.${recipient.signature}`
            }
            compactSerializer.validate = (
                jws,
                { 0: { unprotectedHeader, protectedHeader }, length }
            ) => {
                if (length !== 1 || unprotectedHeader) {
                    throw new JWSInvalid(
                        "JWS Compact Serialization doesn't support multiple recipients or JWS unprotected headers"
                    )
                }
                validateCrit(
                    protectedHeader,
                    unprotectedHeader,
                    protectedHeader ? protectedHeader.crit : undefined
                )
            }

            const flattenedSerializer = (payload, [recipient]) => {
                const { header, signature, protected: prot } = recipient

                return {
                    payload,
                    ...(prot ? { protected: prot } : undefined),
                    ...(header ? { header } : undefined),
                    signature
                }
            }
            flattenedSerializer.validate = (
                jws,
                { 0: { unprotectedHeader, protectedHeader }, length }
            ) => {
                if (length !== 1) {
                    throw new JWSInvalid(
                        "Flattened JWS JSON Serialization doesn't support multiple recipients"
                    )
                }
                validateCrit(
                    protectedHeader,
                    unprotectedHeader,
                    protectedHeader ? protectedHeader.crit : undefined
                )
            }

            const generalSerializer = (payload, recipients) => {
                return {
                    payload,
                    signatures: recipients.map(
                        ({ header, signature, protected: prot }) => {
                            return {
                                ...(prot ? { protected: prot } : undefined),
                                ...(header ? { header } : undefined),
                                signature
                            }
                        }
                    )
                }
            }
            generalSerializer.validate = (jws, recipients) => {
                recipients.forEach(({ protectedHeader, unprotectedHeader }) => {
                    validateCrit(
                        protectedHeader,
                        unprotectedHeader,
                        protectedHeader ? protectedHeader.crit : undefined
                    )
                })
            }

            const isJSON = input => {
                return (
                    isObject(input) &&
                    (typeof input.payload === 'string' ||
                        Buffer.isBuffer(input.payload))
                )
            }

            const isValidRecipient = recipient => {
                return (
                    isObject(recipient) &&
                    typeof recipient.signature === 'string' &&
                    (recipient.header === undefined ||
                        isObject(recipient.header)) &&
                    (recipient.protected === undefined ||
                        typeof recipient.protected === 'string')
                )
            }

            const isMultiRecipient = input => {
                if (
                    Array.isArray(input.signatures) &&
                    input.signatures.every(isValidRecipient)
                ) {
                    return true
                }

                return false
            }

            const detect = input => {
                if (
                    typeof input === 'string' &&
                    input.split('.').length === 3
                ) {
                    return 'compact'
                }

                if (isJSON(input)) {
                    if (isMultiRecipient(input)) {
                        return 'general'
                    }

                    if (isValidRecipient(input)) {
                        return 'flattened'
                    }
                }

                throw new JWSInvalid('JWS malformed or invalid serialization')
            }

            module.exports = {
                compact: compactSerializer,
                flattened: flattenedSerializer,
                general: generalSerializer,
                detect
            }

            /***/
        },

        /***/ T1AV: /***/ function(module, exports, __webpack_require__) {
            var assignMergeValue = __webpack_require__('t2Dn'),
                cloneBuffer = __webpack_require__('5Tg0'),
                cloneTypedArray = __webpack_require__('yP5f'),
                copyArray = __webpack_require__('Q1l4'),
                initCloneObject = __webpack_require__('+iFO'),
                isArguments = __webpack_require__('03A+'),
                isArray = __webpack_require__('Z0cm'),
                isArrayLikeObject = __webpack_require__('3L66'),
                isBuffer = __webpack_require__('DSRE'),
                isFunction = __webpack_require__('lSCD'),
                isObject = __webpack_require__('GoyQ'),
                isPlainObject = __webpack_require__('YO3V'),
                isTypedArray = __webpack_require__('c6wG'),
                safeGet = __webpack_require__('itsj'),
                toPlainObject = __webpack_require__('jeLo')

            /**
             * A specialized version of `baseMerge` for arrays and objects which performs
             * deep merges and tracks traversed objects enabling objects with circular
             * references to be merged.
             *
             * @private
             * @param {Object} object The destination object.
             * @param {Object} source The source object.
             * @param {string} key The key of the value to merge.
             * @param {number} srcIndex The index of `source`.
             * @param {Function} mergeFunc The function to merge values.
             * @param {Function} [customizer] The function to customize assigned values.
             * @param {Object} [stack] Tracks traversed source values and their merged
             *  counterparts.
             */
            function baseMergeDeep(
                object,
                source,
                key,
                srcIndex,
                mergeFunc,
                customizer,
                stack
            ) {
                var objValue = safeGet(object, key),
                    srcValue = safeGet(source, key),
                    stacked = stack.get(srcValue)

                if (stacked) {
                    assignMergeValue(object, key, stacked)
                    return
                }
                var newValue = customizer
                    ? customizer(
                          objValue,
                          srcValue,
                          key + '',
                          object,
                          source,
                          stack
                      )
                    : undefined

                var isCommon = newValue === undefined

                if (isCommon) {
                    var isArr = isArray(srcValue),
                        isBuff = !isArr && isBuffer(srcValue),
                        isTyped = !isArr && !isBuff && isTypedArray(srcValue)

                    newValue = srcValue
                    if (isArr || isBuff || isTyped) {
                        if (isArray(objValue)) {
                            newValue = objValue
                        } else if (isArrayLikeObject(objValue)) {
                            newValue = copyArray(objValue)
                        } else if (isBuff) {
                            isCommon = false
                            newValue = cloneBuffer(srcValue, true)
                        } else if (isTyped) {
                            isCommon = false
                            newValue = cloneTypedArray(srcValue, true)
                        } else {
                            newValue = []
                        }
                    } else if (
                        isPlainObject(srcValue) ||
                        isArguments(srcValue)
                    ) {
                        newValue = objValue
                        if (isArguments(objValue)) {
                            newValue = toPlainObject(objValue)
                        } else if (
                            !isObject(objValue) ||
                            isFunction(objValue)
                        ) {
                            newValue = initCloneObject(srcValue)
                        }
                    } else {
                        isCommon = false
                    }
                }
                if (isCommon) {
                    // Recursively merge objects and arrays (susceptible to call stack limits).
                    stack.set(srcValue, newValue)
                    mergeFunc(newValue, srcValue, srcIndex, customizer, stack)
                    stack['delete'](srcValue)
                }
                assignMergeValue(object, key, newValue)
            }

            module.exports = baseMergeDeep

            /***/
        },

        /***/ TJWN: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var global = __webpack_require__('5T2Y')
            var core = __webpack_require__('WEpk')
            var dP = __webpack_require__('2faE')
            var DESCRIPTORS = __webpack_require__('jmDH')
            var SPECIES = __webpack_require__('UWiX')('species')

            module.exports = function(KEY) {
                var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY]
                if (DESCRIPTORS && C && !C[SPECIES])
                    dP.f(C, SPECIES, {
                        configurable: true,
                        get: function() {
                            return this
                        }
                    })
            }

            /***/
        },

        /***/ TJm8: /***/ function(module, exports) {
            const OIDC_DISCOVERY = '/.well-known/openid-configuration'
            const OAUTH2_DISCOVERY = '/.well-known/oauth-authorization-server'
            const WEBFINGER = '/.well-known/webfinger'
            const REL = 'http://openid.net/specs/connect/1.0/issuer'
            const AAD_MULTITENANT_DISCOVERY = new Set([
                `https://login.microsoftonline.com/common/v2.0${OIDC_DISCOVERY}`,
                `https://login.microsoftonline.com/organizations/v2.0${OIDC_DISCOVERY}`,
                `https://login.microsoftonline.com/consumers/v2.0${OIDC_DISCOVERY}`
            ])

            const CLIENT_DEFAULTS = {
                grant_types: ['authorization_code'],
                id_token_signed_response_alg: 'RS256',
                authorization_signed_response_alg: 'RS256',
                response_types: ['code'],
                token_endpoint_auth_method: 'client_secret_basic'
            }

            const ISSUER_DEFAULTS = {
                claim_types_supported: ['normal'],
                claims_parameter_supported: false,
                grant_types_supported: ['authorization_code', 'implicit'],
                request_parameter_supported: false,
                request_uri_parameter_supported: true,
                require_request_uri_registration: false,
                response_modes_supported: ['query', 'fragment'],
                token_endpoint_auth_methods_supported: ['client_secret_basic']
            }

            const CALLBACK_PROPERTIES = [
                'access_token', // 6749
                'code', // 6749
                'error', // 6749
                'error_description', // 6749
                'error_uri', // 6749
                'expires_in', // 6749
                'id_token', // Core 1.0
                'state', // 6749
                'token_type', // 6749
                'session_state', // Session Management
                'response' // JARM
            ]

            const JWT_CONTENT = /^application\/jwt/

            const HTTP_OPTIONS = Symbol('openid-client.custom.http-options')
            const CLOCK_TOLERANCE = Symbol(
                'openid-client.custom.clock-tolerance'
            )

            module.exports = {
                AAD_MULTITENANT_DISCOVERY,
                CALLBACK_PROPERTIES,
                CLIENT_DEFAULTS,
                CLOCK_TOLERANCE,
                HTTP_OPTIONS,
                ISSUER_DEFAULTS,
                JWT_CONTENT,
                OAUTH2_DISCOVERY,
                OIDC_DISCOVERY,
                REL,
                WEBFINGER
            }

            /***/
        },

        /***/ Tqu4: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = (url, opts) => {
                if (typeof url !== 'string') {
                    throw new TypeError(
                        `Expected \`url\` to be of type \`string\`, got \`${typeof url}\``
                    )
                }

                url = url.trim()
                opts = Object.assign({ https: false }, opts)

                if (/^\.*\/|^(?!localhost)\w+:/.test(url)) {
                    return url
                }

                return url.replace(
                    /^(?!(?:\w+:)?\/\/)/,
                    opts.https ? 'https://' : 'http://'
                )
            }

            /***/
        },

        /***/ TuGD: /***/ function(module, exports, __webpack_require__) {
            var ITERATOR = __webpack_require__('UWiX')('iterator')
            var SAFE_CLOSING = false

            try {
                var riter = [7][ITERATOR]()
                riter['return'] = function() {
                    SAFE_CLOSING = true
                }
                // eslint-disable-next-line no-throw-literal
                Array.from(riter, function() {
                    throw 2
                })
            } catch (e) {
                /* empty */
            }

            module.exports = function(exec, skipClosing) {
                if (!skipClosing && !SAFE_CLOSING) return false
                var safe = false
                try {
                    var arr = [7]
                    var iter = arr[ITERATOR]()
                    iter.next = function() {
                        return { done: (safe = true) }
                    }
                    arr[ITERATOR] = function() {
                        return iter
                    }
                    exec(arr)
                } catch (e) {
                    /* empty */
                }
                return safe
            }

            /***/
        },

        /***/ 'U+KD': /***/ function(module, exports, __webpack_require__) {
            // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
            var has = __webpack_require__('B+OT')
            var toObject = __webpack_require__('JB68')
            var IE_PROTO = __webpack_require__('VVlx')('IE_PROTO')
            var ObjectProto = Object.prototype

            module.exports =
                Object.getPrototypeOf ||
                function(O) {
                    O = toObject(O)
                    if (has(O, IE_PROTO)) return O[IE_PROTO]
                    if (
                        typeof O.constructor == 'function' &&
                        O instanceof O.constructor
                    ) {
                        return O.constructor.prototype
                    }
                    return O instanceof Object ? ObjectProto : null
                }

            /***/
        },

        /***/ U064: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var stream = __webpack_require__('msIP')

            function DuplexWrapper(options, writable, readable) {
                if (typeof readable === 'undefined') {
                    readable = writable
                    writable = options
                    options = null
                }

                stream.Duplex.call(this, options)

                if (typeof readable.read !== 'function') {
                    readable = new stream.Readable(options).wrap(readable)
                }

                this._writable = writable
                this._readable = readable
                this._waiting = false

                var self = this

                writable.once('finish', function() {
                    self.end()
                })

                this.once('finish', function() {
                    writable.end()
                })

                readable.on('readable', function() {
                    if (self._waiting) {
                        self._waiting = false
                        self._read()
                    }
                })

                readable.once('end', function() {
                    self.push(null)
                })

                if (
                    !options ||
                    typeof options.bubbleErrors === 'undefined' ||
                    options.bubbleErrors
                ) {
                    writable.on('error', function(err) {
                        self.emit('error', err)
                    })

                    readable.on('error', function(err) {
                        self.emit('error', err)
                    })
                }
            }

            DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {
                constructor: { value: DuplexWrapper }
            })

            DuplexWrapper.prototype._write = function _write(
                input,
                encoding,
                done
            ) {
                this._writable.write(input, encoding, done)
            }

            DuplexWrapper.prototype._read = function _read() {
                var buf
                var reads = 0
                while ((buf = this._readable.read()) !== null) {
                    this.push(buf)
                    reads++
                }
                if (reads === 0) {
                    this._waiting = true
                }
            }

            module.exports = function duplex2(options, writable, readable) {
                return new DuplexWrapper(options, writable, readable)
            }

            module.exports.DuplexWrapper = DuplexWrapper

            /***/
        },

        /***/ U3sn: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Hoek = __webpack_require__('RXbi')

            const internals = {
                codes: new Map([
                    [100, 'Continue'],
                    [101, 'Switching Protocols'],
                    [102, 'Processing'],
                    [200, 'OK'],
                    [201, 'Created'],
                    [202, 'Accepted'],
                    [203, 'Non-Authoritative Information'],
                    [204, 'No Content'],
                    [205, 'Reset Content'],
                    [206, 'Partial Content'],
                    [207, 'Multi-Status'],
                    [300, 'Multiple Choices'],
                    [301, 'Moved Permanently'],
                    [302, 'Moved Temporarily'],
                    [303, 'See Other'],
                    [304, 'Not Modified'],
                    [305, 'Use Proxy'],
                    [307, 'Temporary Redirect'],
                    [400, 'Bad Request'],
                    [401, 'Unauthorized'],
                    [402, 'Payment Required'],
                    [403, 'Forbidden'],
                    [404, 'Not Found'],
                    [405, 'Method Not Allowed'],
                    [406, 'Not Acceptable'],
                    [407, 'Proxy Authentication Required'],
                    [408, 'Request Time-out'],
                    [409, 'Conflict'],
                    [410, 'Gone'],
                    [411, 'Length Required'],
                    [412, 'Precondition Failed'],
                    [413, 'Request Entity Too Large'],
                    [414, 'Request-URI Too Large'],
                    [415, 'Unsupported Media Type'],
                    [416, 'Requested Range Not Satisfiable'],
                    [417, 'Expectation Failed'],
                    [418, "I'm a teapot"],
                    [422, 'Unprocessable Entity'],
                    [423, 'Locked'],
                    [424, 'Failed Dependency'],
                    [425, 'Unordered Collection'],
                    [426, 'Upgrade Required'],
                    [428, 'Precondition Required'],
                    [429, 'Too Many Requests'],
                    [431, 'Request Header Fields Too Large'],
                    [451, 'Unavailable For Legal Reasons'],
                    [500, 'Internal Server Error'],
                    [501, 'Not Implemented'],
                    [502, 'Bad Gateway'],
                    [503, 'Service Unavailable'],
                    [504, 'Gateway Time-out'],
                    [505, 'HTTP Version Not Supported'],
                    [506, 'Variant Also Negotiates'],
                    [507, 'Insufficient Storage'],
                    [509, 'Bandwidth Limit Exceeded'],
                    [510, 'Not Extended'],
                    [511, 'Network Authentication Required']
                ])
            }

            module.exports = internals.Boom = class extends Error {
                constructor(message, options = {}) {
                    if (message instanceof Error) {
                        return internals.Boom.boomify(
                            Hoek.clone(message),
                            options
                        )
                    }

                    const {
                        statusCode = 500,
                        data = null,
                        ctor = internals.Boom
                    } = options
                    const error = new Error(message ? message : undefined) // Avoids settings null message
                    Error.captureStackTrace(error, ctor) // Filter the stack to our external API
                    error.data = data
                    const boom = internals.initialize(error, statusCode)

                    Object.defineProperty(boom, 'typeof', { value: ctor })

                    if (options.decorate) {
                        Object.assign(boom, options.decorate)
                    }

                    return boom
                }

                static [Symbol.hasInstance](instance) {
                    return internals.Boom.isBoom(instance)
                }

                static isBoom(err) {
                    return err instanceof Error && !!err.isBoom
                }

                static boomify(err, options) {
                    Hoek.assert(
                        err instanceof Error,
                        'Cannot wrap non-Error object'
                    )

                    options = options || {}

                    if (options.data !== undefined) {
                        err.data = options.data
                    }

                    if (options.decorate) {
                        Object.assign(err, options.decorate)
                    }

                    if (!err.isBoom) {
                        return internals.initialize(
                            err,
                            options.statusCode || 500,
                            options.message
                        )
                    }

                    if (
                        options.override === false || // Defaults to true
                        (!options.statusCode && !options.message)
                    ) {
                        return err
                    }

                    return internals.initialize(
                        err,
                        options.statusCode || err.output.statusCode,
                        options.message
                    )
                }

                // 4xx Client Errors

                static badRequest(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 400,
                        data,
                        ctor: internals.Boom.badRequest
                    })
                }

                static unauthorized(message, scheme, attributes) {
                    // Or (message, wwwAuthenticate[])

                    const err = new internals.Boom(message, {
                        statusCode: 401,
                        ctor: internals.Boom.unauthorized
                    })

                    // function (message)

                    if (!scheme) {
                        return err
                    }

                    // function (message, wwwAuthenticate[])

                    if (typeof scheme !== 'string') {
                        err.output.headers['WWW-Authenticate'] = scheme.join(
                            ', '
                        )
                        return err
                    }

                    // function (message, scheme, attributes)

                    let wwwAuthenticate = `${scheme} `

                    if (attributes || message) {
                        err.output.payload.attributes = {}
                    }

                    if (attributes) {
                        if (typeof attributes === 'string') {
                            wwwAuthenticate += Hoek.escapeHeaderAttribute(
                                attributes
                            )
                            err.output.payload.attributes = attributes
                        } else {
                            wwwAuthenticate += Object.keys(attributes)
                                .map(name => {
                                    let value = attributes[name]
                                    if (value === null || value === undefined) {
                                        value = ''
                                    }

                                    err.output.payload.attributes[name] = value
                                    return `${name}="${Hoek.escapeHeaderAttribute(
                                        value.toString()
                                    )}"`
                                })
                                .join(', ')
                        }
                    }

                    if (message) {
                        if (attributes) {
                            wwwAuthenticate += ', '
                        }

                        wwwAuthenticate += `error="${Hoek.escapeHeaderAttribute(
                            message
                        )}"`
                        err.output.payload.attributes.error = message
                    } else {
                        err.isMissing = true
                    }

                    err.output.headers['WWW-Authenticate'] = wwwAuthenticate
                    return err
                }

                static paymentRequired(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 402,
                        data,
                        ctor: internals.Boom.paymentRequired
                    })
                }

                static forbidden(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 403,
                        data,
                        ctor: internals.Boom.forbidden
                    })
                }

                static notFound(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 404,
                        data,
                        ctor: internals.Boom.notFound
                    })
                }

                static methodNotAllowed(message, data, allow) {
                    const err = new internals.Boom(message, {
                        statusCode: 405,
                        data,
                        ctor: internals.Boom.methodNotAllowed
                    })

                    if (typeof allow === 'string') {
                        allow = [allow]
                    }

                    if (Array.isArray(allow)) {
                        err.output.headers.Allow = allow.join(', ')
                    }

                    return err
                }

                static notAcceptable(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 406,
                        data,
                        ctor: internals.Boom.notAcceptable
                    })
                }

                static proxyAuthRequired(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 407,
                        data,
                        ctor: internals.Boom.proxyAuthRequired
                    })
                }

                static clientTimeout(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 408,
                        data,
                        ctor: internals.Boom.clientTimeout
                    })
                }

                static conflict(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 409,
                        data,
                        ctor: internals.Boom.conflict
                    })
                }

                static resourceGone(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 410,
                        data,
                        ctor: internals.Boom.resourceGone
                    })
                }

                static lengthRequired(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 411,
                        data,
                        ctor: internals.Boom.lengthRequired
                    })
                }

                static preconditionFailed(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 412,
                        data,
                        ctor: internals.Boom.preconditionFailed
                    })
                }

                static entityTooLarge(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 413,
                        data,
                        ctor: internals.Boom.entityTooLarge
                    })
                }

                static uriTooLong(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 414,
                        data,
                        ctor: internals.Boom.uriTooLong
                    })
                }

                static unsupportedMediaType(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 415,
                        data,
                        ctor: internals.Boom.unsupportedMediaType
                    })
                }

                static rangeNotSatisfiable(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 416,
                        data,
                        ctor: internals.Boom.rangeNotSatisfiable
                    })
                }

                static expectationFailed(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 417,
                        data,
                        ctor: internals.Boom.expectationFailed
                    })
                }

                static teapot(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 418,
                        data,
                        ctor: internals.Boom.teapot
                    })
                }

                static badData(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 422,
                        data,
                        ctor: internals.Boom.badData
                    })
                }

                static locked(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 423,
                        data,
                        ctor: internals.Boom.locked
                    })
                }

                static failedDependency(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 424,
                        data,
                        ctor: internals.Boom.failedDependency
                    })
                }

                static preconditionRequired(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 428,
                        data,
                        ctor: internals.Boom.preconditionRequired
                    })
                }

                static tooManyRequests(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 429,
                        data,
                        ctor: internals.Boom.tooManyRequests
                    })
                }

                static illegal(message, data) {
                    return new internals.Boom(message, {
                        statusCode: 451,
                        data,
                        ctor: internals.Boom.illegal
                    })
                }

                // 5xx Server Errors

                static internal(message, data, statusCode = 500) {
                    return internals.serverError(
                        message,
                        data,
                        statusCode,
                        internals.Boom.internal
                    )
                }

                static notImplemented(message, data) {
                    return internals.serverError(
                        message,
                        data,
                        501,
                        internals.Boom.notImplemented
                    )
                }

                static badGateway(message, data) {
                    return internals.serverError(
                        message,
                        data,
                        502,
                        internals.Boom.badGateway
                    )
                }

                static serverUnavailable(message, data) {
                    return internals.serverError(
                        message,
                        data,
                        503,
                        internals.Boom.serverUnavailable
                    )
                }

                static gatewayTimeout(message, data) {
                    return internals.serverError(
                        message,
                        data,
                        504,
                        internals.Boom.gatewayTimeout
                    )
                }

                static badImplementation(message, data) {
                    const err = internals.serverError(
                        message,
                        data,
                        500,
                        internals.Boom.badImplementation
                    )
                    err.isDeveloperError = true
                    return err
                }
            }

            internals.Boom.default = internals.Boom // Support ES6 module import

            internals.initialize = function(err, statusCode, message) {
                const numberCode = parseInt(statusCode, 10)
                Hoek.assert(
                    !isNaN(numberCode) && numberCode >= 400,
                    'First argument must be a number (400+):',
                    statusCode
                )

                err.isBoom = true
                err.isServer = numberCode >= 500

                if (!err.hasOwnProperty('data')) {
                    err.data = null
                }

                err.output = {
                    statusCode: numberCode,
                    payload: {},
                    headers: {}
                }

                Object.defineProperty(err, 'reformat', {
                    value: internals.reformat
                })

                if (!message && !err.message) {
                    err.reformat()
                    message = err.output.payload.error
                }

                if (message) {
                    const props =
                        Object.getOwnPropertyDescriptor(err, 'message') ||
                        Object.getOwnPropertyDescriptor(
                            Object.getPrototypeOf(err),
                            'message'
                        )
                    Hoek.assert(
                        props.configurable && !props.get,
                        'The error is not compatible with boom'
                    )

                    err.message =
                        message + (err.message ? ': ' + err.message : '')
                    err.output.payload.message = err.message
                }

                err.reformat()
                return err
            }

            internals.reformat = function(debug = false) {
                this.output.payload.statusCode = this.output.statusCode
                this.output.payload.error =
                    internals.codes.get(this.output.statusCode) || 'Unknown'

                if (this.output.statusCode === 500 && debug !== true) {
                    this.output.payload.message =
                        'An internal server error occurred' // Hide actual error from user
                } else if (this.message) {
                    this.output.payload.message = this.message
                }
            }

            internals.serverError = function(message, data, statusCode, ctor) {
                if (data instanceof Error && !data.isBoom) {
                    return internals.Boom.boomify(data, { statusCode, message })
                }

                return new internals.Boom(message, { statusCode, data, ctor })
            }

            /***/
        },

        /***/ UDep: /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('wgeU')
            __webpack_require__('FlQf')
            __webpack_require__('bBy9')
            __webpack_require__('g33z')
            __webpack_require__('XLbu')
            __webpack_require__('/h46')
            __webpack_require__('dVTT')
            module.exports = __webpack_require__('WEpk').Map

            /***/
        },

        /***/ UNVE: /***/ function(module, exports) {
            module.exports = require('tty')

            /***/
        },

        /***/ 'UNi/': /***/ function(module, exports) {
            /**
             * The base implementation of `_.times` without support for iteratee shorthands
             * or max array length checks.
             *
             * @private
             * @param {number} n The number of times to invoke `iteratee`.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the array of results.
             */
            function baseTimes(n, iteratee) {
                var index = -1,
                    result = Array(n)

                while (++index < n) {
                    result[index] = iteratee(index)
                }
                return result
            }

            module.exports = baseTimes

            /***/
        },

        /***/ UO39: /***/ function(module, exports) {
            module.exports = function(done, value) {
                return { value: value, done: !!done }
            }

            /***/
        },

        /***/ UWiX: /***/ function(module, exports, __webpack_require__) {
            var store = __webpack_require__('29s/')('wks')
            var uid = __webpack_require__('YqAc')
            var Symbol = __webpack_require__('5T2Y').Symbol
            var USE_SYMBOL = typeof Symbol == 'function'

            var $exports = (module.exports = function(name) {
                return (
                    store[name] ||
                    (store[name] =
                        (USE_SYMBOL && Symbol[name]) ||
                        (USE_SYMBOL ? Symbol : uid)('Symbol.' + name))
                )
            })

            $exports.store = store

            /***/
        },

        /***/ UXZV: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('UbbE')

            /***/
        },

        /***/ UbbE: /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('o8NH')
            module.exports = __webpack_require__('WEpk').Object.assign

            /***/
        },

        /***/ UnBK: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')
            var transformData = __webpack_require__('xAGQ')
            var isCancel = __webpack_require__('Lmem')
            var defaults = __webpack_require__('JEQr')

            /**
             * Throws a `Cancel` if cancellation has been requested.
             */
            function throwIfCancellationRequested(config) {
                if (config.cancelToken) {
                    config.cancelToken.throwIfRequested()
                }
            }

            /**
             * Dispatch a request to the server using the configured adapter.
             *
             * @param {object} config The config that is to be used for the request
             * @returns {Promise} The Promise to be fulfilled
             */
            module.exports = function dispatchRequest(config) {
                throwIfCancellationRequested(config)

                // Ensure headers exist
                config.headers = config.headers || {}

                // Transform request data
                config.data = transformData(
                    config.data,
                    config.headers,
                    config.transformRequest
                )

                // Flatten headers
                config.headers = utils.merge(
                    config.headers.common || {},
                    config.headers[config.method] || {},
                    config.headers
                )

                utils.forEach(
                    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
                    function cleanHeaderConfig(method) {
                        delete config.headers[method]
                    }
                )

                var adapter = config.adapter || defaults.adapter

                return adapter(config).then(
                    function onAdapterResolution(response) {
                        throwIfCancellationRequested(config)

                        // Transform response data
                        response.data = transformData(
                            response.data,
                            response.headers,
                            config.transformResponse
                        )

                        return response
                    },
                    function onAdapterRejection(reason) {
                        if (!isCancel(reason)) {
                            throwIfCancellationRequested(config)

                            // Transform response data
                            if (reason && reason.response) {
                                reason.response.data = transformData(
                                    reason.response.data,
                                    reason.response.headers,
                                    config.transformResponse
                                )
                            }
                        }

                        return Promise.reject(reason)
                    }
                )
            }

            /***/
        },

        /***/ UwMm: /***/ function(module, exports, __webpack_require__) {
            const Got = __webpack_require__('AfMj')
            const defaultsDeep = __webpack_require__('P4Tr')

            const pkg = __webpack_require__('nK8a')

            const isAbsoluteUrl = __webpack_require__('Ndh8')
            const { HTTP_OPTIONS } = __webpack_require__('TJm8')

            let DEFAULT_HTTP_OPTIONS
            let got

            const setDefaults = options => {
                DEFAULT_HTTP_OPTIONS = defaultsDeep(
                    options,
                    DEFAULT_HTTP_OPTIONS
                )
                got = Got.extend(DEFAULT_HTTP_OPTIONS)
            }

            setDefaults({
                followRedirect: false,
                headers: {
                    'User-Agent': `${pkg.name}/${pkg.version} (${pkg.homepage})`
                },
                retry: 0,
                timeout: 2500,
                throwHttpErrors: false
            })

            module.exports = function request(options, { mTLS = false } = {}) {
                const { url } = options
                isAbsoluteUrl(url)
                const optsFn = this[HTTP_OPTIONS]
                let opts
                if (optsFn) {
                    opts = optsFn.call(
                        this,
                        defaultsDeep(options, DEFAULT_HTTP_OPTIONS)
                    )
                } else {
                    opts = options
                }

                if (mTLS && (!opts.key || !opts.cert)) {
                    throw new TypeError(
                        'mutual-TLS certificate and key not set'
                    )
                }
                return got(opts)
            }

            module.exports.setDefaults = setDefaults

            /***/
        },

        /***/ 'V+O7': /***/ function(module, exports, __webpack_require__) {
            // https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
            __webpack_require__('aPfg')('Set')

            /***/
        },

        /***/ V6Ve: /***/ function(module, exports, __webpack_require__) {
            var overArg = __webpack_require__('kekF')

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeKeys = overArg(Object.keys, Object)

            module.exports = nativeKeys

            /***/
        },

        /***/ V7Et: /***/ function(module, exports, __webpack_require__) {
            // 0 -> Array#forEach
            // 1 -> Array#map
            // 2 -> Array#filter
            // 3 -> Array#some
            // 4 -> Array#every
            // 5 -> Array#find
            // 6 -> Array#findIndex
            var ctx = __webpack_require__('2GTP')
            var IObject = __webpack_require__('M1xp')
            var toObject = __webpack_require__('JB68')
            var toLength = __webpack_require__('tEej')
            var asc = __webpack_require__('v6xn')
            module.exports = function(TYPE, $create) {
                var IS_MAP = TYPE == 1
                var IS_FILTER = TYPE == 2
                var IS_SOME = TYPE == 3
                var IS_EVERY = TYPE == 4
                var IS_FIND_INDEX = TYPE == 6
                var NO_HOLES = TYPE == 5 || IS_FIND_INDEX
                var create = $create || asc
                return function($this, callbackfn, that) {
                    var O = toObject($this)
                    var self = IObject(O)
                    var f = ctx(callbackfn, that, 3)
                    var length = toLength(self.length)
                    var index = 0
                    var result = IS_MAP
                        ? create($this, length)
                        : IS_FILTER
                        ? create($this, 0)
                        : undefined
                    var val, res
                    for (; length > index; index++)
                        if (NO_HOLES || index in self) {
                            val = self[index]
                            res = f(val, index, O)
                            if (TYPE) {
                                if (IS_MAP) result[index] = res
                                // map
                                else if (res)
                                    switch (TYPE) {
                                        case 3:
                                            return true // some
                                        case 5:
                                            return val // find
                                        case 6:
                                            return index // findIndex
                                        case 2:
                                            result.push(val) // filter
                                    }
                                else if (IS_EVERY) return false // every
                            }
                        }
                    return IS_FIND_INDEX
                        ? -1
                        : IS_SOME || IS_EVERY
                        ? IS_EVERY
                        : result
                }
            }

            /***/
        },

        /***/ VDXt: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _interopRequireWildcard3 = __webpack_require__('5Uuq')

            var _interopRequireDefault = __webpack_require__('KI45')

            exports.__esModule = true
            exports.middleware = middleware
            exports.NextScript = exports.Main = exports.Head = exports.Html = exports.default = void 0

            var _stringify = _interopRequireDefault(__webpack_require__('9Jkg'))

            var _isArray = _interopRequireDefault(__webpack_require__('p0XB'))

            var _keys = _interopRequireDefault(__webpack_require__('pLtp'))

            var _extends2 = _interopRequireDefault(__webpack_require__('htGi'))

            var _now = _interopRequireDefault(__webpack_require__('Cg2A'))

            var _promise = _interopRequireDefault(__webpack_require__('eVuF'))

            var _interopRequireWildcard2 = _interopRequireDefault(
                __webpack_require__('5Uuq')
            )

            var _set = _interopRequireDefault(__webpack_require__('ttDY'))

            var _asyncToGenerator2 = _interopRequireDefault(
                __webpack_require__('+oT+')
            )

            var _propTypes = _interopRequireDefault(__webpack_require__('17x9'))

            var _react = _interopRequireWildcard3(__webpack_require__('q1tI'))

            var _server = _interopRequireDefault(__webpack_require__('DTay'))

            var _constants = __webpack_require__('w7wo')

            var _documentContext = __webpack_require__('nRxi')

            var _utils = __webpack_require__('g/15')

            exports.DocumentContext = _utils.DocumentContext
            exports.DocumentInitialProps = _utils.DocumentInitialProps
            exports.DocumentProps = _utils.DocumentProps

            var _utils2 = __webpack_require__('PRL6')

            var _htmlescape = __webpack_require__('AXZJ')

            function middleware(_x) {
                return _middleware.apply(this, arguments)
            }

            function _middleware() {
                _middleware = (0, _asyncToGenerator2.default)(function*(_ref) {
                    var { req, res } = _ref
                })
                return _middleware.apply(this, arguments)
            }

            function dedupe(bundles) {
                var files = new _set.default()
                var kept = []

                for (var bundle of bundles) {
                    if (files.has(bundle.file)) continue
                    files.add(bundle.file)
                    kept.push(bundle)
                }

                return kept
            }

            function getOptionalModernScriptVariant(path) {
                if (false) {
                }

                return path
            }

            function isLowPriority(file) {
                return file.includes('_buildManifest')
            }
            /**
             * `Document` component handles the initial `document` markup and renders only on the server side.
             * Commonly used for implementing server side rendering for `css-in-js` libraries.
             */

            class Document extends _react.Component {
                /**
                 * `getInitialProps` hook returns the context object with the addition of `renderPage`.
                 * `renderPage` callback executes `React` rendering logic synchronously to support server-rendering wrappers
                 */
                static getInitialProps(ctx) {
                    return (0, _asyncToGenerator2.default)(function*() {
                        var enhancers = false ? undefined : []

                        var enhanceApp = App => {
                            for (var enhancer of enhancers) {
                                App = enhancer(App)
                            }

                            return props =>
                                _react.default.createElement(App, props)
                        }

                        var { html, head, dataOnly } = yield ctx.renderPage({
                            enhanceApp
                        })
                        var styles = [
                            ...(0, _server.default)(),
                            ...(false ? undefined : [])
                        ]
                        return {
                            html,
                            head,
                            styles,
                            dataOnly
                        }
                    })()
                }

                static renderDocument(Document, props) {
                    return _react.default.createElement(
                        _documentContext.DocumentContext.Provider,
                        {
                            value: {
                                _documentProps: props,
                                // In dev we invalidate the cache by appending a timestamp to the resource URL.
                                // This is a workaround to fix https://github.com/zeit/next.js/issues/5860
                                // TODO: remove this workaround when https://bugs.webkit.org/show_bug.cgi?id=187726 is fixed.
                                _devOnlyInvalidateCacheQueryString: false
                                    ? undefined
                                    : ''
                            }
                        },
                        _react.default.createElement(Document, props)
                    )
                }

                render() {
                    return _react.default.createElement(
                        Html,
                        null,
                        _react.default.createElement(Head, null),
                        _react.default.createElement(
                            'body',
                            null,
                            _react.default.createElement(Main, null),
                            _react.default.createElement(NextScript, null)
                        )
                    )
                }
            }

            exports.default = Document
            Document.headTagsMiddleware = false ? undefined : () => []
            Document.bodyTagsMiddleware = false ? undefined : () => []
            Document.htmlPropsMiddleware = false ? undefined : () => []

            class Html extends _react.Component {
                constructor() {
                    super(...arguments)
                    this.context = void 0
                }

                render() {
                    var { inAmpMode, htmlProps } = this.context._documentProps
                    return _react.default.createElement(
                        'html',
                        (0, _extends2.default)({}, htmlProps, this.props, {
                            amp: inAmpMode ? '' : undefined,
                            'data-ampdevmode':
                                inAmpMode && 'production' !== 'production'
                                    ? ''
                                    : undefined
                        })
                    )
                }
            }

            exports.Html = Html
            Html.contextType = _documentContext.DocumentContext
            Html.propTypes = {
                children: _propTypes.default.node.isRequired
            }

            class Head extends _react.Component {
                constructor() {
                    super(...arguments)
                    this.context = void 0
                }

                getCssLinks() {
                    var { assetPrefix, files } = this.context._documentProps
                    var cssFiles =
                        files && files.length
                            ? files.filter(f => /\.css$/.test(f))
                            : []
                    var cssLinkElements = []
                    cssFiles.forEach(file => {
                        cssLinkElements.push(
                            _react.default.createElement('link', {
                                key: file + '-preload',
                                nonce: this.props.nonce,
                                rel: 'preload',
                                href: assetPrefix + '/_next/' + encodeURI(file),
                                as: 'style',
                                crossOrigin: this.props.crossOrigin || undefined
                            }),
                            _react.default.createElement('link', {
                                key: file,
                                nonce: this.props.nonce,
                                rel: 'stylesheet',
                                href: assetPrefix + '/_next/' + encodeURI(file),
                                crossOrigin: this.props.crossOrigin || undefined
                            })
                        )
                    })
                    return cssLinkElements.length === 0 ? null : cssLinkElements
                }

                getPreloadDynamicChunks() {
                    var {
                        dynamicImports,
                        assetPrefix
                    } = this.context._documentProps
                    var { _devOnlyInvalidateCacheQueryString } = this.context
                    return dedupe(dynamicImports)
                        .map(bundle => {
                            // `dynamicImports` will contain both `.js` and `.module.js` when the
                            // feature is enabled. This clause will filter down to the modern
                            // variants only.
                            if (
                                !bundle.file.endsWith(
                                    getOptionalModernScriptVariant('.js')
                                )
                            ) {
                                return null
                            }

                            return _react.default.createElement('link', {
                                rel: 'preload',
                                key: bundle.file,
                                href:
                                    assetPrefix +
                                    '/_next/' +
                                    encodeURI(bundle.file) +
                                    _devOnlyInvalidateCacheQueryString,
                                as: 'script',
                                nonce: this.props.nonce,
                                crossOrigin: this.props.crossOrigin || undefined
                            })
                        }) // Filter out nulled scripts
                        .filter(Boolean)
                }

                getPreloadMainLinks() {
                    var { assetPrefix, files } = this.context._documentProps
                    var { _devOnlyInvalidateCacheQueryString } = this.context
                    var preloadFiles =
                        files && files.length
                            ? files.filter(file => {
                                  // `dynamicImports` will contain both `.js` and `.module.js` when
                                  // the feature is enabled. This clause will filter down to the
                                  // modern variants only.
                                  //
                                  // Also filter out low priority files because they should not be
                                  // preloaded for performance reasons.
                                  return (
                                      file.endsWith(
                                          getOptionalModernScriptVariant('.js')
                                      ) && !isLowPriority(file)
                                  )
                              })
                            : []
                    return preloadFiles.length === 0
                        ? null
                        : preloadFiles.map(file => {
                              return _react.default.createElement('link', {
                                  key: file,
                                  nonce: this.props.nonce,
                                  rel: 'preload',
                                  href:
                                      assetPrefix +
                                      '/_next/' +
                                      encodeURI(file) +
                                      _devOnlyInvalidateCacheQueryString,
                                  as: 'script',
                                  crossOrigin:
                                      this.props.crossOrigin || undefined
                              })
                          })
                }

                render() {
                    var {
                        styles,
                        ampPath,
                        inAmpMode,
                        assetPrefix,
                        hybridAmp,
                        canonicalBase,
                        __NEXT_DATA__,
                        dangerousAsPath,
                        headTags
                    } = this.context._documentProps
                    var { _devOnlyInvalidateCacheQueryString } = this.context
                    var { page, buildId } = __NEXT_DATA__
                    var { head } = this.context._documentProps
                    var children = this.props.children // show a warning if Head contains <title> (only in development)

                    if (false) {
                    }

                    var hasAmphtmlRel = false
                    var hasCanonicalRel = false // show warning and remove conflicting amp head tags

                    head = _react.default.Children.map(head || [], child => {
                        if (!child) return child
                        var { type, props } = child

                        if (inAmpMode) {
                            var badProp = ''

                            if (type === 'meta' && props.name === 'viewport') {
                                badProp = 'name="viewport"'
                            } else if (
                                type === 'link' &&
                                props.rel === 'canonical'
                            ) {
                                hasCanonicalRel = true
                            } else if (type === 'script') {
                                // only block if
                                // 1. it has a src and isn't pointing to ampproject's CDN
                                // 2. it is using dangerouslySetInnerHTML without a type or
                                // a type of text/javascript
                                if (
                                    (props.src &&
                                        props.src.indexOf('ampproject') < -1) ||
                                    (props.dangerouslySetInnerHTML &&
                                        (!props.type ||
                                            props.type === 'text/javascript'))
                                ) {
                                    badProp = '<script'
                                    ;(0, _keys.default)(props).forEach(prop => {
                                        badProp +=
                                            ' ' +
                                            prop +
                                            '="' +
                                            props[prop] +
                                            '"'
                                    })
                                    badProp += '/>'
                                }
                            }

                            if (badProp) {
                                console.warn(
                                    'Found conflicting amp tag "' +
                                        child.type +
                                        '" with conflicting prop ' +
                                        badProp +
                                        ' in ' +
                                        __NEXT_DATA__.page +
                                        '. https://err.sh/next.js/conflicting-amp-tag'
                                )
                                return null
                            }
                        } else {
                            // non-amp mode
                            if (type === 'link' && props.rel === 'amphtml') {
                                hasAmphtmlRel = true
                            }
                        }

                        return child
                    }) // try to parse styles from fragment for backwards compat

                    var curStyles = (0, _isArray.default)(styles) ? styles : []

                    if (
                        inAmpMode &&
                        styles && // @ts-ignore Property 'props' does not exist on type ReactElement
                        styles.props && // @ts-ignore Property 'props' does not exist on type ReactElement
                        (0, _isArray.default)(styles.props.children)
                    ) {
                        var hasStyles = el =>
                            el &&
                            el.props &&
                            el.props.dangerouslySetInnerHTML &&
                            el.props.dangerouslySetInnerHTML.__html // @ts-ignore Property 'props' does not exist on type ReactElement

                        styles.props.children.forEach(child => {
                            if ((0, _isArray.default)(child)) {
                                child.map(
                                    el => hasStyles(el) && curStyles.push(el)
                                )
                            } else if (hasStyles(child)) {
                                curStyles.push(child)
                            }
                        })
                    }

                    return _react.default.createElement(
                        'head',
                        this.props,
                        this.context._documentProps.isDevelopment &&
                            this.context._documentProps.hasCssMode &&
                            _react.default.createElement(
                                _react.default.Fragment,
                                null,
                                _react.default.createElement('style', {
                                    'data-next-hide-fouc': true,
                                    dangerouslySetInnerHTML: {
                                        __html: 'body{display:none}'
                                    }
                                }),
                                _react.default.createElement(
                                    'noscript',
                                    {
                                        'data-next-hide-fouc': true
                                    },
                                    _react.default.createElement('style', {
                                        dangerouslySetInnerHTML: {
                                            __html: 'body{display:block}'
                                        }
                                    })
                                )
                            ),
                        children,
                        head,
                        _react.default.createElement('meta', {
                            name: 'next-head-count',
                            content: _react.default.Children.count(
                                head || []
                            ).toString()
                        }),
                        inAmpMode &&
                            _react.default.createElement(
                                _react.default.Fragment,
                                null,
                                _react.default.createElement('meta', {
                                    name: 'viewport',
                                    content:
                                        'width=device-width,minimum-scale=1,initial-scale=1'
                                }),
                                !hasCanonicalRel &&
                                    _react.default.createElement('link', {
                                        rel: 'canonical',
                                        href:
                                            canonicalBase +
                                            (0, _utils2.cleanAmpPath)(
                                                dangerousAsPath
                                            )
                                    }),
                                _react.default.createElement('link', {
                                    rel: 'preload',
                                    as: 'script',
                                    href: 'https://cdn.ampproject.org/v0.js'
                                }),
                                styles &&
                                    _react.default.createElement('style', {
                                        'amp-custom': '',
                                        dangerouslySetInnerHTML: {
                                            __html: curStyles
                                                .map(
                                                    style =>
                                                        style.props
                                                            .dangerouslySetInnerHTML
                                                            .__html
                                                )
                                                .join('')
                                                .replace(
                                                    /\/\*# sourceMappingURL=.*\*\//g,
                                                    ''
                                                )
                                                .replace(
                                                    /\/\*@ sourceURL=.*?\*\//g,
                                                    ''
                                                )
                                        }
                                    }),
                                _react.default.createElement('style', {
                                    'amp-boilerplate': '',
                                    dangerouslySetInnerHTML: {
                                        __html:
                                            'body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}'
                                    }
                                }),
                                _react.default.createElement(
                                    'noscript',
                                    null,
                                    _react.default.createElement('style', {
                                        'amp-boilerplate': '',
                                        dangerouslySetInnerHTML: {
                                            __html:
                                                'body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}'
                                        }
                                    })
                                ),
                                _react.default.createElement('script', {
                                    async: true,
                                    src: 'https://cdn.ampproject.org/v0.js'
                                })
                            ),
                        !inAmpMode &&
                            _react.default.createElement(
                                _react.default.Fragment,
                                null,
                                !hasAmphtmlRel &&
                                    hybridAmp &&
                                    _react.default.createElement('link', {
                                        rel: 'amphtml',
                                        href:
                                            canonicalBase +
                                            getAmpPath(ampPath, dangerousAsPath)
                                    }),
                                page !== '/_error' &&
                                    _react.default.createElement('link', {
                                        rel: 'preload',
                                        href:
                                            assetPrefix +
                                            getOptionalModernScriptVariant(
                                                encodeURI(
                                                    '/_next/static/' +
                                                        buildId +
                                                        '/pages' +
                                                        getPageFile(page)
                                                )
                                            ) +
                                            _devOnlyInvalidateCacheQueryString,
                                        as: 'script',
                                        nonce: this.props.nonce,
                                        crossOrigin:
                                            this.props.crossOrigin || undefined
                                    }),
                                _react.default.createElement('link', {
                                    rel: 'preload',
                                    href:
                                        assetPrefix +
                                        getOptionalModernScriptVariant(
                                            encodeURI(
                                                '/_next/static/' +
                                                    buildId +
                                                    '/pages/_app.js'
                                            )
                                        ) +
                                        _devOnlyInvalidateCacheQueryString,
                                    as: 'script',
                                    nonce: this.props.nonce,
                                    crossOrigin:
                                        this.props.crossOrigin || undefined
                                }),
                                this.getPreloadDynamicChunks(),
                                this.getPreloadMainLinks(),
                                this.context._documentProps.isDevelopment &&
                                this.context._documentProps.hasCssMode && // this element is used to mount development styles so the
                                    // ordering matches production
                                    // (by default, style-loader injects at the bottom of <head />)
                                    _react.default.createElement('noscript', {
                                        id: '__next_css__DO_NOT_USE__'
                                    }),
                                this.getCssLinks(),
                                styles || null
                            ),
                        _react.default.createElement(
                            _react.default.Fragment,
                            {},
                            ...(headTags || [])
                        )
                    )
                }
            }

            exports.Head = Head
            Head.contextType = _documentContext.DocumentContext
            Head.propTypes = {
                nonce: _propTypes.default.string,
                crossOrigin: _propTypes.default.string
            }

            class Main extends _react.Component {
                constructor() {
                    super(...arguments)
                    this.context = void 0
                }

                render() {
                    var { inAmpMode, html } = this.context._documentProps
                    if (inAmpMode) return '__NEXT_AMP_RENDER_TARGET__'
                    return _react.default.createElement('div', {
                        id: '__next',
                        dangerouslySetInnerHTML: {
                            __html: html
                        }
                    })
                }
            }

            exports.Main = Main
            Main.contextType = _documentContext.DocumentContext

            class NextScript extends _react.Component {
                constructor() {
                    super(...arguments)
                    this.context = void 0
                }

                getDynamicChunks() {
                    var {
                        dynamicImports,
                        assetPrefix,
                        files
                    } = this.context._documentProps
                    var { _devOnlyInvalidateCacheQueryString } = this.context
                    return dedupe(dynamicImports).map(bundle => {
                        var modernProps = {}

                        if (false) {
                        }

                        if (
                            !/\.js$/.test(bundle.file) ||
                            files.includes(bundle.file)
                        )
                            return null
                        return _react.default.createElement(
                            'script',
                            (0, _extends2.default)(
                                {
                                    defer: false,
                                    async: !false,
                                    key: bundle.file,
                                    src:
                                        assetPrefix +
                                        '/_next/' +
                                        encodeURI(bundle.file) +
                                        _devOnlyInvalidateCacheQueryString,
                                    nonce: this.props.nonce,
                                    crossOrigin:
                                        this.props.crossOrigin || undefined
                                },
                                modernProps
                            )
                        )
                    })
                }

                getScripts() {
                    var { assetPrefix, files } = this.context._documentProps

                    if (!files || files.length === 0) {
                        return null
                    }

                    var { _devOnlyInvalidateCacheQueryString } = this.context
                    var normalScripts = files.filter(
                        file => file.endsWith('.js') && !isLowPriority(file)
                    )
                    var lowPriorityScripts = files.filter(
                        file => file.endsWith('.js') && isLowPriority(file)
                    )
                    return [...normalScripts, ...lowPriorityScripts].map(
                        file => {
                            var modernProps = {}

                            if (false) {
                            }

                            return _react.default.createElement(
                                'script',
                                (0, _extends2.default)(
                                    {
                                        key: file,
                                        src:
                                            assetPrefix +
                                            '/_next/' +
                                            encodeURI(file) +
                                            _devOnlyInvalidateCacheQueryString,
                                        nonce: this.props.nonce,
                                        defer: false,
                                        async: !false,
                                        crossOrigin:
                                            this.props.crossOrigin || undefined
                                    },
                                    modernProps
                                )
                            )
                        }
                    )
                }

                getPolyfillScripts() {
                    // polyfills.js has to be rendered as nomodule without async
                    // It also has to be the first script to load
                    var {
                        assetPrefix,
                        polyfillFiles
                    } = this.context._documentProps
                    var { _devOnlyInvalidateCacheQueryString } = this.context
                    return polyfillFiles
                        .filter(polyfill => !/\.module\.js$/.test(polyfill))
                        .map(polyfill =>
                            _react.default.createElement('script', {
                                key: polyfill,
                                nonce: this.props.nonce,
                                crossOrigin:
                                    this.props.crossOrigin || undefined,
                                noModule: true,
                                src:
                                    assetPrefix +
                                    '/_next/' +
                                    polyfill +
                                    _devOnlyInvalidateCacheQueryString
                            })
                        )
                }

                static getInlineScriptSource(documentProps) {
                    var { __NEXT_DATA__ } = documentProps

                    try {
                        var data = (0, _stringify.default)(__NEXT_DATA__)
                        return (0, _htmlescape.htmlEscapeJsonString)(data)
                    } catch (err) {
                        if (err.message.indexOf('circular structure')) {
                            throw new Error(
                                'Circular structure in "getInitialProps" result of page "' +
                                    __NEXT_DATA__.page +
                                    '". https://err.sh/zeit/next.js/circular-structure'
                            )
                        }

                        throw err
                    }
                }

                render() {
                    var {
                        staticMarkup,
                        assetPrefix,
                        inAmpMode,
                        devFiles,
                        __NEXT_DATA__,
                        bodyTags
                    } = this.context._documentProps
                    var deferScripts = false
                    var { _devOnlyInvalidateCacheQueryString } = this.context

                    if (inAmpMode) {
                        if (true) {
                            return null
                        }

                        var _devFiles = [
                            _constants.CLIENT_STATIC_FILES_RUNTIME_AMP,
                            _constants.CLIENT_STATIC_FILES_RUNTIME_WEBPACK
                        ]
                        return _react.default.createElement(
                            _react.default.Fragment,
                            null,
                            staticMarkup
                                ? null
                                : _react.default.createElement('script', {
                                      id: '__NEXT_DATA__',
                                      type: 'application/json',
                                      nonce: this.props.nonce,
                                      crossOrigin:
                                          this.props.crossOrigin || undefined,
                                      dangerouslySetInnerHTML: {
                                          __html: NextScript.getInlineScriptSource(
                                              this.context._documentProps
                                          )
                                      },
                                      'data-ampdevmode': true
                                  }),
                            _devFiles
                                ? _devFiles.map(file =>
                                      _react.default.createElement('script', {
                                          key: file,
                                          src:
                                              assetPrefix +
                                              '/_next/' +
                                              file +
                                              _devOnlyInvalidateCacheQueryString,
                                          nonce: this.props.nonce,
                                          crossOrigin:
                                              this.props.crossOrigin ||
                                              undefined,
                                          'data-ampdevmode': true
                                      })
                                  )
                                : null,
                            _react.default.createElement(
                                _react.default.Fragment,
                                {},
                                ...(bodyTags || [])
                            )
                        )
                    }

                    var { page, buildId } = __NEXT_DATA__

                    if (false) {
                    }

                    var pageScript = [
                        _react.default.createElement(
                            'script',
                            (0, _extends2.default)(
                                {
                                    defer: deferScripts,
                                    async: !deferScripts,
                                    'data-next-page': page,
                                    key: page,
                                    src:
                                        assetPrefix +
                                        encodeURI(
                                            '/_next/static/' +
                                                buildId +
                                                '/pages' +
                                                getPageFile(page)
                                        ) +
                                        _devOnlyInvalidateCacheQueryString,
                                    nonce: this.props.nonce,
                                    crossOrigin:
                                        this.props.crossOrigin || undefined
                                },
                                false ? undefined : {}
                            )
                        ),
                        false && false
                    ]
                    var appScript = [
                        _react.default.createElement(
                            'script',
                            (0, _extends2.default)(
                                {
                                    defer: deferScripts,
                                    async: !deferScripts,
                                    'data-next-page': '/_app',
                                    src:
                                        assetPrefix +
                                        ('/_next/static/' +
                                            buildId +
                                            '/pages/_app.js') +
                                        _devOnlyInvalidateCacheQueryString,
                                    key: '_app',
                                    nonce: this.props.nonce,
                                    crossOrigin:
                                        this.props.crossOrigin || undefined
                                },
                                false ? undefined : {}
                            )
                        ),
                        false && false
                    ]
                    return _react.default.createElement(
                        _react.default.Fragment,
                        null,
                        devFiles
                            ? devFiles.map(
                                  file =>
                                      !file.match(/\.js\.map/) &&
                                      _react.default.createElement('script', {
                                          key: file,
                                          src:
                                              assetPrefix +
                                              '/_next/' +
                                              encodeURI(file) +
                                              _devOnlyInvalidateCacheQueryString,
                                          nonce: this.props.nonce,
                                          crossOrigin:
                                              this.props.crossOrigin ||
                                              undefined
                                      })
                              )
                            : null,
                        staticMarkup
                            ? null
                            : _react.default.createElement('script', {
                                  id: '__NEXT_DATA__',
                                  type: 'application/json',
                                  nonce: this.props.nonce,
                                  crossOrigin:
                                      this.props.crossOrigin || undefined,
                                  dangerouslySetInnerHTML: {
                                      __html: NextScript.getInlineScriptSource(
                                          this.context._documentProps
                                      )
                                  }
                              }),
                        false ? undefined : null,
                        this.getPolyfillScripts(),
                        page !== '/_error' && pageScript,
                        appScript,
                        staticMarkup ? null : this.getDynamicChunks(),
                        staticMarkup ? null : this.getScripts(),
                        _react.default.createElement(
                            _react.default.Fragment,
                            {},
                            ...(bodyTags || [])
                        )
                    )
                }
            }

            exports.NextScript = NextScript
            NextScript.contextType = _documentContext.DocumentContext
            NextScript.propTypes = {
                nonce: _propTypes.default.string,
                crossOrigin: _propTypes.default.string
            }
            NextScript.safariNomoduleFix =
                '!function(){var e=document,t=e.createElement("script");if(!("noModule"in t)&&"onbeforeload"in t){var n=!1;e.addEventListener("beforeload",function(e){if(e.target===t)n=!0;else if(!e.target.hasAttribute("nomodule")||!n)return;e.preventDefault()},!0),t.type="module",t.src=".",e.head.appendChild(t),t.remove()}}();'

            function getAmpPath(ampPath, asPath) {
                return ampPath
                    ? ampPath
                    : '' + asPath + (asPath.includes('?') ? '&' : '?') + 'amp=1'
            }

            function getPageFile(page, buildId) {
                if (page === '/') {
                    return buildId ? '/index.' + buildId + '.js' : '/index.js'
                }

                return buildId ? page + '.' + buildId + '.js' : page + '.js'
            }

            /***/
        },

        /***/ VOtZ: /***/ function(module, exports, __webpack_require__) {
            var copyObject = __webpack_require__('juv8'),
                getSymbols = __webpack_require__('MvSz')

            /**
             * Copies own symbols of `source` to `object`.
             *
             * @private
             * @param {Object} source The object to copy symbols from.
             * @param {Object} [object={}] The object to copy symbols to.
             * @returns {Object} Returns `object`.
             */
            function copySymbols(source, object) {
                return copyObject(source, getSymbols(source), object)
            }

            module.exports = copySymbols

            /***/
        },

        /***/ VVlx: /***/ function(module, exports, __webpack_require__) {
            var shared = __webpack_require__('29s/')('keys')
            var uid = __webpack_require__('YqAc')
            module.exports = function(key) {
                return shared[key] || (shared[key] = uid(key))
            }

            /***/
        },

        /***/ VZIC: /***/ function(module, exports, __webpack_require__) {
            const { Reporter } = __webpack_require__('1WHo')
            const { DecoderBuffer, EncoderBuffer } = __webpack_require__('Z9M3')
            const Node = __webpack_require__('k+0e')

            module.exports = {
                DecoderBuffer,
                EncoderBuffer,
                Node,
                Reporter
            }

            /***/
        },

        /***/ VaNO: /***/ function(module, exports) {
            /**
             * Checks if a stack value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf Stack
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function stackHas(key) {
                return this.__data__.has(key)
            }

            module.exports = stackHas

            /***/
        },

        /***/ VmuJ: /***/ function(module, exports, __webpack_require__) {
            var wrappy = __webpack_require__('1jOq')
            module.exports = wrappy(once)
            module.exports.strict = wrappy(onceStrict)

            once.proto = once(function() {
                Object.defineProperty(Function.prototype, 'once', {
                    value: function() {
                        return once(this)
                    },
                    configurable: true
                })

                Object.defineProperty(Function.prototype, 'onceStrict', {
                    value: function() {
                        return onceStrict(this)
                    },
                    configurable: true
                })
            })

            function once(fn) {
                var f = function() {
                    if (f.called) return f.value
                    f.called = true
                    return (f.value = fn.apply(this, arguments))
                }
                f.called = false
                return f
            }

            function onceStrict(fn) {
                var f = function() {
                    if (f.called) throw new Error(f.onceError)
                    f.called = true
                    return (f.value = fn.apply(this, arguments))
                }
                var name = fn.name || 'Function wrapped with `once`'
                f.onceError = name + " shouldn't be called more than once"
                f.called = false
                return f
            }

            /***/
        },

        /***/ VraX: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(...args) {
                try {
                    return JSON.stringify.apply(null, args)
                } catch (err) {
                    return '[Cannot display object: ' + err.message + ']'
                }
            }

            /***/
        },

        /***/ W070: /***/ function(module, exports, __webpack_require__) {
            // false -> Array#indexOf
            // true  -> Array#includes
            var toIObject = __webpack_require__('NsO/')
            var toLength = __webpack_require__('tEej')
            var toAbsoluteIndex = __webpack_require__('D8kY')
            module.exports = function(IS_INCLUDES) {
                return function($this, el, fromIndex) {
                    var O = toIObject($this)
                    var length = toLength(O.length)
                    var index = toAbsoluteIndex(fromIndex, length)
                    var value
                    // Array#includes uses SameValueZero equality algorithm
                    // eslint-disable-next-line no-self-compare
                    if (IS_INCLUDES && el != el)
                        while (length > index) {
                            value = O[index++]
                            // eslint-disable-next-line no-self-compare
                            if (value != value) return true
                            // Array#indexOf ignores holes, Array#includes - not
                        }
                    else
                        for (; length > index; index++)
                            if (IS_INCLUDES || index in O) {
                                if (O[index] === el)
                                    return IS_INCLUDES || index || 0
                            }
                    return !IS_INCLUDES && -1
                }
            }

            /***/
        },

        /***/ W7oM: /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('nZgG')
            var $Object = __webpack_require__('WEpk').Object
            module.exports = function defineProperties(T, D) {
                return $Object.defineProperties(T, D)
            }

            /***/
        },

        /***/ WEpk: /***/ function(module, exports) {
            var core = (module.exports = { version: '2.6.11' })
            if (typeof __e == 'number') __e = core // eslint-disable-line no-undef

            /***/
        },

        /***/ WFqU: /***/ function(module, exports) {
            /** Detect free variable `global` from Node.js. */
            var freeGlobal =
                typeof global == 'object' &&
                global &&
                global.Object === Object &&
                global

            module.exports = freeGlobal

            /***/
        },

        /***/ WPgm: /***/ function(module, exports, __webpack_require__) {
            const KeyStore = __webpack_require__('aIoy')

            module.exports = KeyStore

            /***/
        },

        /***/ WbBG: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /**
             * Copyright (c) 2013-present, Facebook, Inc.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */

            var ReactPropTypesSecret =
                'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'

            module.exports = ReactPropTypesSecret

            /***/
        },

        /***/ WeJA: /***/ function(module, exports, __webpack_require__) {
            const { STATUS_CODES } = __webpack_require__('KEll')
            const { format } = __webpack_require__('jK02')

            const { OPError } = __webpack_require__('L71r')

            const REGEXP = /(\w+)=("[^"]*")/g
            const throwAuthenticateErrors = response => {
                const params = {}
                try {
                    while (
                        REGEXP.exec(response.headers['www-authenticate']) !==
                        null
                    ) {
                        if (RegExp.$1 && RegExp.$2) {
                            params[RegExp.$1] = RegExp.$2.slice(1, -1)
                        }
                    }
                } catch (err) {}

                if (params.error) {
                    throw new OPError(params, response)
                }
            }

            const isStandardBodyError = response => {
                let result = false
                try {
                    let jsonbody
                    if (
                        typeof response.body !== 'object' ||
                        Buffer.isBuffer(response.body)
                    ) {
                        jsonbody = JSON.parse(response.body)
                    } else {
                        jsonbody = response.body
                    }
                    result =
                        typeof jsonbody.error === 'string' &&
                        jsonbody.error.length
                    if (result) response.body = jsonbody
                } catch (err) {}

                return result
            }

            function processResponse(
                response,
                { statusCode = 200, body = true, bearer = false } = {}
            ) {
                if (response.statusCode !== statusCode) {
                    if (bearer) {
                        throwAuthenticateErrors(response)
                    }

                    if (isStandardBodyError(response)) {
                        throw new OPError(response.body, response)
                    }

                    throw new OPError(
                        {
                            error: format(
                                'expected %i %s, got: %i %s',
                                statusCode,
                                STATUS_CODES[statusCode],
                                response.statusCode,
                                STATUS_CODES[response.statusCode]
                            )
                        },
                        response
                    )
                }

                if (body && !response.body) {
                    throw new OPError(
                        {
                            error: format(
                                'expected %i %s with body but no body was returned',
                                statusCode,
                                STATUS_CODES[statusCode]
                            )
                        },
                        response
                    )
                }

                return response.body
            }

            module.exports = processResponse

            /***/
        },

        /***/ Wu5q: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var dP = __webpack_require__('2faE').f
            var create = __webpack_require__('oVml')
            var redefineAll = __webpack_require__('XJU/')
            var ctx = __webpack_require__('2GTP')
            var anInstance = __webpack_require__('EXMj')
            var forOf = __webpack_require__('oioR')
            var $iterDefine = __webpack_require__('MPFp')
            var step = __webpack_require__('UO39')
            var setSpecies = __webpack_require__('TJWN')
            var DESCRIPTORS = __webpack_require__('jmDH')
            var fastKey = __webpack_require__('6/1s').fastKey
            var validate = __webpack_require__('n3ko')
            var SIZE = DESCRIPTORS ? '_s' : 'size'

            var getEntry = function(that, key) {
                // fast case
                var index = fastKey(key)
                var entry
                if (index !== 'F') return that._i[index]
                // frozen object case
                for (entry = that._f; entry; entry = entry.n) {
                    if (entry.k == key) return entry
                }
            }

            module.exports = {
                getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
                    var C = wrapper(function(that, iterable) {
                        anInstance(that, C, NAME, '_i')
                        that._t = NAME // collection type
                        that._i = create(null) // index
                        that._f = undefined // first entry
                        that._l = undefined // last entry
                        that[SIZE] = 0 // size
                        if (iterable != undefined)
                            forOf(iterable, IS_MAP, that[ADDER], that)
                    })
                    redefineAll(C.prototype, {
                        // 23.1.3.1 Map.prototype.clear()
                        // 23.2.3.2 Set.prototype.clear()
                        clear: function clear() {
                            for (
                                var that = validate(this, NAME),
                                    data = that._i,
                                    entry = that._f;
                                entry;
                                entry = entry.n
                            ) {
                                entry.r = true
                                if (entry.p) entry.p = entry.p.n = undefined
                                delete data[entry.i]
                            }
                            that._f = that._l = undefined
                            that[SIZE] = 0
                        },
                        // 23.1.3.3 Map.prototype.delete(key)
                        // 23.2.3.4 Set.prototype.delete(value)
                        delete: function(key) {
                            var that = validate(this, NAME)
                            var entry = getEntry(that, key)
                            if (entry) {
                                var next = entry.n
                                var prev = entry.p
                                delete that._i[entry.i]
                                entry.r = true
                                if (prev) prev.n = next
                                if (next) next.p = prev
                                if (that._f == entry) that._f = next
                                if (that._l == entry) that._l = prev
                                that[SIZE]--
                            }
                            return !!entry
                        },
                        // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
                        // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
                        forEach: function forEach(
                            callbackfn /* , that = undefined */
                        ) {
                            validate(this, NAME)
                            var f = ctx(
                                callbackfn,
                                arguments.length > 1 ? arguments[1] : undefined,
                                3
                            )
                            var entry
                            while ((entry = entry ? entry.n : this._f)) {
                                f(entry.v, entry.k, this)
                                // revert to the last existing entry
                                while (entry && entry.r) entry = entry.p
                            }
                        },
                        // 23.1.3.7 Map.prototype.has(key)
                        // 23.2.3.7 Set.prototype.has(value)
                        has: function has(key) {
                            return !!getEntry(validate(this, NAME), key)
                        }
                    })
                    if (DESCRIPTORS)
                        dP(C.prototype, 'size', {
                            get: function() {
                                return validate(this, NAME)[SIZE]
                            }
                        })
                    return C
                },
                def: function(that, key, value) {
                    var entry = getEntry(that, key)
                    var prev, index
                    // change existing entry
                    if (entry) {
                        entry.v = value
                        // create new entry
                    } else {
                        that._l = entry = {
                            i: (index = fastKey(key, true)), // <- index
                            k: key, // <- key
                            v: value, // <- value
                            p: (prev = that._l), // <- previous entry
                            n: undefined, // <- next entry
                            r: false // <- removed
                        }
                        if (!that._f) that._f = entry
                        if (prev) prev.n = entry
                        that[SIZE]++
                        // add to index
                        if (index !== 'F') that._i[index] = entry
                    }
                    return that
                },
                getEntry: getEntry,
                setStrong: function(C, NAME, IS_MAP) {
                    // add .keys, .values, .entries, [@@iterator]
                    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
                    $iterDefine(
                        C,
                        NAME,
                        function(iterated, kind) {
                            this._t = validate(iterated, NAME) // target
                            this._k = kind // kind
                            this._l = undefined // previous
                        },
                        function() {
                            var that = this
                            var kind = that._k
                            var entry = that._l
                            // revert to the last existing entry
                            while (entry && entry.r) entry = entry.p
                            // get next entry
                            if (
                                !that._t ||
                                !(that._l = entry = entry
                                    ? entry.n
                                    : that._t._f)
                            ) {
                                // or finish the iteration
                                that._t = undefined
                                return step(1)
                            }
                            // return step by kind
                            if (kind == 'keys') return step(0, entry.k)
                            if (kind == 'values') return step(0, entry.v)
                            return step(0, [entry.k, entry.v])
                        },
                        IS_MAP ? 'entries' : 'values',
                        !IS_MAP,
                        true
                    )

                    // add [@@species], 23.1.2.2, 23.2.2.2
                    setSpecies(NAME)
                }
            }

            /***/
        },

        /***/ WwFo: /***/ function(module, exports, __webpack_require__) {
            var copyObject = __webpack_require__('juv8'),
                keys = __webpack_require__('7GkX')

            /**
             * The base implementation of `_.assign` without support for multiple sources
             * or `customizer` functions.
             *
             * @private
             * @param {Object} object The destination object.
             * @param {Object} source The source object.
             * @returns {Object} Returns `object`.
             */
            function baseAssign(object, source) {
                return object && copyObject(source, keys(source), object)
            }

            module.exports = baseAssign

            /***/
        },

        /***/ X3uD: /***/ function(module, exports, __webpack_require__) {
            const { randomBytes } = __webpack_require__('PJMN')

            const { IVLENGTHS } = __webpack_require__('N+nT')

            module.exports = alg => randomBytes(IVLENGTHS.get(alg) / 8)

            /***/
        },

        /***/ X5QW: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = (flag, argv) => {
                argv = argv || process.argv
                const prefix = flag.startsWith('-')
                    ? ''
                    : flag.length === 1
                    ? '-'
                    : '--'
                const pos = argv.indexOf(prefix + flag)
                const terminatorPos = argv.indexOf('--')
                return (
                    pos !== -1 &&
                    (terminatorPos === -1 ? true : pos < terminatorPos)
                )
            }

            /***/
        },

        /***/ 'XJU/': /***/ function(module, exports, __webpack_require__) {
            var hide = __webpack_require__('NegM')
            module.exports = function(target, src, safe) {
                for (var key in src) {
                    if (safe && target[key]) target[key] = src[key]
                    else hide(target, key, src[key])
                }
                return target
            }

            /***/
        },

        /***/ XLbu: /***/ function(module, exports, __webpack_require__) {
            // https://github.com/DavidBruant/Map-Set.prototype.toJSON
            var $export = __webpack_require__('Y7ZC')

            $export($export.P + $export.R, 'Map', {
                toJSON: __webpack_require__('8iia')('Map')
            })

            /***/
        },

        /***/ XPeR: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = Yallist

            Yallist.Node = Node
            Yallist.create = Yallist

            function Yallist(list) {
                var self = this
                if (!(self instanceof Yallist)) {
                    self = new Yallist()
                }

                self.tail = null
                self.head = null
                self.length = 0

                if (list && typeof list.forEach === 'function') {
                    list.forEach(function(item) {
                        self.push(item)
                    })
                } else if (arguments.length > 0) {
                    for (var i = 0, l = arguments.length; i < l; i++) {
                        self.push(arguments[i])
                    }
                }

                return self
            }

            Yallist.prototype.removeNode = function(node) {
                if (node.list !== this) {
                    throw new Error(
                        'removing node which does not belong to this list'
                    )
                }

                var next = node.next
                var prev = node.prev

                if (next) {
                    next.prev = prev
                }

                if (prev) {
                    prev.next = next
                }

                if (node === this.head) {
                    this.head = next
                }
                if (node === this.tail) {
                    this.tail = prev
                }

                node.list.length--
                node.next = null
                node.prev = null
                node.list = null

                return next
            }

            Yallist.prototype.unshiftNode = function(node) {
                if (node === this.head) {
                    return
                }

                if (node.list) {
                    node.list.removeNode(node)
                }

                var head = this.head
                node.list = this
                node.next = head
                if (head) {
                    head.prev = node
                }

                this.head = node
                if (!this.tail) {
                    this.tail = node
                }
                this.length++
            }

            Yallist.prototype.pushNode = function(node) {
                if (node === this.tail) {
                    return
                }

                if (node.list) {
                    node.list.removeNode(node)
                }

                var tail = this.tail
                node.list = this
                node.prev = tail
                if (tail) {
                    tail.next = node
                }

                this.tail = node
                if (!this.head) {
                    this.head = node
                }
                this.length++
            }

            Yallist.prototype.push = function() {
                for (var i = 0, l = arguments.length; i < l; i++) {
                    push(this, arguments[i])
                }
                return this.length
            }

            Yallist.prototype.unshift = function() {
                for (var i = 0, l = arguments.length; i < l; i++) {
                    unshift(this, arguments[i])
                }
                return this.length
            }

            Yallist.prototype.pop = function() {
                if (!this.tail) {
                    return undefined
                }

                var res = this.tail.value
                this.tail = this.tail.prev
                if (this.tail) {
                    this.tail.next = null
                } else {
                    this.head = null
                }
                this.length--
                return res
            }

            Yallist.prototype.shift = function() {
                if (!this.head) {
                    return undefined
                }

                var res = this.head.value
                this.head = this.head.next
                if (this.head) {
                    this.head.prev = null
                } else {
                    this.tail = null
                }
                this.length--
                return res
            }

            Yallist.prototype.forEach = function(fn, thisp) {
                thisp = thisp || this
                for (var walker = this.head, i = 0; walker !== null; i++) {
                    fn.call(thisp, walker.value, i, this)
                    walker = walker.next
                }
            }

            Yallist.prototype.forEachReverse = function(fn, thisp) {
                thisp = thisp || this
                for (
                    var walker = this.tail, i = this.length - 1;
                    walker !== null;
                    i--
                ) {
                    fn.call(thisp, walker.value, i, this)
                    walker = walker.prev
                }
            }

            Yallist.prototype.get = function(n) {
                for (
                    var i = 0, walker = this.head;
                    walker !== null && i < n;
                    i++
                ) {
                    // abort out of the list early if we hit a cycle
                    walker = walker.next
                }
                if (i === n && walker !== null) {
                    return walker.value
                }
            }

            Yallist.prototype.getReverse = function(n) {
                for (
                    var i = 0, walker = this.tail;
                    walker !== null && i < n;
                    i++
                ) {
                    // abort out of the list early if we hit a cycle
                    walker = walker.prev
                }
                if (i === n && walker !== null) {
                    return walker.value
                }
            }

            Yallist.prototype.map = function(fn, thisp) {
                thisp = thisp || this
                var res = new Yallist()
                for (var walker = this.head; walker !== null; ) {
                    res.push(fn.call(thisp, walker.value, this))
                    walker = walker.next
                }
                return res
            }

            Yallist.prototype.mapReverse = function(fn, thisp) {
                thisp = thisp || this
                var res = new Yallist()
                for (var walker = this.tail; walker !== null; ) {
                    res.push(fn.call(thisp, walker.value, this))
                    walker = walker.prev
                }
                return res
            }

            Yallist.prototype.reduce = function(fn, initial) {
                var acc
                var walker = this.head
                if (arguments.length > 1) {
                    acc = initial
                } else if (this.head) {
                    walker = this.head.next
                    acc = this.head.value
                } else {
                    throw new TypeError(
                        'Reduce of empty list with no initial value'
                    )
                }

                for (var i = 0; walker !== null; i++) {
                    acc = fn(acc, walker.value, i)
                    walker = walker.next
                }

                return acc
            }

            Yallist.prototype.reduceReverse = function(fn, initial) {
                var acc
                var walker = this.tail
                if (arguments.length > 1) {
                    acc = initial
                } else if (this.tail) {
                    walker = this.tail.prev
                    acc = this.tail.value
                } else {
                    throw new TypeError(
                        'Reduce of empty list with no initial value'
                    )
                }

                for (var i = this.length - 1; walker !== null; i--) {
                    acc = fn(acc, walker.value, i)
                    walker = walker.prev
                }

                return acc
            }

            Yallist.prototype.toArray = function() {
                var arr = new Array(this.length)
                for (var i = 0, walker = this.head; walker !== null; i++) {
                    arr[i] = walker.value
                    walker = walker.next
                }
                return arr
            }

            Yallist.prototype.toArrayReverse = function() {
                var arr = new Array(this.length)
                for (var i = 0, walker = this.tail; walker !== null; i++) {
                    arr[i] = walker.value
                    walker = walker.prev
                }
                return arr
            }

            Yallist.prototype.slice = function(from, to) {
                to = to || this.length
                if (to < 0) {
                    to += this.length
                }
                from = from || 0
                if (from < 0) {
                    from += this.length
                }
                var ret = new Yallist()
                if (to < from || to < 0) {
                    return ret
                }
                if (from < 0) {
                    from = 0
                }
                if (to > this.length) {
                    to = this.length
                }
                for (
                    var i = 0, walker = this.head;
                    walker !== null && i < from;
                    i++
                ) {
                    walker = walker.next
                }
                for (; walker !== null && i < to; i++, walker = walker.next) {
                    ret.push(walker.value)
                }
                return ret
            }

            Yallist.prototype.sliceReverse = function(from, to) {
                to = to || this.length
                if (to < 0) {
                    to += this.length
                }
                from = from || 0
                if (from < 0) {
                    from += this.length
                }
                var ret = new Yallist()
                if (to < from || to < 0) {
                    return ret
                }
                if (from < 0) {
                    from = 0
                }
                if (to > this.length) {
                    to = this.length
                }
                for (
                    var i = this.length, walker = this.tail;
                    walker !== null && i > to;
                    i--
                ) {
                    walker = walker.prev
                }
                for (; walker !== null && i > from; i--, walker = walker.prev) {
                    ret.push(walker.value)
                }
                return ret
            }

            Yallist.prototype.splice = function(
                start,
                deleteCount /*, ...nodes */
            ) {
                if (start > this.length) {
                    start = this.length - 1
                }
                if (start < 0) {
                    start = this.length + start
                }

                for (
                    var i = 0, walker = this.head;
                    walker !== null && i < start;
                    i++
                ) {
                    walker = walker.next
                }

                var ret = []
                for (var i = 0; walker && i < deleteCount; i++) {
                    ret.push(walker.value)
                    walker = this.removeNode(walker)
                }
                if (walker === null) {
                    walker = this.tail
                }

                if (walker !== this.head && walker !== this.tail) {
                    walker = walker.prev
                }

                for (var i = 2; i < arguments.length; i++) {
                    walker = insert(this, walker, arguments[i])
                }
                return ret
            }

            Yallist.prototype.reverse = function() {
                var head = this.head
                var tail = this.tail
                for (var walker = head; walker !== null; walker = walker.prev) {
                    var p = walker.prev
                    walker.prev = walker.next
                    walker.next = p
                }
                this.head = tail
                this.tail = head
                return this
            }

            function insert(self, node, value) {
                var inserted =
                    node === self.head
                        ? new Node(value, null, node, self)
                        : new Node(value, node, node.next, self)

                if (inserted.next === null) {
                    self.tail = inserted
                }
                if (inserted.prev === null) {
                    self.head = inserted
                }

                self.length++

                return inserted
            }

            function push(self, item) {
                self.tail = new Node(item, self.tail, null, self)
                if (!self.head) {
                    self.head = self.tail
                }
                self.length++
            }

            function unshift(self, item) {
                self.head = new Node(item, null, self.head, self)
                if (!self.tail) {
                    self.tail = self.head
                }
                self.length++
            }

            function Node(value, prev, next, list) {
                if (!(this instanceof Node)) {
                    return new Node(value, prev, next, list)
                }

                this.list = list
                this.value = value

                if (prev) {
                    prev.next = this
                    this.prev = prev
                } else {
                    this.prev = null
                }

                if (next) {
                    next.prev = this
                    this.next = next
                } else {
                    this.next = null
                }
            }

            try {
                // add if support for Symbol.iterator is present
                __webpack_require__('HwNo')(Yallist)
            } catch (er) {}

            /***/
        },

        /***/ XYm9: /***/ function(module, exports, __webpack_require__) {
            var cloneArrayBuffer = __webpack_require__('+K+b')

            /**
             * Creates a clone of `dataView`.
             *
             * @private
             * @param {Object} dataView The data view to clone.
             * @param {boolean} [isDeep] Specify a deep clone.
             * @returns {Object} Returns the cloned data view.
             */
            function cloneDataView(dataView, isDeep) {
                var buffer = isDeep
                    ? cloneArrayBuffer(dataView.buffer)
                    : dataView.buffer
                return new dataView.constructor(
                    buffer,
                    dataView.byteOffset,
                    dataView.byteLength
                )
            }

            module.exports = cloneDataView

            /***/
        },

        /***/ Xab3: /***/ function(module, exports) {
            /* global BigInt */

            const fromBase64 = base64 => {
                return base64
                    .replace(/=/g, '')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
            }

            const encode = (input, encoding = 'utf8') => {
                return fromBase64(
                    Buffer.from(input, encoding).toString('base64')
                )
            }

            const encodeBuffer = buf => {
                return fromBase64(buf.toString('base64'))
            }

            const decodeToBuffer = input => {
                return Buffer.from(input, 'base64')
            }

            const decode = (input, encoding = 'utf8') => {
                return decodeToBuffer(input).toString(encoding)
            }

            const b64uJSON = {
                encode: input => {
                    return encode(JSON.stringify(input))
                },
                decode: (input, encoding = 'utf8') => {
                    return JSON.parse(decode(input, encoding))
                }
            }

            b64uJSON.decode.try = (input, encoding = 'utf8') => {
                try {
                    return b64uJSON.decode(input, encoding)
                } catch (err) {
                    return decode(input, encoding)
                }
            }

            const bnToBuf = bn => {
                let hex = BigInt(bn).toString(16)
                if (hex.length % 2) {
                    hex = `0${hex}`
                }

                const len = hex.length / 2
                const u8 = new Uint8Array(len)

                let i = 0
                let j = 0
                while (i < len) {
                    u8[i] = parseInt(hex.slice(j, j + 2), 16)
                    i += 1
                    j += 2
                }

                return u8
            }

            const encodeBigInt = bn => encodeBuffer(Buffer.from(bnToBuf(bn)))

            module.exports.decode = decode
            module.exports.decodeToBuffer = decodeToBuffer
            module.exports.encode = encode
            module.exports.encodeBuffer = encodeBuffer
            module.exports.JSON = b64uJSON
            module.exports.encodeBigInt = encodeBigInt

            /***/
        },

        /***/ Xi7e: /***/ function(module, exports, __webpack_require__) {
            var listCacheClear = __webpack_require__('KMkd'),
                listCacheDelete = __webpack_require__('adU4'),
                listCacheGet = __webpack_require__('tMB7'),
                listCacheHas = __webpack_require__('+6XX'),
                listCacheSet = __webpack_require__('Z8oC')

            /**
             * Creates an list cache object.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function ListCache(entries) {
                var index = -1,
                    length = entries == null ? 0 : entries.length

                this.clear()
                while (++index < length) {
                    var entry = entries[index]
                    this.set(entry[0], entry[1])
                }
            }

            // Add methods to `ListCache`.
            ListCache.prototype.clear = listCacheClear
            ListCache.prototype['delete'] = listCacheDelete
            ListCache.prototype.get = listCacheGet
            ListCache.prototype.has = listCacheHas
            ListCache.prototype.set = listCacheSet

            module.exports = ListCache

            /***/
        },

        /***/ XoMD: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('hYAz')

            /***/
        },

        /***/ Xuae: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Set = __webpack_require__('ttDY')

            var _Object$defineProperty = __webpack_require__('hfKm')

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            const react_1 = __webpack_require__('q1tI')

            const isServer = true

            exports.default = () => {
                const mountedInstances = new _Set()
                let state

                function emitChange(component) {
                    state = component.props.reduceComponentsToState(
                        [...mountedInstances],
                        component.props
                    )

                    if (component.props.handleStateChange) {
                        component.props.handleStateChange(state)
                    }
                }

                return class extends react_1.Component {
                    // Used when server rendering
                    static rewind() {
                        const recordedState = state
                        state = undefined
                        mountedInstances.clear()
                        return recordedState
                    }

                    constructor(props) {
                        super(props)

                        if (isServer) {
                            mountedInstances.add(this)
                            emitChange(this)
                        }
                    }

                    componentDidMount() {
                        mountedInstances.add(this)
                        emitChange(this)
                    }

                    componentDidUpdate() {
                        emitChange(this)
                    }

                    componentWillUnmount() {
                        mountedInstances.delete(this)
                        emitChange(this)
                    }

                    render() {
                        return null
                    }
                }
            }

            /***/
        },

        /***/ Y4gF: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * etag
             * Copyright(c) 2014-2016 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module exports.
             * @public
             */

            module.exports = etag

            /**
             * Module dependencies.
             * @private
             */

            var crypto = __webpack_require__('PJMN')
            var Stats = __webpack_require__('mw/K').Stats

            /**
             * Module variables.
             * @private
             */

            var toString = Object.prototype.toString

            /**
             * Generate an entity tag.
             *
             * @param {Buffer|string} entity
             * @return {string}
             * @private
             */

            function entitytag(entity) {
                if (entity.length === 0) {
                    // fast-path empty
                    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"'
                }

                // compute hash of entity
                var hash = crypto
                    .createHash('sha1')
                    .update(entity, 'utf8')
                    .digest('base64')
                    .substring(0, 27)

                // compute length of entity
                var len =
                    typeof entity === 'string'
                        ? Buffer.byteLength(entity, 'utf8')
                        : entity.length

                return '"' + len.toString(16) + '-' + hash + '"'
            }

            /**
             * Create a simple ETag.
             *
             * @param {string|Buffer|Stats} entity
             * @param {object} [options]
             * @param {boolean} [options.weak]
             * @return {String}
             * @public
             */

            function etag(entity, options) {
                if (entity == null) {
                    throw new TypeError('argument entity is required')
                }

                // support fs.Stats object
                var isStats = isstats(entity)
                var weak =
                    options && typeof options.weak === 'boolean'
                        ? options.weak
                        : isStats

                // validate argument
                if (
                    !isStats &&
                    typeof entity !== 'string' &&
                    !Buffer.isBuffer(entity)
                ) {
                    throw new TypeError(
                        'argument entity must be string, Buffer, or fs.Stats'
                    )
                }

                // generate entity tag
                var tag = isStats ? stattag(entity) : entitytag(entity)

                return weak ? 'W/' + tag : tag
            }

            /**
             * Determine if object is a Stats object.
             *
             * @param {object} obj
             * @return {boolean}
             * @api private
             */

            function isstats(obj) {
                // genuine fs.Stats
                if (typeof Stats === 'function' && obj instanceof Stats) {
                    return true
                }

                // quack quack
                return (
                    obj &&
                    typeof obj === 'object' &&
                    'ctime' in obj &&
                    toString.call(obj.ctime) === '[object Date]' &&
                    'mtime' in obj &&
                    toString.call(obj.mtime) === '[object Date]' &&
                    'ino' in obj &&
                    typeof obj.ino === 'number' &&
                    'size' in obj &&
                    typeof obj.size === 'number'
                )
            }

            /**
             * Generate a tag for a stat.
             *
             * @param {object} stat
             * @return {string}
             * @private
             */

            function stattag(stat) {
                var mtime = stat.mtime.getTime().toString(16)
                var size = stat.size.toString(16)

                return '"' + size + '-' + mtime + '"'
            }

            /***/
        },

        /***/ Y7ZC: /***/ function(module, exports, __webpack_require__) {
            var global = __webpack_require__('5T2Y')
            var core = __webpack_require__('WEpk')
            var ctx = __webpack_require__('2GTP')
            var hide = __webpack_require__('NegM')
            var has = __webpack_require__('B+OT')
            var PROTOTYPE = 'prototype'

            var $export = function(type, name, source) {
                var IS_FORCED = type & $export.F
                var IS_GLOBAL = type & $export.G
                var IS_STATIC = type & $export.S
                var IS_PROTO = type & $export.P
                var IS_BIND = type & $export.B
                var IS_WRAP = type & $export.W
                var exports = IS_GLOBAL ? core : core[name] || (core[name] = {})
                var expProto = exports[PROTOTYPE]
                var target = IS_GLOBAL
                    ? global
                    : IS_STATIC
                    ? global[name]
                    : (global[name] || {})[PROTOTYPE]
                var key, own, out
                if (IS_GLOBAL) source = name
                for (key in source) {
                    // contains in native
                    own = !IS_FORCED && target && target[key] !== undefined
                    if (own && has(exports, key)) continue
                    // export native or passed
                    out = own ? target[key] : source[key]
                    // prevent global pollution for namespaces
                    exports[key] =
                        IS_GLOBAL && typeof target[key] != 'function'
                            ? source[key]
                            : // bind timers to global for call from export context
                            IS_BIND && own
                            ? ctx(out, global)
                            : // wrap global constructors for prevent change them in library
                            IS_WRAP && target[key] == out
                            ? (function(C) {
                                  var F = function(a, b, c) {
                                      if (this instanceof C) {
                                          switch (arguments.length) {
                                              case 0:
                                                  return new C()
                                              case 1:
                                                  return new C(a)
                                              case 2:
                                                  return new C(a, b)
                                          }
                                          return new C(a, b, c)
                                      }
                                      return C.apply(this, arguments)
                                  }
                                  F[PROTOTYPE] = C[PROTOTYPE]
                                  return F
                                  // make static versions for prototype methods
                              })(out)
                            : IS_PROTO && typeof out == 'function'
                            ? ctx(Function.call, out)
                            : out
                    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
                    if (IS_PROTO) {
                        ;(exports.virtual || (exports.virtual = {}))[key] = out
                        // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
                        if (type & $export.R && expProto && !expProto[key])
                            hide(expProto, key, out)
                    }
                }
            }
            // type bitmap
            $export.F = 1 // forced
            $export.G = 2 // global
            $export.S = 4 // static
            $export.P = 8 // proto
            $export.B = 16 // bind
            $export.W = 32 // wrap
            $export.U = 64 // safe
            $export.R = 128 // real proto method for `library`
            module.exports = $export

            /***/
        },

        /***/ YESw: /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5')

            /* Built-in method references that are verified to be native. */
            var nativeCreate = getNative(Object, 'create')

            module.exports = nativeCreate

            /***/
        },

        /***/ YFSu: /***/ function(module, exports) {
            module.exports = function() {
                this.octstr()
                    .contains()
                    .obj(this.key('privateKey').octstr())
            }

            /***/
        },

        /***/ YFqc: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('cTJO')

            /***/
        },

        /***/ YNnK: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const PassThrough = __webpack_require__('msIP').PassThrough
            const zlib = __webpack_require__('FMKJ')
            const mimicResponse = __webpack_require__('qsvm')

            module.exports = response => {
                // TODO: Use Array#includes when targeting Node.js 6
                if (
                    ['gzip', 'deflate'].indexOf(
                        response.headers['content-encoding']
                    ) === -1
                ) {
                    return response
                }

                const unzip = zlib.createUnzip()
                const stream = new PassThrough()

                mimicResponse(response, stream)

                unzip.on('error', err => {
                    if (err.code === 'Z_BUF_ERROR') {
                        stream.end()
                        return
                    }

                    stream.emit('error', err)
                })

                response.pipe(unzip).pipe(stream)

                return stream
            }

            /***/
        },

        /***/ YO3V: /***/ function(module, exports, __webpack_require__) {
            var baseGetTag = __webpack_require__('NykK'),
                getPrototype = __webpack_require__('LcsW'),
                isObjectLike = __webpack_require__('ExA7')

            /** `Object#toString` result references. */
            var objectTag = '[object Object]'

            /** Used for built-in method references. */
            var funcProto = Function.prototype,
                objectProto = Object.prototype

            /** Used to resolve the decompiled source of functions. */
            var funcToString = funcProto.toString

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /** Used to infer the `Object` constructor. */
            var objectCtorString = funcToString.call(Object)

            /**
             * Checks if `value` is a plain object, that is, an object created by the
             * `Object` constructor or one with a `[[Prototype]]` of `null`.
             *
             * @static
             * @memberOf _
             * @since 0.8.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
             * @example
             *
             * function Foo() {
             *   this.a = 1;
             * }
             *
             * _.isPlainObject(new Foo);
             * // => false
             *
             * _.isPlainObject([1, 2, 3]);
             * // => false
             *
             * _.isPlainObject({ 'x': 0, 'y': 0 });
             * // => true
             *
             * _.isPlainObject(Object.create(null));
             * // => true
             */
            function isPlainObject(value) {
                if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                    return false
                }
                var proto = getPrototype(value)
                if (proto === null) {
                    return true
                }
                var Ctor =
                    hasOwnProperty.call(proto, 'constructor') &&
                    proto.constructor
                return (
                    typeof Ctor == 'function' &&
                    Ctor instanceof Ctor &&
                    funcToString.call(Ctor) == objectCtorString
                )
            }

            module.exports = isPlainObject

            /***/
        },

        /***/ YTqd: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$defineProperty = __webpack_require__('hfKm')

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            function getRouteRegex(normalizedRoute) {
                // Escape all characters that could be considered RegEx
                const escapedRoute = (
                    normalizedRoute.replace(/\/$/, '') || '/'
                ).replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&')
                const groups = {}
                let groupIndex = 1
                const parameterizedRoute = escapedRoute.replace(
                    /\/\\\[([^/]+?)\\\](?=\/|$)/g,
                    (_, $1) => (
                        (groups[
                            $1 // Un-escape key
                                .replace(/\\([|\\{}()[\]^$+*?.-])/g, '$1')
                                .replace(/^\.{3}/, '') // eslint-disable-next-line no-sequences
                        ] = groupIndex++),
                        $1.indexOf('\\.\\.\\.') === 0 ? '/(.+?)' : '/([^/]+?)'
                    )
                )
                return {
                    re: new RegExp('^' + parameterizedRoute + '(?:/)?$', 'i'),
                    groups
                }
            }

            exports.getRouteRegex = getRouteRegex

            /***/
        },

        /***/ YqAc: /***/ function(module, exports) {
            var id = 0
            var px = Math.random()
            module.exports = function(key) {
                return 'Symbol('.concat(
                    key === undefined ? '' : key,
                    ')_',
                    (++id + px).toString(36)
                )
            }

            /***/
        },

        /***/ YuTi: /***/ function(module, exports) {
            module.exports = function(module) {
                if (!module.webpackPolyfill) {
                    module.deprecate = function() {}
                    module.paths = []
                    // module.parent = undefined by default
                    if (!module.children) module.children = []
                    Object.defineProperty(module, 'loaded', {
                        enumerable: true,
                        get: function() {
                            return module.l
                        }
                    })
                    Object.defineProperty(module, 'id', {
                        enumerable: true,
                        get: function() {
                            return module.i
                        }
                    })
                    module.webpackPolyfill = 1
                }
                return module
            }

            /***/
        },

        /***/ Z0cm: /***/ function(module, exports) {
            /**
             * Checks if `value` is classified as an `Array` object.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is an array, else `false`.
             * @example
             *
             * _.isArray([1, 2, 3]);
             * // => true
             *
             * _.isArray(document.body.children);
             * // => false
             *
             * _.isArray('abc');
             * // => false
             *
             * _.isArray(_.noop);
             * // => false
             */
            var isArray = Array.isArray

            module.exports = isArray

            /***/
        },

        /***/ Z8oC: /***/ function(module, exports, __webpack_require__) {
            var assocIndexOf = __webpack_require__('y1pI')

            /**
             * Sets the list cache `key` to `value`.
             *
             * @private
             * @name set
             * @memberOf ListCache
             * @param {string} key The key of the value to set.
             * @param {*} value The value to set.
             * @returns {Object} Returns the list cache instance.
             */
            function listCacheSet(key, value) {
                var data = this.__data__,
                    index = assocIndexOf(data, key)

                if (index < 0) {
                    ++this.size
                    data.push([key, value])
                } else {
                    data[index][1] = value
                }
                return this
            }

            module.exports = listCacheSet

            /***/
        },

        /***/ Z9M3: /***/ function(module, exports, __webpack_require__) {
            const { inherits } = __webpack_require__('jK02')

            const { Reporter } = __webpack_require__('1WHo')

            function DecoderBuffer(base, options) {
                Reporter.call(this, options)
                if (!Buffer.isBuffer(base)) {
                    this.error('Input not Buffer')
                    return
                }

                this.base = base
                this.offset = 0
                this.length = base.length
            }
            inherits(DecoderBuffer, Reporter)

            DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
                if (data instanceof DecoderBuffer) {
                    return true
                }

                // Or accept compatible API
                const isCompatible =
                    typeof data === 'object' &&
                    Buffer.isBuffer(data.base) &&
                    data.constructor.name === 'DecoderBuffer' &&
                    typeof data.offset === 'number' &&
                    typeof data.length === 'number' &&
                    typeof data.save === 'function' &&
                    typeof data.restore === 'function' &&
                    typeof data.isEmpty === 'function' &&
                    typeof data.readUInt8 === 'function' &&
                    typeof data.skip === 'function' &&
                    typeof data.raw === 'function'

                return isCompatible
            }

            DecoderBuffer.prototype.save = function save() {
                return {
                    offset: this.offset,
                    reporter: Reporter.prototype.save.call(this)
                }
            }

            DecoderBuffer.prototype.restore = function restore(save) {
                // Return skipped data
                const res = new DecoderBuffer(this.base)
                res.offset = save.offset
                res.length = this.offset

                this.offset = save.offset
                Reporter.prototype.restore.call(this, save.reporter)

                return res
            }

            DecoderBuffer.prototype.isEmpty = function isEmpty() {
                return this.offset === this.length
            }

            DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
                if (this.offset + 1 <= this.length) {
                    return this.base.readUInt8(this.offset++, true)
                } else {
                    return this.error(fail || 'DecoderBuffer overrun')
                }
            }

            DecoderBuffer.prototype.skip = function skip(bytes, fail) {
                if (!(this.offset + bytes <= this.length)) {
                    return this.error(fail || 'DecoderBuffer overrun')
                }

                const res = new DecoderBuffer(this.base)

                // Share reporter state
                res._reporterState = this._reporterState

                res.offset = this.offset
                res.length = this.offset + bytes
                this.offset += bytes
                return res
            }

            DecoderBuffer.prototype.raw = function raw(save) {
                return this.base.slice(
                    save ? save.offset : this.offset,
                    this.length
                )
            }

            function EncoderBuffer(value, reporter) {
                if (Array.isArray(value)) {
                    this.length = 0
                    this.value = value.map(function(item) {
                        if (!EncoderBuffer.isEncoderBuffer(item)) {
                            item = new EncoderBuffer(item, reporter)
                        }
                        this.length += item.length
                        return item
                    }, this)
                } else if (typeof value === 'number') {
                    if (!(value >= 0 && value <= 0xff)) {
                        return reporter.error('non-byte EncoderBuffer value')
                    }
                    this.value = value
                    this.length = 1
                } else if (typeof value === 'string') {
                    this.value = value
                    this.length = Buffer.byteLength(value)
                } else if (Buffer.isBuffer(value)) {
                    this.value = value
                    this.length = value.length
                } else {
                    return reporter.error(`Unsupported type: ${typeof value}`)
                }
            }

            EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
                if (data instanceof EncoderBuffer) {
                    return true
                }

                // Or accept compatible API
                const isCompatible =
                    typeof data === 'object' &&
                    data.constructor.name === 'EncoderBuffer' &&
                    typeof data.length === 'number' &&
                    typeof data.join === 'function'

                return isCompatible
            }

            EncoderBuffer.prototype.join = function join(out, offset) {
                if (!out) {
                    out = Buffer.alloc(this.length)
                }
                if (!offset) {
                    offset = 0
                }

                if (this.length === 0) {
                    return out
                }

                if (Array.isArray(this.value)) {
                    this.value.forEach(function(item) {
                        item.join(out, offset)
                        offset += item.length
                    })
                } else {
                    if (typeof this.value === 'number') {
                        out[offset] = this.value
                    } else if (typeof this.value === 'string') {
                        out.write(this.value, offset)
                    } else if (Buffer.isBuffer(this.value)) {
                        this.value.copy(out, offset)
                    }
                    offset += this.length
                }

                return out
            }

            module.exports = {
                DecoderBuffer,
                EncoderBuffer
            }

            /***/
        },

        /***/ ZCpW: /***/ function(module, exports, __webpack_require__) {
            var baseIsMatch = __webpack_require__('lm/5'),
                getMatchData = __webpack_require__('O7RO'),
                matchesStrictComparable = __webpack_require__('IOzZ')

            /**
             * The base implementation of `_.matches` which doesn't clone `source`.
             *
             * @private
             * @param {Object} source The object of property values to match.
             * @returns {Function} Returns the new spec function.
             */
            function baseMatches(source) {
                var matchData = getMatchData(source)
                if (matchData.length == 1 && matchData[0][2]) {
                    return matchesStrictComparable(
                        matchData[0][0],
                        matchData[0][1]
                    )
                }
                return function(object) {
                    return (
                        object === source ||
                        baseIsMatch(object, source, matchData)
                    )
                }
            }

            module.exports = baseMatches

            /***/
        },

        /***/ ZUdF: /***/ function(module, exports, __webpack_require__) {
            /* global BigInt */
            const { inherits } = __webpack_require__('jK02')

            const Node = __webpack_require__('k+0e')
            const der = __webpack_require__('1Gj5')

            function DEREncoder(entity) {
                this.enc = 'der'
                this.name = entity.name
                this.entity = entity

                // Construct base tree
                this.tree = new DERNode()
                this.tree._init(entity.body)
            }

            DEREncoder.prototype.encode = function encode(data, reporter) {
                return this.tree._encode(data, reporter).join()
            }

            // Tree methods

            function DERNode(parent) {
                Node.call(this, 'der', parent)
            }
            inherits(DERNode, Node)

            DERNode.prototype._encodeComposite = function encodeComposite(
                tag,
                primitive,
                cls,
                content
            ) {
                const encodedTag = encodeTag(tag, primitive, cls, this.reporter)

                // Short form
                if (content.length < 0x80) {
                    const header = Buffer.alloc(2)
                    header[0] = encodedTag
                    header[1] = content.length
                    return this._createEncoderBuffer([header, content])
                }

                // Long form
                // Count octets required to store length
                let lenOctets = 1
                for (let i = content.length; i >= 0x100; i >>= 8) {
                    lenOctets++
                }

                const header = Buffer.alloc(1 + 1 + lenOctets)
                header[0] = encodedTag
                header[1] = 0x80 | lenOctets

                for (
                    let i = 1 + lenOctets, j = content.length;
                    j > 0;
                    i--, j >>= 8
                ) {
                    header[i] = j & 0xff
                }

                return this._createEncoderBuffer([header, content])
            }

            DERNode.prototype._encodeStr = function encodeStr(str, tag) {
                if (tag === 'bitstr') {
                    return this._createEncoderBuffer([str.unused | 0, str.data])
                } else if (tag === 'bmpstr') {
                    const buf = Buffer.alloc(str.length * 2)
                    for (let i = 0; i < str.length; i++) {
                        buf.writeUInt16BE(str.charCodeAt(i), i * 2)
                    }
                    return this._createEncoderBuffer(buf)
                } else if (tag === 'numstr') {
                    if (!this._isNumstr(str)) {
                        return this.reporter.error(
                            'Encoding of string type: numstr supports only digits and space'
                        )
                    }
                    return this._createEncoderBuffer(str)
                } else if (tag === 'printstr') {
                    if (!this._isPrintstr(str)) {
                        return this.reporter.error(
                            'Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark'
                        )
                    }
                    return this._createEncoderBuffer(str)
                } else if (/str$/.test(tag)) {
                    return this._createEncoderBuffer(str)
                } else if (tag === 'objDesc') {
                    return this._createEncoderBuffer(str)
                } else {
                    return this.reporter.error(
                        `Encoding of string type: ${tag} unsupported`
                    )
                }
            }

            DERNode.prototype._encodeObjid = function encodeObjid(
                id,
                values,
                relative
            ) {
                if (typeof id === 'string') {
                    if (!values) {
                        return this.reporter.error(
                            'string objid given, but no values map found'
                        )
                    }
                    if (!Object.prototype.hasOwnProperty.call(values, id)) {
                        return this.reporter.error(
                            'objid not found in values map'
                        )
                    }
                    id = values[id].split(/[\s.]+/g)
                    for (let i = 0; i < id.length; i++) {
                        id[i] |= 0
                    }
                } else if (Array.isArray(id)) {
                    id = id.slice()
                    for (let i = 0; i < id.length; i++) {
                        id[i] |= 0
                    }
                }

                if (!Array.isArray(id)) {
                    return this.reporter.error(
                        `objid() should be either array or string, got: ${JSON.stringify(
                            id
                        )}`
                    )
                }

                if (!relative) {
                    if (id[1] >= 40) {
                        return this.reporter.error(
                            'Second objid identifier OOB'
                        )
                    }
                    id.splice(0, 2, id[0] * 40 + id[1])
                }

                // Count number of octets
                let size = 0
                for (let i = 0; i < id.length; i++) {
                    let ident = id[i]
                    for (size++; ident >= 0x80; ident >>= 7) {
                        size++
                    }
                }

                const objid = Buffer.alloc(size)
                let offset = objid.length - 1
                for (let i = id.length - 1; i >= 0; i--) {
                    let ident = id[i]
                    objid[offset--] = ident & 0x7f
                    while ((ident >>= 7) > 0) {
                        objid[offset--] = 0x80 | (ident & 0x7f)
                    }
                }

                return this._createEncoderBuffer(objid)
            }

            function two(num) {
                if (num < 10) {
                    return `0${num}`
                } else {
                    return num
                }
            }

            DERNode.prototype._encodeTime = function encodeTime(time, tag) {
                let str
                const date = new Date(time)

                if (tag === 'gentime') {
                    str = [
                        two(date.getUTCFullYear()),
                        two(date.getUTCMonth() + 1),
                        two(date.getUTCDate()),
                        two(date.getUTCHours()),
                        two(date.getUTCMinutes()),
                        two(date.getUTCSeconds()),
                        'Z'
                    ].join('')
                } else if (tag === 'utctime') {
                    str = [
                        two(date.getUTCFullYear() % 100),
                        two(date.getUTCMonth() + 1),
                        two(date.getUTCDate()),
                        two(date.getUTCHours()),
                        two(date.getUTCMinutes()),
                        two(date.getUTCSeconds()),
                        'Z'
                    ].join('')
                } else {
                    this.reporter.error(
                        `Encoding ${tag} time is not supported yet`
                    )
                }

                return this._encodeStr(str, 'octstr')
            }

            DERNode.prototype._encodeNull = function encodeNull() {
                return this._createEncoderBuffer('')
            }

            function bnToBuf(bn) {
                var hex = BigInt(bn).toString(16)
                if (hex.length % 2) {
                    hex = '0' + hex
                }

                var len = hex.length / 2
                var u8 = new Uint8Array(len)

                var i = 0
                var j = 0
                while (i < len) {
                    u8[i] = parseInt(hex.slice(j, j + 2), 16)
                    i += 1
                    j += 2
                }

                return u8
            }

            DERNode.prototype._encodeInt = function encodeInt(num, values) {
                if (typeof num === 'string') {
                    if (!values) {
                        return this.reporter.error(
                            'String int or enum given, but no values map'
                        )
                    }
                    if (!Object.prototype.hasOwnProperty.call(values, num)) {
                        return this.reporter.error(
                            `Values map doesn't contain: ${JSON.stringify(num)}`
                        )
                    }
                    num = values[num]
                }

                if (typeof num === 'bigint') {
                    const numArray = [...bnToBuf(num)]
                    if (numArray[0] & 0x80) {
                        numArray.unshift(0)
                    }
                    num = Buffer.from(numArray)
                }

                if (Buffer.isBuffer(num)) {
                    let size = num.length
                    if (num.length === 0) {
                        size++
                    }

                    const out = Buffer.alloc(size)
                    num.copy(out)
                    if (num.length === 0) {
                        out[0] = 0
                    }
                    return this._createEncoderBuffer(out)
                }

                if (num < 0x80) {
                    return this._createEncoderBuffer(num)
                }

                if (num < 0x100) {
                    return this._createEncoderBuffer([0, num])
                }

                let size = 1
                for (let i = num; i >= 0x100; i >>= 8) {
                    size++
                }

                const out = new Array(size)
                for (let i = out.length - 1; i >= 0; i--) {
                    out[i] = num & 0xff
                    num >>= 8
                }
                if (out[0] & 0x80) {
                    out.unshift(0)
                }

                return this._createEncoderBuffer(Buffer.from(out))
            }

            DERNode.prototype._encodeBool = function encodeBool(value) {
                return this._createEncoderBuffer(value ? 0xff : 0)
            }

            DERNode.prototype._use = function use(entity, obj) {
                if (typeof entity === 'function') {
                    entity = entity(obj)
                }
                return entity._getEncoder('der').tree
            }

            DERNode.prototype._skipDefault = function skipDefault(
                dataBuffer,
                reporter,
                parent
            ) {
                const state = this._baseState
                let i
                if (state.default === null) {
                    return false
                }

                const data = dataBuffer.join()
                if (state.defaultBuffer === undefined) {
                    state.defaultBuffer = this._encodeValue(
                        state.default,
                        reporter,
                        parent
                    ).join()
                }

                if (data.length !== state.defaultBuffer.length) {
                    return false
                }

                for (i = 0; i < data.length; i++) {
                    if (data[i] !== state.defaultBuffer[i]) {
                        return false
                    }
                }

                return true
            }

            // Utility methods

            function encodeTag(tag, primitive, cls, reporter) {
                let res

                if (tag === 'seqof') {
                    tag = 'seq'
                } else if (tag === 'setof') {
                    tag = 'set'
                }

                if (Object.prototype.hasOwnProperty.call(der.tagByName, tag)) {
                    res = der.tagByName[tag]
                } else if (typeof tag === 'number' && (tag | 0) === tag) {
                    res = tag
                } else {
                    return reporter.error(`Unknown tag: ${tag}`)
                }

                if (res >= 0x1f) {
                    return reporter.error(
                        'Multi-octet tag encoding unsupported'
                    )
                }

                if (!primitive) {
                    res |= 0x20
                }

                res |= der.tagClassByName[cls || 'universal'] << 6

                return res
            }

            module.exports = DEREncoder

            /***/
        },

        /***/ ZW5q: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // 25.4.1.5 NewPromiseCapability(C)
            var aFunction = __webpack_require__('eaoh')

            function PromiseCapability(C) {
                var resolve, reject
                this.promise = new C(function($$resolve, $$reject) {
                    if (resolve !== undefined || reject !== undefined)
                        throw TypeError('Bad Promise constructor')
                    resolve = $$resolve
                    reject = $$reject
                })
                this.resolve = aFunction(resolve)
                this.reject = aFunction(reject)
            }

            module.exports.f = function(C) {
                return new PromiseCapability(C)
            }

            /***/
        },

        /***/ ZWtO: /***/ function(module, exports, __webpack_require__) {
            var castPath = __webpack_require__('4uTw'),
                toKey = __webpack_require__('9Nap')

            /**
             * The base implementation of `_.get` without support for default values.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Array|string} path The path of the property to get.
             * @returns {*} Returns the resolved value.
             */
            function baseGet(object, path) {
                path = castPath(path, object)

                var index = 0,
                    length = path.length

                while (object != null && index < length) {
                    object = object[toKey(path[index++])]
                }
                return index && index == length ? object : undefined
            }

            module.exports = baseGet

            /***/
        },

        /***/ ZXG7: /***/ function(module, exports, __webpack_require__) {
            const base64url = __webpack_require__('Xab3')
            const isDisjoint = __webpack_require__('KQbz')
            let validateCrit = __webpack_require__('urXW')
            const getKey = __webpack_require__('oGTz')
            const { KeyStore } = __webpack_require__('WPgm')
            const errors = __webpack_require__('yt7c')
            const { check, verify } = __webpack_require__('FUB/')

            const { detect: resolveSerialization } = __webpack_require__('SwXk')

            validateCrit = validateCrit.bind(undefined, errors.JWSInvalid)
            const SINGLE_RECIPIENT = new Set([
                'compact',
                'flattened',
                'preparsed'
            ])

            /*
             * @public
             */
            const jwsVerify = (
                skipDisjointCheck,
                serialization,
                jws,
                key,
                {
                    crit = [],
                    complete = false,
                    algorithms,
                    parse = true,
                    encoding = 'utf8'
                } = {}
            ) => {
                key = getKey(key, true)

                if (
                    algorithms !== undefined &&
                    (!Array.isArray(algorithms) ||
                        algorithms.some(s => typeof s !== 'string' || !s))
                ) {
                    throw new TypeError(
                        '"algorithms" option must be an array of non-empty strings'
                    )
                } else if (algorithms) {
                    algorithms = new Set(algorithms)
                }

                if (
                    !Array.isArray(crit) ||
                    crit.some(s => typeof s !== 'string' || !s)
                ) {
                    throw new TypeError(
                        '"crit" option must be an array of non-empty strings'
                    )
                }

                if (!serialization) {
                    serialization = resolveSerialization(jws)
                }

                let prot // protected header
                let header // unprotected header
                let payload
                let signature
                let alg

                // treat general format with one recipient as flattened
                // skips iteration and avoids multi errors in this case
                if (
                    serialization === 'general' &&
                    jws.signatures.length === 1
                ) {
                    serialization = 'flattened'
                    const { signatures, ...root } = jws
                    jws = { ...root, ...signatures[0] }
                }

                let decoded

                if (SINGLE_RECIPIENT.has(serialization)) {
                    let parsedProt = {}

                    switch (serialization) {
                        case 'compact': // compact serialization format
                            ;[prot, payload, signature] = jws.split('.')
                            break
                        case 'flattened': // flattened serialization format
                            ;({
                                protected: prot,
                                payload,
                                signature,
                                header
                            } = jws)
                            break
                        case 'preparsed': {
                            // from the JWT module
                            ;({ decoded } = jws)
                            ;[prot, payload, signature] = jws.token.split('.')
                            break
                        }
                    }

                    if (!header) {
                        skipDisjointCheck = true
                    }

                    if (decoded) {
                        parsedProt = decoded.header
                    } else if (prot) {
                        try {
                            parsedProt = base64url.JSON.decode(prot)
                        } catch (err) {
                            throw new errors.JWSInvalid(
                                'could not parse JWS protected header'
                            )
                        }
                    } else {
                        skipDisjointCheck = skipDisjointCheck || true
                    }

                    if (!skipDisjointCheck && !isDisjoint(parsedProt, header)) {
                        throw new errors.JWSInvalid(
                            'JWS Protected and JWS Unprotected Header Parameter names must be disjoint'
                        )
                    }

                    const combinedHeader = { ...parsedProt, ...header }
                    validateCrit(parsedProt, header, crit)

                    alg = parsedProt.alg || (header && header.alg)
                    if (!alg) {
                        throw new errors.JWSInvalid(
                            'missing JWS signature algorithm'
                        )
                    } else if (algorithms && !algorithms.has(alg)) {
                        throw new errors.JOSEAlgNotWhitelisted(
                            'alg not whitelisted'
                        )
                    }

                    if (key instanceof KeyStore) {
                        const keystore = key
                        const keys = keystore.all({
                            kid: combinedHeader.kid,
                            alg: combinedHeader.alg,
                            key_ops: ['verify']
                        })
                        switch (keys.length) {
                            case 0:
                                throw new errors.JWKSNoMatchingKey()
                            case 1:
                                // treat the call as if a Key instance was passed in
                                // skips iteration and avoids multi errors in this case
                                key = keys[0]
                                break
                            default: {
                                const errs = []
                                for (const key of keys) {
                                    try {
                                        return jwsVerify(
                                            true,
                                            serialization,
                                            jws,
                                            key,
                                            {
                                                crit,
                                                complete,
                                                encoding,
                                                parse,
                                                algorithms: algorithms
                                                    ? [...algorithms]
                                                    : undefined
                                            }
                                        )
                                    } catch (err) {
                                        errs.push(err)
                                        continue
                                    }
                                }

                                const multi = new errors.JOSEMultiError(errs)
                                if (
                                    [...multi].some(
                                        e =>
                                            e instanceof
                                            errors.JWSVerificationFailed
                                    )
                                ) {
                                    throw new errors.JWSVerificationFailed()
                                }
                                throw multi
                            }
                        }
                    }

                    check(key, 'verify', alg)

                    const toBeVerified = Buffer.concat([
                        Buffer.from(prot || ''),
                        Buffer.from('.'),
                        Buffer.isBuffer(payload)
                            ? payload
                            : Buffer.from(payload)
                    ])

                    if (
                        !verify(
                            alg,
                            key,
                            toBeVerified,
                            base64url.decodeToBuffer(signature)
                        )
                    ) {
                        throw new errors.JWSVerificationFailed()
                    }

                    if (
                        !combinedHeader.crit ||
                        !combinedHeader.crit.includes('b64') ||
                        combinedHeader.b64
                    ) {
                        if (parse) {
                            payload = decoded
                                ? decoded.payload
                                : base64url.JSON.decode.try(payload, encoding)
                        } else {
                            payload = base64url.decodeToBuffer(payload)
                        }
                    }

                    if (complete) {
                        const result = { payload, key }
                        if (prot) result.protected = parsedProt
                        if (header) result.header = header
                        return result
                    }

                    return payload
                }

                // general serialization format
                const { signatures, ...root } = jws
                const errs = []
                for (const recipient of signatures) {
                    try {
                        return jwsVerify(
                            false,
                            'flattened',
                            { ...root, ...recipient },
                            key,
                            {
                                crit,
                                complete,
                                encoding,
                                parse,
                                algorithms: algorithms
                                    ? [...algorithms]
                                    : undefined
                            }
                        )
                    } catch (err) {
                        errs.push(err)
                        continue
                    }
                }

                const multi = new errors.JOSEMultiError(errs)
                if (
                    [...multi].some(
                        e => e instanceof errors.JWSVerificationFailed
                    )
                ) {
                    throw new errors.JWSVerificationFailed()
                } else if (
                    [...multi].every(e => e instanceof errors.JWKSNoMatchingKey)
                ) {
                    throw new errors.JWKSNoMatchingKey()
                }
                throw multi
            }

            module.exports = {
                bare: jwsVerify,
                verify: jwsVerify.bind(undefined, false, undefined)
            }

            /***/
        },

        /***/ ZfBq: /***/ function(module, exports, __webpack_require__) {
            const { strict: assert } = __webpack_require__('Qs3B')
            const { createHash } = __webpack_require__('PJMN')
            const { format } = __webpack_require__('jK02')

            const shake256 = __webpack_require__('5sMl')

            const fromBase64 = base64 =>
                base64
                    .replace(/=/g, '')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
            const encode = input => fromBase64(input.toString('base64'))

            /** SPECIFICATION
             * Its (_hash) value is the base64url encoding of the left-most half of the hash of the octets of
             * the ASCII representation of the token value, where the hash algorithm used is the hash algorithm
             * used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is
             * RS256, hash the token value with SHA-256, then take the left-most 128 bits and base64url encode
             * them. The _hash value is a case sensitive string.
             */

            /**
             * @name getHash
             * @api private
             *
             * returns the sha length based off the JOSE alg heade value, defaults to sha256
             *
             * @param token {String} token value to generate the hash from
             * @param alg {String} ID Token JOSE header alg value (i.e. RS256, HS384, ES512, PS256)
             * @param [crv] {String} For EdDSA the curve decides what hash algorithm is used. Required for EdDSA
             */
            function getHash(alg, crv) {
                switch (alg) {
                    case 'HS256':
                    case 'RS256':
                    case 'PS256':
                    case 'ES256':
                    case 'ES256K':
                        return createHash('sha256')

                    case 'HS384':
                    case 'RS384':
                    case 'PS384':
                    case 'ES384':
                        return createHash('sha384')

                    case 'HS512':
                    case 'RS512':
                    case 'PS512':
                    case 'ES512':
                        return createHash('sha512')

                    case 'EdDSA':
                        switch (crv) {
                            case 'Ed25519':
                                return createHash('sha512')
                            case 'Ed448':
                                if (!shake256) {
                                    throw new TypeError(
                                        'Ed448 *_hash calculation is not supported in your Node.js runtime version'
                                    )
                                }

                                return createHash('shake256', {
                                    outputLength: 114
                                })
                            default:
                                throw new TypeError(
                                    'unrecognized or invalid EdDSA curve provided'
                                )
                        }

                    default:
                        throw new TypeError(
                            'unrecognized or invalid JWS algorithm provided'
                        )
                }
            }

            function generate(token, alg, crv) {
                const digest = getHash(alg, crv)
                    .update(token)
                    .digest()
                return encode(digest.slice(0, digest.length / 2))
            }

            function validate(names, actual, source, alg, crv) {
                if (typeof names.claim !== 'string' || !names.claim) {
                    throw new TypeError(
                        'names.claim must be a non-empty string'
                    )
                }

                if (typeof names.source !== 'string' || !names.source) {
                    throw new TypeError(
                        'names.source must be a non-empty string'
                    )
                }

                assert(
                    typeof actual === 'string' && actual,
                    `${names.claim} must be a non-empty string`
                )
                assert(
                    typeof source === 'string' && source,
                    `${names.source} must be a non-empty string`
                )

                let expected
                let msg
                try {
                    expected = generate(source, alg, crv)
                } catch (err) {
                    msg = format(
                        '%s could not be validated (%s)',
                        names.claim,
                        err.message
                    )
                }

                msg =
                    msg ||
                    format(
                        '%s mismatch, expected %s, got: %s',
                        names.claim,
                        expected,
                        actual
                    )

                assert.equal(expected, actual, msg)
            }

            module.exports = {
                validate,
                generate
            }

            /***/
        },

        /***/ Zxgi: /***/ function(module, exports, __webpack_require__) {
            var global = __webpack_require__('5T2Y')
            var core = __webpack_require__('WEpk')
            var LIBRARY = __webpack_require__('uOPS')
            var wksExt = __webpack_require__('zLkG')
            var defineProperty = __webpack_require__('2faE').f
            module.exports = function(name) {
                var $Symbol =
                    core.Symbol ||
                    (core.Symbol = LIBRARY ? {} : global.Symbol || {})
                if (name.charAt(0) != '_' && !(name in $Symbol))
                    defineProperty($Symbol, name, { value: wksExt.f(name) })
            }

            /***/
        },

        /***/ a0xu: /***/ function(module, exports) {
            var toString = {}.toString

            module.exports = function(it) {
                return toString.call(it).slice(8, -1)
            }

            /***/
        },

        /***/ aIoy: /***/ function(module, exports, __webpack_require__) {
            const { deprecate, inspect } = __webpack_require__('jK02')

            const isObject = __webpack_require__('kF1/')
            const { generate, generateSync } = __webpack_require__('LDEB')
            const { USES_MAPPING } = __webpack_require__('ehsS')
            const { None, isKey, asKey: importKey } = __webpack_require__(
                'lA9T'
            )

            const keyscore = (key, { alg, use, ops }) => {
                let score = 0

                if (alg && key.alg) {
                    score++
                }

                if (use && key.use) {
                    score++
                }

                if (ops && key.key_ops) {
                    score++
                }

                return score
            }

            class KeyStore {
                constructor(...keys) {
                    while (keys.some(Array.isArray)) {
                        keys = keys.flat
                            ? keys.flat()
                            : keys.reduce((acc, val) => {
                                  if (Array.isArray(val)) {
                                      return [...acc, ...val]
                                  }

                                  acc.push(val)
                                  return acc
                              }, [])
                    }
                    if (keys.some(k => !isKey(k) || k === None)) {
                        throw new TypeError(
                            'all keys must be instances of a key instantiated by JWK.asKey'
                        )
                    }

                    this._keys = new Set(keys)
                }

                all({
                    alg,
                    kid,
                    thumbprint,
                    use,
                    kty,
                    key_ops: ops,
                    x5t,
                    'x5t#S256': x5t256,
                    crv
                } = {}) {
                    if (
                        ops !== undefined &&
                        (!Array.isArray(ops) ||
                            !ops.length ||
                            ops.some(x => typeof x !== 'string'))
                    ) {
                        throw new TypeError(
                            '`key_ops` must be a non-empty array of strings'
                        )
                    }

                    const search = { alg, use, ops }
                    return [...this._keys]
                        .filter(key => {
                            let candidate = true

                            if (
                                candidate &&
                                kid !== undefined &&
                                key.kid !== kid
                            ) {
                                candidate = false
                            }

                            if (
                                candidate &&
                                thumbprint !== undefined &&
                                key.thumbprint !== thumbprint
                            ) {
                                candidate = false
                            }

                            if (
                                candidate &&
                                x5t !== undefined &&
                                key.x5t !== x5t
                            ) {
                                candidate = false
                            }

                            if (
                                candidate &&
                                x5t256 !== undefined &&
                                key['x5t#S256'] !== x5t256
                            ) {
                                candidate = false
                            }

                            if (
                                candidate &&
                                kty !== undefined &&
                                key.kty !== kty
                            ) {
                                candidate = false
                            }

                            if (
                                candidate &&
                                crv !== undefined &&
                                key.crv !== crv
                            ) {
                                candidate = false
                            }

                            if (
                                alg !== undefined &&
                                !key.algorithms().has(alg)
                            ) {
                                candidate = false
                            }

                            if (
                                candidate &&
                                use !== undefined &&
                                key.use !== undefined && key.use !== use
                            ) {
                                candidate = false
                            }

                            // TODO:
                            if (
                                candidate &&
                                ops !== undefined &&
                                (key.key_ops !== undefined ||
                                    key.use !== undefined)
                            ) {
                                let keyOps
                                if (key.key_ops) {
                                    keyOps = new Set(key.key_ops)
                                } else {
                                    keyOps = USES_MAPPING[key.use]
                                }
                                if (ops.some(x => !keyOps.has(x))) {
                                    candidate = false
                                }
                            }

                            return candidate
                        })
                        .sort(
                            (first, second) =>
                                keyscore(second, search) -
                                keyscore(first, search)
                        )
                }

                get(...args) {
                    return this.all(...args)[0]
                }

                add(key) {
                    if (!isKey(key) || key === None) {
                        throw new TypeError(
                            'key must be an instance of a key instantiated by JWK.asKey'
                        )
                    }

                    this._keys.add(key)
                }

                remove(key) {
                    if (!isKey(key)) {
                        throw new TypeError(
                            'key must be an instance of a key instantiated by JWK.asKey'
                        )
                    }

                    this._keys.delete(key)
                }

                toJWKS(priv = false) {
                    return {
                        keys: [...this._keys.values()].map(key =>
                            key.toJWK(
                                priv && (key.private || (key.secret && key.k))
                            )
                        )
                    }
                }

                async generate(...args) {
                    this._keys.add(await generate(...args))
                }

                generateSync(...args) {
                    this._keys.add(generateSync(...args))
                }

                get size() {
                    return this._keys.size
                }

                /* c8 ignore next 8 */
                [inspect.custom]() {
                    return `${this.constructor.name} ${inspect(
                        this.toJWKS(false),
                        {
                            depth: Infinity,
                            colors: process.stdout.isTTY,
                            compact: false,
                            sorted: true
                        }
                    )}`
                }

                *[Symbol.iterator]() {
                    for (const key of this._keys) {
                        yield key
                    }
                }
            }

            function asKeyStore(
                jwks,
                { ignoreErrors = false, calculateMissingRSAPrimes = false } = {}
            ) {
                if (
                    !isObject(jwks) ||
                    !Array.isArray(jwks.keys) ||
                    jwks.keys.some(k => !isObject(k) || !('kty' in k))
                ) {
                    throw new TypeError(
                        'jwks must be a JSON Web Key Set formatted object'
                    )
                }

                const keys = jwks.keys
                    .map(jwk => {
                        try {
                            return importKey(jwk, { calculateMissingRSAPrimes })
                        } catch (err) {
                            if (!ignoreErrors) {
                                throw err
                            }
                        }
                    })
                    .filter(Boolean)

                return new KeyStore(...keys)
            }

            Object.defineProperty(KeyStore, 'fromJWKS', {
                value: deprecate(
                    jwks =>
                        asKeyStore(jwks, { calculateMissingRSAPrimes: true }),
                    'JWKS.KeyStore.fromJWKS() is deprecated, use JWKS.asKeyStore() instead'
                ),
                enumerable: false
            })

            module.exports = { KeyStore, asKeyStore }

            /***/
        },

        /***/ aOmh: /***/ function(module, exports) {
            module.exports = new Map()

            /***/
        },

        /***/ aPfg: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // https://tc39.github.io/proposal-setmap-offrom/
            var $export = __webpack_require__('Y7ZC')
            var aFunction = __webpack_require__('eaoh')
            var ctx = __webpack_require__('2GTP')
            var forOf = __webpack_require__('oioR')

            module.exports = function(COLLECTION) {
                $export($export.S, COLLECTION, {
                    from: function from(source /* , mapFn, thisArg */) {
                        var mapFn = arguments[1]
                        var mapping, A, n, cb
                        aFunction(this)
                        mapping = mapFn !== undefined
                        if (mapping) aFunction(mapFn)
                        if (source == undefined) return new this()
                        A = []
                        if (mapping) {
                            n = 0
                            cb = ctx(mapFn, arguments[2], 2)
                            forOf(source, false, function(nextItem) {
                                A.push(cb(nextItem, n++))
                            })
                        } else {
                            forOf(source, false, A.push, A)
                        }
                        return new this(A)
                    }
                })
            }

            /***/
        },

        /***/ aW7e: /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('wgeU')
            __webpack_require__('FlQf')
            __webpack_require__('bBy9')
            __webpack_require__('JMW+')
            __webpack_require__('PBE1')
            __webpack_require__('Q/yX')
            module.exports = __webpack_require__('WEpk').Promise

            /***/
        },

        /***/ adU4: /***/ function(module, exports, __webpack_require__) {
            var assocIndexOf = __webpack_require__('y1pI')

            /** Used for built-in method references. */
            var arrayProto = Array.prototype

            /** Built-in value references. */
            var splice = arrayProto.splice

            /**
             * Removes `key` and its value from the list cache.
             *
             * @private
             * @name delete
             * @memberOf ListCache
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function listCacheDelete(key) {
                var data = this.__data__,
                    index = assocIndexOf(data, key)

                if (index < 0) {
                    return false
                }
                var lastIndex = data.length - 1
                if (index == lastIndex) {
                    data.pop()
                } else {
                    splice.call(data, index, 1)
                }
                --this.size
                return true
            }

            module.exports = listCacheDelete

            /***/
        },

        /***/ 'ar/p': /***/ function(module, exports, __webpack_require__) {
            // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
            var $keys = __webpack_require__('5vMV')
            var hiddenKeys = __webpack_require__('FpHa').concat(
                'length',
                'prototype'
            )

            exports.f =
                Object.getOwnPropertyNames ||
                function getOwnPropertyNames(O) {
                    return $keys(O, hiddenKeys)
                }

            /***/
        },

        /***/ b1HN: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            // ISC @ Julien Fontanet

            // ===================================================================

            var construct =
                typeof Reflect !== 'undefined' ? Reflect.construct : undefined
            var defineProperty = Object.defineProperty

            // -------------------------------------------------------------------

            var captureStackTrace = Error.captureStackTrace
            if (captureStackTrace === undefined) {
                captureStackTrace = function captureStackTrace(error) {
                    var container = new Error()

                    defineProperty(error, 'stack', {
                        configurable: true,
                        get: function getStack() {
                            var stack = container.stack

                            // Replace property with value for faster future accesses.
                            defineProperty(this, 'stack', {
                                configurable: true,
                                value: stack,
                                writable: true
                            })

                            return stack
                        },
                        set: function setStack(stack) {
                            defineProperty(error, 'stack', {
                                configurable: true,
                                value: stack,
                                writable: true
                            })
                        }
                    })
                }
            }

            // -------------------------------------------------------------------

            function BaseError(message) {
                if (message !== undefined) {
                    defineProperty(this, 'message', {
                        configurable: true,
                        value: message,
                        writable: true
                    })
                }

                var cname = this.constructor.name
                if (cname !== undefined && cname !== this.name) {
                    defineProperty(this, 'name', {
                        configurable: true,
                        value: cname,
                        writable: true
                    })
                }

                captureStackTrace(this, this.constructor)
            }

            BaseError.prototype = Object.create(Error.prototype, {
                // See: https://github.com/JsCommunity/make-error/issues/4
                constructor: {
                    configurable: true,
                    value: BaseError,
                    writable: true
                }
            })

            // -------------------------------------------------------------------

            // Sets the name of a function if possible (depends of the JS engine).
            var setFunctionName = (function() {
                function setFunctionName(fn, name) {
                    return defineProperty(fn, 'name', {
                        configurable: true,
                        value: name
                    })
                }
                try {
                    var f = function() {}
                    setFunctionName(f, 'foo')
                    if (f.name === 'foo') {
                        return setFunctionName
                    }
                } catch (_) {}
            })()

            // -------------------------------------------------------------------

            function makeError(constructor, super_) {
                if (super_ == null || super_ === Error) {
                    super_ = BaseError
                } else if (typeof super_ !== 'function') {
                    throw new TypeError('super_ should be a function')
                }

                var name
                if (typeof constructor === 'string') {
                    name = constructor
                    constructor =
                        construct !== undefined
                            ? function() {
                                  return construct(
                                      super_,
                                      arguments,
                                      this.constructor
                                  )
                              }
                            : function() {
                                  super_.apply(this, arguments)
                              }

                    // If the name can be set, do it once and for all.
                    if (setFunctionName !== undefined) {
                        setFunctionName(constructor, name)
                        name = undefined
                    }
                } else if (typeof constructor !== 'function') {
                    throw new TypeError(
                        'constructor should be either a string or a function'
                    )
                }

                // Also register the super constructor also as `constructor.super_` just
                // like Node's `util.inherits()`.
                //
                // eslint-disable-next-line dot-notation
                constructor.super_ = constructor['super'] = super_

                var properties = {
                    constructor: {
                        configurable: true,
                        value: constructor,
                        writable: true
                    }
                }

                // If the name could not be set on the constructor, set it on the
                // prototype.
                if (name !== undefined) {
                    properties.name = {
                        configurable: true,
                        value: name,
                        writable: true
                    }
                }
                constructor.prototype = Object.create(
                    super_.prototype,
                    properties
                )

                return constructor
            }
            exports = module.exports = makeError
            exports.BaseError = BaseError

            /***/
        },

        /***/ b1mx: /***/ function(module, exports, __webpack_require__) {
            var once = __webpack_require__('VmuJ')
            var eos = __webpack_require__('q1Jy')
            var fs = __webpack_require__('mw/K') // we only need fs to get the ReadStream and WriteStream prototypes

            var noop = function() {}
            var ancient = /^v?\.0/.test(process.version)

            var isFn = function(fn) {
                return typeof fn === 'function'
            }

            var isFS = function(stream) {
                if (!ancient) return false // newer node version do not need to care about fs is a special way
                if (!fs) return false // browser
                return (
                    (stream instanceof (fs.ReadStream || noop) ||
                        stream instanceof (fs.WriteStream || noop)) &&
                    isFn(stream.close)
                )
            }

            var isRequest = function(stream) {
                return stream.setHeader && isFn(stream.abort)
            }

            var destroyer = function(stream, reading, writing, callback) {
                callback = once(callback)

                var closed = false
                stream.on('close', function() {
                    closed = true
                })

                eos(stream, { readable: reading, writable: writing }, function(
                    err
                ) {
                    if (err) return callback(err)
                    closed = true
                    callback()
                })

                var destroyed = false
                return function(err) {
                    if (closed) return
                    if (destroyed) return
                    destroyed = true

                    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
                    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

                    if (isFn(stream.destroy)) return stream.destroy()

                    callback(err || new Error('stream was destroyed'))
                }
            }

            var call = function(fn) {
                fn()
            }

            var pipe = function(from, to) {
                return from.pipe(to)
            }

            var pump = function() {
                var streams = Array.prototype.slice.call(arguments)
                var callback =
                    (isFn(streams[streams.length - 1] || noop) &&
                        streams.pop()) ||
                    noop

                if (Array.isArray(streams[0])) streams = streams[0]
                if (streams.length < 2)
                    throw new Error('pump requires two streams per minimum')

                var error
                var destroys = streams.map(function(stream, i) {
                    var reading = i < streams.length - 1
                    var writing = i > 0
                    return destroyer(stream, reading, writing, function(err) {
                        if (!error) error = err
                        if (err) destroys.forEach(call)
                        if (reading) return
                        destroys.forEach(call)
                        callback(error)
                    })
                })

                return streams.reduce(pipe)
            }

            module.exports = pump

            /***/
        },

        /***/ b2z7: /***/ function(module, exports) {
            /** Used to match `RegExp` flags from their coerced string values. */
            var reFlags = /\w*$/

            /**
             * Creates a clone of `regexp`.
             *
             * @private
             * @param {Object} regexp The regexp to clone.
             * @returns {Object} Returns the cloned regexp.
             */
            function cloneRegExp(regexp) {
                var result = new regexp.constructor(
                    regexp.source,
                    reFlags.exec(regexp)
                )
                result.lastIndex = regexp.lastIndex
                return result
            }

            module.exports = cloneRegExp

            /***/
        },

        /***/ b80T: /***/ function(module, exports, __webpack_require__) {
            var baseTimes = __webpack_require__('UNi/'),
                isArguments = __webpack_require__('03A+'),
                isArray = __webpack_require__('Z0cm'),
                isBuffer = __webpack_require__('DSRE'),
                isIndex = __webpack_require__('wJg7'),
                isTypedArray = __webpack_require__('c6wG')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Creates an array of the enumerable property names of the array-like `value`.
             *
             * @private
             * @param {*} value The value to query.
             * @param {boolean} inherited Specify returning inherited property names.
             * @returns {Array} Returns the array of property names.
             */
            function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value),
                    isArg = !isArr && isArguments(value),
                    isBuff = !isArr && !isArg && isBuffer(value),
                    isType = !isArr && !isArg && !isBuff && isTypedArray(value),
                    skipIndexes = isArr || isArg || isBuff || isType,
                    result = skipIndexes ? baseTimes(value.length, String) : [],
                    length = result.length

                for (var key in value) {
                    if (
                        (inherited || hasOwnProperty.call(value, key)) &&
                        !(
                            skipIndexes &&
                            // Safari 9 has enumerable `arguments.length` in strict mode.
                            (key == 'length' ||
                                // Node.js 0.10 has enumerable non-index properties on buffers.
                                (isBuff &&
                                    (key == 'offset' || key == 'parent')) ||
                                // PhantomJS 2 has enumerable non-index properties on typed arrays.
                                (isType &&
                                    (key == 'buffer' ||
                                        key == 'byteLength' ||
                                        key == 'byteOffset')) ||
                                // Skip index properties.
                                isIndex(key, length))
                        )
                    ) {
                        result.push(key)
                    }
                }
                return result
            }

            module.exports = arrayLikeKeys

            /***/
        },

        /***/ b9eJ: /***/ function(module, exports, __webpack_require__) {
            const { getCurves } = __webpack_require__('PJMN')

            const { name: secp256k1 } = __webpack_require__('F/JS')

            const curves = new Set()

            if (getCurves().includes('prime256v1')) {
                curves.add('P-256')
            }

            if (getCurves().includes('secp256k1')) {
                curves.add(secp256k1)
            }

            if (getCurves().includes('secp384r1')) {
                curves.add('P-384')
            }

            if (getCurves().includes('secp521r1')) {
                curves.add('P-521')
            }

            module.exports = curves

            /***/
        },

        /***/ bAum: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const os = __webpack_require__('jle/')
            const hasFlag = __webpack_require__('X5QW')

            const { env } = process

            let forceColor
            if (
                hasFlag('no-color') ||
                hasFlag('no-colors') ||
                hasFlag('color=false') ||
                hasFlag('color=never')
            ) {
                forceColor = 0
            } else if (
                hasFlag('color') ||
                hasFlag('colors') ||
                hasFlag('color=true') ||
                hasFlag('color=always')
            ) {
                forceColor = 1
            }
            if ('FORCE_COLOR' in env) {
                if (env.FORCE_COLOR === true || env.FORCE_COLOR === 'true') {
                    forceColor = 1
                } else if (
                    env.FORCE_COLOR === false ||
                    env.FORCE_COLOR === 'false'
                ) {
                    forceColor = 0
                } else {
                    forceColor =
                        env.FORCE_COLOR.length === 0
                            ? 1
                            : Math.min(parseInt(env.FORCE_COLOR, 10), 3)
                }
            }

            function translateLevel(level) {
                if (level === 0) {
                    return false
                }

                return {
                    level,
                    hasBasic: true,
                    has256: level >= 2,
                    has16m: level >= 3
                }
            }

            function supportsColor(stream) {
                if (forceColor === 0) {
                    return 0
                }

                if (
                    hasFlag('color=16m') ||
                    hasFlag('color=full') ||
                    hasFlag('color=truecolor')
                ) {
                    return 3
                }

                if (hasFlag('color=256')) {
                    return 2
                }

                if (stream && !stream.isTTY && forceColor === undefined) {
                    return 0
                }

                const min = forceColor || 0

                if (env.TERM === 'dumb') {
                    return min
                }

                if (process.platform === 'win32') {
                    // Node.js 7.5.0 is the first version of Node.js to include a patch to
                    // libuv that enables 256 color output on Windows. Anything earlier and it
                    // won't work. However, here we target Node.js 8 at minimum as it is an LTS
                    // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
                    // release that supports 256 colors. Windows 10 build 14931 is the first release
                    // that supports 16m/TrueColor.
                    const osRelease = os.release().split('.')
                    if (
                        Number(process.versions.node.split('.')[0]) >= 8 &&
                        Number(osRelease[0]) >= 10 &&
                        Number(osRelease[2]) >= 10586
                    ) {
                        return Number(osRelease[2]) >= 14931 ? 3 : 2
                    }

                    return 1
                }

                if ('CI' in env) {
                    if (
                        ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(
                            sign => sign in env
                        ) ||
                        env.CI_NAME === 'codeship'
                    ) {
                        return 1
                    }

                    return min
                }

                if ('TEAMCITY_VERSION' in env) {
                    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(
                        env.TEAMCITY_VERSION
                    )
                        ? 1
                        : 0
                }

                if (env.COLORTERM === 'truecolor') {
                    return 3
                }

                if ('TERM_PROGRAM' in env) {
                    const version = parseInt(
                        (env.TERM_PROGRAM_VERSION || '').split('.')[0],
                        10
                    )

                    switch (env.TERM_PROGRAM) {
                        case 'iTerm.app':
                            return version >= 3 ? 3 : 2
                        case 'Apple_Terminal':
                            return 2
                        // No default
                    }
                }

                if (/-256(color)?$/i.test(env.TERM)) {
                    return 2
                }

                if (
                    /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
                        env.TERM
                    )
                ) {
                    return 1
                }

                if ('COLORTERM' in env) {
                    return 1
                }

                return min
            }

            function getSupportLevel(stream) {
                const level = supportsColor(stream)
                return translateLevel(level)
            }

            module.exports = {
                supportsColor: getSupportLevel,
                stdout: getSupportLevel(process.stdout),
                stderr: getSupportLevel(process.stderr)
            }

            /***/
        },

        /***/ bBy9: /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('w2d+')
            var global = __webpack_require__('5T2Y')
            var hide = __webpack_require__('NegM')
            var Iterators = __webpack_require__('SBuE')
            var TO_STRING_TAG = __webpack_require__('UWiX')('toStringTag')

            var DOMIterables = (
                'CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
                'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
                'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
                'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
                'TextTrackList,TouchList'
            ).split(',')

            for (var i = 0; i < DOMIterables.length; i++) {
                var NAME = DOMIterables[i]
                var Collection = global[NAME]
                var proto = Collection && Collection.prototype
                if (proto && !proto[TO_STRING_TAG])
                    hide(proto, TO_STRING_TAG, NAME)
                Iterators[NAME] = Iterators.Array
            }

            /***/
        },

        /***/ bUME: /***/ function(module, exports, __webpack_require__) {
            const {
                createCipheriv,
                createDecipheriv,
                getCiphers
            } = __webpack_require__('PJMN')

            const uint64be = __webpack_require__('PsWn')
            const timingSafeEqual = __webpack_require__('kuaU')
            const { KEYOBJECT } = __webpack_require__('ehsS')
            const { asInput } = __webpack_require__('1ALl')

            const checkInput = data => {
                if (data !== undefined && data.length % 8 !== 0) {
                    throw new Error('invalid data length')
                }
            }

            const IV = Buffer.alloc(8, 'a6', 'hex')

            const xor = (a, b) => {
                const len = Math.max(a.length, b.length)
                const result = Buffer.alloc(len)
                for (let idx = 0; len > idx; idx++) {
                    result[idx] = (a[idx] || 0) ^ (b[idx] || 0)
                }

                return result
            }

            const split = (input, size) => {
                const output = []
                for (let idx = 0; input.length > idx; idx += size) {
                    output.push(input.slice(idx, idx + size))
                }
                return output
            }

            const wrapKey = (size, { [KEYOBJECT]: keyObject }, payload) => {
                const key = asInput(keyObject, false)
                const iv = Buffer.alloc(16)
                let R = split(payload, 8)
                let A
                let B
                let count
                A = IV
                for (let jdx = 0; jdx < 6; jdx++) {
                    for (let idx = 0; R.length > idx; idx++) {
                        count = R.length * jdx + idx + 1
                        const cipher = createCipheriv(`aes${size}`, key, iv)
                        B = Buffer.concat([A, R[idx]])
                        B = cipher.update(B)

                        A = xor(B.slice(0, 8), uint64be(count))
                        R[idx] = B.slice(8, 16)
                    }
                }
                R = [A].concat(R)

                return { wrapped: Buffer.concat(R) }
            }

            const unwrapKey = (size, { [KEYOBJECT]: keyObject }, payload) => {
                const key = asInput(keyObject, false)
                checkInput(payload)

                const iv = Buffer.alloc(16)

                let R = split(payload, 8)
                let A
                let B
                let count
                A = R[0]
                R = R.slice(1)
                for (let jdx = 5; jdx >= 0; --jdx) {
                    for (let idx = R.length - 1; idx >= 0; --idx) {
                        count = R.length * jdx + idx + 1
                        B = xor(A, uint64be(count))
                        B = Buffer.concat([B, R[idx], iv])
                        const cipher = createDecipheriv(`aes${size}`, key, iv)
                        B = cipher.update(B)

                        A = B.slice(0, 8)
                        R[idx] = B.slice(8, 16)
                    }
                }

                if (!timingSafeEqual(IV, A)) {
                    throw new Error('unwrap failed')
                }

                return Buffer.concat(R)
            }

            module.exports = (JWA, JWK) => {
                ;['A128KW', 'A192KW', 'A256KW'].forEach(jwaAlg => {
                    const size = parseInt(jwaAlg.substr(1, 3), 10)
                    if (getCiphers().includes(`aes${size}`)) {
                        JWA.keyManagementEncrypt.set(
                            jwaAlg,
                            wrapKey.bind(undefined, size)
                        )
                        JWA.keyManagementDecrypt.set(
                            jwaAlg,
                            unwrapKey.bind(undefined, size)
                        )
                        JWK.oct.wrapKey[jwaAlg] = JWK.oct.unwrapKey[
                            jwaAlg
                        ] = key =>
                            (key.use === 'enc' || key.use === undefined) &&
                            key.length === size
                    }
                })
            }

            /***/
        },

        /***/ bVZc: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            exports.__esModule = true
            exports['default'] = void 0

            function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i]
                    descriptor.enumerable = descriptor.enumerable || false
                    descriptor.configurable = true
                    if ('value' in descriptor) descriptor.writable = true
                    Object.defineProperty(target, descriptor.key, descriptor)
                }
            }

            function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps)
                if (staticProps) _defineProperties(Constructor, staticProps)
                return Constructor
            }

            /*
Based on Glamor's sheet
https://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js
*/
            var isProd =
                typeof process !== 'undefined' &&
                process.env &&
                'production' === 'production'

            var isString = function isString(o) {
                return Object.prototype.toString.call(o) === '[object String]'
            }

            var StyleSheet =
                /*#__PURE__*/
                (function() {
                    function StyleSheet(_temp) {
                        var _ref = _temp === void 0 ? {} : _temp,
                            _ref$name = _ref.name,
                            name =
                                _ref$name === void 0 ? 'stylesheet' : _ref$name,
                            _ref$optimizeForSpeed = _ref.optimizeForSpeed,
                            optimizeForSpeed =
                                _ref$optimizeForSpeed === void 0
                                    ? isProd
                                    : _ref$optimizeForSpeed,
                            _ref$isBrowser = _ref.isBrowser,
                            isBrowser =
                                _ref$isBrowser === void 0
                                    ? typeof window !== 'undefined'
                                    : _ref$isBrowser

                        invariant(isString(name), '`name` must be a string')
                        this._name = name
                        this._deletedRulePlaceholder =
                            '#' + name + '-deleted-rule____{}'
                        invariant(
                            typeof optimizeForSpeed === 'boolean',
                            '`optimizeForSpeed` must be a boolean'
                        )
                        this._optimizeForSpeed = optimizeForSpeed
                        this._isBrowser = isBrowser
                        this._serverSheet = undefined
                        this._tags = []
                        this._injected = false
                        this._rulesCount = 0
                        var node =
                            this._isBrowser &&
                            document.querySelector('meta[property="csp-nonce"]')
                        this._nonce = node ? node.getAttribute('content') : null
                    }

                    var _proto = StyleSheet.prototype

                    _proto.setOptimizeForSpeed = function setOptimizeForSpeed(
                        bool
                    ) {
                        invariant(
                            typeof bool === 'boolean',
                            '`setOptimizeForSpeed` accepts a boolean'
                        )
                        invariant(
                            this._rulesCount === 0,
                            'optimizeForSpeed cannot be when rules have already been inserted'
                        )
                        this.flush()
                        this._optimizeForSpeed = bool
                        this.inject()
                    }

                    _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {
                        return this._optimizeForSpeed
                    }

                    _proto.inject = function inject() {
                        var _this = this

                        invariant(!this._injected, 'sheet already injected')
                        this._injected = true

                        if (this._isBrowser && this._optimizeForSpeed) {
                            this._tags[0] = this.makeStyleTag(this._name)
                            this._optimizeForSpeed =
                                'insertRule' in this.getSheet()

                            if (!this._optimizeForSpeed) {
                                if (!isProd) {
                                    console.warn(
                                        'StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.'
                                    )
                                }

                                this.flush()
                                this._injected = true
                            }

                            return
                        }

                        this._serverSheet = {
                            cssRules: [],
                            insertRule: function insertRule(rule, index) {
                                if (typeof index === 'number') {
                                    _this._serverSheet.cssRules[index] = {
                                        cssText: rule
                                    }
                                } else {
                                    _this._serverSheet.cssRules.push({
                                        cssText: rule
                                    })
                                }

                                return index
                            },
                            deleteRule: function deleteRule(index) {
                                _this._serverSheet.cssRules[index] = null
                            }
                        }
                    }

                    _proto.getSheetForTag = function getSheetForTag(tag) {
                        if (tag.sheet) {
                            return tag.sheet
                        } // this weirdness brought to you by firefox

                        for (var i = 0; i < document.styleSheets.length; i++) {
                            if (document.styleSheets[i].ownerNode === tag) {
                                return document.styleSheets[i]
                            }
                        }
                    }

                    _proto.getSheet = function getSheet() {
                        return this.getSheetForTag(
                            this._tags[this._tags.length - 1]
                        )
                    }

                    _proto.insertRule = function insertRule(rule, index) {
                        invariant(
                            isString(rule),
                            '`insertRule` accepts only strings'
                        )

                        if (!this._isBrowser) {
                            if (typeof index !== 'number') {
                                index = this._serverSheet.cssRules.length
                            }

                            this._serverSheet.insertRule(rule, index)

                            return this._rulesCount++
                        }

                        if (this._optimizeForSpeed) {
                            var sheet = this.getSheet()

                            if (typeof index !== 'number') {
                                index = sheet.cssRules.length
                            } // this weirdness for perf, and chrome's weird bug
                            // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule

                            try {
                                sheet.insertRule(rule, index)
                            } catch (error) {
                                if (!isProd) {
                                    console.warn(
                                        'StyleSheet: illegal rule: \n\n' +
                                            rule +
                                            '\n\nSee https://stackoverflow.com/q/20007992 for more info'
                                    )
                                }

                                return -1
                            }
                        } else {
                            var insertionPoint = this._tags[index]

                            this._tags.push(
                                this.makeStyleTag(
                                    this._name,
                                    rule,
                                    insertionPoint
                                )
                            )
                        }

                        return this._rulesCount++
                    }

                    _proto.replaceRule = function replaceRule(index, rule) {
                        if (this._optimizeForSpeed || !this._isBrowser) {
                            var sheet = this._isBrowser
                                ? this.getSheet()
                                : this._serverSheet

                            if (!rule.trim()) {
                                rule = this._deletedRulePlaceholder
                            }

                            if (!sheet.cssRules[index]) {
                                // @TBD Should we throw an error?
                                return index
                            }

                            sheet.deleteRule(index)

                            try {
                                sheet.insertRule(rule, index)
                            } catch (error) {
                                if (!isProd) {
                                    console.warn(
                                        'StyleSheet: illegal rule: \n\n' +
                                            rule +
                                            '\n\nSee https://stackoverflow.com/q/20007992 for more info'
                                    )
                                } // In order to preserve the indices we insert a deleteRulePlaceholder

                                sheet.insertRule(
                                    this._deletedRulePlaceholder,
                                    index
                                )
                            }
                        } else {
                            var tag = this._tags[index]
                            invariant(
                                tag,
                                'old rule at index `' + index + '` not found'
                            )
                            tag.textContent = rule
                        }

                        return index
                    }

                    _proto.deleteRule = function deleteRule(index) {
                        if (!this._isBrowser) {
                            this._serverSheet.deleteRule(index)

                            return
                        }

                        if (this._optimizeForSpeed) {
                            this.replaceRule(index, '')
                        } else {
                            var tag = this._tags[index]
                            invariant(
                                tag,
                                'rule at index `' + index + '` not found'
                            )
                            tag.parentNode.removeChild(tag)
                            this._tags[index] = null
                        }
                    }

                    _proto.flush = function flush() {
                        this._injected = false
                        this._rulesCount = 0

                        if (this._isBrowser) {
                            this._tags.forEach(function(tag) {
                                return tag && tag.parentNode.removeChild(tag)
                            })

                            this._tags = []
                        } else {
                            // simpler on server
                            this._serverSheet.cssRules = []
                        }
                    }

                    _proto.cssRules = function cssRules() {
                        var _this2 = this

                        if (!this._isBrowser) {
                            return this._serverSheet.cssRules
                        }

                        return this._tags.reduce(function(rules, tag) {
                            if (tag) {
                                rules = rules.concat(
                                    Array.prototype.map.call(
                                        _this2.getSheetForTag(tag).cssRules,
                                        function(rule) {
                                            return rule.cssText ===
                                                _this2._deletedRulePlaceholder
                                                ? null
                                                : rule
                                        }
                                    )
                                )
                            } else {
                                rules.push(null)
                            }

                            return rules
                        }, [])
                    }

                    _proto.makeStyleTag = function makeStyleTag(
                        name,
                        cssString,
                        relativeToTag
                    ) {
                        if (cssString) {
                            invariant(
                                isString(cssString),
                                'makeStyleTag acceps only strings as second parameter'
                            )
                        }

                        var tag = document.createElement('style')
                        if (this._nonce) tag.setAttribute('nonce', this._nonce)
                        tag.type = 'text/css'
                        tag.setAttribute('data-' + name, '')

                        if (cssString) {
                            tag.appendChild(document.createTextNode(cssString))
                        }

                        var head =
                            document.head ||
                            document.getElementsByTagName('head')[0]

                        if (relativeToTag) {
                            head.insertBefore(tag, relativeToTag)
                        } else {
                            head.appendChild(tag)
                        }

                        return tag
                    }

                    _createClass(StyleSheet, [
                        {
                            key: 'length',
                            get: function get() {
                                return this._rulesCount
                            }
                        }
                    ])

                    return StyleSheet
                })()

            exports['default'] = StyleSheet

            function invariant(condition, message) {
                if (!condition) {
                    throw new Error('StyleSheet: ' + message + '.')
                }
            }

            /***/
        },

        /***/ bzos: /***/ function(module, exports) {
            module.exports = require('url')

            /***/
        },

        /***/ 'c1/D': /***/ function(module, exports, __webpack_require__) {
            const { inherits } = __webpack_require__('jK02')

            const DEREncoder = __webpack_require__('ZUdF')

            function PEMEncoder(entity) {
                DEREncoder.call(this, entity)
                this.enc = 'pem'
            }
            inherits(PEMEncoder, DEREncoder)

            PEMEncoder.prototype.encode = function encode(data, options) {
                const buf = DEREncoder.prototype.encode.call(this, data)

                const p = buf.toString('base64')
                const out = [`-----BEGIN ${options.label}-----`]
                for (let i = 0; i < p.length; i += 64) {
                    out.push(p.slice(i, i + 64))
                }
                out.push(`-----END ${options.label}-----`)
                return out.join('\n')
            }

            module.exports = PEMEncoder

            /***/
        },

        /***/ c6wG: /***/ function(module, exports, __webpack_require__) {
            var baseIsTypedArray = __webpack_require__('dD9F'),
                baseUnary = __webpack_require__('sEf8'),
                nodeUtil = __webpack_require__('mdPL')

            /* Node.js helper references. */
            var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray

            /**
             * Checks if `value` is classified as a typed array.
             *
             * @static
             * @memberOf _
             * @since 3.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
             * @example
             *
             * _.isTypedArray(new Uint8Array);
             * // => true
             *
             * _.isTypedArray([]);
             * // => false
             */
            var isTypedArray = nodeIsTypedArray
                ? baseUnary(nodeIsTypedArray)
                : baseIsTypedArray

            module.exports = isTypedArray

            /***/
        },

        /***/ cHUd: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // https://tc39.github.io/proposal-setmap-offrom/
            var $export = __webpack_require__('Y7ZC')

            module.exports = function(COLLECTION) {
                $export($export.S, COLLECTION, {
                    of: function of() {
                        var length = arguments.length
                        var A = new Array(length)
                        while (length--) A[length] = arguments[length]
                        return new this(A)
                    }
                })
            }

            /***/
        },

        /***/ cTJO: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _interopRequireWildcard = __webpack_require__('5Uuq')

            var _interopRequireDefault = __webpack_require__('KI45')

            exports.__esModule = true
            exports.default = void 0

            var _map = _interopRequireDefault(__webpack_require__('LX0d'))

            var _url = __webpack_require__('bzos')

            var _react = _interopRequireWildcard(__webpack_require__('q1tI'))

            var _propTypes = _interopRequireDefault(__webpack_require__('17x9'))

            var _router = _interopRequireDefault(__webpack_require__('nOHt'))

            var _rewriteUrlForExport = __webpack_require__('P5f7')

            var _utils = __webpack_require__('g/15')

            function isLocal(href) {
                var url = (0, _url.parse)(href, false, true)
                var origin = (0, _url.parse)(
                    (0, _utils.getLocationOrigin)(),
                    false,
                    true
                )
                return (
                    !url.host ||
                    (url.protocol === origin.protocol &&
                        url.host === origin.host)
                )
            }

            function memoizedFormatUrl(formatFunc) {
                var lastHref = null
                var lastAs = null
                var lastResult = null
                return (href, as) => {
                    if (lastResult && href === lastHref && as === lastAs) {
                        return lastResult
                    }

                    var result = formatFunc(href, as)
                    lastHref = href
                    lastAs = as
                    lastResult = result
                    return result
                }
            }

            function formatUrl(url) {
                return url && typeof url === 'object'
                    ? (0, _utils.formatWithValidation)(url)
                    : url
            }

            var observer
            var listeners = new _map.default()
            var IntersectionObserver = false ? undefined : null

            function getObserver() {
                // Return shared instance of IntersectionObserver if already created
                if (observer) {
                    return observer
                } // Only create shared IntersectionObserver if supported in browser

                if (!IntersectionObserver) {
                    return undefined
                }

                return (observer = new IntersectionObserver(
                    entries => {
                        entries.forEach(entry => {
                            if (!listeners.has(entry.target)) {
                                return
                            }

                            var cb = listeners.get(entry.target)

                            if (
                                entry.isIntersecting ||
                                entry.intersectionRatio > 0
                            ) {
                                observer.unobserve(entry.target)
                                listeners.delete(entry.target)
                                cb()
                            }
                        })
                    },
                    {
                        rootMargin: '200px'
                    }
                ))
            }

            var listenToIntersections = (el, cb) => {
                var observer = getObserver()

                if (!observer) {
                    return () => {}
                }

                observer.observe(el)
                listeners.set(el, cb)
                return () => {
                    try {
                        observer.unobserve(el)
                    } catch (err) {
                        console.error(err)
                    }

                    listeners.delete(el)
                }
            }

            class Link extends _react.Component {
                constructor(props) {
                    super(props)
                    this.p = void 0

                    this.cleanUpListeners = () => {}

                    this.formatUrls = memoizedFormatUrl((href, asHref) => {
                        return {
                            href: formatUrl(href),
                            as: asHref ? formatUrl(asHref) : asHref
                        }
                    })

                    this.linkClicked = e => {
                        // @ts-ignore target exists on currentTarget
                        var { nodeName, target } = e.currentTarget

                        if (
                            nodeName === 'A' &&
                            ((target && target !== '_self') ||
                                e.metaKey ||
                                e.ctrlKey ||
                                e.shiftKey ||
                                (e.nativeEvent && e.nativeEvent.which === 2))
                        ) {
                            // ignore click for new tab / new window behavior
                            return
                        }

                        var { href, as } = this.formatUrls(
                            this.props.href,
                            this.props.as
                        )

                        if (!isLocal(href)) {
                            // ignore click if it's outside our scope (e.g. https://google.com)
                            return
                        }

                        var { pathname } = window.location
                        href = (0, _url.resolve)(pathname, href)
                        as = as ? (0, _url.resolve)(pathname, as) : href
                        e.preventDefault() //  avoid scroll for urls with anchor refs

                        var { scroll } = this.props

                        if (scroll == null) {
                            scroll = as.indexOf('#') < 0
                        } // replace state instead of push if prop is present

                        _router.default[
                            this.props.replace ? 'replace' : 'push'
                        ](href, as, {
                            shallow: this.props.shallow
                        }).then(success => {
                            if (!success) return

                            if (scroll) {
                                window.scrollTo(0, 0)
                                document.body.focus()
                            }
                        })
                    }

                    if (false) {
                    }

                    this.p = props.prefetch !== false
                }

                componentWillUnmount() {
                    this.cleanUpListeners()
                }

                handleRef(ref) {
                    if (this.p && IntersectionObserver && ref && ref.tagName) {
                        this.cleanUpListeners()
                        this.cleanUpListeners = listenToIntersections(
                            ref,
                            () => {
                                this.prefetch()
                            }
                        )
                    }
                } // The function is memoized so that no extra lifecycles are needed
                // as per https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html

                prefetch() {
                    if (!this.p || true) return // Prefetch the JSON page if asked (only in the client)

                    var { pathname } = window.location
                    var { href: parsedHref } = this.formatUrls(
                        this.props.href,
                        this.props.as
                    )
                    var href = (0, _url.resolve)(pathname, parsedHref)

                    _router.default.prefetch(href)
                }

                render() {
                    var { children } = this.props
                    var { href, as } = this.formatUrls(
                        this.props.href,
                        this.props.as
                    ) // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

                    if (typeof children === 'string') {
                        children = _react.default.createElement(
                            'a',
                            null,
                            children
                        )
                    } // This will return the first child, if multiple are provided it will throw an error

                    var child = _react.Children.only(children)

                    var props = {
                        ref: el => {
                            this.handleRef(el)

                            if (
                                child &&
                                typeof child === 'object' &&
                                child.ref
                            ) {
                                if (typeof child.ref === 'function')
                                    child.ref(el)
                                else if (typeof child.ref === 'object') {
                                    child.ref.current = el
                                }
                            }
                        },
                        onMouseEnter: e => {
                            if (
                                child.props &&
                                typeof child.props.onMouseEnter === 'function'
                            ) {
                                child.props.onMouseEnter(e)
                            }

                            this.prefetch()
                        },
                        onClick: e => {
                            if (
                                child.props &&
                                typeof child.props.onClick === 'function'
                            ) {
                                child.props.onClick(e)
                            }

                            if (!e.defaultPrevented) {
                                this.linkClicked(e)
                            }
                        }
                    } // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
                    // defined, we specify the current 'href', so that repetition is not needed by the user

                    if (
                        this.props.passHref ||
                        (child.type === 'a' && !('href' in child.props))
                    ) {
                        props.href = as || href
                    } // Add the ending slash to the paths. So, we can serve the
                    // "<page>/index.html" directly.

                    if (false) {
                    }

                    return _react.default.cloneElement(child, props)
                }
            }

            Link.propTypes = void 0

            if (false) {
                var exact, warn
            }

            var _default = Link
            exports.default = _default

            /***/
        },

        /***/ canG: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const errors = __webpack_require__('9Fi5')
            const asStream = __webpack_require__('kjw5')
            const asPromise = __webpack_require__('4UWp')
            const normalizeArguments = __webpack_require__('whhB')
            const merge = __webpack_require__('AW8e')
            const deepFreeze = __webpack_require__('z/H/')

            const getPromiseOrStream = options =>
                options.stream ? asStream(options) : asPromise(options)

            const aliases = ['get', 'post', 'put', 'patch', 'head', 'delete']

            const create = defaults => {
                defaults = merge({}, defaults)
                normalizeArguments.preNormalize(defaults.options)

                if (!defaults.handler) {
                    // This can't be getPromiseOrStream, because when merging
                    // the chain would stop at this point and no further handlers would be called.
                    defaults.handler = (options, next) => next(options)
                }

                function got(url, options) {
                    try {
                        return defaults.handler(
                            normalizeArguments(url, options, defaults),
                            getPromiseOrStream
                        )
                    } catch (error) {
                        if (options && options.stream) {
                            throw error
                        } else {
                            return Promise.reject(error)
                        }
                    }
                }

                got.create = create
                got.extend = options => {
                    let mutableDefaults
                    if (options && Reflect.has(options, 'mutableDefaults')) {
                        mutableDefaults = options.mutableDefaults
                        delete options.mutableDefaults
                    } else {
                        mutableDefaults = defaults.mutableDefaults
                    }

                    return create({
                        options: merge.options(defaults.options, options),
                        handler: defaults.handler,
                        mutableDefaults
                    })
                }

                got.mergeInstances = (...args) => create(merge.instances(args))

                got.stream = (url, options) =>
                    got(url, { ...options, stream: true })

                for (const method of aliases) {
                    got[method] = (url, options) =>
                        got(url, { ...options, method })
                    got.stream[method] = (url, options) =>
                        got.stream(url, { ...options, method })
                }

                Object.assign(got, { ...errors, mergeOptions: merge.options })
                Object.defineProperty(got, 'defaults', {
                    value: defaults.mutableDefaults
                        ? defaults
                        : deepFreeze(defaults),
                    writable: defaults.mutableDefaults,
                    configurable: defaults.mutableDefaults,
                    enumerable: true
                })

                return got
            }

            module.exports = create

            /***/
        },

        /***/ ccE7: /***/ function(module, exports, __webpack_require__) {
            var toInteger = __webpack_require__('Ojgd')
            var defined = __webpack_require__('Jes0')
            // true  -> String#at
            // false -> String#codePointAt
            module.exports = function(TO_STRING) {
                return function(that, pos) {
                    var s = String(defined(that))
                    var i = toInteger(pos)
                    var l = s.length
                    var a, b
                    if (i < 0 || i >= l) return TO_STRING ? '' : undefined
                    a = s.charCodeAt(i)
                    return a < 0xd800 ||
                        a > 0xdbff ||
                        i + 1 === l ||
                        (b = s.charCodeAt(i + 1)) < 0xdc00 ||
                        b > 0xdfff
                        ? TO_STRING
                            ? s.charAt(i)
                            : a
                        : TO_STRING
                        ? s.slice(i, i + 2)
                        : ((a - 0xd800) << 10) + (b - 0xdc00) + 0x10000
                }
            }

            /***/
        },

        /***/ ckmc: /***/ function(module, exports, __webpack_require__) {
            /**
             * Module dependencies.
             */

            var tty = __webpack_require__('UNVE')
            var util = __webpack_require__('jK02')

            /**
             * This is the Node.js implementation of `debug()`.
             *
             * Expose `debug()` as the module.
             */

            exports = module.exports = __webpack_require__('BKKR')
            exports.init = init
            exports.log = log
            exports.formatArgs = formatArgs
            exports.save = save
            exports.load = load
            exports.useColors = useColors

            /**
             * Colors.
             */

            exports.colors = [6, 2, 3, 4, 5, 1]

            try {
                var supportsColor = __webpack_require__('bAum')
                if (supportsColor && supportsColor.level >= 2) {
                    exports.colors = [
                        20,
                        21,
                        26,
                        27,
                        32,
                        33,
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44,
                        45,
                        56,
                        57,
                        62,
                        63,
                        68,
                        69,
                        74,
                        75,
                        76,
                        77,
                        78,
                        79,
                        80,
                        81,
                        92,
                        93,
                        98,
                        99,
                        112,
                        113,
                        128,
                        129,
                        134,
                        135,
                        148,
                        149,
                        160,
                        161,
                        162,
                        163,
                        164,
                        165,
                        166,
                        167,
                        168,
                        169,
                        170,
                        171,
                        172,
                        173,
                        178,
                        179,
                        184,
                        185,
                        196,
                        197,
                        198,
                        199,
                        200,
                        201,
                        202,
                        203,
                        204,
                        205,
                        206,
                        207,
                        208,
                        209,
                        214,
                        215,
                        220,
                        221
                    ]
                }
            } catch (err) {
                // swallow - we only care if `supports-color` is available; it doesn't have to be.
            }

            /**
             * Build up the default `inspectOpts` object from the environment variables.
             *
             *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
             */

            exports.inspectOpts = Object.keys(process.env)
                .filter(function(key) {
                    return /^debug_/i.test(key)
                })
                .reduce(function(obj, key) {
                    // camel-case
                    var prop = key
                        .substring(6)
                        .toLowerCase()
                        .replace(/_([a-z])/g, function(_, k) {
                            return k.toUpperCase()
                        })

                    // coerce string value into JS value
                    var val = process.env[key]
                    if (/^(yes|on|true|enabled)$/i.test(val)) val = true
                    else if (/^(no|off|false|disabled)$/i.test(val)) val = false
                    else if (val === 'null') val = null
                    else val = Number(val)

                    obj[prop] = val
                    return obj
                }, {})

            /**
             * Is stdout a TTY? Colored output is enabled when `true`.
             */

            function useColors() {
                return 'colors' in exports.inspectOpts
                    ? Boolean(exports.inspectOpts.colors)
                    : tty.isatty(process.stderr.fd)
            }

            /**
             * Map %o to `util.inspect()`, all on a single line.
             */

            exports.formatters.o = function(v) {
                this.inspectOpts.colors = this.useColors
                return util
                    .inspect(v, this.inspectOpts)
                    .split('\n')
                    .map(function(str) {
                        return str.trim()
                    })
                    .join(' ')
            }

            /**
             * Map %o to `util.inspect()`, allowing multiple lines if needed.
             */

            exports.formatters.O = function(v) {
                this.inspectOpts.colors = this.useColors
                return util.inspect(v, this.inspectOpts)
            }

            /**
             * Adds ANSI color escape codes if enabled.
             *
             * @api public
             */

            function formatArgs(args) {
                var name = this.namespace
                var useColors = this.useColors

                if (useColors) {
                    var c = this.color
                    var colorCode = '\u001b[3' + (c < 8 ? c : '8;5;' + c)
                    var prefix =
                        '  ' + colorCode + ';1m' + name + ' ' + '\u001b[0m'

                    args[0] = prefix + args[0].split('\n').join('\n' + prefix)
                    args.push(
                        colorCode +
                            'm+' +
                            exports.humanize(this.diff) +
                            '\u001b[0m'
                    )
                } else {
                    args[0] = getDate() + name + ' ' + args[0]
                }
            }

            function getDate() {
                if (exports.inspectOpts.hideDate) {
                    return ''
                } else {
                    return new Date().toISOString() + ' '
                }
            }

            /**
             * Invokes `util.format()` with the specified arguments and writes to stderr.
             */

            function log() {
                return process.stderr.write(
                    util.format.apply(util, arguments) + '\n'
                )
            }

            /**
             * Save `namespaces`.
             *
             * @param {String} namespaces
             * @api private
             */

            function save(namespaces) {
                if (null == namespaces) {
                    // If you set a process.env field to null or undefined, it gets cast to the
                    // string 'null' or 'undefined'. Just delete instead.
                    delete process.env.DEBUG
                } else {
                    process.env.DEBUG = namespaces
                }
            }

            /**
             * Load `namespaces`.
             *
             * @return {String} returns the previously persisted debug modes
             * @api private
             */

            function load() {
                return process.env.DEBUG
            }

            /**
             * Init logic for `debug` instances.
             *
             * Create a new `inspectOpts` object in case `useColors` is set
             * differently for a particular `debug` instance.
             */

            function init(debug) {
                debug.inspectOpts = {}

                var keys = Object.keys(exports.inspectOpts)
                for (var i = 0; i < keys.length; i++) {
                    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]]
                }
            }

            /**
             * Enable namespaces listed in `process.env.DEBUG` initially.
             */

            exports.enable(load())

            /***/
        },

        /***/ 'cq/+': /***/ function(module, exports, __webpack_require__) {
            var createBaseFor = __webpack_require__('mc0g')

            /**
             * The base implementation of `baseForOwn` which iterates over `object`
             * properties returned by `keysFunc` and invokes `iteratee` for each property.
             * Iteratee functions may exit iteration early by explicitly returning `false`.
             *
             * @private
             * @param {Object} object The object to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @param {Function} keysFunc The function to get the keys of `object`.
             * @returns {Object} Returns `object`.
             */
            var baseFor = createBaseFor()

            module.exports = baseFor

            /***/
        },

        /***/ cvCv: /***/ function(module, exports) {
            /**
             * Creates a function that returns `value`.
             *
             * @static
             * @memberOf _
             * @since 2.4.0
             * @category Util
             * @param {*} value The value to return from the new function.
             * @returns {Function} Returns the new constant function.
             * @example
             *
             * var objects = _.times(2, _.constant({ 'a': 1 }));
             *
             * console.log(objects);
             * // => [{ 'a': 1 }, { 'a': 1 }]
             *
             * console.log(objects[0] === objects[1]);
             * // => true
             */
            function constant(value) {
                return function() {
                    return value
                }
            }

            module.exports = constant

            /***/
        },

        /***/ d4WF: /***/ function(module, exports, __webpack_require__) {
            const {
                createCipheriv,
                createDecipheriv,
                getCiphers
            } = __webpack_require__('PJMN')

            const uint64be = __webpack_require__('PsWn')
            const timingSafeEqual = __webpack_require__('kuaU')
            const { KEYOBJECT } = __webpack_require__('ehsS')
            const { JWEInvalid, JWEDecryptionFailed } = __webpack_require__(
                'yt7c'
            )

            const checkInput = function(size, iv, tag) {
                if (iv.length !== 16) {
                    throw new JWEInvalid('invalid iv')
                }
                if (arguments.length === 3) {
                    if (tag.length !== size / 8) {
                        throw new JWEInvalid('invalid tag')
                    }
                }
            }

            const encrypt = (
                size,
                sign,
                { [KEYOBJECT]: keyObject },
                cleartext,
                { iv, aad = Buffer.alloc(0) }
            ) => {
                const key = keyObject.export()
                checkInput(size, iv)

                const keySize = size / 8
                const encKey = key.slice(keySize)
                const cipher = createCipheriv(`aes-${size}-cbc`, encKey, iv)
                const ciphertext = Buffer.concat([
                    cipher.update(cleartext),
                    cipher.final()
                ])
                const macData = Buffer.concat([
                    aad,
                    iv,
                    ciphertext,
                    uint64be(aad.length * 8)
                ])

                const macKey = key.slice(0, keySize)
                const tag = sign({ [KEYOBJECT]: macKey }, macData).slice(
                    0,
                    keySize
                )

                return { ciphertext, tag }
            }

            const decrypt = (
                size,
                sign,
                { [KEYOBJECT]: keyObject },
                ciphertext,
                { iv, tag = Buffer.alloc(0), aad = Buffer.alloc(0) }
            ) => {
                checkInput(size, iv, tag)

                const keySize = size / 8
                const key = keyObject.export()
                const encKey = key.slice(keySize)
                const macKey = key.slice(0, keySize)

                const macData = Buffer.concat([
                    aad,
                    iv,
                    ciphertext,
                    uint64be(aad.length * 8)
                ])
                const expectedTag = sign(
                    { [KEYOBJECT]: macKey },
                    macData,
                    tag
                ).slice(0, keySize)
                const macCheckPassed = timingSafeEqual(tag, expectedTag)

                let cleartext
                try {
                    const cipher = createDecipheriv(
                        `aes-${size}-cbc`,
                        encKey,
                        iv
                    )
                    cleartext = Buffer.concat([
                        cipher.update(ciphertext),
                        cipher.final()
                    ])
                } catch (err) {}

                if (!cleartext || !macCheckPassed) {
                    throw new JWEDecryptionFailed()
                }

                return cleartext
            }

            module.exports = (JWA, JWK) => {
                ;['A128CBC-HS256', 'A192CBC-HS384', 'A256CBC-HS512'].forEach(
                    jwaAlg => {
                        const size = parseInt(jwaAlg.substr(1, 3), 10)
                        const sign = JWA.sign.get(`HS${size * 2}`)
                        if (getCiphers().includes(`aes-${size}-cbc`)) {
                            JWA.encrypt.set(
                                jwaAlg,
                                encrypt.bind(undefined, size, sign)
                            )
                            JWA.decrypt.set(
                                jwaAlg,
                                decrypt.bind(undefined, size, sign)
                            )
                            JWK.oct.encrypt[jwaAlg] = JWK.oct.decrypt[
                                jwaAlg
                            ] = key =>
                                (key.use === 'enc' || key.use === undefined) &&
                                key.length / 2 === size
                        }
                    }
                )
            }

            /***/
        },

        /***/ d8FT: /***/ function(module, exports, __webpack_require__) {
            var arrayMap = __webpack_require__('eUgh'),
                baseIteratee = __webpack_require__('ut/Y'),
                basePickBy = __webpack_require__('idmN'),
                getAllKeysIn = __webpack_require__('G6z8')

            /**
             * Creates an object composed of the `object` properties `predicate` returns
             * truthy for. The predicate is invoked with two arguments: (value, key).
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Object
             * @param {Object} object The source object.
             * @param {Function} [predicate=_.identity] The function invoked per property.
             * @returns {Object} Returns the new object.
             * @example
             *
             * var object = { 'a': 1, 'b': '2', 'c': 3 };
             *
             * _.pickBy(object, _.isNumber);
             * // => { 'a': 1, 'c': 3 }
             */
            function pickBy(object, predicate) {
                if (object == null) {
                    return {}
                }
                var props = arrayMap(getAllKeysIn(object), function(prop) {
                    return [prop]
                })
                predicate = baseIteratee(predicate)
                return basePickBy(object, props, function(value, path) {
                    return predicate(value, path[0])
                })
            }

            module.exports = pickBy

            /***/
        },

        /***/ dD9F: /***/ function(module, exports, __webpack_require__) {
            var baseGetTag = __webpack_require__('NykK'),
                isLength = __webpack_require__('shjB'),
                isObjectLike = __webpack_require__('ExA7')

            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]',
                arrayTag = '[object Array]',
                boolTag = '[object Boolean]',
                dateTag = '[object Date]',
                errorTag = '[object Error]',
                funcTag = '[object Function]',
                mapTag = '[object Map]',
                numberTag = '[object Number]',
                objectTag = '[object Object]',
                regexpTag = '[object RegExp]',
                setTag = '[object Set]',
                stringTag = '[object String]',
                weakMapTag = '[object WeakMap]'

            var arrayBufferTag = '[object ArrayBuffer]',
                dataViewTag = '[object DataView]',
                float32Tag = '[object Float32Array]',
                float64Tag = '[object Float64Array]',
                int8Tag = '[object Int8Array]',
                int16Tag = '[object Int16Array]',
                int32Tag = '[object Int32Array]',
                uint8Tag = '[object Uint8Array]',
                uint8ClampedTag = '[object Uint8ClampedArray]',
                uint16Tag = '[object Uint16Array]',
                uint32Tag = '[object Uint32Array]'

            /** Used to identify `toStringTag` values of typed arrays. */
            var typedArrayTags = {}
            typedArrayTags[float32Tag] = typedArrayTags[
                float64Tag
            ] = typedArrayTags[int8Tag] = typedArrayTags[
                int16Tag
            ] = typedArrayTags[int32Tag] = typedArrayTags[
                uint8Tag
            ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
                uint16Tag
            ] = typedArrayTags[uint32Tag] = true
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[
                arrayBufferTag
            ] = typedArrayTags[boolTag] = typedArrayTags[
                dataViewTag
            ] = typedArrayTags[dateTag] = typedArrayTags[
                errorTag
            ] = typedArrayTags[funcTag] = typedArrayTags[
                mapTag
            ] = typedArrayTags[numberTag] = typedArrayTags[
                objectTag
            ] = typedArrayTags[regexpTag] = typedArrayTags[
                setTag
            ] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false

            /**
             * The base implementation of `_.isTypedArray` without Node.js optimizations.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
             */
            function baseIsTypedArray(value) {
                return (
                    isObjectLike(value) &&
                    isLength(value.length) &&
                    !!typedArrayTags[baseGetTag(value)]
                )
            }

            module.exports = baseIsTypedArray

            /***/
        },

        /***/ dL40: /***/ function(module, exports, __webpack_require__) {
            // https://github.com/DavidBruant/Map-Set.prototype.toJSON
            var $export = __webpack_require__('Y7ZC')

            $export($export.P + $export.R, 'Set', {
                toJSON: __webpack_require__('8iia')('Set')
            })

            /***/
        },

        /***/ dTAl: /***/ function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__('GoyQ')

            /** Built-in value references. */
            var objectCreate = Object.create

            /**
             * The base implementation of `_.create` without support for assigning
             * properties to the created object.
             *
             * @private
             * @param {Object} proto The object to inherit from.
             * @returns {Object} Returns the new object.
             */
            var baseCreate = (function() {
                function object() {}
                return function(proto) {
                    if (!isObject(proto)) {
                        return {}
                    }
                    if (objectCreate) {
                        return objectCreate(proto)
                    }
                    object.prototype = proto
                    var result = new object()
                    object.prototype = undefined
                    return result
                }
            })()

            module.exports = baseCreate

            /***/
        },

        /***/ dVTT: /***/ function(module, exports, __webpack_require__) {
            // https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
            __webpack_require__('aPfg')('Map')

            /***/
        },

        /***/ dZ6Y: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /*
MIT License

Copyright (c) Jason Miller (https://jasonformat.com/)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

            var _Object$create = __webpack_require__('SqZg')

            var _Object$defineProperty = __webpack_require__('hfKm')

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            function mitt() {
                const all = _Object$create(null)

                return {
                    on(type, handler) {
                        ;(all[type] || (all[type] = [])).push(handler)
                    },

                    off(type, handler) {
                        if (all[type]) {
                            // tslint:disable-next-line:no-bitwise
                            all[type].splice(
                                all[type].indexOf(handler) >>> 0,
                                1
                            )
                        }
                    },

                    emit(type, ...evts) {
                        // eslint-disable-next-line array-callback-return
                        ;(all[type] || []).slice().map(handler => {
                            handler(...evts)
                        })
                    }
                }
            }

            exports.default = mitt

            /***/
        },

        /***/ dmkc: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /* WEBPACK VAR INJECTION */ ;(function(__dirname) {
                exports.__esModule = true
                exports.SPR_GET_INITIAL_PROPS_CONFLICT = exports.PUBLIC_DIR_MIDDLEWARE_CONFLICT = exports.DOT_NEXT_ALIAS = exports.PAGES_DIR_ALIAS = exports.API_ROUTE = exports.NEXT_PROJECT_ROOT_DIST_SERVER = exports.NEXT_PROJECT_ROOT_DIST_CLIENT = exports.NEXT_PROJECT_ROOT_NODE_MODULES = exports.NEXT_PROJECT_ROOT_DIST = exports.NEXT_PROJECT_ROOT = void 0
                var _path = __webpack_require__('oyvS')
                const NEXT_PROJECT_ROOT = (0, _path.join)(__dirname, '..', '..')
                exports.NEXT_PROJECT_ROOT = NEXT_PROJECT_ROOT
                const NEXT_PROJECT_ROOT_DIST = (0, _path.join)(
                    NEXT_PROJECT_ROOT,
                    'dist'
                )
                exports.NEXT_PROJECT_ROOT_DIST = NEXT_PROJECT_ROOT_DIST
                const NEXT_PROJECT_ROOT_NODE_MODULES = (0, _path.join)(
                    NEXT_PROJECT_ROOT,
                    'node_modules'
                )
                exports.NEXT_PROJECT_ROOT_NODE_MODULES = NEXT_PROJECT_ROOT_NODE_MODULES
                const NEXT_PROJECT_ROOT_DIST_CLIENT = (0, _path.join)(
                    NEXT_PROJECT_ROOT_DIST,
                    'client'
                )
                exports.NEXT_PROJECT_ROOT_DIST_CLIENT = NEXT_PROJECT_ROOT_DIST_CLIENT
                const NEXT_PROJECT_ROOT_DIST_SERVER = (0, _path.join)(
                    NEXT_PROJECT_ROOT_DIST,
                    'server'
                ) // Regex for API routes
                exports.NEXT_PROJECT_ROOT_DIST_SERVER = NEXT_PROJECT_ROOT_DIST_SERVER
                const API_ROUTE = /^\/api(?:\/|$)/ // Because on Windows absolute paths in the generated code can break because of numbers, eg 1 in the path,
                // we have to use a private alias
                exports.API_ROUTE = API_ROUTE
                const PAGES_DIR_ALIAS = 'private-next-pages'
                exports.PAGES_DIR_ALIAS = PAGES_DIR_ALIAS
                const DOT_NEXT_ALIAS = 'private-dot-next'
                exports.DOT_NEXT_ALIAS = DOT_NEXT_ALIAS
                const PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://err.sh/zeit/next.js/public-next-folder-conflict`
                exports.PUBLIC_DIR_MIDDLEWARE_CONFLICT = PUBLIC_DIR_MIDDLEWARE_CONFLICT
                const SPR_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with unstable_getStaticProps. To use SPR, please remove your getInitialProps`
                exports.SPR_GET_INITIAL_PROPS_CONFLICT = SPR_GET_INITIAL_PROPS_CONFLICT
                /* WEBPACK VAR INJECTION */
            }.call(this, '/'))

            /***/
        },

        /***/ dt0z: /***/ function(module, exports, __webpack_require__) {
            var baseToString = __webpack_require__('zoYe')

            /**
             * Converts `value` to a string. An empty string is returned for `null`
             * and `undefined` values. The sign of `-0` is preserved.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to convert.
             * @returns {string} Returns the converted string.
             * @example
             *
             * _.toString(null);
             * // => ''
             *
             * _.toString(-0);
             * // => '-0'
             *
             * _.toString([1, 2, 3]);
             * // => '1,2,3'
             */
            function toString(value) {
                return value == null ? '' : baseToString(value)
            }

            module.exports = toString

            /***/
        },

        /***/ e4Nc: /***/ function(module, exports, __webpack_require__) {
            var mapCacheClear = __webpack_require__('fGT3'),
                mapCacheDelete = __webpack_require__('k+1r'),
                mapCacheGet = __webpack_require__('JHgL'),
                mapCacheHas = __webpack_require__('pSRY'),
                mapCacheSet = __webpack_require__('H8j4')

            /**
             * Creates a map cache object to store key-value pairs.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function MapCache(entries) {
                var index = -1,
                    length = entries == null ? 0 : entries.length

                this.clear()
                while (++index < length) {
                    var entry = entries[index]
                    this.set(entry[0], entry[1])
                }
            }

            // Add methods to `MapCache`.
            MapCache.prototype.clear = mapCacheClear
            MapCache.prototype['delete'] = mapCacheDelete
            MapCache.prototype.get = mapCacheGet
            MapCache.prototype.has = mapCacheHas
            MapCache.prototype.set = mapCacheSet

            module.exports = MapCache

            /***/
        },

        /***/ e5cp: /***/ function(module, exports, __webpack_require__) {
            var Stack = __webpack_require__('fmRc'),
                equalArrays = __webpack_require__('or5M'),
                equalByTag = __webpack_require__('HDyB'),
                equalObjects = __webpack_require__('seXi'),
                getTag = __webpack_require__('QqLw'),
                isArray = __webpack_require__('Z0cm'),
                isBuffer = __webpack_require__('DSRE'),
                isTypedArray = __webpack_require__('c6wG')

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1

            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]',
                arrayTag = '[object Array]',
                objectTag = '[object Object]'

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * A specialized version of `baseIsEqual` for arrays and objects which performs
             * deep comparisons and tracks traversed objects enabling objects with circular
             * references to be compared.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
             * @param {Function} customizer The function to customize comparisons.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Object} [stack] Tracks traversed `object` and `other` objects.
             * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
             */
            function baseIsEqualDeep(
                object,
                other,
                bitmask,
                customizer,
                equalFunc,
                stack
            ) {
                var objIsArr = isArray(object),
                    othIsArr = isArray(other),
                    objTag = objIsArr ? arrayTag : getTag(object),
                    othTag = othIsArr ? arrayTag : getTag(other)

                objTag = objTag == argsTag ? objectTag : objTag
                othTag = othTag == argsTag ? objectTag : othTag

                var objIsObj = objTag == objectTag,
                    othIsObj = othTag == objectTag,
                    isSameTag = objTag == othTag

                if (isSameTag && isBuffer(object)) {
                    if (!isBuffer(other)) {
                        return false
                    }
                    objIsArr = true
                    objIsObj = false
                }
                if (isSameTag && !objIsObj) {
                    stack || (stack = new Stack())
                    return objIsArr || isTypedArray(object)
                        ? equalArrays(
                              object,
                              other,
                              bitmask,
                              customizer,
                              equalFunc,
                              stack
                          )
                        : equalByTag(
                              object,
                              other,
                              objTag,
                              bitmask,
                              customizer,
                              equalFunc,
                              stack
                          )
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                    var objIsWrapped =
                            objIsObj &&
                            hasOwnProperty.call(object, '__wrapped__'),
                        othIsWrapped =
                            othIsObj &&
                            hasOwnProperty.call(other, '__wrapped__')

                    if (objIsWrapped || othIsWrapped) {
                        var objUnwrapped = objIsWrapped
                                ? object.value()
                                : object,
                            othUnwrapped = othIsWrapped ? other.value() : other

                        stack || (stack = new Stack())
                        return equalFunc(
                            objUnwrapped,
                            othUnwrapped,
                            bitmask,
                            customizer,
                            stack
                        )
                    }
                }
                if (!isSameTag) {
                    return false
                }
                stack || (stack = new Stack())
                return equalObjects(
                    object,
                    other,
                    bitmask,
                    customizer,
                    equalFunc,
                    stack
                )
            }

            module.exports = baseIsEqualDeep

            /***/
        },

        /***/ eC53: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const EventEmitter = __webpack_require__('/0p4')
            const urlLib = __webpack_require__('bzos')
            const normalizeUrl = __webpack_require__('NCJl')
            const getStream = __webpack_require__('gK4g')
            const CachePolicy = __webpack_require__('lERV')
            const Response = __webpack_require__('O9zF')
            const lowercaseKeys = __webpack_require__('D5mk')
            const cloneResponse = __webpack_require__('21rS')
            const Keyv = __webpack_require__('mxNO')

            class CacheableRequest {
                constructor(request, cacheAdapter) {
                    if (typeof request !== 'function') {
                        throw new TypeError(
                            'Parameter `request` must be a function'
                        )
                    }

                    this.cache = new Keyv({
                        uri: typeof cacheAdapter === 'string' && cacheAdapter,
                        store: typeof cacheAdapter !== 'string' && cacheAdapter,
                        namespace: 'cacheable-request'
                    })

                    return this.createCacheableRequest(request)
                }

                createCacheableRequest(request) {
                    return (opts, cb) => {
                        let url
                        if (typeof opts === 'string') {
                            url = normalizeUrlObject(urlLib.parse(opts))
                            opts = {}
                        } else if (opts instanceof urlLib.URL) {
                            url = normalizeUrlObject(
                                urlLib.parse(opts.toString())
                            )
                            opts = {}
                        } else {
                            const [pathname, ...searchParts] = (
                                opts.path || ''
                            ).split('?')
                            const search =
                                searchParts.length > 0
                                    ? `?${searchParts.join('?')}`
                                    : ''
                            url = normalizeUrlObject({
                                ...opts,
                                pathname,
                                search
                            })
                        }

                        opts = {
                            headers: {},
                            method: 'GET',
                            cache: true,
                            strictTtl: false,
                            automaticFailover: false,
                            ...opts,
                            ...urlObjectToRequestOptions(url)
                        }
                        opts.headers = lowercaseKeys(opts.headers)

                        const ee = new EventEmitter()
                        const normalizedUrlString = normalizeUrl(
                            urlLib.format(url),
                            {
                                stripWWW: false,
                                removeTrailingSlash: false,
                                stripAuthentication: false
                            }
                        )
                        const key = `${opts.method}:${normalizedUrlString}`
                        let revalidate = false
                        let madeRequest = false

                        const makeRequest = opts => {
                            madeRequest = true
                            let requestErrored = false
                            let requestErrorCallback

                            const requestErrorPromise = new Promise(resolve => {
                                requestErrorCallback = () => {
                                    if (!requestErrored) {
                                        requestErrored = true
                                        resolve()
                                    }
                                }
                            })

                            const handler = response => {
                                if (revalidate && !opts.forceRefresh) {
                                    response.status = response.statusCode
                                    const revalidatedPolicy = CachePolicy.fromObject(
                                        revalidate.cachePolicy
                                    ).revalidatedPolicy(opts, response)
                                    if (!revalidatedPolicy.modified) {
                                        const headers = revalidatedPolicy.policy.responseHeaders()
                                        response = new Response(
                                            revalidate.statusCode,
                                            headers,
                                            revalidate.body,
                                            revalidate.url
                                        )
                                        response.cachePolicy =
                                            revalidatedPolicy.policy
                                        response.fromCache = true
                                    }
                                }

                                if (!response.fromCache) {
                                    response.cachePolicy = new CachePolicy(
                                        opts,
                                        response,
                                        opts
                                    )
                                    response.fromCache = false
                                }

                                let clonedResponse
                                if (
                                    opts.cache &&
                                    response.cachePolicy.storable()
                                ) {
                                    clonedResponse = cloneResponse(response)

                                    ;(async () => {
                                        try {
                                            const bodyPromise = getStream.buffer(
                                                response
                                            )

                                            await Promise.race([
                                                requestErrorPromise,
                                                new Promise(resolve =>
                                                    response.once(
                                                        'end',
                                                        resolve
                                                    )
                                                )
                                            ])

                                            if (requestErrored) {
                                                return
                                            }

                                            const body = await bodyPromise

                                            const value = {
                                                cachePolicy: response.cachePolicy.toObject(),
                                                url: response.url,
                                                statusCode: response.fromCache
                                                    ? revalidate.statusCode
                                                    : response.statusCode,
                                                body
                                            }

                                            let ttl = opts.strictTtl
                                                ? response.cachePolicy.timeToLive()
                                                : undefined
                                            if (opts.maxTtl) {
                                                ttl = ttl
                                                    ? Math.min(ttl, opts.maxTtl)
                                                    : opts.maxTtl
                                            }

                                            await this.cache.set(
                                                key,
                                                value,
                                                ttl
                                            )
                                        } catch (error) {
                                            ee.emit(
                                                'error',
                                                new CacheableRequest.CacheError(
                                                    error
                                                )
                                            )
                                        }
                                    })()
                                } else if (opts.cache && revalidate) {
                                    ;(async () => {
                                        try {
                                            await this.cache.delete(key)
                                        } catch (error) {
                                            ee.emit(
                                                'error',
                                                new CacheableRequest.CacheError(
                                                    error
                                                )
                                            )
                                        }
                                    })()
                                }

                                ee.emit('response', clonedResponse || response)
                                if (typeof cb === 'function') {
                                    cb(clonedResponse || response)
                                }
                            }

                            try {
                                const req = request(opts, handler)
                                req.once('error', requestErrorCallback)
                                req.once('abort', requestErrorCallback)
                                ee.emit('request', req)
                            } catch (error) {
                                ee.emit(
                                    'error',
                                    new CacheableRequest.RequestError(error)
                                )
                            }
                        }

                        ;(async () => {
                            const get = async opts => {
                                await Promise.resolve()

                                const cacheEntry = opts.cache
                                    ? await this.cache.get(key)
                                    : undefined
                                if (typeof cacheEntry === 'undefined') {
                                    return makeRequest(opts)
                                }

                                const policy = CachePolicy.fromObject(
                                    cacheEntry.cachePolicy
                                )
                                if (
                                    policy.satisfiesWithoutRevalidation(opts) &&
                                    !opts.forceRefresh
                                ) {
                                    const headers = policy.responseHeaders()
                                    const response = new Response(
                                        cacheEntry.statusCode,
                                        headers,
                                        cacheEntry.body,
                                        cacheEntry.url
                                    )
                                    response.cachePolicy = policy
                                    response.fromCache = true

                                    ee.emit('response', response)
                                    if (typeof cb === 'function') {
                                        cb(response)
                                    }
                                } else {
                                    revalidate = cacheEntry
                                    opts.headers = policy.revalidationHeaders(
                                        opts
                                    )
                                    makeRequest(opts)
                                }
                            }

                            const errorHandler = error =>
                                ee.emit(
                                    'error',
                                    new CacheableRequest.CacheError(error)
                                )
                            this.cache.once('error', errorHandler)
                            ee.on('response', () =>
                                this.cache.removeListener('error', errorHandler)
                            )

                            try {
                                await get(opts)
                            } catch (error) {
                                if (opts.automaticFailover && !madeRequest) {
                                    makeRequest(opts)
                                }

                                ee.emit(
                                    'error',
                                    new CacheableRequest.CacheError(error)
                                )
                            }
                        })()

                        return ee
                    }
                }
            }

            function urlObjectToRequestOptions(url) {
                const options = { ...url }
                options.path = `${url.pathname || '/'}${url.search || ''}`
                delete options.pathname
                delete options.search
                return options
            }

            function normalizeUrlObject(url) {
                // If url was parsed by url.parse or new URL:
                // - hostname will be set
                // - host will be hostname[:port]
                // - port will be set if it was explicit in the parsed string
                // Otherwise, url was from request options:
                // - hostname or host may be set
                // - host shall not have port encoded
                return {
                    protocol: url.protocol,
                    auth: url.auth,
                    hostname: url.hostname || url.host || 'localhost',
                    port: url.port,
                    pathname: url.pathname,
                    search: url.search
                }
            }

            CacheableRequest.RequestError = class extends Error {
                constructor(error) {
                    super(error.message)
                    this.name = 'RequestError'
                    Object.assign(this, error)
                }
            }

            CacheableRequest.CacheError = class extends Error {
                constructor(error) {
                    super(error.message)
                    this.name = 'CacheError'
                    Object.assign(this, error)
                }
            }

            module.exports = CacheableRequest

            /***/
        },

        /***/ eHfw: /***/ function(module, exports, __webpack_require__) {
            /* global BigInt */

            const { randomBytes } = __webpack_require__('PJMN')

            const base64url = __webpack_require__('Xab3')
            const errors = __webpack_require__('yt7c')

            const ZERO = BigInt(0)
            const ONE = BigInt(1)
            const TWO = BigInt(2)

            const toJWKParameter = n => {
                const hex = n.toString(16)
                return base64url.encodeBuffer(
                    Buffer.from(hex.length % 2 ? `0${hex}` : hex, 'hex')
                )
            }
            const fromBuffer = buf => BigInt(`0x${buf.toString('hex')}`)
            const bitLength = n => n.toString(2).length

            const eGcdX = (a, b) => {
                let x = ZERO
                let y = ONE
                let u = ONE
                let v = ZERO

                while (a !== ZERO) {
                    const q = b / a
                    const r = b % a
                    const m = x - u * q
                    const n = y - v * q
                    b = a
                    a = r
                    x = u
                    y = v
                    u = m
                    v = n
                }
                return x
            }

            const gcd = (a, b) => {
                let shift = ZERO
                while (!((a | b) & ONE)) {
                    a >>= ONE
                    b >>= ONE
                    shift++
                }
                while (!(a & ONE)) {
                    a >>= ONE
                }
                do {
                    while (!(b & ONE)) {
                        b >>= ONE
                    }
                    if (a > b) {
                        const x = a
                        a = b
                        b = x
                    }
                    b -= a
                } while (b)

                return a << shift
            }

            const modPow = (a, b, n) => {
                a = toZn(a, n)
                let result = ONE
                let x = a
                while (b > 0) {
                    var leastSignificantBit = b % TWO
                    b = b / TWO
                    if (leastSignificantBit === ONE) {
                        result = result * x
                        result = result % n
                    }
                    x = x * x
                    x = x % n
                }
                return result
            }

            const randBetween = (min, max) => {
                const interval = max - min
                const bitLen = bitLength(interval)
                let rnd
                do {
                    rnd = fromBuffer(randBits(bitLen))
                } while (rnd > interval)
                return rnd + min
            }

            const randBits = bitLength => {
                const byteLength = Math.ceil(bitLength / 8)
                const rndBytes = randomBytes(byteLength)
                // Fill with 0's the extra bits
                rndBytes[0] = rndBytes[0] & (2 ** (bitLength % 8) - 1)
                return rndBytes
            }

            const toZn = (a, n) => {
                a = a % n
                return a < 0 ? a + n : a
            }

            const odd = n => {
                let r = n
                while (r % TWO === ZERO) {
                    r = r / TWO
                }
                return r
            }

            // not sold on these values
            const maxCountWhileNoY = 30
            const maxCountWhileInot0 = 22

            const getPrimeFactors = (e, d, n) => {
                const r = odd(e * d - ONE)

                let countWhileNoY = 0
                let y
                do {
                    countWhileNoY++
                    if (countWhileNoY === maxCountWhileNoY) {
                        throw new errors.JWKImportFailed(
                            'failed to calculate missing primes'
                        )
                    }

                    let countWhileInot0 = 0
                    let i = modPow(randBetween(TWO, n), r, n)
                    let o = ZERO
                    while (i !== ONE) {
                        countWhileInot0++
                        if (countWhileInot0 === maxCountWhileInot0) {
                            throw new errors.JWKImportFailed(
                                'failed to calculate missing primes'
                            )
                        }
                        o = i
                        i = (i * i) % n
                    }
                    if (o !== n - ONE) {
                        y = o
                    }
                } while (!y)

                const p = gcd(y - ONE, n)
                const q = n / p

                return p > q ? { p, q } : { p: q, q: p }
            }

            module.exports = jwk => {
                const e = fromBuffer(base64url.decodeToBuffer(jwk.e))
                const d = fromBuffer(base64url.decodeToBuffer(jwk.d))
                const n = fromBuffer(base64url.decodeToBuffer(jwk.n))

                if (d >= n) {
                    throw new errors.JWKInvalid('invalid RSA private exponent')
                }

                const { p, q } = getPrimeFactors(e, d, n)
                const dp = d % (p - ONE)
                const dq = d % (q - ONE)
                const qi = toZn(eGcdX(toZn(q, p), p), p)

                return {
                    ...jwk,
                    p: toJWKParameter(p),
                    q: toJWKParameter(q),
                    dp: toJWKParameter(dp),
                    dq: toJWKParameter(dq),
                    qi: toJWKParameter(qi)
                }
            }

            /***/
        },

        /***/ eUgh: /***/ function(module, exports) {
            /**
             * A specialized version of `_.map` for arrays without support for iteratee
             * shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the new mapped array.
             */
            function arrayMap(array, iteratee) {
                var index = -1,
                    length = array == null ? 0 : array.length,
                    result = Array(length)

                while (++index < length) {
                    result[index] = iteratee(array[index], index, array)
                }
                return result
            }

            module.exports = arrayMap

            /***/
        },

        /***/ eUtF: /***/ function(module, exports, __webpack_require__) {
            module.exports =
                !__webpack_require__('jmDH') &&
                !__webpack_require__('KUxP')(function() {
                    return (
                        Object.defineProperty(
                            __webpack_require__('Hsns')('div'),
                            'a',
                            {
                                get: function() {
                                    return 7
                                }
                            }
                        ).a != 7
                    )
                })

            /***/
        },

        /***/ eVuF: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('aW7e')

            /***/
        },

        /***/ eaoh: /***/ function(module, exports) {
            module.exports = function(it) {
                if (typeof it != 'function')
                    throw TypeError(it + ' is not a function!')
                return it
            }

            /***/
        },

        /***/ ebwN: /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5'),
                root = __webpack_require__('Kz5y')

            /* Built-in method references that are verified to be native. */
            var Map = getNative(root, 'Map')

            module.exports = Map

            /***/
        },

        /***/ ecj1: /***/ function(module, exports, __webpack_require__) {
            const Issuer = __webpack_require__('A93I')
            const { OPError, RPError } = __webpack_require__('L71r')
            const Registry = __webpack_require__('0Aai')
            const Strategy = __webpack_require__('/co4')
            const TokenSet = __webpack_require__('IgmS')
            const { CLOCK_TOLERANCE, HTTP_OPTIONS } = __webpack_require__(
                'TJm8'
            )
            const generators = __webpack_require__('iAgo')
            const { setDefaults } = __webpack_require__('UwMm')

            module.exports = {
                Issuer,
                Registry,
                Strategy,
                TokenSet,
                errors: {
                    OPError,
                    RPError
                },
                custom: {
                    setHttpOptionsDefaults: setDefaults,
                    http_options: HTTP_OPTIONS,
                    clock_tolerance: CLOCK_TOLERANCE
                },
                generators
            }

            /***/
        },

        /***/ ehsS: /***/ function(module, exports) {
            module.exports.KEYOBJECT = Symbol('KEYOBJECT')
            module.exports.PRIVATE_MEMBERS = Symbol('PRIVATE_MEMBERS')
            module.exports.PUBLIC_MEMBERS = Symbol('PUBLIC_MEMBERS')
            module.exports.THUMBPRINT_MATERIAL = Symbol('THUMBPRINT_MATERIAL')
            module.exports.JWK_MEMBERS = Symbol('JWK_MEMBERS')
            module.exports.KEY_MANAGEMENT_ENCRYPT = Symbol(
                'KEY_MANAGEMENT_ENCRYPT'
            )
            module.exports.KEY_MANAGEMENT_DECRYPT = Symbol(
                'KEY_MANAGEMENT_DECRYPT'
            )

            const USES_MAPPING = {
                sig: new Set(['sign', 'verify']),
                enc: new Set([
                    'encrypt',
                    'decrypt',
                    'wrapKey',
                    'unwrapKey',
                    'deriveKey'
                ])
            }
            const OPS = new Set([...USES_MAPPING.sig, ...USES_MAPPING.enc])
            const USES = new Set(Object.keys(USES_MAPPING))

            module.exports.USES_MAPPING = USES_MAPPING
            module.exports.OPS = OPS
            module.exports.USES = USES

            /***/
        },

        /***/ ekgI: /***/ function(module, exports, __webpack_require__) {
            var nativeCreate = __webpack_require__('YESw')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Checks if a hash value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf Hash
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function hashHas(key) {
                var data = this.__data__
                return nativeCreate
                    ? data[key] !== undefined
                    : hasOwnProperty.call(data, key)
            }

            module.exports = hashHas

            /***/
        },

        /***/ elyg: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Promise = __webpack_require__('eVuF')

            var _Object$assign = __webpack_require__('UXZV')

            var _Object$defineProperty = __webpack_require__('hfKm')

            var __importDefault =
                (this && this.__importDefault) ||
                function(mod) {
                    return mod && mod.__esModule
                        ? mod
                        : {
                              default: mod
                          }
                }

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            const url_1 = __webpack_require__('bzos')

            const mitt_1 = __importDefault(__webpack_require__('dZ6Y'))

            const utils_1 = __webpack_require__('g/15')

            const rewrite_url_for_export_1 = __webpack_require__('P5f7')

            const is_dynamic_1 = __webpack_require__('/jkW')

            const route_matcher_1 = __webpack_require__('gguc')

            const route_regex_1 = __webpack_require__('YTqd')

            function toRoute(path) {
                return path.replace(/\/$/, '') || '/'
            }

            class Router {
                constructor(
                    pathname,
                    query,
                    as,
                    {
                        initialProps,
                        pageLoader,
                        App,
                        wrapApp,
                        Component,
                        err,
                        subscription
                    }
                ) {
                    this.onPopState = e => {
                        if (!e.state) {
                            // We get state as undefined for two reasons.
                            //  1. With older safari (< 8) and older chrome (< 34)
                            //  2. When the URL changed with #
                            //
                            // In the both cases, we don't need to proceed and change the route.
                            // (as it's already changed)
                            // But we can simply replace the state with the new changes.
                            // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
                            // So, doing the following for (1) does no harm.
                            const { pathname, query } = this
                            this.changeState(
                                'replaceState',
                                utils_1.formatWithValidation({
                                    pathname,
                                    query
                                }),
                                utils_1.getURL()
                            )
                            return
                        } // Make sure we don't re-render on initial load,
                        // can be caused by navigating back from an external site

                        if (
                            e.state &&
                            this.isSsr &&
                            e.state.url === this.pathname &&
                            e.state.as === this.asPath
                        ) {
                            return
                        } // If the downstream application returns falsy, return.
                        // They will then be responsible for handling the event.

                        if (this._bps && !this._bps(e.state)) {
                            return
                        }

                        const { url, as, options } = e.state

                        if (false) {
                        }

                        this.replace(url, as, options)
                    } // represents the current component key

                    this.route = toRoute(pathname) // set up the component cache (by route keys)

                    this.components = {} // We should not keep the cache, if there's an error
                    // Otherwise, this cause issues when when going back and
                    // come again to the errored page.

                    if (pathname !== '/_error') {
                        this.components[this.route] = {
                            Component,
                            props: initialProps,
                            err
                        }
                    }

                    this.components['/_app'] = {
                        Component: App
                    } // Backwards compat for Router.router.events
                    // TODO: Should be remove the following major version as it was never documented
                    // @ts-ignore backwards compatibility

                    this.events = Router.events
                    this.pageLoader = pageLoader
                    this.pathname = pathname
                    this.query = query // if auto prerendered and dynamic route wait to update asPath
                    // until after mount to prevent hydration mismatch

                    this.asPath = // @ts-ignore this is temporarily global (attached to window)
                        is_dynamic_1.isDynamicRoute(pathname) &&
                        __NEXT_DATA__.autoExport
                            ? pathname
                            : as
                    this.sub = subscription
                    this.clc = null
                    this._wrapApp = wrapApp // make sure to ignore extra popState in safari on navigating
                    // back from external site

                    this.isSsr = true

                    if (false) {
                    }
                } // @deprecated backwards compatibility even though it's a private method.

                static _rewriteUrlForNextExport(url) {
                    return rewrite_url_for_export_1.rewriteUrlForNextExport(url)
                }

                update(route, mod) {
                    const Component = mod.default || mod
                    const data = this.components[route]

                    if (!data) {
                        throw new Error(
                            `Cannot update unavailable route: ${route}`
                        )
                    }

                    const newData = _Object$assign({}, data, {
                        Component
                    })

                    this.components[route] = newData // pages/_app.js updated

                    if (route === '/_app') {
                        this.notify(this.components[this.route])
                        return
                    }

                    if (route === this.route) {
                        this.notify(newData)
                    }
                }

                reload() {
                    window.location.reload()
                }
                /**
                 * Go back in history
                 */

                back() {
                    window.history.back()
                }
                /**
                 * Performs a `pushState` with arguments
                 * @param url of the route
                 * @param as masks `url` for the browser
                 * @param options object you can define `shallow` and other options
                 */

                push(url, as = url, options = {}) {
                    return this.change('pushState', url, as, options)
                }
                /**
                 * Performs a `replaceState` with arguments
                 * @param url of the route
                 * @param as masks `url` for the browser
                 * @param options object you can define `shallow` and other options
                 */

                replace(url, as = url, options = {}) {
                    return this.change('replaceState', url, as, options)
                }

                change(method, _url, _as, options) {
                    return new _Promise((resolve, reject) => {
                        if (!options._h) {
                            this.isSsr = false
                        } // marking route changes as a navigation start entry

                        if (utils_1.SUPPORTS_PERFORMANCE_USER_TIMING) {
                            performance.mark('routeChange')
                        } // If url and as provided as an object representation,
                        // we'll format them into the string version here.

                        const url =
                            typeof _url === 'object'
                                ? utils_1.formatWithValidation(_url)
                                : _url
                        let as =
                            typeof _as === 'object'
                                ? utils_1.formatWithValidation(_as)
                                : _as // Add the ending slash to the paths. So, we can serve the
                        // "<page>/index.html" directly for the SSR page.

                        if (false) {
                        }

                        this.abortComponentLoad(as) // If the url change is only related to a hash change
                        // We should not proceed. We should only change the state.
                        // WARNING: `_h` is an internal option for handing Next.js client-side
                        // hydration. Your app should _never_ use this property. It may change at
                        // any time without notice.

                        if (!options._h && this.onlyAHashChange(as)) {
                            this.asPath = as
                            Router.events.emit('hashChangeStart', as)
                            this.changeState(method, url, as)
                            this.scrollToHash(as)
                            Router.events.emit('hashChangeComplete', as)
                            return resolve(true)
                        }

                        const { pathname, query, protocol } = url_1.parse(
                            url,
                            true
                        )

                        if (!pathname || protocol) {
                            if (false) {
                            }

                            return resolve(false)
                        } // If asked to change the current URL we should reload the current page
                        // (not location.reload() but reload getInitialProps and other Next.js stuffs)
                        // We also need to set the method = replaceState always
                        // as this should not go into the history (That's how browsers work)
                        // We should compare the new asPath to the current asPath, not the url

                        if (!this.urlIsNew(as)) {
                            method = 'replaceState'
                        } // @ts-ignore pathname is always a string

                        const route = toRoute(pathname)
                        const { shallow = false } = options

                        if (is_dynamic_1.isDynamicRoute(route)) {
                            const { pathname: asPathname } = url_1.parse(as)
                            const rr = route_regex_1.getRouteRegex(route)
                            const routeMatch = route_matcher_1.getRouteMatcher(
                                rr
                            )(asPathname)

                            if (!routeMatch) {
                                const error =
                                    'The provided `as` value is incompatible with the `href` value. This is invalid. https://err.sh/zeit/next.js/incompatible-href-as'

                                if (false) {
                                } else {
                                    console.error(error)
                                }

                                return resolve(false)
                            } // Merge params into `query`, overwriting any specified in search

                            _Object$assign(query, routeMatch)
                        }

                        Router.events.emit('routeChangeStart', as) // If shallow is true and the route exists in the router cache we reuse the previous result
                        // @ts-ignore pathname is always a string

                        this.getRouteInfo(
                            route,
                            pathname,
                            query,
                            as,
                            shallow
                        ).then(routeInfo => {
                            const { error } = routeInfo

                            if (error && error.cancelled) {
                                return resolve(false)
                            }

                            Router.events.emit('beforeHistoryChange', as)
                            this.changeState(method, url, as, options)
                            const hash = window.location.hash.substring(1)

                            if (false) {
                            } // @ts-ignore pathname is always defined

                            this.set(
                                route,
                                pathname,
                                query,
                                as,
                                _Object$assign({}, routeInfo, {
                                    hash
                                })
                            )

                            if (error) {
                                Router.events.emit(
                                    'routeChangeError',
                                    error,
                                    as
                                )
                                throw error
                            }

                            Router.events.emit('routeChangeComplete', as)
                            return resolve(true)
                        }, reject)
                    })
                }

                changeState(method, url, as, options = {}) {
                    if (false) {
                    }

                    if (method !== 'pushState' || utils_1.getURL() !== as) {
                        // @ts-ignore method should always exist on history
                        window.history[method](
                            {
                                url,
                                as,
                                options
                            },
                            null,
                            as
                        )
                    }
                }

                getRouteInfo(route, pathname, query, as, shallow = false) {
                    const cachedRouteInfo = this.components[route] // If there is a shallow route transition possible
                    // If the route is already rendered on the screen.

                    if (shallow && cachedRouteInfo && this.route === route) {
                        return _Promise.resolve(cachedRouteInfo)
                    }

                    return new _Promise((resolve, reject) => {
                        if (cachedRouteInfo) {
                            return resolve(cachedRouteInfo)
                        }

                        this.fetchComponent(route).then(
                            Component =>
                                resolve({
                                    Component
                                }),
                            reject
                        )
                    })
                        .then(routeInfo => {
                            const { Component } = routeInfo

                            if (false) {
                            }

                            return new _Promise((resolve, reject) => {
                                // we provide AppTree later so this needs to be `any`
                                this.getInitialProps(Component, {
                                    pathname,
                                    query,
                                    asPath: as
                                }).then(props => {
                                    routeInfo.props = props
                                    this.components[route] = routeInfo
                                    resolve(routeInfo)
                                }, reject)
                            })
                        })
                        .catch(err => {
                            return new _Promise(resolve => {
                                if (err.code === 'PAGE_LOAD_ERROR') {
                                    // If we can't load the page it could be one of following reasons
                                    //  1. Page doesn't exists
                                    //  2. Page does exist in a different zone
                                    //  3. Internal error while loading the page
                                    // So, doing a hard reload is the proper way to deal with this.
                                    window.location.href = as // Changing the URL doesn't block executing the current code path.
                                    // So, we need to mark it as a cancelled error and stop the routing logic.

                                    err.cancelled = true // @ts-ignore TODO: fix the control flow here

                                    return resolve({
                                        error: err
                                    })
                                }

                                if (err.cancelled) {
                                    // @ts-ignore TODO: fix the control flow here
                                    return resolve({
                                        error: err
                                    })
                                }

                                resolve(
                                    this.fetchComponent('/_error').then(
                                        Component => {
                                            const routeInfo = {
                                                Component,
                                                err
                                            }
                                            return new _Promise(resolve => {
                                                this.getInitialProps(
                                                    Component,
                                                    {
                                                        err,
                                                        pathname,
                                                        query
                                                    }
                                                ).then(
                                                    props => {
                                                        routeInfo.props = props
                                                        routeInfo.error = err
                                                        resolve(routeInfo)
                                                    },
                                                    gipErr => {
                                                        console.error(
                                                            'Error in error page `getInitialProps`: ',
                                                            gipErr
                                                        )
                                                        routeInfo.error = err
                                                        routeInfo.props = {}
                                                        resolve(routeInfo)
                                                    }
                                                )
                                            })
                                        }
                                    )
                                )
                            })
                        })
                }

                set(route, pathname, query, as, data) {
                    this.route = route
                    this.pathname = pathname
                    this.query = query
                    this.asPath = as
                    this.notify(data)
                }
                /**
                 * Callback to execute before replacing router state
                 * @param cb callback to be executed
                 */

                beforePopState(cb) {
                    this._bps = cb
                }

                onlyAHashChange(as) {
                    if (!this.asPath) return false
                    const [oldUrlNoHash, oldHash] = this.asPath.split('#')
                    const [newUrlNoHash, newHash] = as.split('#') // Makes sure we scroll to the provided hash if the url/hash are the same

                    if (
                        newHash &&
                        oldUrlNoHash === newUrlNoHash &&
                        oldHash === newHash
                    ) {
                        return true
                    } // If the urls are change, there's more than a hash change

                    if (oldUrlNoHash !== newUrlNoHash) {
                        return false
                    } // If the hash has changed, then it's a hash only change.
                    // This check is necessary to handle both the enter and
                    // leave hash === '' cases. The identity case falls through
                    // and is treated as a next reload.

                    return oldHash !== newHash
                }

                scrollToHash(as) {
                    const [, hash] = as.split('#') // Scroll to top if the hash is just `#` with no value

                    if (hash === '') {
                        window.scrollTo(0, 0)
                        return
                    } // First we check if the element by id is found

                    const idEl = document.getElementById(hash)

                    if (idEl) {
                        idEl.scrollIntoView()
                        return
                    } // If there's no element with the id, we check the `name` property
                    // To mirror browsers

                    const nameEl = document.getElementsByName(hash)[0]

                    if (nameEl) {
                        nameEl.scrollIntoView()
                    }
                }

                urlIsNew(asPath) {
                    return this.asPath !== asPath
                }
                /**
                 * Prefetch `page` code, you may wait for the data during `page` rendering.
                 * This feature only works in production!
                 * @param url of prefetched `page`
                 */

                prefetch(url) {
                    return new _Promise((resolve, reject) => {
                        const { pathname, protocol } = url_1.parse(url)

                        if (!pathname || protocol) {
                            if (false) {
                            }

                            return
                        } // Prefetch is not supported in development mode because it would trigger on-demand-entries

                        if (false) {
                        } // @ts-ignore pathname is always defined

                        const route = toRoute(pathname)
                        this.pageLoader.prefetch(route).then(resolve, reject)
                    })
                }

                async fetchComponent(route) {
                    let cancelled = false

                    const cancel = (this.clc = () => {
                        cancelled = true
                    })

                    const Component = await this.pageLoader.loadPage(route)

                    if (cancelled) {
                        const error = new Error(
                            `Abort fetching component for route: "${route}"`
                        )
                        error.cancelled = true
                        throw error
                    }

                    if (cancel === this.clc) {
                        this.clc = null
                    }

                    return Component
                }

                async getInitialProps(Component, ctx) {
                    let cancelled = false

                    const cancel = () => {
                        cancelled = true
                    }

                    this.clc = cancel
                    const { Component: App } = this.components['/_app']
                    let props

                    if (Component.__NEXT_SPR) {
                        let status // pathname should have leading slash

                        let { pathname } = url_1.parse(
                            ctx.asPath || ctx.pathname
                        )
                        pathname =
                            !pathname || pathname === '/' ? '/index' : pathname
                        props = await fetch(
                            // @ts-ignore __NEXT_DATA__
                            `/_next/data/${__NEXT_DATA__.buildId}${pathname}.json`
                        )
                            .then(res => {
                                if (!res.ok) {
                                    status = res.status
                                    throw new Error(
                                        'failed to load prerender data'
                                    )
                                }

                                return res.json()
                            })
                            .catch(err => {
                                console.error(
                                    `Failed to load data`,
                                    status,
                                    err
                                )
                                window.location.href = pathname
                                return new _Promise(() => {})
                            })
                    } else {
                        const AppTree = this._wrapApp(App)

                        ctx.AppTree = AppTree
                        props = await utils_1.loadGetInitialProps(App, {
                            AppTree,
                            Component,
                            router: this,
                            ctx
                        })
                    }

                    if (cancel === this.clc) {
                        this.clc = null
                    }

                    if (cancelled) {
                        const err = new Error('Loading initial props cancelled')
                        err.cancelled = true
                        throw err
                    }

                    return props
                }

                abortComponentLoad(as) {
                    if (this.clc) {
                        const e = new Error('Route Cancelled')
                        e.cancelled = true
                        Router.events.emit('routeChangeError', e, as)
                        this.clc()
                        this.clc = null
                    }
                }

                notify(data) {
                    this.sub(data, this.components['/_app'].Component)
                }
            }

            Router.events = mitt_1.default()
            exports.default = Router

            /***/
        },

        /***/ endd: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            /**
             * A `Cancel` is an object that is thrown when an operation is canceled.
             *
             * @class
             * @param {string=} message The message.
             */
            function Cancel(message) {
                this.message = message
            }

            Cancel.prototype.toString = function toString() {
                return 'Cancel' + (this.message ? ': ' + this.message : '')
            }

            Cancel.prototype.__CANCEL__ = true

            module.exports = Cancel

            /***/
        },

        /***/ eqyj: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')

            module.exports = utils.isStandardBrowserEnv()
                ? // Standard browser envs support document.cookie
                  (function standardBrowserEnv() {
                      return {
                          write: function write(
                              name,
                              value,
                              expires,
                              path,
                              domain,
                              secure
                          ) {
                              var cookie = []
                              cookie.push(
                                  name + '=' + encodeURIComponent(value)
                              )

                              if (utils.isNumber(expires)) {
                                  cookie.push(
                                      'expires=' +
                                          new Date(expires).toGMTString()
                                  )
                              }

                              if (utils.isString(path)) {
                                  cookie.push('path=' + path)
                              }

                              if (utils.isString(domain)) {
                                  cookie.push('domain=' + domain)
                              }

                              if (secure === true) {
                                  cookie.push('secure')
                              }

                              document.cookie = cookie.join('; ')
                          },

                          read: function read(name) {
                              var match = document.cookie.match(
                                  new RegExp('(^|;\\s*)(' + name + ')=([^;]*)')
                              )
                              return match ? decodeURIComponent(match[3]) : null
                          },

                          remove: function remove(name) {
                              this.write(name, '', Date.now() - 86400000)
                          }
                      }
                  })()
                : // Non standard browser env (web workers, react-native) lack needed support.
                  (function nonStandardBrowserEnv() {
                      return {
                          write: function write() {},
                          read: function read() {
                              return null
                          },
                          remove: function remove() {}
                      }
                  })()

            /***/
        },

        /***/ 'f/k9': /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /** @license React v1.1.1
             * use-subscription.production.min.js
             *
             * Copyright (c) Facebook, Inc. and its affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */

            Object.defineProperty(exports, '__esModule', { value: !0 })
            var h = __webpack_require__('q1tI'),
                l = Object.getOwnPropertySymbols,
                m = Object.prototype.hasOwnProperty,
                n = Object.prototype.propertyIsEnumerable,
                p = (function() {
                    try {
                        if (!Object.assign) return !1
                        var a = new String('abc')
                        a[5] = 'de'
                        if ('5' === Object.getOwnPropertyNames(a)[0]) return !1
                        var c = {}
                        for (a = 0; 10 > a; a++)
                            c['_' + String.fromCharCode(a)] = a
                        if (
                            '0123456789' !==
                            Object.getOwnPropertyNames(c)
                                .map(function(b) {
                                    return c[b]
                                })
                                .join('')
                        )
                            return !1
                        var d = {}
                        'abcdefghijklmnopqrst'.split('').forEach(function(b) {
                            d[b] = b
                        })
                        return 'abcdefghijklmnopqrst' !==
                            Object.keys(Object.assign({}, d)).join('')
                            ? !1
                            : !0
                    } catch (b) {
                        return !1
                    }
                })()
                    ? Object.assign
                    : function(a, c) {
                          if (null === a || void 0 === a)
                              throw new TypeError(
                                  'Object.assign cannot be called with null or undefined'
                              )
                          var d = Object(a)
                          for (var b, f = 1; f < arguments.length; f++) {
                              var g = Object(arguments[f])
                              for (var k in g) m.call(g, k) && (d[k] = g[k])
                              if (l) {
                                  b = l(g)
                                  for (var e = 0; e < b.length; e++)
                                      n.call(g, b[e]) && (d[b[e]] = g[b[e]])
                              }
                          }
                          return d
                      }
            exports.useSubscription = function(a) {
                var c = a.getCurrentValue,
                    d = a.subscribe,
                    b = h.useState(function() {
                        return { getCurrentValue: c, subscribe: d, value: c() }
                    })
                a = b[0]
                var f = b[1]
                b = a.value
                if (a.getCurrentValue !== c || a.subscribe !== d)
                    (b = c()), f({ getCurrentValue: c, subscribe: d, value: b })
                h.useDebugValue(b)
                h.useEffect(
                    function() {
                        function b() {
                            if (!a) {
                                var b = c()
                                f(function(a) {
                                    return a.getCurrentValue !== c ||
                                        a.subscribe !== d ||
                                        a.value === b
                                        ? a
                                        : p({}, a, { value: b })
                                })
                            }
                        }
                        var a = !1,
                            e = d(b)
                        b()
                        return function() {
                            a = !0
                            e()
                        }
                    },
                    [c, d]
                )
                return b
            }

            /***/
        },

        /***/ f0Nx: /***/ function(module, exports) {
            const MAX_OCTET = 0x80
            const CLASS_UNIVERSAL = 0
            const PRIMITIVE_BIT = 0x20
            const TAG_SEQ = 0x10
            const TAG_INT = 0x02
            const ENCODED_TAG_SEQ =
                TAG_SEQ | PRIMITIVE_BIT | (CLASS_UNIVERSAL << 6)
            const ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6)

            const getParamSize = keySize =>
                ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1)

            const paramBytesForAlg = {
                ES256: getParamSize(256),
                ES256K: getParamSize(256),
                ES384: getParamSize(384),
                ES512: getParamSize(521)
            }

            const countPadding = (buf, start, stop) => {
                let padding = 0
                while (start + padding < stop && buf[start + padding] === 0) {
                    ++padding
                }

                const needsSign = buf[start + padding] >= MAX_OCTET
                if (needsSign) {
                    --padding
                }

                return padding
            }

            module.exports.derToJose = (signature, alg) => {
                if (!Buffer.isBuffer(signature)) {
                    throw new TypeError('ECDSA signature must be a Buffer')
                }

                if (!paramBytesForAlg[alg]) {
                    throw new Error(`Unknown algorithm "${alg}"`)
                }

                const paramBytes = paramBytesForAlg[alg]

                // the DER encoded param should at most be the param size, plus a padding
                // zero, since due to being a signed integer
                const maxEncodedParamLength = paramBytes + 1

                const inputLength = signature.length

                let offset = 0
                if (signature[offset++] !== ENCODED_TAG_SEQ) {
                    throw new Error('Could not find expected "seq"')
                }

                let seqLength = signature[offset++]
                if (seqLength === (MAX_OCTET | 1)) {
                    seqLength = signature[offset++]
                }

                if (inputLength - offset < seqLength) {
                    throw new Error(
                        `"seq" specified length of ${seqLength}", only ${inputLength -
                            offset}" remaining`
                    )
                }

                if (signature[offset++] !== ENCODED_TAG_INT) {
                    throw new Error('Could not find expected "int" for "r"')
                }

                const rLength = signature[offset++]

                if (inputLength - offset - 2 < rLength) {
                    throw new Error(
                        `"r" specified length of "${rLength}", only "${inputLength -
                            offset -
                            2}" available`
                    )
                }

                if (maxEncodedParamLength < rLength) {
                    throw new Error(
                        `"r" specified length of "${rLength}", max of "${maxEncodedParamLength}" is acceptable`
                    )
                }

                const rOffset = offset
                offset += rLength

                if (signature[offset++] !== ENCODED_TAG_INT) {
                    throw new Error('Could not find expected "int" for "s"')
                }

                const sLength = signature[offset++]

                if (inputLength - offset !== sLength) {
                    throw new Error(
                        `"s" specified length of "${sLength}", expected "${inputLength -
                            offset}"`
                    )
                }

                if (maxEncodedParamLength < sLength) {
                    throw new Error(
                        `"s" specified length of "${sLength}", max of "${maxEncodedParamLength}" is acceptable`
                    )
                }

                const sOffset = offset
                offset += sLength

                if (offset !== inputLength) {
                    throw new Error(
                        `Expected to consume entire buffer, but "${inputLength -
                            offset}" bytes remain`
                    )
                }

                const rPadding = paramBytes - rLength

                const sPadding = paramBytes - sLength

                const dst = Buffer.allocUnsafe(
                    rPadding + rLength + sPadding + sLength
                )

                for (offset = 0; offset < rPadding; ++offset) {
                    dst[offset] = 0
                }
                signature.copy(
                    dst,
                    offset,
                    rOffset + Math.max(-rPadding, 0),
                    rOffset + rLength
                )

                offset = paramBytes

                for (const o = offset; offset < o + sPadding; ++offset) {
                    dst[offset] = 0
                }
                signature.copy(
                    dst,
                    offset,
                    sOffset + Math.max(-sPadding, 0),
                    sOffset + sLength
                )

                return dst
            }

            module.exports.joseToDer = (signature, alg) => {
                if (!Buffer.isBuffer(signature)) {
                    throw new TypeError('ECDSA signature must be a Buffer')
                }

                if (!paramBytesForAlg[alg]) {
                    throw new TypeError(`Unknown algorithm "${alg}"`)
                }

                const paramBytes = paramBytesForAlg[alg]

                const signatureBytes = signature.length
                if (signatureBytes !== paramBytes * 2) {
                    throw new Error(
                        `"${alg}" signatures must be "${paramBytes *
                            2}" bytes, saw "${signatureBytes}"`
                    )
                }

                const rPadding = countPadding(signature, 0, paramBytes)
                const sPadding = countPadding(
                    signature,
                    paramBytes,
                    signature.length
                )
                const rLength = paramBytes - rPadding
                const sLength = paramBytes - sPadding

                const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength

                const shortLength = rsBytes < MAX_OCTET

                const dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes)

                let offset = 0
                dst[offset++] = ENCODED_TAG_SEQ
                if (shortLength) {
                    // Bit 8 has value "0"
                    // bits 7-1 give the length.
                    dst[offset++] = rsBytes
                } else {
                    // Bit 8 of first octet has value "1"
                    // bits 7-1 give the number of additional length octets.
                    dst[offset++] = MAX_OCTET | 1 // eslint-disable-line no-tabs
                    // length, base 256
                    dst[offset++] = rsBytes & 0xff
                }
                dst[offset++] = ENCODED_TAG_INT
                dst[offset++] = rLength
                if (rPadding < 0) {
                    dst[offset++] = 0
                    offset += signature.copy(dst, offset, 0, paramBytes)
                } else {
                    offset += signature.copy(dst, offset, rPadding, paramBytes)
                }
                dst[offset++] = ENCODED_TAG_INT
                dst[offset++] = sLength
                if (sPadding < 0) {
                    dst[offset++] = 0
                    signature.copy(dst, offset, paramBytes)
                } else {
                    signature.copy(dst, offset, paramBytes + sPadding)
                }

                return dst
            }

            /***/
        },

        /***/ fGT3: /***/ function(module, exports, __webpack_require__) {
            var Hash = __webpack_require__('4kuk'),
                ListCache = __webpack_require__('Xi7e'),
                Map = __webpack_require__('ebwN')

            /**
             * Removes all key-value entries from the map.
             *
             * @private
             * @name clear
             * @memberOf MapCache
             */
            function mapCacheClear() {
                this.size = 0
                this.__data__ = {
                    hash: new Hash(),
                    map: new (Map || ListCache)(),
                    string: new Hash()
                }
            }

            module.exports = mapCacheClear

            /***/
        },

        /***/ fNZA: /***/ function(module, exports, __webpack_require__) {
            var classof = __webpack_require__('QMMT')
            var ITERATOR = __webpack_require__('UWiX')('iterator')
            var Iterators = __webpack_require__('SBuE')
            module.exports = __webpack_require__(
                'WEpk'
            ).getIteratorMethod = function(it) {
                if (it != undefined)
                    return (
                        it[ITERATOR] ||
                        it['@@iterator'] ||
                        Iterators[classof(it)]
                    )
            }

            /***/
        },

        /***/ 'fR/l': /***/ function(module, exports, __webpack_require__) {
            var arrayPush = __webpack_require__('CH3K'),
                isArray = __webpack_require__('Z0cm')

            /**
             * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
             * `keysFunc` and `symbolsFunc` to get the enumerable property names and
             * symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Function} keysFunc The function to get the keys of `object`.
             * @param {Function} symbolsFunc The function to get the symbols of `object`.
             * @returns {Array} Returns the array of property names and symbols.
             */
            function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object)
                return isArray(object)
                    ? result
                    : arrayPush(result, symbolsFunc(object))
            }

            module.exports = baseGetAllKeys

            /***/
        },

        /***/ faWz: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const is = __webpack_require__('6mOv')

            module.exports = body =>
                is.nodeStream(body) && is.function(body.getBoundary)

            /***/
        },

        /***/ fmRc: /***/ function(module, exports, __webpack_require__) {
            var ListCache = __webpack_require__('Xi7e'),
                stackClear = __webpack_require__('77Zs'),
                stackDelete = __webpack_require__('L8xA'),
                stackGet = __webpack_require__('gCq4'),
                stackHas = __webpack_require__('VaNO'),
                stackSet = __webpack_require__('0Cz8')

            /**
             * Creates a stack cache object to store key-value pairs.
             *
             * @private
             * @constructor
             * @param {Array} [entries] The key-value pairs to cache.
             */
            function Stack(entries) {
                var data = (this.__data__ = new ListCache(entries))
                this.size = data.size
            }

            // Add methods to `Stack`.
            Stack.prototype.clear = stackClear
            Stack.prototype['delete'] = stackDelete
            Stack.prototype.get = stackGet
            Stack.prototype.has = stackHas
            Stack.prototype.set = stackSet

            module.exports = Stack

            /***/
        },

        /***/ fpC5: /***/ function(module, exports, __webpack_require__) {
            var dP = __webpack_require__('2faE')
            var anObject = __webpack_require__('5K7Z')
            var getKeys = __webpack_require__('w6GO')

            module.exports = __webpack_require__('jmDH')
                ? Object.defineProperties
                : function defineProperties(O, Properties) {
                      anObject(O)
                      var keys = getKeys(Properties)
                      var length = keys.length
                      var i = 0
                      var P
                      while (length > i) dP.f(O, (P = keys[i++]), Properties[P])
                      return O
                  }

            /***/
        },

        /***/ ftKO: /***/ function(module, exports) {
            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__'

            /**
             * Adds `value` to the array cache.
             *
             * @private
             * @name add
             * @memberOf SetCache
             * @alias push
             * @param {*} value The value to cache.
             * @returns {Object} Returns the cache instance.
             */
            function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED)
                return this
            }

            module.exports = setCacheAdd

            /***/
        },

        /***/ 'g/15': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$keys = __webpack_require__('pLtp')

            var _Object$defineProperty = __webpack_require__('hfKm')

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            const url_1 = __webpack_require__('bzos')
            /**
             * Utils
             */

            function execOnce(fn) {
                let used = false
                let result = null
                return (...args) => {
                    if (!used) {
                        used = true
                        result = fn.apply(this, args)
                    }

                    return result
                }
            }

            exports.execOnce = execOnce

            function getLocationOrigin() {
                const { protocol, hostname, port } = window.location
                return `${protocol}//${hostname}${port ? ':' + port : ''}`
            }

            exports.getLocationOrigin = getLocationOrigin

            function getURL() {
                const { href } = window.location
                const origin = getLocationOrigin()
                return href.substring(origin.length)
            }

            exports.getURL = getURL

            function getDisplayName(Component) {
                return typeof Component === 'string'
                    ? Component
                    : Component.displayName || Component.name || 'Unknown'
            }

            exports.getDisplayName = getDisplayName

            function isResSent(res) {
                return res.finished || res.headersSent
            }

            exports.isResSent = isResSent

            async function loadGetInitialProps(App, ctx) {
                if (false) {
                } // when called from _app `ctx` is nested in `ctx`

                const res = ctx.res || (ctx.ctx && ctx.ctx.res)

                if (!App.getInitialProps) {
                    if (ctx.ctx && ctx.Component) {
                        // @ts-ignore pageProps default
                        return {
                            pageProps: await loadGetInitialProps(
                                ctx.Component,
                                ctx.ctx
                            )
                        }
                    }

                    return {}
                }

                const props = await App.getInitialProps(ctx)

                if (res && isResSent(res)) {
                    return props
                }

                if (!props) {
                    const message = `"${getDisplayName(
                        App
                    )}.getInitialProps()" should resolve to an object. But found "${props}" instead.`
                    throw new Error(message)
                }

                if (false) {
                }

                return props
            }

            exports.loadGetInitialProps = loadGetInitialProps
            exports.urlObjectKeys = [
                'auth',
                'hash',
                'host',
                'hostname',
                'href',
                'path',
                'pathname',
                'port',
                'protocol',
                'query',
                'search',
                'slashes'
            ]

            function formatWithValidation(url, options) {
                if (false) {
                }

                return url_1.format(url, options)
            }

            exports.formatWithValidation = formatWithValidation
            exports.SUPPORTS_PERFORMANCE = typeof performance !== 'undefined'
            exports.SUPPORTS_PERFORMANCE_USER_TIMING =
                exports.SUPPORTS_PERFORMANCE &&
                typeof performance.mark === 'function' &&
                typeof performance.measure === 'function'

            /***/
        },

        /***/ g33z: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var strong = __webpack_require__('Wu5q')
            var validate = __webpack_require__('n3ko')
            var MAP = 'Map'

            // 23.1 Map Objects
            module.exports = __webpack_require__('raTm')(
                MAP,
                function(get) {
                    return function Map() {
                        return get(
                            this,
                            arguments.length > 0 ? arguments[0] : undefined
                        )
                    }
                },
                {
                    // 23.1.3.6 Map.prototype.get(key)
                    get: function get(key) {
                        var entry = strong.getEntry(validate(this, MAP), key)
                        return entry && entry.v
                    },
                    // 23.1.3.9 Map.prototype.set(key, value)
                    set: function set(key, value) {
                        return strong.def(
                            validate(this, MAP),
                            key === 0 ? 0 : key,
                            value
                        )
                    }
                },
                strong,
                true
            )

            /***/
        },

        /***/ g7np: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var isAbsoluteURL = __webpack_require__('2SVd')
            var combineURLs = __webpack_require__('5oMp')

            /**
             * Creates a new URL by combining the baseURL with the requestedURL,
             * only when the requestedURL is not already an absolute URL.
             * If the requestURL is absolute, this function returns the requestedURL untouched.
             *
             * @param {string} baseURL The base URL
             * @param {string} requestedURL Absolute or relative URL to combine
             * @returns {string} The combined full path
             */
            module.exports = function buildFullPath(baseURL, requestedURL) {
                if (baseURL && !isAbsoluteURL(requestedURL)) {
                    return combineURLs(baseURL, requestedURL)
                }
                return requestedURL
            }

            /***/
        },

        /***/ gAB1: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(timeout) {
                return new Promise(resolve => setTimeout(resolve, timeout))
            }

            /***/
        },

        /***/ gCq4: /***/ function(module, exports) {
            /**
             * Gets the stack value for `key`.
             *
             * @private
             * @name get
             * @memberOf Stack
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function stackGet(key) {
                return this.__data__.get(key)
            }

            module.exports = stackGet

            /***/
        },

        /***/ gFfm: /***/ function(module, exports) {
            /**
             * A specialized version of `_.forEach` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns `array`.
             */
            function arrayEach(array, iteratee) {
                var index = -1,
                    length = array == null ? 0 : array.length

                while (++index < length) {
                    if (iteratee(array[index], index, array) === false) {
                        break
                    }
                }
                return array
            }

            module.exports = arrayEach

            /***/
        },

        /***/ gK4g: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const pump = __webpack_require__('b1mx')
            const bufferStream = __webpack_require__('iGjV')

            class MaxBufferError extends Error {
                constructor() {
                    super('maxBuffer exceeded')
                    this.name = 'MaxBufferError'
                }
            }

            async function getStream(inputStream, options) {
                if (!inputStream) {
                    return Promise.reject(new Error('Expected a stream'))
                }

                options = {
                    maxBuffer: Infinity,
                    ...options
                }

                const { maxBuffer } = options

                let stream
                await new Promise((resolve, reject) => {
                    const rejectPromise = error => {
                        if (error) {
                            // A null check
                            error.bufferedData = stream.getBufferedValue()
                        }

                        reject(error)
                    }

                    stream = pump(inputStream, bufferStream(options), error => {
                        if (error) {
                            rejectPromise(error)
                            return
                        }

                        resolve()
                    })

                    stream.on('data', () => {
                        if (stream.getBufferedLength() > maxBuffer) {
                            rejectPromise(new MaxBufferError())
                        }
                    })
                })

                return stream.getBufferedValue()
            }

            module.exports = getStream
            // TODO: Remove this for the next major release
            module.exports.default = getStream
            module.exports.buffer = (stream, options) =>
                getStream(stream, { ...options, encoding: 'buffer' })
            module.exports.array = (stream, options) =>
                getStream(stream, { ...options, array: true })
            module.exports.MaxBufferError = MaxBufferError

            /***/
        },

        /***/ gKi1: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const cookie_1 = __webpack_require__('iVi/')
            /**
             * Parses the cookies from an API Route or from Pages and returns a key/value object containing all the cookies.
             * @param req Incoming HTTP request.
             */
            function parseCookies(req) {
                const { cookies } = req
                // For API Routes we don't need to parse the cookies.
                if (cookies) {
                    return cookies
                }
                // For pages we still need to parse the cookies.
                const cookie = req && req.headers && req.headers.cookie
                return cookie_1.parse(cookie || '')
            }
            exports.parseCookies = parseCookies
            /**
             * Based on the environment and the request we know if a secure cookie can be set.
             */
            function isSecureEnvironment(req) {
                if (!req || !req.headers || !req.headers.host) {
                    throw new Error(
                        'The "host" request header is not available'
                    )
                }
                if (false) {
                }
                const host =
                    (req.headers.host.indexOf(':') > -1 &&
                        req.headers.host.split(':')[0]) ||
                    req.headers.host
                if (['localhost', '127.0.0.1'].indexOf(host) > -1) {
                    return false
                }
                return true
            }
            /**
             * Serialize a cookie to a string.
             * @param cookie The cookie to serialize
             * @param secure Create a secure cookie.
             */
            function serializeCookie(cookie, secure) {
                return cookie_1.serialize(cookie.name, cookie.value, {
                    maxAge: cookie.maxAge,
                    expires: new Date(Date.now() + cookie.maxAge * 1000),
                    httpOnly: true,
                    secure,
                    path: cookie.path
                })
            }
            /**
             * Set one or more cookies.
             * @param res The HTTP response on which the cookie will be set.
             */
            function setCookies(req, res, cookies) {
                res.setHeader(
                    'Set-Cookie',
                    cookies.map(c =>
                        serializeCookie(c, isSecureEnvironment(req))
                    )
                )
            }
            exports.setCookies = setCookies
            /**
             * Set one or more cookies.
             * @param res The HTTP response on which the cookie will be set.
             */
            function setCookie(req, res, cookie) {
                res.setHeader(
                    'Set-Cookie',
                    serializeCookie(cookie, isSecureEnvironment(req))
                )
            }
            exports.setCookie = setCookie
            //# sourceMappingURL=cookies.js.map

            /***/
        },

        /***/ gXwc: /***/ function(module, exports, __webpack_require__) {
            /* global BigInt */
            const { EOL } = __webpack_require__('jle/')

            const { name: secp256k1 } = __webpack_require__('F/JS')
            const errors = __webpack_require__('yt7c')

            const { createPublicKey } = __webpack_require__('1ALl')
            const base64url = __webpack_require__('Xab3')
            const asn1 = __webpack_require__('u88T')
            const computePrimes = __webpack_require__('eHfw')
            const { OKP_CURVES, EC_CURVES } = __webpack_require__('N+nT')

            const oidHexToCurve = new Map([
                ['06082a8648ce3d030107', 'P-256'],
                ['06052b8104000a', secp256k1],
                ['06052b81040022', 'P-384'],
                ['06052b81040023', 'P-521']
            ])
            const EC_KEY_OID = '1.2.840.10045.2.1'.split('.')
            const crvToOid = new Map([
                ['P-256', '1.2.840.10045.3.1.7'.split('.')],
                [secp256k1, '1.3.132.0.10'.split('.')],
                ['P-384', '1.3.132.0.34'.split('.')],
                ['P-521', '1.3.132.0.35'.split('.')]
            ])
            const crvToOidBuf = new Map([
                ['P-256', Buffer.from('06082a8648ce3d030107', 'hex')],
                [secp256k1, Buffer.from('06052b8104000a', 'hex')],
                ['P-384', Buffer.from('06052b81040022', 'hex')],
                ['P-521', Buffer.from('06052b81040023', 'hex')]
            ])

            const formatPem = (base64pem, descriptor) =>
                `-----BEGIN ${descriptor} KEY-----${EOL}${base64pem
                    .match(/.{1,64}/g)
                    .join(EOL)}${EOL}-----END ${descriptor} KEY-----`

            const okpToJWK = {
                private(crv, keyObject) {
                    const der = keyObject.export({
                        type: 'pkcs8',
                        format: 'der'
                    })
                    const OneAsymmetricKey = asn1.get('OneAsymmetricKey')
                    const {
                        privateKey: { privateKey: d }
                    } = OneAsymmetricKey.decode(der)

                    return {
                        ...okpToJWK.public(crv, createPublicKey(keyObject)),
                        d: base64url.encodeBuffer(d)
                    }
                },
                public(crv, keyObject) {
                    const der = keyObject.export({
                        type: 'spki',
                        format: 'der'
                    })

                    const PublicKeyInfo = asn1.get('PublicKeyInfo')

                    const {
                        publicKey: { data: x }
                    } = PublicKeyInfo.decode(der)

                    return {
                        kty: 'OKP',
                        crv,
                        x: base64url.encodeBuffer(x)
                    }
                }
            }

            const keyObjectToJWK = {
                rsa: {
                    private(keyObject) {
                        const der = keyObject.export({
                            type: 'pkcs8',
                            format: 'der'
                        })

                        const PrivateKeyInfo = asn1.get('PrivateKeyInfo')
                        const RSAPrivateKey = asn1.get('RSAPrivateKey')

                        const { privateKey } = PrivateKeyInfo.decode(der)
                        const {
                            version,
                            n,
                            e,
                            d,
                            p,
                            q,
                            dp,
                            dq,
                            qi
                        } = RSAPrivateKey.decode(privateKey)

                        if (version !== 'two-prime') {
                            throw new errors.JOSENotSupported(
                                'Private RSA keys with more than two primes are not supported'
                            )
                        }

                        return {
                            kty: 'RSA',
                            n: base64url.encodeBigInt(n),
                            e: base64url.encodeBigInt(e),
                            d: base64url.encodeBigInt(d),
                            p: base64url.encodeBigInt(p),
                            q: base64url.encodeBigInt(q),
                            dp: base64url.encodeBigInt(dp),
                            dq: base64url.encodeBigInt(dq),
                            qi: base64url.encodeBigInt(qi)
                        }
                    },
                    public(keyObject) {
                        const der = keyObject.export({
                            type: 'spki',
                            format: 'der'
                        })

                        const PublicKeyInfo = asn1.get('PublicKeyInfo')
                        const RSAPublicKey = asn1.get('RSAPublicKey')

                        const {
                            publicKey: { data: publicKey }
                        } = PublicKeyInfo.decode(der)
                        const { n, e } = RSAPublicKey.decode(publicKey)

                        return {
                            kty: 'RSA',
                            n: base64url.encodeBigInt(n),
                            e: base64url.encodeBigInt(e)
                        }
                    }
                },
                ec: {
                    private(keyObject) {
                        const der = keyObject.export({
                            type: 'pkcs8',
                            format: 'der'
                        })

                        const PrivateKeyInfo = asn1.get('PrivateKeyInfo')
                        const ECPrivateKey = asn1.get('ECPrivateKey')

                        const {
                            privateKey,
                            algorithm: { parameters: curveOid }
                        } = PrivateKeyInfo.decode(der)
                        const crv = oidHexToCurve.get(curveOid.toString('hex'))
                        const {
                            privateKey: d,
                            publicKey: { data: publicKey }
                        } = ECPrivateKey.decode(privateKey)

                        const x = publicKey.slice(
                            1,
                            (publicKey.length - 1) / 2 + 1
                        )
                        const y = publicKey.slice(
                            (publicKey.length - 1) / 2 + 1
                        )

                        return {
                            kty: 'EC',
                            crv,
                            d: base64url.encodeBuffer(d),
                            x: base64url.encodeBuffer(x),
                            y: base64url.encodeBuffer(y)
                        }
                    },
                    public(keyObject) {
                        const der = keyObject.export({
                            type: 'spki',
                            format: 'der'
                        })

                        const PublicKeyInfo = asn1.get('PublicKeyInfo')

                        const {
                            publicKey: { data: publicKey },
                            algorithm: { parameters: curveOid }
                        } = PublicKeyInfo.decode(der)
                        const crv = oidHexToCurve.get(curveOid.toString('hex'))

                        const x = publicKey.slice(
                            1,
                            (publicKey.length - 1) / 2 + 1
                        )
                        const y = publicKey.slice(
                            (publicKey.length - 1) / 2 + 1
                        )

                        return {
                            kty: 'EC',
                            crv,
                            x: base64url.encodeBuffer(x),
                            y: base64url.encodeBuffer(y)
                        }
                    }
                },
                ed25519: {
                    private(keyObject) {
                        return okpToJWK.private('Ed25519', keyObject)
                    },
                    public(keyObject) {
                        return okpToJWK.public('Ed25519', keyObject)
                    }
                },
                ed448: {
                    private(keyObject) {
                        return okpToJWK.private('Ed448', keyObject)
                    },
                    public(keyObject) {
                        return okpToJWK.public('Ed448', keyObject)
                    }
                },
                x25519: {
                    private(keyObject) {
                        return okpToJWK.private('X25519', keyObject)
                    },
                    public(keyObject) {
                        return okpToJWK.public('X25519', keyObject)
                    }
                },
                x448: {
                    private(keyObject) {
                        return okpToJWK.private('X448', keyObject)
                    },
                    public(keyObject) {
                        return okpToJWK.public('X448', keyObject)
                    }
                }
            }

            module.exports.keyObjectToJWK = keyObject => {
                if (keyObject.type === 'private') {
                    return keyObjectToJWK[keyObject.asymmetricKeyType].private(
                        keyObject
                    )
                }

                return keyObjectToJWK[keyObject.asymmetricKeyType].public(
                    keyObject
                )
            }

            const concatEcPublicKey = (x, y) => ({
                unused: 0,
                data: Buffer.concat([
                    Buffer.alloc(1, 4),
                    base64url.decodeToBuffer(x),
                    base64url.decodeToBuffer(y)
                ])
            })

            const okpCrvToOid = crv => {
                switch (crv) {
                    case 'X25519':
                        return '1.3.101.110'.split('.')
                    case 'X448':
                        return '1.3.101.111'.split('.')
                    case 'Ed25519':
                        return '1.3.101.112'.split('.')
                    case 'Ed448':
                        return '1.3.101.113'.split('.')
                }
            }

            const jwkToPem = {
                RSA: {
                    private(jwk, { calculateMissingRSAPrimes }) {
                        const RSAPrivateKey = asn1.get('RSAPrivateKey')

                        if ('oth' in jwk) {
                            throw new errors.JOSENotSupported(
                                'Private RSA keys with more than two primes are not supported'
                            )
                        }

                        if (jwk.p || jwk.q || jwk.dp || jwk.dq || jwk.qi) {
                            if (
                                !(jwk.p && jwk.q && jwk.dp && jwk.dq && jwk.qi)
                            ) {
                                throw new errors.JWKInvalid(
                                    'all other private key parameters must be present when any one of them is present'
                                )
                            }
                        } else if (calculateMissingRSAPrimes) {
                            jwk = computePrimes(jwk)
                        } else if (!calculateMissingRSAPrimes) {
                            throw new errors.JOSENotSupported(
                                'importing private RSA keys without all other private key parameters is not enabled, see documentation and its advisory on how and when its ok to enable it'
                            )
                        }

                        return RSAPrivateKey.encode(
                            {
                                version: 0,
                                n: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.n)
                                        .toString('hex')}`
                                ),
                                e: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.e)
                                        .toString('hex')}`
                                ),
                                d: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.d)
                                        .toString('hex')}`
                                ),
                                p: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.p)
                                        .toString('hex')}`
                                ),
                                q: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.q)
                                        .toString('hex')}`
                                ),
                                dp: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.dp)
                                        .toString('hex')}`
                                ),
                                dq: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.dq)
                                        .toString('hex')}`
                                ),
                                qi: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.qi)
                                        .toString('hex')}`
                                )
                            },
                            'pem',
                            { label: 'RSA PRIVATE KEY' }
                        )
                    },
                    public(jwk) {
                        const RSAPublicKey = asn1.get('RSAPublicKey')

                        return RSAPublicKey.encode(
                            {
                                version: 0,
                                n: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.n)
                                        .toString('hex')}`
                                ),
                                e: BigInt(
                                    `0x${base64url
                                        .decodeToBuffer(jwk.e)
                                        .toString('hex')}`
                                )
                            },
                            'pem',
                            { label: 'RSA PUBLIC KEY' }
                        )
                    }
                },
                EC: {
                    private(jwk) {
                        const ECPrivateKey = asn1.get('ECPrivateKey')

                        return ECPrivateKey.encode(
                            {
                                version: 1,
                                privateKey: base64url.decodeToBuffer(jwk.d),
                                parameters: {
                                    type: 'namedCurve',
                                    value: crvToOid.get(jwk.crv)
                                },
                                publicKey: concatEcPublicKey(jwk.x, jwk.y)
                            },
                            'pem',
                            { label: 'EC PRIVATE KEY' }
                        )
                    },
                    public(jwk) {
                        const PublicKeyInfo = asn1.get('PublicKeyInfo')

                        return PublicKeyInfo.encode(
                            {
                                algorithm: {
                                    algorithm: EC_KEY_OID,
                                    parameters: crvToOidBuf.get(jwk.crv)
                                },
                                publicKey: concatEcPublicKey(jwk.x, jwk.y)
                            },
                            'pem',
                            { label: 'PUBLIC KEY' }
                        )
                    }
                },
                OKP: {
                    private(jwk) {
                        const OneAsymmetricKey = asn1.get('OneAsymmetricKey')

                        const b64 = OneAsymmetricKey.encode(
                            {
                                version: 0,
                                privateKey: {
                                    privateKey: base64url.decodeToBuffer(jwk.d)
                                },
                                algorithm: { algorithm: okpCrvToOid(jwk.crv) }
                            },
                            'der'
                        )

                        // TODO: WHYYY? https://github.com/indutny/asn1.js/issues/110
                        b64.write('04', 12, 1, 'hex')

                        return formatPem(b64.toString('base64'), 'PRIVATE')
                    },
                    public(jwk) {
                        const PublicKeyInfo = asn1.get('PublicKeyInfo')

                        return PublicKeyInfo.encode(
                            {
                                algorithm: { algorithm: okpCrvToOid(jwk.crv) },
                                publicKey: {
                                    unused: 0,
                                    data: base64url.decodeToBuffer(jwk.x)
                                }
                            },
                            'pem',
                            { label: 'PUBLIC KEY' }
                        )
                    }
                }
            }

            module.exports.jwkToPem = (
                jwk,
                { calculateMissingRSAPrimes = false } = {}
            ) => {
                switch (jwk.kty) {
                    case 'EC':
                        if (!EC_CURVES.has(jwk.crv)) {
                            throw new errors.JOSENotSupported(
                                `unsupported EC key curve: ${jwk.crv}`
                            )
                        }
                        break
                    case 'OKP':
                        if (!OKP_CURVES.has(jwk.crv)) {
                            throw new errors.JOSENotSupported(
                                `unsupported OKP key curve: ${jwk.crv}`
                            )
                        }
                        break
                    case 'RSA':
                        break
                    default:
                        throw new errors.JOSENotSupported(
                            `unsupported key type: ${jwk.kty}`
                        )
                }

                if (jwk.d) {
                    return jwkToPem[jwk.kty].private(jwk, {
                        calculateMissingRSAPrimes
                    })
                }

                return jwkToPem[jwk.kty].public(jwk)
            }

            /***/
        },

        /***/ gdNv: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            exports = module.exports = {
                array: Array.prototype,
                buffer: Buffer && Buffer.prototype, // $lab:coverage:ignore$
                date: Date.prototype,
                error: Error.prototype,
                generic: Object.prototype,
                map: Map.prototype,
                promise: Promise.prototype,
                regex: RegExp.prototype,
                set: Set.prototype,
                weakMap: WeakMap.prototype,
                weakSet: WeakSet.prototype
            }

            internals.typeMap = new Map([
                ['[object Error]', exports.error],
                ['[object Map]', exports.map],
                ['[object Promise]', exports.promise],
                ['[object Set]', exports.set],
                ['[object WeakMap]', exports.weakMap],
                ['[object WeakSet]', exports.weakSet]
            ])

            exports.getInternalProto = function(obj) {
                if (Array.isArray(obj)) {
                    return exports.array
                }

                if (Buffer && obj instanceof Buffer) {
                    // $lab:coverage:ignore$
                    return exports.buffer
                }

                if (obj instanceof Date) {
                    return exports.date
                }

                if (obj instanceof RegExp) {
                    return exports.regex
                }

                if (obj instanceof Error) {
                    return exports.error
                }

                const objName = Object.prototype.toString.call(obj)
                return internals.typeMap.get(objName) || exports.generic
            }

            /***/
        },

        /***/ gguc: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$keys = __webpack_require__('pLtp')

            var _Object$defineProperty = __webpack_require__('hfKm')

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            function getRouteMatcher(routeRegex) {
                const { re, groups } = routeRegex
                return pathname => {
                    const routeMatch = re.exec(pathname)

                    if (!routeMatch) {
                        return false
                    }

                    const params = {}

                    _Object$keys(groups).forEach(slugName => {
                        const m = routeMatch[groups[slugName]]

                        if (m !== undefined) {
                            params[slugName] =
                                m.indexOf('/') !== -1
                                    ? m
                                          .split('/')
                                          .map(entry =>
                                              decodeURIComponent(entry)
                                          )
                                    : decodeURIComponent(m)
                        }
                    })

                    return params
                }
            }

            exports.getRouteMatcher = getRouteMatcher

            /***/
        },

        /***/ gt9x: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            class Session {
                constructor(user, createdAt) {
                    this.user = user
                    if (createdAt) {
                        this.createdAt = createdAt
                    } else {
                        this.createdAt = Date.now()
                    }
                }
            }
            exports.default = Session
            //# sourceMappingURL=session.js.map

            /***/
        },

        /***/ 'h+i2': /***/ function(module, exports, __webpack_require__) {
            module.exports = {
                der: __webpack_require__('1Gj5')
            }

            /***/
        },

        /***/ hDam: /***/ function(module, exports) {
            module.exports = function() {
                /* empty */
            }

            /***/
        },

        /***/ hYAz: /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('7m0m')
            module.exports = __webpack_require__(
                'WEpk'
            ).Object.getOwnPropertyDescriptors

            /***/
        },

        /***/ heNW: /***/ function(module, exports) {
            /**
             * A faster alternative to `Function#apply`, this function invokes `func`
             * with the `this` binding of `thisArg` and the arguments of `args`.
             *
             * @private
             * @param {Function} func The function to invoke.
             * @param {*} thisArg The `this` binding of `func`.
             * @param {Array} args The arguments to invoke `func` with.
             * @returns {*} Returns the result of `func`.
             */
            function apply(func, thisArg, args) {
                switch (args.length) {
                    case 0:
                        return func.call(thisArg)
                    case 1:
                        return func.call(thisArg, args[0])
                    case 2:
                        return func.call(thisArg, args[0], args[1])
                    case 3:
                        return func.call(thisArg, args[0], args[1], args[2])
                }
                return func.apply(thisArg, args)
            }

            module.exports = apply

            /***/
        },

        /***/ hfKm: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('RU/L')

            /***/
        },

        /***/ hgQt: /***/ function(module, exports, __webpack_require__) {
            var baseHasIn = __webpack_require__('Juji'),
                hasPath = __webpack_require__('4sDh')

            /**
             * Checks if `path` is a direct or inherited property of `object`.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Object
             * @param {Object} object The object to query.
             * @param {Array|string} path The path to check.
             * @returns {boolean} Returns `true` if `path` exists, else `false`.
             * @example
             *
             * var object = _.create({ 'a': _.create({ 'b': 2 }) });
             *
             * _.hasIn(object, 'a');
             * // => true
             *
             * _.hasIn(object, 'a.b');
             * // => true
             *
             * _.hasIn(object, ['a', 'b']);
             * // => true
             *
             * _.hasIn(object, 'b');
             * // => false
             */
            function hasIn(object, path) {
                return object != null && hasPath(object, path, baseHasIn)
            }

            module.exports = hasIn

            /***/
        },

        /***/ hk9D: /***/ function(module, exports, __webpack_require__) {
            const {
                publicEncrypt,
                privateDecrypt,
                constants
            } = __webpack_require__('PJMN')

            const { oaepHashSupported } = __webpack_require__('pDDt')
            const { KEYOBJECT } = __webpack_require__('ehsS')
            const { asInput } = __webpack_require__('1ALl')

            const resolvePadding = alg => {
                switch (alg) {
                    case 'RSA-OAEP':
                    case 'RSA-OAEP-256':
                    case 'RSA-OAEP-384':
                    case 'RSA-OAEP-512':
                        return constants.RSA_PKCS1_OAEP_PADDING
                    case 'RSA1_5':
                        return constants.RSA_PKCS1_PADDING
                }
            }

            const resolveOaepHash = alg => {
                switch (alg) {
                    case 'RSA-OAEP':
                        return 'sha1'
                    case 'RSA-OAEP-256':
                        return 'sha256'
                    case 'RSA-OAEP-384':
                        return 'sha384'
                    case 'RSA-OAEP-512':
                        return 'sha512'
                    default:
                        return undefined
                }
            }

            const wrapKey = (
                padding,
                oaepHash,
                { [KEYOBJECT]: keyObject },
                payload
            ) => {
                const key = asInput(keyObject, true)
                return {
                    wrapped: publicEncrypt({ key, oaepHash, padding }, payload)
                }
            }

            const unwrapKey = (
                padding,
                oaepHash,
                { [KEYOBJECT]: keyObject },
                payload
            ) => {
                const key = asInput(keyObject, false)
                return privateDecrypt({ key, oaepHash, padding }, payload)
            }

            const LENGTHS = {
                RSA1_5: 0,
                'RSA-OAEP': 592,
                'RSA-OAEP-256': 784,
                'RSA-OAEP-384': 1040,
                'RSA-OAEP-512': 1296
            }

            module.exports = (JWA, JWK) => {
                const algs = ['RSA-OAEP', 'RSA1_5']

                if (oaepHashSupported) {
                    algs.splice(
                        1,
                        0,
                        'RSA-OAEP-256',
                        'RSA-OAEP-384',
                        'RSA-OAEP-512'
                    )
                }

                algs.forEach(jwaAlg => {
                    const padding = resolvePadding(jwaAlg)
                    const oaepHash = resolveOaepHash(jwaAlg)
                    JWA.keyManagementEncrypt.set(
                        jwaAlg,
                        wrapKey.bind(undefined, padding, oaepHash)
                    )
                    JWA.keyManagementDecrypt.set(
                        jwaAlg,
                        unwrapKey.bind(undefined, padding, oaepHash)
                    )
                    JWK.RSA.wrapKey[jwaAlg] = key =>
                        (key.use === 'enc' || key.use === undefined) &&
                        key.length >= LENGTHS[jwaAlg]
                    JWK.RSA.unwrapKey[jwaAlg] = key =>
                        key.private &&
                        (key.use === 'enc' || key.use === undefined) &&
                        key.length >= LENGTHS[jwaAlg]
                })
            }

            /***/
        },

        /***/ hnhG: /***/ function(module, exports, __webpack_require__) {
            const { createSign, createVerify, constants } = __webpack_require__(
                'PJMN'
            )

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const resolveNodeAlg = __webpack_require__('uGJc')
            const { asInput } = __webpack_require__('1ALl')

            const sign = (nodeAlg, { [KEYOBJECT]: keyObject }, payload) => {
                const key = asInput(keyObject, false)
                return createSign(nodeAlg)
                    .update(payload)
                    .sign({
                        key,
                        padding: constants.RSA_PKCS1_PSS_PADDING,
                        saltLength: constants.RSA_PSS_SALTLEN_DIGEST
                    })
            }

            const verify = (
                nodeAlg,
                { [KEYOBJECT]: keyObject },
                payload,
                signature
            ) => {
                const key = asInput(keyObject, true)
                return createVerify(nodeAlg)
                    .update(payload)
                    .verify(
                        {
                            key,
                            padding: constants.RSA_PKCS1_PSS_PADDING,
                            saltLength: constants.RSA_PSS_SALTLEN_DIGEST
                        },
                        signature
                    )
            }

            const LENGTHS = {
                PS256: 528,
                PS384: 784,
                PS512: 1040
            }

            module.exports = (JWA, JWK) => {
                ;['PS256', 'PS384', 'PS512'].forEach(jwaAlg => {
                    const nodeAlg = resolveNodeAlg(jwaAlg)
                    JWA.sign.set(jwaAlg, sign.bind(undefined, nodeAlg))
                    JWA.verify.set(jwaAlg, verify.bind(undefined, nodeAlg))
                    JWK.RSA.sign[jwaAlg] = key =>
                        key.private && JWK.RSA.verify[jwaAlg](key)
                    JWK.RSA.verify[jwaAlg] = key =>
                        (key.use === 'sig' || key.use === undefined) &&
                        key.length >= LENGTHS[jwaAlg]
                })
            }

            /***/
        },

        /***/ hpEj: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(promise) {
                return !!promise && typeof promise.then === 'function'
            }

            /***/
        },

        /***/ htGi: /***/ function(module, exports, __webpack_require__) {
            var _Object$assign = __webpack_require__('UXZV')

            function _extends() {
                module.exports = _extends =
                    _Object$assign ||
                    function(target) {
                        for (var i = 1; i < arguments.length; i++) {
                            var source = arguments[i]

                            for (var key in source) {
                                if (
                                    Object.prototype.hasOwnProperty.call(
                                        source,
                                        key
                                    )
                                ) {
                                    target[key] = source[key]
                                }
                            }
                        }

                        return target
                    }

                return _extends.apply(this, arguments)
            }

            module.exports = _extends

            /***/
        },

        /***/ htIY: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const AggregateError = __webpack_require__('xh2E')
            const PCancelable = __webpack_require__('ijcl')

            const pSome = (iterable, options) =>
                new PCancelable((resolve, reject, onCancel) => {
                    options = {
                        filter: () => true,
                        ...options
                    }

                    if (!Number.isFinite(options.count)) {
                        throw new TypeError(
                            `Expected a finite number, got ${typeof options.count}`
                        )
                    }

                    const values = []
                    const errors = []
                    let elementCount = 0
                    let maxErrors = -options.count + 1
                    let maxFiltered = -options.count + 1
                    let isDone = false

                    const completed = new Set()
                    const cancelPendingIfDone = () => {
                        if (!isDone) {
                            return
                        }

                        for (const promise of iterable) {
                            if (
                                !completed.has(promise) &&
                                typeof promise.cancel === 'function'
                            ) {
                                promise.cancel()
                            }
                        }
                    }

                    onCancel(() => {
                        isDone = true
                        cancelPendingIfDone()
                    })

                    const fulfilled = value => {
                        if (isDone) {
                            return
                        }

                        if (!options.filter(value)) {
                            if (--maxFiltered === 0) {
                                isDone = true
                                reject(
                                    new RangeError(
                                        'Not enough values pass the `filter` option'
                                    )
                                )
                            }

                            return
                        }

                        values.push(value)

                        if (--options.count === 0) {
                            isDone = true
                            resolve(values)
                        }
                    }

                    const rejected = error => {
                        if (isDone) {
                            return
                        }

                        errors.push(error)

                        if (--maxErrors === 0) {
                            isDone = true
                            reject(new AggregateError(errors))
                        }
                    }

                    for (const element of iterable) {
                        maxErrors++
                        maxFiltered++
                        elementCount++

                        ;(async () => {
                            try {
                                const value = await Promise.resolve(element)
                                fulfilled(value)
                            } catch (error) {
                                rejected(error)
                            }

                            completed.add(element)
                            cancelPendingIfDone()
                        })()
                    }

                    if (options.count > elementCount) {
                        throw new RangeError(
                            `Expected input to contain at least ${options.count} items, but contains ${elementCount} items`
                        )
                    }
                })

            module.exports = pSome
            // TODO: Remove this for the next major release
            module.exports.default = pSome

            module.exports.AggregateError = AggregateError

            /***/
        },

        /***/ hypo: /***/ function(module, exports, __webpack_require__) {
            var defineProperty = __webpack_require__('O0oS')

            /**
             * The base implementation of `assignValue` and `assignMergeValue` without
             * value checks.
             *
             * @private
             * @param {Object} object The object to modify.
             * @param {string} key The key of the property to assign.
             * @param {*} value The value to assign.
             */
            function baseAssignValue(object, key, value) {
                if (key == '__proto__' && defineProperty) {
                    defineProperty(object, key, {
                        configurable: true,
                        enumerable: true,
                        value: value,
                        writable: true
                    })
                } else {
                    object[key] = value
                }
            }

            module.exports = baseAssignValue

            /***/
        },

        /***/ i8G8: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(method) {
                if (method._hoekOnce) {
                    return method
                }

                let once = false
                const wrapped = function(...args) {
                    if (!once) {
                        once = true
                        method(...args)
                    }
                }

                wrapped._hoekOnce = true
                return wrapped
            }

            /***/
        },

        /***/ iAgo: /***/ function(module, exports, __webpack_require__) {
            const { createHash, randomBytes } = __webpack_require__('PJMN')

            const { encode: base64url } = __webpack_require__('+00W')

            const random = (bytes = 32) => base64url(randomBytes(bytes))

            module.exports = {
                random,
                state: random,
                nonce: random,
                codeVerifier: random,
                codeChallenge: codeVerifier =>
                    base64url(
                        createHash('sha256')
                            .update(codeVerifier)
                            .digest()
                    )
            }

            /***/
        },

        /***/ iGjV: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { PassThrough: PassThroughStream } = __webpack_require__(
                'msIP'
            )

            module.exports = options => {
                options = { ...options }

                const { array } = options
                let { encoding } = options
                const isBuffer = encoding === 'buffer'
                let objectMode = false

                if (array) {
                    objectMode = !(encoding || isBuffer)
                } else {
                    encoding = encoding || 'utf8'
                }

                if (isBuffer) {
                    encoding = null
                }

                const stream = new PassThroughStream({ objectMode })

                if (encoding) {
                    stream.setEncoding(encoding)
                }

                let length = 0
                const chunks = []

                stream.on('data', chunk => {
                    chunks.push(chunk)

                    if (objectMode) {
                        length = chunks.length
                    } else {
                        length += chunk.length
                    }
                })

                stream.getBufferedValue = () => {
                    if (array) {
                        return chunks
                    }

                    return isBuffer
                        ? Buffer.concat(chunks, length)
                        : chunks.join('')
                }

                stream.getBufferedLength = () => length

                return stream
            }

            /***/
        },

        /***/ 'iVi/': /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /*!
             * cookie
             * Copyright(c) 2012-2014 Roman Shtylman
             * Copyright(c) 2015 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module exports.
             * @public
             */

            exports.parse = parse
            exports.serialize = serialize

            /**
             * Module variables.
             * @private
             */

            var decode = decodeURIComponent
            var encode = encodeURIComponent
            var pairSplitRegExp = /; */

            /**
             * RegExp to match field-content in RFC 7230 sec 3.2
             *
             * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
             * field-vchar   = VCHAR / obs-text
             * obs-text      = %x80-FF
             */

            var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/

            /**
             * Parse a cookie header.
             *
             * Parse the given cookie header string into an object
             * The object has the various cookies as keys(names) => values
             *
             * @param {string} str
             * @param {object} [options]
             * @return {object}
             * @public
             */

            function parse(str, options) {
                if (typeof str !== 'string') {
                    throw new TypeError('argument str must be a string')
                }

                var obj = {}
                var opt = options || {}
                var pairs = str.split(pairSplitRegExp)
                var dec = opt.decode || decode

                for (var i = 0; i < pairs.length; i++) {
                    var pair = pairs[i]
                    var eq_idx = pair.indexOf('=')

                    // skip things that don't look like key=value
                    if (eq_idx < 0) {
                        continue
                    }

                    var key = pair.substr(0, eq_idx).trim()
                    var val = pair.substr(++eq_idx, pair.length).trim()

                    // quoted values
                    if ('"' == val[0]) {
                        val = val.slice(1, -1)
                    }

                    // only assign once
                    if (undefined == obj[key]) {
                        obj[key] = tryDecode(val, dec)
                    }
                }

                return obj
            }

            /**
             * Serialize data into a cookie header.
             *
             * Serialize the a name value pair into a cookie string suitable for
             * http headers. An optional options object specified cookie parameters.
             *
             * serialize('foo', 'bar', { httpOnly: true })
             *   => "foo=bar; httpOnly"
             *
             * @param {string} name
             * @param {string} val
             * @param {object} [options]
             * @return {string}
             * @public
             */

            function serialize(name, val, options) {
                var opt = options || {}
                var enc = opt.encode || encode

                if (typeof enc !== 'function') {
                    throw new TypeError('option encode is invalid')
                }

                if (!fieldContentRegExp.test(name)) {
                    throw new TypeError('argument name is invalid')
                }

                var value = enc(val)

                if (value && !fieldContentRegExp.test(value)) {
                    throw new TypeError('argument val is invalid')
                }

                var str = name + '=' + value

                if (null != opt.maxAge) {
                    var maxAge = opt.maxAge - 0
                    if (isNaN(maxAge))
                        throw new Error('maxAge should be a Number')
                    str += '; Max-Age=' + Math.floor(maxAge)
                }

                if (opt.domain) {
                    if (!fieldContentRegExp.test(opt.domain)) {
                        throw new TypeError('option domain is invalid')
                    }

                    str += '; Domain=' + opt.domain
                }

                if (opt.path) {
                    if (!fieldContentRegExp.test(opt.path)) {
                        throw new TypeError('option path is invalid')
                    }

                    str += '; Path=' + opt.path
                }

                if (opt.expires) {
                    if (typeof opt.expires.toUTCString !== 'function') {
                        throw new TypeError('option expires is invalid')
                    }

                    str += '; Expires=' + opt.expires.toUTCString()
                }

                if (opt.httpOnly) {
                    str += '; HttpOnly'
                }

                if (opt.secure) {
                    str += '; Secure'
                }

                if (opt.sameSite) {
                    var sameSite =
                        typeof opt.sameSite === 'string'
                            ? opt.sameSite.toLowerCase()
                            : opt.sameSite

                    switch (sameSite) {
                        case true:
                            str += '; SameSite=Strict'
                            break
                        case 'lax':
                            str += '; SameSite=Lax'
                            break
                        case 'strict':
                            str += '; SameSite=Strict'
                            break
                        case 'none':
                            str += '; SameSite=None'
                            break
                        default:
                            throw new TypeError('option sameSite is invalid')
                    }
                }

                return str
            }

            /**
             * Try decoding a string using a decoding function.
             *
             * @param {string} str
             * @param {function} decode
             * @private
             */

            function tryDecode(str, decode) {
                try {
                    return decode(str)
                } catch (e) {
                    return str
                }
            }

            /***/
        },

        /***/ idmN: /***/ function(module, exports, __webpack_require__) {
            var baseGet = __webpack_require__('ZWtO'),
                baseSet = __webpack_require__('FZoo'),
                castPath = __webpack_require__('4uTw')

            /**
             * The base implementation of  `_.pickBy` without support for iteratee shorthands.
             *
             * @private
             * @param {Object} object The source object.
             * @param {string[]} paths The property paths to pick.
             * @param {Function} predicate The function invoked per property.
             * @returns {Object} Returns the new object.
             */
            function basePickBy(object, paths, predicate) {
                var index = -1,
                    length = paths.length,
                    result = {}

                while (++index < length) {
                    var path = paths[index],
                        value = baseGet(object, path)

                    if (predicate(value, path)) {
                        baseSet(result, castPath(path, object), value)
                    }
                }
                return result
            }

            module.exports = basePickBy

            /***/
        },

        /***/ ieHi: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Crypto = __webpack_require__('PJMN')

            const Boom = __webpack_require__('U3sn')

            const internals = {}

            // Generate a cryptographically strong pseudo-random data

            exports.randomString = function(size) {
                const buffer = exports.randomBits((size + 1) * 6)
                const string = buffer
                    .toString('base64')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/\=/g, '')
                return string.slice(0, size)
            }

            // Return a random string of digits

            exports.randomDigits = function(size) {
                const digits = []

                let buffer = internals.random(size * 2) // Provision twice the amount of bytes needed to increase chance of single pass
                let pos = 0

                while (digits.length < size) {
                    if (pos >= buffer.length) {
                        buffer = internals.random(size * 2)
                        pos = 0
                    }

                    if (buffer[pos] < 250) {
                        digits.push(buffer[pos] % 10)
                    }

                    ++pos
                }

                return digits.join('')
            }

            // Generate a buffer of random bits

            exports.randomBits = function(bits) {
                if (!bits || bits < 0) {
                    throw Boom.internal('Invalid random bits count')
                }

                const bytes = Math.ceil(bits / 8)
                return internals.random(bytes)
            }

            exports.fixedTimeComparison = function(a, b) {
                try {
                    return Crypto.timingSafeEqual(
                        Buffer.from(a),
                        Buffer.from(b)
                    )
                } catch (err) {
                    return false
                }
            }

            internals.random = function(bytes) {
                try {
                    return Crypto.randomBytes(bytes)
                } catch (err) {
                    throw Boom.internal(
                        'Failed generating random bits: ' + err.message
                    )
                }
            }

            /***/
        },

        /***/ ijcl: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            class CancelError extends Error {
                constructor(reason) {
                    super(reason || 'Promise was canceled')
                    this.name = 'CancelError'
                }

                get isCanceled() {
                    return true
                }
            }

            class PCancelable {
                static fn(userFn) {
                    return (...arguments_) => {
                        return new PCancelable((resolve, reject, onCancel) => {
                            arguments_.push(onCancel)
                            // eslint-disable-next-line promise/prefer-await-to-then
                            userFn(...arguments_).then(resolve, reject)
                        })
                    }
                }

                constructor(executor) {
                    this._cancelHandlers = []
                    this._isPending = true
                    this._isCanceled = false
                    this._rejectOnCancel = true

                    this._promise = new Promise((resolve, reject) => {
                        this._reject = reject

                        const onResolve = value => {
                            this._isPending = false
                            resolve(value)
                        }

                        const onReject = error => {
                            this._isPending = false
                            reject(error)
                        }

                        const onCancel = handler => {
                            if (!this._isPending) {
                                throw new Error(
                                    'The `onCancel` handler was attached after the promise settled.'
                                )
                            }

                            this._cancelHandlers.push(handler)
                        }

                        Object.defineProperties(onCancel, {
                            shouldReject: {
                                get: () => this._rejectOnCancel,
                                set: boolean => {
                                    this._rejectOnCancel = boolean
                                }
                            }
                        })

                        return executor(onResolve, onReject, onCancel)
                    })
                }

                then(onFulfilled, onRejected) {
                    // eslint-disable-next-line promise/prefer-await-to-then
                    return this._promise.then(onFulfilled, onRejected)
                }

                catch(onRejected) {
                    return this._promise.catch(onRejected)
                }

                finally(onFinally) {
                    return this._promise.finally(onFinally)
                }

                cancel(reason) {
                    if (!this._isPending || this._isCanceled) {
                        return
                    }

                    if (this._cancelHandlers.length > 0) {
                        try {
                            for (const handler of this._cancelHandlers) {
                                handler()
                            }
                        } catch (error) {
                            this._reject(error)
                        }
                    }

                    this._isCanceled = true
                    if (this._rejectOnCancel) {
                        this._reject(new CancelError(reason))
                    }
                }

                get isCanceled() {
                    return this._isCanceled
                }
            }

            Object.setPrototypeOf(PCancelable.prototype, Promise.prototype)

            module.exports = PCancelable
            module.exports.CancelError = CancelError

            /***/
        },

        /***/ iq4v: /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('Mqbl')
            module.exports = __webpack_require__('WEpk').Object.keys

            /***/
        },

        /***/ irzI: /***/ function(module, exports, __webpack_require__) {
            /**
             * This is the web browser implementation of `debug()`.
             *
             * Expose `debug()` as the module.
             */

            exports = module.exports = __webpack_require__('BKKR')
            exports.log = log
            exports.formatArgs = formatArgs
            exports.save = save
            exports.load = load
            exports.useColors = useColors
            exports.storage =
                'undefined' != typeof chrome &&
                'undefined' != typeof chrome.storage
                    ? chrome.storage.local
                    : localstorage()

            /**
             * Colors.
             */

            exports.colors = [
                '#0000CC',
                '#0000FF',
                '#0033CC',
                '#0033FF',
                '#0066CC',
                '#0066FF',
                '#0099CC',
                '#0099FF',
                '#00CC00',
                '#00CC33',
                '#00CC66',
                '#00CC99',
                '#00CCCC',
                '#00CCFF',
                '#3300CC',
                '#3300FF',
                '#3333CC',
                '#3333FF',
                '#3366CC',
                '#3366FF',
                '#3399CC',
                '#3399FF',
                '#33CC00',
                '#33CC33',
                '#33CC66',
                '#33CC99',
                '#33CCCC',
                '#33CCFF',
                '#6600CC',
                '#6600FF',
                '#6633CC',
                '#6633FF',
                '#66CC00',
                '#66CC33',
                '#9900CC',
                '#9900FF',
                '#9933CC',
                '#9933FF',
                '#99CC00',
                '#99CC33',
                '#CC0000',
                '#CC0033',
                '#CC0066',
                '#CC0099',
                '#CC00CC',
                '#CC00FF',
                '#CC3300',
                '#CC3333',
                '#CC3366',
                '#CC3399',
                '#CC33CC',
                '#CC33FF',
                '#CC6600',
                '#CC6633',
                '#CC9900',
                '#CC9933',
                '#CCCC00',
                '#CCCC33',
                '#FF0000',
                '#FF0033',
                '#FF0066',
                '#FF0099',
                '#FF00CC',
                '#FF00FF',
                '#FF3300',
                '#FF3333',
                '#FF3366',
                '#FF3399',
                '#FF33CC',
                '#FF33FF',
                '#FF6600',
                '#FF6633',
                '#FF9900',
                '#FF9933',
                '#FFCC00',
                '#FFCC33'
            ]

            /**
             * Currently only WebKit-based Web Inspectors, Firefox >= v31,
             * and the Firebug extension (any Firefox version) are known
             * to support "%c" CSS customizations.
             *
             * TODO: add a `localStorage` variable to explicitly enable/disable colors
             */

            function useColors() {
                // NB: In an Electron preload script, document will be defined but not fully
                // initialized. Since we know we're in Chrome, we'll just detect this case
                // explicitly
                if (
                    typeof window !== 'undefined' &&
                    window.process &&
                    window.process.type === 'renderer'
                ) {
                    return true
                }

                // Internet Explorer and Edge do not support colors.
                if (
                    typeof navigator !== 'undefined' &&
                    navigator.userAgent &&
                    navigator.userAgent
                        .toLowerCase()
                        .match(/(edge|trident)\/(\d+)/)
                ) {
                    return false
                }

                // is webkit? http://stackoverflow.com/a/16459606/376773
                // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
                return (
                    (typeof document !== 'undefined' &&
                        document.documentElement &&
                        document.documentElement.style &&
                        document.documentElement.style.WebkitAppearance) ||
                    // is firebug? http://stackoverflow.com/a/398120/376773
                    (typeof window !== 'undefined' &&
                        window.console &&
                        (window.console.firebug ||
                            (window.console.exception &&
                                window.console.table))) ||
                    // is firefox >= v31?
                    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                    (typeof navigator !== 'undefined' &&
                        navigator.userAgent &&
                        navigator.userAgent
                            .toLowerCase()
                            .match(/firefox\/(\d+)/) &&
                        parseInt(RegExp.$1, 10) >= 31) ||
                    // double check webkit in userAgent just in case we are in a worker
                    (typeof navigator !== 'undefined' &&
                        navigator.userAgent &&
                        navigator.userAgent
                            .toLowerCase()
                            .match(/applewebkit\/(\d+)/))
                )
            }

            /**
             * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
             */

            exports.formatters.j = function(v) {
                try {
                    return JSON.stringify(v)
                } catch (err) {
                    return '[UnexpectedJSONParseError]: ' + err.message
                }
            }

            /**
             * Colorize log arguments if enabled.
             *
             * @api public
             */

            function formatArgs(args) {
                var useColors = this.useColors

                args[0] =
                    (useColors ? '%c' : '') +
                    this.namespace +
                    (useColors ? ' %c' : ' ') +
                    args[0] +
                    (useColors ? '%c ' : ' ') +
                    '+' +
                    exports.humanize(this.diff)

                if (!useColors) return

                var c = 'color: ' + this.color
                args.splice(1, 0, c, 'color: inherit')

                // the final "%c" is somewhat tricky, because there could be other
                // arguments passed either before or after the %c, so we need to
                // figure out the correct index to insert the CSS into
                var index = 0
                var lastC = 0
                args[0].replace(/%[a-zA-Z%]/g, function(match) {
                    if ('%%' === match) return
                    index++
                    if ('%c' === match) {
                        // we only are interested in the *last* %c
                        // (the user may have provided their own)
                        lastC = index
                    }
                })

                args.splice(lastC, 0, c)
            }

            /**
             * Invokes `console.log()` when available.
             * No-op when `console.log` is not a "function".
             *
             * @api public
             */

            function log() {
                // this hackery is required for IE8/9, where
                // the `console.log` function doesn't have 'apply'
                return (
                    'object' === typeof console &&
                    console.log &&
                    Function.prototype.apply.call(
                        console.log,
                        console,
                        arguments
                    )
                )
            }

            /**
             * Save `namespaces`.
             *
             * @param {String} namespaces
             * @api private
             */

            function save(namespaces) {
                try {
                    if (null == namespaces) {
                        exports.storage.removeItem('debug')
                    } else {
                        exports.storage.debug = namespaces
                    }
                } catch (e) {}
            }

            /**
             * Load `namespaces`.
             *
             * @return {String} returns the previously persisted debug modes
             * @api private
             */

            function load() {
                var r
                try {
                    r = exports.storage.debug
                } catch (e) {}

                // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
                if (!r && typeof process !== 'undefined' && 'env' in process) {
                    r = process.env.DEBUG
                }

                return r
            }

            /**
             * Enable namespaces listed in `localStorage.debug` initially.
             */

            exports.enable(load())

            /**
             * Localstorage attempts to return the localstorage.
             *
             * This is necessary because safari throws
             * when a user disables cookies/localstorage
             * and you attempt to access it.
             *
             * @return {LocalStorage}
             * @api private
             */

            function localstorage() {
                try {
                    return window.localStorage
                } catch (e) {}
            }

            /***/
        },

        /***/ itsj: /***/ function(module, exports) {
            /**
             * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
             *
             * @private
             * @param {Object} object The object to query.
             * @param {string} key The key of the property to get.
             * @returns {*} Returns the property value.
             */
            function safeGet(object, key) {
                if (
                    key === 'constructor' &&
                    typeof object[key] === 'function'
                ) {
                    return
                }

                if (key == '__proto__') {
                    return
                }

                return object[key]
            }

            module.exports = safeGet

            /***/
        },

        /***/ j0Yl: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const deferToConnect = __webpack_require__('xZ+y')

            module.exports = request => {
                const timings = {
                    start: Date.now(),
                    socket: null,
                    lookup: null,
                    connect: null,
                    upload: null,
                    response: null,
                    end: null,
                    error: null,
                    phases: {
                        wait: null,
                        dns: null,
                        tcp: null,
                        request: null,
                        firstByte: null,
                        download: null,
                        total: null
                    }
                }

                const handleError = origin => {
                    const emit = origin.emit.bind(origin)
                    origin.emit = (event, ...args) => {
                        // Catches the `error` event
                        if (event === 'error') {
                            timings.error = Date.now()
                            timings.phases.total = timings.error - timings.start

                            origin.emit = emit
                        }

                        // Saves the original behavior
                        return emit(event, ...args)
                    }
                }

                let uploadFinished = false
                const onUpload = () => {
                    timings.upload = Date.now()
                    timings.phases.request = timings.upload - timings.connect
                }

                handleError(request)

                request.once('socket', socket => {
                    timings.socket = Date.now()
                    timings.phases.wait = timings.socket - timings.start

                    const lookupListener = () => {
                        timings.lookup = Date.now()
                        timings.phases.dns = timings.lookup - timings.socket
                    }

                    socket.once('lookup', lookupListener)

                    deferToConnect(socket, () => {
                        timings.connect = Date.now()

                        if (timings.lookup === null) {
                            socket.removeListener('lookup', lookupListener)
                            timings.lookup = timings.connect
                            timings.phases.dns = timings.lookup - timings.socket
                        }

                        timings.phases.tcp = timings.connect - timings.lookup

                        if (uploadFinished && !timings.upload) {
                            onUpload()
                        }
                    })
                })

                request.once('finish', () => {
                    uploadFinished = true

                    if (timings.connect) {
                        onUpload()
                    }
                })

                request.once('response', response => {
                    timings.response = Date.now()
                    timings.phases.firstByte = timings.response - timings.upload

                    handleError(response)

                    response.once('end', () => {
                        timings.end = Date.now()
                        timings.phases.download = timings.end - timings.response
                        timings.phases.total = timings.end - timings.start
                    })
                })

                return timings
            }

            /***/
        },

        /***/ j2DC: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var create = __webpack_require__('oVml')
            var descriptor = __webpack_require__('rr1i')
            var setToStringTag = __webpack_require__('RfKB')
            var IteratorPrototype = {}

            // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
            __webpack_require__('NegM')(
                IteratorPrototype,
                __webpack_require__('UWiX')('iterator'),
                function() {
                    return this
                }
            )

            module.exports = function(Constructor, NAME, next) {
                Constructor.prototype = create(IteratorPrototype, {
                    next: descriptor(1, next)
                })
                setToStringTag(Constructor, NAME + ' Iterator')
            }

            /***/
        },

        /***/ jK02: /***/ function(module, exports) {
            module.exports = require('util')

            /***/
        },

        /***/ jUDV: /***/ function(module, exports, __webpack_require__) {
            const { inherits } = __webpack_require__('jK02')
            const encoders = __webpack_require__('E8LI')
            const decoders = __webpack_require__('zspo')

            module.exports.define = function define(name, body) {
                return new Entity(name, body)
            }

            function Entity(name, body) {
                this.name = name
                this.body = body

                this.decoders = {}
                this.encoders = {}
            }

            Entity.prototype._createNamed = function createNamed(Base) {
                const name = this.name

                function Generated(entity) {
                    this._initNamed(entity, name)
                }
                inherits(Generated, Base)
                Generated.prototype._initNamed = function _initNamed(
                    entity,
                    name
                ) {
                    Base.call(this, entity, name)
                }

                return new Generated(this)
            }

            Entity.prototype._getDecoder = function _getDecoder(enc) {
                enc = enc || 'der'
                // Lazily create decoder
                if (!Object.prototype.hasOwnProperty.call(this.decoders, enc)) {
                    this.decoders[enc] = this._createNamed(decoders[enc])
                }
                return this.decoders[enc]
            }

            Entity.prototype.decode = function decode(data, enc, options) {
                return this._getDecoder(enc).decode(data, options)
            }

            Entity.prototype._getEncoder = function _getEncoder(enc) {
                enc = enc || 'der'
                // Lazily create encoder
                if (!Object.prototype.hasOwnProperty.call(this.encoders, enc)) {
                    this.encoders[enc] = this._createNamed(encoders[enc])
                }
                return this.encoders[enc]
            }

            Entity.prototype.encode = function encode(
                data,
                enc,
                /* internal */ reporter
            ) {
                return this._getEncoder(enc).encode(data, reporter)
            }

            /***/
        },

        /***/ jeLo: /***/ function(module, exports, __webpack_require__) {
            var copyObject = __webpack_require__('juv8'),
                keysIn = __webpack_require__('mTTR')

            /**
             * Converts `value` to a plain object flattening inherited enumerable string
             * keyed properties of `value` to own properties of the plain object.
             *
             * @static
             * @memberOf _
             * @since 3.0.0
             * @category Lang
             * @param {*} value The value to convert.
             * @returns {Object} Returns the converted plain object.
             * @example
             *
             * function Foo() {
             *   this.b = 2;
             * }
             *
             * Foo.prototype.c = 3;
             *
             * _.assign({ 'a': 1 }, new Foo);
             * // => { 'a': 1, 'b': 2 }
             *
             * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
             * // => { 'a': 1, 'b': 2, 'c': 3 }
             */
            function toPlainObject(value) {
                return copyObject(value, keysIn(value))
            }

            module.exports = toPlainObject

            /***/
        },

        /***/ 'jfS+': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var Cancel = __webpack_require__('endd')

            /**
             * A `CancelToken` is an object that can be used to request cancellation of an operation.
             *
             * @class
             * @param {Function} executor The executor function.
             */
            function CancelToken(executor) {
                if (typeof executor !== 'function') {
                    throw new TypeError('executor must be a function.')
                }

                var resolvePromise
                this.promise = new Promise(function promiseExecutor(resolve) {
                    resolvePromise = resolve
                })

                var token = this
                executor(function cancel(message) {
                    if (token.reason) {
                        // Cancellation has already been requested
                        return
                    }

                    token.reason = new Cancel(message)
                    resolvePromise(token.reason)
                })
            }

            /**
             * Throws a `Cancel` if cancellation has been requested.
             */
            CancelToken.prototype.throwIfRequested = function throwIfRequested() {
                if (this.reason) {
                    throw this.reason
                }
            }

            /**
             * Returns an object that contains a new `CancelToken` and a function that, when called,
             * cancels the `CancelToken`.
             */
            CancelToken.source = function source() {
                var cancel
                var token = new CancelToken(function executor(c) {
                    cancel = c
                })
                return {
                    token: token,
                    cancel: cancel
                }
            }

            module.exports = CancelToken

            /***/
        },

        /***/ 'jle/': /***/ function(module, exports) {
            module.exports = require('os')

            /***/
        },

        /***/ jmDH: /***/ function(module, exports, __webpack_require__) {
            // Thank's IE8 for his funny defineProperty
            module.exports = !__webpack_require__('KUxP')(function() {
                return (
                    Object.defineProperty({}, 'a', {
                        get: function() {
                            return 7
                        }
                    }).a != 7
                )
            })

            /***/
        },

        /***/ juv8: /***/ function(module, exports, __webpack_require__) {
            var assignValue = __webpack_require__('MrPd'),
                baseAssignValue = __webpack_require__('hypo')

            /**
             * Copies properties of `source` to `object`.
             *
             * @private
             * @param {Object} source The object to copy properties from.
             * @param {Array} props The property identifiers to copy.
             * @param {Object} [object={}] The object to copy properties to.
             * @param {Function} [customizer] The function to customize copied values.
             * @returns {Object} Returns `object`.
             */
            function copyObject(source, props, object, customizer) {
                var isNew = !object
                object || (object = {})

                var index = -1,
                    length = props.length

                while (++index < length) {
                    var key = props[index]

                    var newValue = customizer
                        ? customizer(
                              object[key],
                              source[key],
                              key,
                              object,
                              source
                          )
                        : undefined

                    if (newValue === undefined) {
                        newValue = source[key]
                    }
                    if (isNew) {
                        baseAssignValue(object, key, newValue)
                    } else {
                        assignValue(object, key, newValue)
                    }
                }
                return object
            }

            module.exports = copyObject

            /***/
        },

        /***/ jwwS: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$defineProperty = __webpack_require__('hfKm')

            var __importStar =
                (this && this.__importStar) ||
                function(mod) {
                    if (mod && mod.__esModule) return mod
                    var result = {}
                    if (mod != null)
                        for (var k in mod)
                            if (Object.hasOwnProperty.call(mod, k))
                                result[k] = mod[k]
                    result['default'] = mod
                    return result
                }

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            const React = __importStar(__webpack_require__('q1tI')) // @ts-ignore for some reason the React types don't like this, but it's correct.

            exports.LoadableContext = React.createContext(null)

            /***/
        },

        /***/ 'k+0e': /***/ function(module, exports, __webpack_require__) {
            const { strict: assert } = __webpack_require__('Qs3B')

            const { Reporter } = __webpack_require__('1WHo')
            const { DecoderBuffer, EncoderBuffer } = __webpack_require__('Z9M3')

            // Supported tags
            const tags = [
                'seq',
                'seqof',
                'set',
                'setof',
                'objid',
                'bool',
                'gentime',
                'utctime',
                'null_',
                'enum',
                'int',
                'objDesc',
                'bitstr',
                'bmpstr',
                'charstr',
                'genstr',
                'graphstr',
                'ia5str',
                'iso646str',
                'numstr',
                'octstr',
                'printstr',
                't61str',
                'unistr',
                'utf8str',
                'videostr'
            ]

            // Public methods list
            const methods = [
                'key',
                'obj',
                'use',
                'optional',
                'explicit',
                'implicit',
                'def',
                'choice',
                'any',
                'contains'
            ].concat(tags)

            // Overrided methods list
            const overrided = [
                '_peekTag',
                '_decodeTag',
                '_use',
                '_decodeStr',
                '_decodeObjid',
                '_decodeTime',
                '_decodeNull',
                '_decodeInt',
                '_decodeBool',
                '_decodeList',

                '_encodeComposite',
                '_encodeStr',
                '_encodeObjid',
                '_encodeTime',
                '_encodeNull',
                '_encodeInt',
                '_encodeBool'
            ]

            function Node(enc, parent, name) {
                const state = {}
                this._baseState = state

                state.name = name
                state.enc = enc

                state.parent = parent || null
                state.children = null

                // State
                state.tag = null
                state.args = null
                state.reverseArgs = null
                state.choice = null
                state.optional = false
                state.any = false
                state.obj = false
                state.use = null
                state.useDecoder = null
                state.key = null
                state.default = null
                state.explicit = null
                state.implicit = null
                state.contains = null

                // Should create new instance on each method
                if (!state.parent) {
                    state.children = []
                    this._wrap()
                }
            }

            const stateProps = [
                'enc',
                'parent',
                'children',
                'tag',
                'args',
                'reverseArgs',
                'choice',
                'optional',
                'any',
                'obj',
                'use',
                'alteredUse',
                'key',
                'default',
                'explicit',
                'implicit',
                'contains'
            ]

            Node.prototype.clone = function clone() {
                const state = this._baseState
                const cstate = {}
                stateProps.forEach(function(prop) {
                    cstate[prop] = state[prop]
                })
                const res = new this.constructor(cstate.parent)
                res._baseState = cstate
                return res
            }

            Node.prototype._wrap = function wrap() {
                const state = this._baseState
                methods.forEach(function(method) {
                    this[method] = function _wrappedMethod() {
                        const clone = new this.constructor(this)
                        state.children.push(clone)
                        return clone[method].apply(clone, arguments)
                    }
                }, this)
            }

            Node.prototype._init = function init(body) {
                const state = this._baseState

                assert(state.parent === null)
                body.call(this)

                // Filter children
                state.children = state.children.filter(function(child) {
                    return child._baseState.parent === this
                }, this)
                assert.equal(
                    state.children.length,
                    1,
                    'Root node can have only one child'
                )
            }

            Node.prototype._useArgs = function useArgs(args) {
                const state = this._baseState

                // Filter children and args
                const children = args.filter(function(arg) {
                    return arg instanceof this.constructor
                }, this)
                args = args.filter(function(arg) {
                    return !(arg instanceof this.constructor)
                }, this)

                if (children.length !== 0) {
                    assert(state.children === null)
                    state.children = children

                    // Replace parent to maintain backward link
                    children.forEach(function(child) {
                        child._baseState.parent = this
                    }, this)
                }
                if (args.length !== 0) {
                    assert(state.args === null)
                    state.args = args
                    state.reverseArgs = args.map(function(arg) {
                        if (
                            typeof arg !== 'object' ||
                            arg.constructor !== Object
                        ) {
                            return arg
                        }

                        const res = {}
                        Object.keys(arg).forEach(function(key) {
                            if (key == (key | 0)) {
                                key |= 0
                            } // eslint-disable-line eqeqeq
                            const value = arg[key]
                            res[value] = key
                        })
                        return res
                    })
                }
            }

            //
            // Overrided methods
            //

            overrided.forEach(function(method) {
                Node.prototype[method] = function _overrided() {
                    const state = this._baseState
                    throw new Error(
                        `${method} not implemented for encoding: ${state.enc}`
                    )
                }
            })

            //
            // Public methods
            //

            tags.forEach(function(tag) {
                Node.prototype[tag] = function _tagMethod() {
                    const state = this._baseState
                    const args = Array.prototype.slice.call(arguments)

                    assert(state.tag === null)
                    state.tag = tag

                    this._useArgs(args)

                    return this
                }
            })

            Node.prototype.use = function use(item) {
                assert(item)
                const state = this._baseState

                assert(state.use === null)
                state.use = item

                return this
            }

            Node.prototype.optional = function optional() {
                const state = this._baseState

                state.optional = true

                return this
            }

            Node.prototype.def = function def(val) {
                const state = this._baseState

                assert(state.default === null)
                state.default = val
                state.optional = true

                return this
            }

            Node.prototype.explicit = function explicit(num) {
                const state = this._baseState

                assert(state.explicit === null && state.implicit === null)
                state.explicit = num

                return this
            }

            Node.prototype.implicit = function implicit(num) {
                const state = this._baseState

                assert(state.explicit === null && state.implicit === null)
                state.implicit = num

                return this
            }

            Node.prototype.obj = function obj() {
                const state = this._baseState
                const args = Array.prototype.slice.call(arguments)

                state.obj = true

                if (args.length !== 0) {
                    this._useArgs(args)
                }

                return this
            }

            Node.prototype.key = function key(newKey) {
                const state = this._baseState

                assert(state.key === null)
                state.key = newKey

                return this
            }

            Node.prototype.any = function any() {
                const state = this._baseState

                state.any = true

                return this
            }

            Node.prototype.choice = function choice(obj) {
                const state = this._baseState

                assert(state.choice === null)
                state.choice = obj
                this._useArgs(
                    Object.keys(obj).map(function(key) {
                        return obj[key]
                    })
                )

                return this
            }

            Node.prototype.contains = function contains(item) {
                const state = this._baseState

                assert(state.use === null)
                state.contains = item

                return this
            }

            //
            // Decoding
            //

            Node.prototype._decode = function decode(input, options) {
                const state = this._baseState

                // Decode root node
                if (state.parent === null) {
                    return input.wrapResult(
                        state.children[0]._decode(input, options)
                    )
                }

                let result = state.default
                let present = true

                let prevKey = null
                if (state.key !== null) {
                    prevKey = input.enterKey(state.key)
                }

                // Check if tag is there
                if (state.optional) {
                    let tag = null
                    if (state.explicit !== null) {
                        tag = state.explicit
                    } else if (state.implicit !== null) {
                        tag = state.implicit
                    } else if (state.tag !== null) {
                        tag = state.tag
                    }

                    if (tag === null && !state.any) {
                        // Trial and Error
                        const save = input.save()
                        try {
                            if (state.choice === null) {
                                this._decodeGeneric(state.tag, input, options)
                            } else {
                                this._decodeChoice(input, options)
                            }
                            present = true
                        } catch (e) {
                            present = false
                        }
                        input.restore(save)
                    } else {
                        present = this._peekTag(input, tag, state.any)

                        if (input.isError(present)) {
                            return present
                        }
                    }
                }

                // Push object on stack
                let prevObj
                if (state.obj && present) {
                    prevObj = input.enterObject()
                }

                if (present) {
                    // Unwrap explicit values
                    if (state.explicit !== null) {
                        const explicit = this._decodeTag(input, state.explicit)
                        if (input.isError(explicit)) {
                            return explicit
                        }
                        input = explicit
                    }

                    const start = input.offset

                    // Unwrap implicit and normal values
                    if (state.use === null && state.choice === null) {
                        let save
                        if (state.any) {
                            save = input.save()
                        }
                        const body = this._decodeTag(
                            input,
                            state.implicit !== null
                                ? state.implicit
                                : state.tag,
                            state.any
                        )
                        if (input.isError(body)) {
                            return body
                        }

                        if (state.any) {
                            result = input.raw(save)
                        } else {
                            input = body
                        }
                    }

                    if (options && options.track && state.tag !== null) {
                        options.track(
                            input.path(),
                            start,
                            input.length,
                            'tagged'
                        )
                    }

                    if (options && options.track && state.tag !== null) {
                        options.track(
                            input.path(),
                            input.offset,
                            input.length,
                            'content'
                        )
                    }

                    // Select proper method for tag
                    if (state.any) {
                        // no-op
                    } else if (state.choice === null) {
                        result = this._decodeGeneric(state.tag, input, options)
                    } else {
                        result = this._decodeChoice(input, options)
                    }

                    if (input.isError(result)) {
                        return result
                    }

                    // Decode children
                    if (
                        !state.any &&
                        state.choice === null &&
                        state.children !== null
                    ) {
                        state.children.forEach(function decodeChildren(child) {
                            // NOTE: We are ignoring errors here, to let parser continue with other
                            // parts of encoded data
                            child._decode(input, options)
                        })
                    }

                    // Decode contained/encoded by schema, only in bit or octet strings
                    if (
                        state.contains &&
                        (state.tag === 'octstr' || state.tag === 'bitstr')
                    ) {
                        const data = new DecoderBuffer(result)
                        result = this._getUse(
                            state.contains,
                            input._reporterState.obj
                        )._decode(data, options)
                    }
                }

                // Pop object
                if (state.obj && present) {
                    result = input.leaveObject(prevObj)
                }

                // Set key
                if (
                    state.key !== null &&
                    (result !== null || present === true)
                ) {
                    input.leaveKey(prevKey, state.key, result)
                } else if (prevKey !== null) {
                    input.exitKey(prevKey)
                }

                return result
            }

            Node.prototype._decodeGeneric = function decodeGeneric(
                tag,
                input,
                options
            ) {
                const state = this._baseState

                if (tag === 'seq' || tag === 'set') {
                    return null
                }
                if (tag === 'seqof' || tag === 'setof') {
                    return this._decodeList(input, tag, state.args[0], options)
                } else if (/str$/.test(tag)) {
                    return this._decodeStr(input, tag, options)
                } else if (tag === 'objid' && state.args) {
                    return this._decodeObjid(
                        input,
                        state.args[0],
                        state.args[1],
                        options
                    )
                } else if (tag === 'objid') {
                    return this._decodeObjid(input, null, null, options)
                } else if (tag === 'gentime' || tag === 'utctime') {
                    return this._decodeTime(input, tag, options)
                } else if (tag === 'null_') {
                    return this._decodeNull(input, options)
                } else if (tag === 'bool') {
                    return this._decodeBool(input, options)
                } else if (tag === 'objDesc') {
                    return this._decodeStr(input, tag, options)
                } else if (tag === 'int' || tag === 'enum') {
                    return this._decodeInt(
                        input,
                        state.args && state.args[0],
                        options
                    )
                }

                if (state.use !== null) {
                    return this._getUse(
                        state.use,
                        input._reporterState.obj
                    )._decode(input, options)
                } else {
                    return input.error(`unknown tag: ${tag}`)
                }
            }

            Node.prototype._getUse = function _getUse(entity, obj) {
                const state = this._baseState
                // Create altered use decoder if implicit is set
                state.useDecoder = this._use(entity, obj)
                assert(state.useDecoder._baseState.parent === null)
                state.useDecoder = state.useDecoder._baseState.children[0]
                if (state.implicit !== state.useDecoder._baseState.implicit) {
                    state.useDecoder = state.useDecoder.clone()
                    state.useDecoder._baseState.implicit = state.implicit
                }
                return state.useDecoder
            }

            Node.prototype._decodeChoice = function decodeChoice(
                input,
                options
            ) {
                const state = this._baseState
                let result = null
                let match = false

                Object.keys(state.choice).some(function(key) {
                    const save = input.save()
                    const node = state.choice[key]
                    try {
                        const value = node._decode(input, options)
                        if (input.isError(value)) {
                            return false
                        }

                        result = { type: key, value: value }
                        match = true
                    } catch (e) {
                        input.restore(save)
                        return false
                    }
                    return true
                }, this)

                if (!match) {
                    return input.error('Choice not matched')
                }

                return result
            }

            //
            // Encoding
            //

            Node.prototype._createEncoderBuffer = function createEncoderBuffer(
                data
            ) {
                return new EncoderBuffer(data, this.reporter)
            }

            Node.prototype._encode = function encode(data, reporter, parent) {
                const state = this._baseState
                if (state.default !== null && state.default === data) {
                    return
                }

                const result = this._encodeValue(data, reporter, parent)
                if (result === undefined) {
                    return
                }

                if (this._skipDefault(result, reporter, parent)) {
                    return
                }

                return result
            }

            Node.prototype._encodeValue = function encode(
                data,
                reporter,
                parent
            ) {
                const state = this._baseState

                // Decode root node
                if (state.parent === null) {
                    return state.children[0]._encode(
                        data,
                        reporter || new Reporter()
                    )
                }

                let result = null

                // Set reporter to share it with a child class
                this.reporter = reporter

                // Check if data is there
                if (state.optional && data === undefined) {
                    if (state.default !== null) {
                        data = state.default
                    } else {
                        return
                    }
                }

                // Encode children first
                let content = null
                let primitive = false
                if (state.any) {
                    // Anything that was given is translated to buffer
                    result = this._createEncoderBuffer(data)
                } else if (state.choice) {
                    result = this._encodeChoice(data, reporter)
                } else if (state.contains) {
                    content = this._getUse(state.contains, parent)._encode(
                        data,
                        reporter
                    )
                    primitive = true
                } else if (state.children) {
                    content = state.children
                        .map(function(child) {
                            if (child._baseState.tag === 'null_') {
                                return child._encode(null, reporter, data)
                            }

                            if (child._baseState.key === null) {
                                return reporter.error('Child should have a key')
                            }
                            const prevKey = reporter.enterKey(
                                child._baseState.key
                            )

                            if (typeof data !== 'object') {
                                return reporter.error(
                                    'Child expected, but input is not object'
                                )
                            }

                            const res = child._encode(
                                data[child._baseState.key],
                                reporter,
                                data
                            )
                            reporter.leaveKey(prevKey)

                            return res
                        }, this)
                        .filter(function(child) {
                            return child
                        })
                    content = this._createEncoderBuffer(content)
                } else {
                    if (state.tag === 'seqof' || state.tag === 'setof') {
                        if (!(state.args && state.args.length === 1)) {
                            return reporter.error(
                                `Too many args for: ${state.tag}`
                            )
                        }

                        if (!Array.isArray(data)) {
                            return reporter.error(
                                'seqof/setof, but data is not Array'
                            )
                        }

                        const child = this.clone()
                        child._baseState.implicit = null
                        content = this._createEncoderBuffer(
                            data.map(function(item) {
                                const state = this._baseState

                                return this._getUse(
                                    state.args[0],
                                    data
                                )._encode(item, reporter)
                            }, child)
                        )
                    } else if (state.use !== null) {
                        result = this._getUse(state.use, parent)._encode(
                            data,
                            reporter
                        )
                    } else {
                        content = this._encodePrimitive(state.tag, data)
                        primitive = true
                    }
                }

                // Encode data itself
                if (!state.any && state.choice === null) {
                    const tag =
                        state.implicit !== null ? state.implicit : state.tag
                    const cls =
                        state.implicit === null ? 'universal' : 'context'

                    if (tag === null) {
                        if (state.use === null) {
                            reporter.error(
                                'Tag could be omitted only for .use()'
                            )
                        }
                    } else {
                        if (state.use === null) {
                            result = this._encodeComposite(
                                tag,
                                primitive,
                                cls,
                                content
                            )
                        }
                    }
                }

                // Wrap in explicit
                if (state.explicit !== null) {
                    result = this._encodeComposite(
                        state.explicit,
                        false,
                        'context',
                        result
                    )
                }

                return result
            }

            Node.prototype._encodeChoice = function encodeChoice(
                data,
                reporter
            ) {
                const state = this._baseState

                const node = state.choice[data.type]
                if (!node) {
                    assert(
                        false,
                        `${data.type} not found in ${JSON.stringify(
                            Object.keys(state.choice)
                        )}`
                    )
                }
                return node._encode(data.value, reporter)
            }

            Node.prototype._encodePrimitive = function encodePrimitive(
                tag,
                data
            ) {
                const state = this._baseState

                if (/str$/.test(tag)) {
                    return this._encodeStr(data, tag)
                } else if (tag === 'objid' && state.args) {
                    return this._encodeObjid(
                        data,
                        state.reverseArgs[0],
                        state.args[1]
                    )
                } else if (tag === 'objid') {
                    return this._encodeObjid(data, null, null)
                } else if (tag === 'gentime' || tag === 'utctime') {
                    return this._encodeTime(data, tag)
                } else if (tag === 'null_') {
                    return this._encodeNull()
                } else if (tag === 'int' || tag === 'enum') {
                    return this._encodeInt(
                        data,
                        state.args && state.reverseArgs[0]
                    )
                } else if (tag === 'bool') {
                    return this._encodeBool(data)
                } else if (tag === 'objDesc') {
                    return this._encodeStr(data, tag)
                } else {
                    throw new Error(`Unsupported tag: ${tag}`)
                }
            }

            Node.prototype._isNumstr = function isNumstr(str) {
                return /^[0-9 ]*$/.test(str)
            }

            Node.prototype._isPrintstr = function isPrintstr(str) {
                return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str)
            }

            module.exports = Node

            /***/
        },

        /***/ 'k+1r': /***/ function(module, exports, __webpack_require__) {
            var getMapData = __webpack_require__('QkVE')

            /**
             * Removes `key` and its value from the map.
             *
             * @private
             * @name delete
             * @memberOf MapCache
             * @param {string} key The key of the value to remove.
             * @returns {boolean} Returns `true` if the entry was removed, else `false`.
             */
            function mapCacheDelete(key) {
                var result = getMapData(this, key)['delete'](key)
                this.size -= result ? 1 : 0
                return result
            }

            module.exports = mapCacheDelete

            /***/
        },

        /***/ k9s9: /***/ function(module, exports) {
            module.exports = function() {
                this.seq().obj(this.key('n').int(), this.key('e').int())
            }

            /***/
        },

        /***/ kAMH: /***/ function(module, exports, __webpack_require__) {
            // 7.2.2 IsArray(argument)
            var cof = __webpack_require__('a0xu')
            module.exports =
                Array.isArray ||
                function isArray(arg) {
                    return cof(arg) == 'Array'
                }

            /***/
        },

        /***/ kB4c: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var redefineAll = __webpack_require__('XJU/')
            var getWeak = __webpack_require__('6/1s').getWeak
            var anObject = __webpack_require__('5K7Z')
            var isObject = __webpack_require__('93I4')
            var anInstance = __webpack_require__('EXMj')
            var forOf = __webpack_require__('oioR')
            var createArrayMethod = __webpack_require__('V7Et')
            var $has = __webpack_require__('B+OT')
            var validate = __webpack_require__('n3ko')
            var arrayFind = createArrayMethod(5)
            var arrayFindIndex = createArrayMethod(6)
            var id = 0

            // fallback for uncaught frozen keys
            var uncaughtFrozenStore = function(that) {
                return that._l || (that._l = new UncaughtFrozenStore())
            }
            var UncaughtFrozenStore = function() {
                this.a = []
            }
            var findUncaughtFrozen = function(store, key) {
                return arrayFind(store.a, function(it) {
                    return it[0] === key
                })
            }
            UncaughtFrozenStore.prototype = {
                get: function(key) {
                    var entry = findUncaughtFrozen(this, key)
                    if (entry) return entry[1]
                },
                has: function(key) {
                    return !!findUncaughtFrozen(this, key)
                },
                set: function(key, value) {
                    var entry = findUncaughtFrozen(this, key)
                    if (entry) entry[1] = value
                    else this.a.push([key, value])
                },
                delete: function(key) {
                    var index = arrayFindIndex(this.a, function(it) {
                        return it[0] === key
                    })
                    if (~index) this.a.splice(index, 1)
                    return !!~index
                }
            }

            module.exports = {
                getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
                    var C = wrapper(function(that, iterable) {
                        anInstance(that, C, NAME, '_i')
                        that._t = NAME // collection type
                        that._i = id++ // collection id
                        that._l = undefined // leak store for uncaught frozen objects
                        if (iterable != undefined)
                            forOf(iterable, IS_MAP, that[ADDER], that)
                    })
                    redefineAll(C.prototype, {
                        // 23.3.3.2 WeakMap.prototype.delete(key)
                        // 23.4.3.3 WeakSet.prototype.delete(value)
                        delete: function(key) {
                            if (!isObject(key)) return false
                            var data = getWeak(key)
                            if (data === true)
                                return uncaughtFrozenStore(
                                    validate(this, NAME)
                                )['delete'](key)
                            return (
                                data &&
                                $has(data, this._i) &&
                                delete data[this._i]
                            )
                        },
                        // 23.3.3.4 WeakMap.prototype.has(key)
                        // 23.4.3.4 WeakSet.prototype.has(value)
                        has: function has(key) {
                            if (!isObject(key)) return false
                            var data = getWeak(key)
                            if (data === true)
                                return uncaughtFrozenStore(
                                    validate(this, NAME)
                                ).has(key)
                            return data && $has(data, this._i)
                        }
                    })
                    return C
                },
                def: function(that, key, value) {
                    var data = getWeak(anObject(key), true)
                    if (data === true) uncaughtFrozenStore(that).set(key, value)
                    else data[that._i] = value
                    return that
                },
                ufstore: uncaughtFrozenStore
            }

            /***/
        },

        /***/ 'kF1/': /***/ function(module, exports) {
            module.exports = a => !!a && a.constructor === Object

            /***/
        },

        /***/ kGOt: /***/ function(module, exports, __webpack_require__) {
            /**
             * Detect Electron renderer process, which is node, but we should
             * treat as a browser.
             */

            if (typeof process === 'undefined' || process.type === 'renderer') {
                module.exports = __webpack_require__('irzI')
            } else {
                module.exports = __webpack_require__('ckmc')
            }

            /***/
        },

        /***/ kTiW: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('NegM')

            /***/
        },

        /***/ kZLX: /***/ function(module, exports, __webpack_require__) {
            const { createHash } = __webpack_require__('PJMN')
            const ecdhComputeSecret = __webpack_require__('RFts')

            const concat = (key, length, value) => {
                const iterations = Math.ceil(length / 32)
                let res

                for (let iter = 1; iter <= iterations; iter++) {
                    const buf = Buffer.allocUnsafe(
                        4 + key.length + value.length
                    )
                    buf.writeUInt32BE(iter, 0)
                    key.copy(buf, 4)
                    value.copy(buf, 4 + key.length)
                    if (!res) {
                        res = createHash('sha256')
                            .update(buf)
                            .digest()
                    } else {
                        res = Buffer.concat([
                            res,
                            createHash('sha256')
                                .update(buf)
                                .digest()
                        ])
                    }
                }

                return res.slice(0, length)
            }

            const uint32be = (value, buf = Buffer.allocUnsafe(4)) => {
                buf.writeUInt32BE(value)
                return buf
            }

            const lengthAndInput = input =>
                Buffer.concat([uint32be(input.length), input])

            module.exports = (
                alg,
                keyLen,
                privKey,
                pubKey,
                { apu = Buffer.alloc(0), apv = Buffer.alloc(0) } = {},
                computeSecret = ecdhComputeSecret
            ) => {
                const value = Buffer.concat([
                    lengthAndInput(Buffer.from(alg)),
                    lengthAndInput(apu),
                    lengthAndInput(apv),
                    uint32be(keyLen)
                ])

                const sharedSecret = computeSecret(privKey, pubKey)
                return concat(sharedSecret, keyLen / 8, value)
            }

            /***/
        },

        /***/ kekF: /***/ function(module, exports) {
            /**
             * Creates a unary function that invokes `func` with its argument transformed.
             *
             * @private
             * @param {Function} func The function to wrap.
             * @param {Function} transform The argument transform.
             * @returns {Function} Returns the new function.
             */
            function overArg(func, transform) {
                return function(arg) {
                    return func(transform(arg))
                }
            }

            module.exports = overArg

            /***/
        },

        /***/ kjw5: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { PassThrough } = __webpack_require__('msIP')
            const duplexer3 = __webpack_require__('U064')
            const requestAsEventEmitter = __webpack_require__('y/nk')
            const { HTTPError, ReadError } = __webpack_require__('9Fi5')

            module.exports = options => {
                const input = new PassThrough()
                const output = new PassThrough()
                const proxy = duplexer3(input, output)
                const piped = new Set()
                let isFinished = false

                options.retry.retries = () => 0

                if (options.body) {
                    proxy.write = () => {
                        throw new Error(
                            "Got's stream is not writable when the `body` option is used"
                        )
                    }
                }

                const emitter = requestAsEventEmitter(options, input)

                // Cancels the request
                proxy._destroy = emitter.abort

                emitter.on('response', response => {
                    const { statusCode } = response

                    response.on('error', error => {
                        proxy.emit('error', new ReadError(error, options))
                    })

                    if (
                        options.throwHttpErrors &&
                        statusCode !== 304 &&
                        (statusCode < 200 || statusCode > 299)
                    ) {
                        proxy.emit(
                            'error',
                            new HTTPError(response, options),
                            null,
                            response
                        )
                        return
                    }

                    isFinished = true

                    response.pipe(output)

                    for (const destination of piped) {
                        if (destination.headersSent) {
                            continue
                        }

                        for (const [key, value] of Object.entries(
                            response.headers
                        )) {
                            // Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.
                            // It's not possible to decompress already decompressed data, is it?
                            const allowed = options.decompress
                                ? key !== 'content-encoding'
                                : true
                            if (allowed) {
                                destination.setHeader(key, value)
                            }
                        }

                        destination.statusCode = response.statusCode
                    }

                    proxy.emit('response', response)
                })

                ;[
                    'error',
                    'request',
                    'redirect',
                    'uploadProgress',
                    'downloadProgress'
                ].forEach(event =>
                    emitter.on(event, (...args) => proxy.emit(event, ...args))
                )

                const pipe = proxy.pipe.bind(proxy)
                const unpipe = proxy.unpipe.bind(proxy)
                proxy.pipe = (destination, options) => {
                    if (isFinished) {
                        throw new Error(
                            'Failed to pipe. The response has been emitted already.'
                        )
                    }

                    const result = pipe(destination, options)

                    if (Reflect.has(destination, 'setHeader')) {
                        piped.add(destination)
                    }

                    return result
                }

                proxy.unpipe = stream => {
                    piped.delete(stream)
                    return unpipe(stream)
                }

                return proxy
            }

            /***/
        },

        /***/ kl4A: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function() {}

            /***/
        },

        /***/ kuaU: /***/ function(module, exports, __webpack_require__) {
            const { timingSafeEqual: TSE } = __webpack_require__('PJMN')

            const paddedBuffer = (input, length) => {
                if (input.length === length) {
                    return input
                }

                const buffer = Buffer.alloc(length)
                input.copy(buffer)
                return buffer
            }

            const timingSafeEqual = (a, b) => {
                const length = Math.max(a.length, b.length)
                return TSE(paddedBuffer(a, length), paddedBuffer(b, length))
            }

            module.exports = timingSafeEqual

            /***/
        },

        /***/ kwZ1: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // 19.1.2.1 Object.assign(target, source, ...)
            var DESCRIPTORS = __webpack_require__('jmDH')
            var getKeys = __webpack_require__('w6GO')
            var gOPS = __webpack_require__('mqlF')
            var pIE = __webpack_require__('NV0k')
            var toObject = __webpack_require__('JB68')
            var IObject = __webpack_require__('M1xp')
            var $assign = Object.assign

            // should work with symbols and should have deterministic property order (V8 bug)
            module.exports =
                !$assign ||
                __webpack_require__('KUxP')(function() {
                    var A = {}
                    var B = {}
                    // eslint-disable-next-line no-undef
                    var S = Symbol()
                    var K = 'abcdefghijklmnopqrst'
                    A[S] = 7
                    K.split('').forEach(function(k) {
                        B[k] = k
                    })
                    return (
                        $assign({}, A)[S] != 7 ||
                        Object.keys($assign({}, B)).join('') != K
                    )
                })
                    ? function assign(target, source) {
                          // eslint-disable-line no-unused-vars
                          var T = toObject(target)
                          var aLen = arguments.length
                          var index = 1
                          var getSymbols = gOPS.f
                          var isEnum = pIE.f
                          while (aLen > index) {
                              var S = IObject(arguments[index++])
                              var keys = getSymbols
                                  ? getKeys(S).concat(getSymbols(S))
                                  : getKeys(S)
                              var length = keys.length
                              var j = 0
                              var key
                              while (length > j) {
                                  key = keys[j++]
                                  if (!DESCRIPTORS || isEnum.call(S, key))
                                      T[key] = S[key]
                              }
                          }
                          return T
                      }
                    : $assign

            /***/
        },

        /***/ l3Iq: /***/ function(module, exports, __webpack_require__) {
            const base64url = __webpack_require__('Xab3')
            const isDisjoint = __webpack_require__('KQbz')
            const isObject = __webpack_require__('kF1/')
            const deepClone = __webpack_require__('O9d4')
            const { JWSInvalid } = __webpack_require__('yt7c')
            const { sign } = __webpack_require__('FUB/')
            const getKey = __webpack_require__('oGTz')

            const serializers = __webpack_require__('SwXk')

            const PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT')

            class Sign {
                constructor(payload) {
                    if (typeof payload === 'string') {
                        payload = base64url.encode(payload)
                    } else if (Buffer.isBuffer(payload)) {
                        payload = base64url.encodeBuffer(payload)
                        this._binary = true
                    } else if (isObject(payload)) {
                        payload = base64url.JSON.encode(payload)
                    } else {
                        throw new TypeError(
                            'payload argument must be a Buffer, string or an object'
                        )
                    }

                    this._payload = payload
                    this._recipients = []
                }

                /*
                 * @public
                 */
                recipient(key, protectedHeader, unprotectedHeader) {
                    key = getKey(key)

                    if (
                        protectedHeader !== undefined &&
                        !isObject(protectedHeader)
                    ) {
                        throw new TypeError(
                            'protectedHeader argument must be a plain object when provided'
                        )
                    }

                    if (
                        unprotectedHeader !== undefined &&
                        !isObject(unprotectedHeader)
                    ) {
                        throw new TypeError(
                            'unprotectedHeader argument must be a plain object when provided'
                        )
                    }

                    if (!isDisjoint(protectedHeader, unprotectedHeader)) {
                        throw new JWSInvalid(
                            'JWS Protected and JWS Unprotected Header Parameter names must be disjoint'
                        )
                    }

                    this._recipients.push({
                        key,
                        protectedHeader: protectedHeader
                            ? deepClone(protectedHeader)
                            : undefined,
                        unprotectedHeader: unprotectedHeader
                            ? deepClone(unprotectedHeader)
                            : undefined
                    })

                    return this
                }

                /*
                 * @private
                 */
                [PROCESS_RECIPIENT](recipient) {
                    const {
                        key,
                        protectedHeader,
                        unprotectedHeader
                    } = recipient

                    if (key.use === 'enc') {
                        throw new TypeError(
                            'a key with "use":"enc" is not usable for signing'
                        )
                    }

                    const joseHeader = {
                        protected: protectedHeader || {},
                        unprotected: unprotectedHeader || {}
                    }

                    let alg =
                        joseHeader.protected.alg || joseHeader.unprotected.alg

                    if (!alg) {
                        alg = key.alg || [...key.algorithms('sign')][0]
                        if (recipient.protectedHeader) {
                            joseHeader.protected.alg = recipient.protectedHeader.alg = alg
                        } else {
                            joseHeader.protected = recipient.protectedHeader = {
                                alg
                            }
                        }
                    }

                    if (!alg) {
                        throw new JWSInvalid(
                            'could not resolve a usable "alg" for a recipient'
                        )
                    }

                    recipient.header = unprotectedHeader
                    recipient.protected = Object.keys(joseHeader.protected)
                        .length
                        ? base64url.JSON.encode(joseHeader.protected)
                        : ''

                    let toBeSigned
                    if (
                        joseHeader.protected.crit &&
                        joseHeader.protected.crit.includes('b64')
                    ) {
                        if (
                            this._b64 !== undefined &&
                            this._b64 !== joseHeader.protected.b64
                        ) {
                            throw new JWSInvalid(
                                'the "b64" Header Parameter value MUST be the same for all recipients'
                            )
                        } else {
                            this._b64 = joseHeader.protected.b64
                        }

                        if (!joseHeader.protected.b64) {
                            if (this._binary) {
                                this._payload = base64url.decodeToBuffer(
                                    this._payload
                                )
                            } else {
                                this._payload = base64url.decode(this._payload)
                            }
                        }

                        toBeSigned = Buffer.concat([
                            Buffer.from(recipient.protected || ''),
                            Buffer.from('.'),
                            Buffer.isBuffer(this._payload)
                                ? this._payload
                                : Buffer.from(this._payload)
                        ])
                    } else {
                        toBeSigned = `${recipient.protected || ''}.${
                            this._payload
                        }`
                    }

                    recipient.signature = base64url.encodeBuffer(
                        sign(alg, key, toBeSigned)
                    )
                }

                /*
                 * @public
                 */
                sign(serialization) {
                    const serializer = serializers[serialization]
                    if (!serializer) {
                        throw new TypeError(
                            'serialization must be one of "compact", "flattened", "general"'
                        )
                    }

                    if (!this._recipients.length) {
                        throw new JWSInvalid('missing recipients')
                    }

                    serializer.validate(this, this._recipients)

                    for (const recipient of this._recipients) {
                        this[PROCESS_RECIPIENT](recipient)
                    }

                    return serializer(this._payload, this._recipients)
                }
            }

            module.exports = Sign

            /***/
        },

        /***/ lA9T: /***/ function(module, exports, __webpack_require__) {
            const Key = __webpack_require__('//Cd')
            const None = __webpack_require__('qSBP')
            const importKey = __webpack_require__('GhER')
            const generate = __webpack_require__('LDEB')

            module.exports = {
                ...generate,
                asKey: importKey,
                isKey: input => input instanceof Key,
                None
            }

            /* deprecated */
            Object.defineProperty(module.exports, 'importKey', {
                value: importKey.deprecated,
                enumerable: false
            })

            /***/
        },

        /***/ lCc8: /***/ function(module, exports, __webpack_require__) {
            var $export = __webpack_require__('Y7ZC')
            // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
            $export($export.S, 'Object', {
                create: __webpack_require__('oVml')
            })

            /***/
        },

        /***/ lERV: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // rfc7231 6.1
            const statusCodeCacheableByDefault = [
                200,
                203,
                204,
                206,
                300,
                301,
                404,
                405,
                410,
                414,
                501
            ]

            // This implementation does not understand partial responses (206)
            const understoodStatuses = [
                200,
                203,
                204,
                300,
                301,
                302,
                303,
                307,
                308,
                404,
                405,
                410,
                414,
                501
            ]

            const hopByHopHeaders = {
                date: true, // included, because we add Age update Date
                connection: true,
                'keep-alive': true,
                'proxy-authenticate': true,
                'proxy-authorization': true,
                te: true,
                trailer: true,
                'transfer-encoding': true,
                upgrade: true
            }
            const excludedFromRevalidationUpdate = {
                // Since the old body is reused, it doesn't make sense to change properties of the body
                'content-length': true,
                'content-encoding': true,
                'transfer-encoding': true,
                'content-range': true
            }

            function parseCacheControl(header) {
                const cc = {}
                if (!header) return cc

                // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),
                // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale
                const parts = header.trim().split(/\s*,\s*/) // TODO: lame parsing
                for (const part of parts) {
                    const [k, v] = part.split(/\s*=\s*/, 2)
                    cc[k] = v === undefined ? true : v.replace(/^"|"$/g, '') // TODO: lame unquoting
                }

                return cc
            }

            function formatCacheControl(cc) {
                let parts = []
                for (const k in cc) {
                    const v = cc[k]
                    parts.push(v === true ? k : k + '=' + v)
                }
                if (!parts.length) {
                    return undefined
                }
                return parts.join(', ')
            }

            module.exports = class CachePolicy {
                constructor(
                    req,
                    res,
                    {
                        shared,
                        cacheHeuristic,
                        immutableMinTimeToLive,
                        ignoreCargoCult,
                        trustServerDate,
                        _fromObject
                    } = {}
                ) {
                    if (_fromObject) {
                        this._fromObject(_fromObject)
                        return
                    }

                    if (!res || !res.headers) {
                        throw Error('Response headers missing')
                    }
                    this._assertRequestHasHeaders(req)

                    this._responseTime = this.now()
                    this._isShared = shared !== false
                    this._trustServerDate =
                        undefined !== trustServerDate ? trustServerDate : true
                    this._cacheHeuristic =
                        undefined !== cacheHeuristic ? cacheHeuristic : 0.1 // 10% matches IE
                    this._immutableMinTtl =
                        undefined !== immutableMinTimeToLive
                            ? immutableMinTimeToLive
                            : 24 * 3600 * 1000

                    this._status = 'status' in res ? res.status : 200
                    this._resHeaders = res.headers
                    this._rescc = parseCacheControl(
                        res.headers['cache-control']
                    )
                    this._method = 'method' in req ? req.method : 'GET'
                    this._url = req.url
                    this._host = req.headers.host
                    this._noAuthorization = !req.headers.authorization
                    this._reqHeaders = res.headers.vary ? req.headers : null // Don't keep all request headers if they won't be used
                    this._reqcc = parseCacheControl(
                        req.headers['cache-control']
                    )

                    // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,
                    // so there's no point stricly adhering to the blindly copy&pasted directives.
                    if (
                        ignoreCargoCult &&
                        'pre-check' in this._rescc &&
                        'post-check' in this._rescc
                    ) {
                        delete this._rescc['pre-check']
                        delete this._rescc['post-check']
                        delete this._rescc['no-cache']
                        delete this._rescc['no-store']
                        delete this._rescc['must-revalidate']
                        this._resHeaders = Object.assign({}, this._resHeaders, {
                            'cache-control': formatCacheControl(this._rescc)
                        })
                        delete this._resHeaders.expires
                        delete this._resHeaders.pragma
                    }

                    // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive
                    // as having the same effect as if "Cache-Control: no-cache" were present (see Section 5.2.1).
                    if (
                        res.headers['cache-control'] == null &&
                        /no-cache/.test(res.headers.pragma)
                    ) {
                        this._rescc['no-cache'] = true
                    }
                }

                now() {
                    return Date.now()
                }

                storable() {
                    // The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.
                    return !!(
                        !this._reqcc['no-store'] &&
                        // A cache MUST NOT store a response to any request, unless:
                        // The request method is understood by the cache and defined as being cacheable, and
                        ('GET' === this._method ||
                            'HEAD' === this._method ||
                            ('POST' === this._method &&
                                this._hasExplicitExpiration())) &&
                        // the response status code is understood by the cache, and
                        understoodStatuses.indexOf(this._status) !== -1 &&
                        // the "no-store" cache directive does not appear in request or response header fields, and
                        !this._rescc['no-store'] &&
                        // the "private" response directive does not appear in the response, if the cache is shared, and
                        (!this._isShared || !this._rescc.private) &&
                        // the Authorization header field does not appear in the request, if the cache is shared,
                        (!this._isShared ||
                            this._noAuthorization ||
                            this._allowsStoringAuthenticated()) &&
                        // the response either:
                        // contains an Expires header field, or
                        (this._resHeaders.expires ||
                            // contains a max-age response directive, or
                            // contains a s-maxage response directive and the cache is shared, or
                            // contains a public response directive.
                            this._rescc['max-age'] ||
                            (this._isShared && this._rescc['s-maxage']) ||
                            this._rescc.public ||
                            // has a status code that is defined as cacheable by default
                            statusCodeCacheableByDefault.indexOf(
                                this._status
                            ) !== -1)
                    )
                }

                _hasExplicitExpiration() {
                    // 4.2.1 Calculating Freshness Lifetime
                    return (
                        (this._isShared && this._rescc['s-maxage']) ||
                        this._rescc['max-age'] ||
                        this._resHeaders.expires
                    )
                }

                _assertRequestHasHeaders(req) {
                    if (!req || !req.headers) {
                        throw Error('Request headers missing')
                    }
                }

                satisfiesWithoutRevalidation(req) {
                    this._assertRequestHasHeaders(req)

                    // When presented with a request, a cache MUST NOT reuse a stored response, unless:
                    // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,
                    // unless the stored response is successfully validated (Section 4.3), and
                    const requestCC = parseCacheControl(
                        req.headers['cache-control']
                    )
                    if (
                        requestCC['no-cache'] ||
                        /no-cache/.test(req.headers.pragma)
                    ) {
                        return false
                    }

                    if (
                        requestCC['max-age'] &&
                        this.age() > requestCC['max-age']
                    ) {
                        return false
                    }

                    if (
                        requestCC['min-fresh'] &&
                        this.timeToLive() < 1000 * requestCC['min-fresh']
                    ) {
                        return false
                    }

                    // the stored response is either:
                    // fresh, or allowed to be served stale
                    if (this.stale()) {
                        const allowsStale =
                            requestCC['max-stale'] &&
                            !this._rescc['must-revalidate'] &&
                            (true === requestCC['max-stale'] ||
                                requestCC['max-stale'] >
                                    this.age() - this.maxAge())
                        if (!allowsStale) {
                            return false
                        }
                    }

                    return this._requestMatches(req, false)
                }

                _requestMatches(req, allowHeadMethod) {
                    // The presented effective request URI and that of the stored response match, and
                    return (
                        (!this._url || this._url === req.url) &&
                        this._host === req.headers.host &&
                        // the request method associated with the stored response allows it to be used for the presented request, and
                        (!req.method ||
                            this._method === req.method ||
                            (allowHeadMethod && 'HEAD' === req.method)) &&
                        // selecting header fields nominated by the stored response (if any) match those presented, and
                        this._varyMatches(req)
                    )
                }

                _allowsStoringAuthenticated() {
                    //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.
                    return (
                        this._rescc['must-revalidate'] ||
                        this._rescc.public ||
                        this._rescc['s-maxage']
                    )
                }

                _varyMatches(req) {
                    if (!this._resHeaders.vary) {
                        return true
                    }

                    // A Vary header field-value of "*" always fails to match
                    if (this._resHeaders.vary === '*') {
                        return false
                    }

                    const fields = this._resHeaders.vary
                        .trim()
                        .toLowerCase()
                        .split(/\s*,\s*/)
                    for (const name of fields) {
                        if (req.headers[name] !== this._reqHeaders[name])
                            return false
                    }
                    return true
                }

                _copyWithoutHopByHopHeaders(inHeaders) {
                    const headers = {}
                    for (const name in inHeaders) {
                        if (hopByHopHeaders[name]) continue
                        headers[name] = inHeaders[name]
                    }
                    // 9.1.  Connection
                    if (inHeaders.connection) {
                        const tokens = inHeaders.connection
                            .trim()
                            .split(/\s*,\s*/)
                        for (const name of tokens) {
                            delete headers[name]
                        }
                    }
                    if (headers.warning) {
                        const warnings = headers.warning
                            .split(/,/)
                            .filter(warning => {
                                return !/^\s*1[0-9][0-9]/.test(warning)
                            })
                        if (!warnings.length) {
                            delete headers.warning
                        } else {
                            headers.warning = warnings.join(',').trim()
                        }
                    }
                    return headers
                }

                responseHeaders() {
                    const headers = this._copyWithoutHopByHopHeaders(
                        this._resHeaders
                    )
                    const age = this.age()

                    // A cache SHOULD generate 113 warning if it heuristically chose a freshness
                    // lifetime greater than 24 hours and the response's age is greater than 24 hours.
                    if (
                        age > 3600 * 24 &&
                        !this._hasExplicitExpiration() &&
                        this.maxAge() > 3600 * 24
                    ) {
                        headers.warning =
                            (headers.warning ? `${headers.warning}, ` : '') +
                            '113 - "rfc7234 5.5.4"'
                    }
                    headers.age = `${Math.round(age)}`
                    headers.date = new Date(this.now()).toUTCString()
                    return headers
                }

                /**
                 * Value of the Date response header or current time if Date was demed invalid
                 * @return timestamp
                 */
                date() {
                    if (this._trustServerDate) {
                        return this._serverDate()
                    }
                    return this._responseTime
                }

                _serverDate() {
                    const serverDate = Date.parse(this._resHeaders.date)
                    if (isFinite(serverDate)) {
                        const maxClockDrift = 8 * 3600 * 1000
                        const clockDrift = Math.abs(
                            this._responseTime - serverDate
                        )
                        if (clockDrift < maxClockDrift) {
                            return serverDate
                        }
                    }
                    return this._responseTime
                }

                /**
                 * Value of the Age header, in seconds, updated for the current time.
                 * May be fractional.
                 *
                 * @return Number
                 */
                age() {
                    let age = Math.max(
                        0,
                        (this._responseTime - this.date()) / 1000
                    )
                    if (this._resHeaders.age) {
                        let ageValue = this._ageValue()
                        if (ageValue > age) age = ageValue
                    }

                    const residentTime =
                        (this.now() - this._responseTime) / 1000
                    return age + residentTime
                }

                _ageValue() {
                    const ageValue = parseInt(this._resHeaders.age)
                    return isFinite(ageValue) ? ageValue : 0
                }

                /**
                 * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
                 *
                 * For an up-to-date value, see `timeToLive()`.
                 *
                 * @return Number
                 */
                maxAge() {
                    if (!this.storable() || this._rescc['no-cache']) {
                        return 0
                    }

                    // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default
                    // so this implementation requires explicit opt-in via public header
                    if (
                        this._isShared &&
                        this._resHeaders['set-cookie'] &&
                            !this._rescc.public &&
                            !this._rescc.immutable
                    ) {
                        return 0
                    }

                    if (this._resHeaders.vary === '*') {
                        return 0
                    }

                    if (this._isShared) {
                        if (this._rescc['proxy-revalidate']) {
                            return 0
                        }
                        // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.
                        if (this._rescc['s-maxage']) {
                            return parseInt(this._rescc['s-maxage'], 10)
                        }
                    }

                    // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.
                    if (this._rescc['max-age']) {
                        return parseInt(this._rescc['max-age'], 10)
                    }

                    const defaultMinTtl = this._rescc.immutable
                        ? this._immutableMinTtl
                        : 0

                    const serverDate = this._serverDate()
                    if (this._resHeaders.expires) {
                        const expires = Date.parse(this._resHeaders.expires)
                        // A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
                        if (Number.isNaN(expires) || expires < serverDate) {
                            return 0
                        }
                        return Math.max(
                            defaultMinTtl,
                            (expires - serverDate) / 1000
                        )
                    }

                    if (this._resHeaders['last-modified']) {
                        const lastModified = Date.parse(
                            this._resHeaders['last-modified']
                        )
                        if (
                            isFinite(lastModified) &&
                            serverDate > lastModified
                        ) {
                            return Math.max(
                                defaultMinTtl,
                                ((serverDate - lastModified) / 1000) *
                                    this._cacheHeuristic
                            )
                        }
                    }

                    return defaultMinTtl
                }

                timeToLive() {
                    return Math.max(0, this.maxAge() - this.age()) * 1000
                }

                stale() {
                    return this.maxAge() <= this.age()
                }

                static fromObject(obj) {
                    return new this(undefined, undefined, { _fromObject: obj })
                }

                _fromObject(obj) {
                    if (this._responseTime) throw Error('Reinitialized')
                    if (!obj || obj.v !== 1)
                        throw Error('Invalid serialization')

                    this._responseTime = obj.t
                    this._isShared = obj.sh
                    this._cacheHeuristic = obj.ch
                    this._immutableMinTtl =
                        obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000
                    this._status = obj.st
                    this._resHeaders = obj.resh
                    this._rescc = obj.rescc
                    this._method = obj.m
                    this._url = obj.u
                    this._host = obj.h
                    this._noAuthorization = obj.a
                    this._reqHeaders = obj.reqh
                    this._reqcc = obj.reqcc
                }

                toObject() {
                    return {
                        v: 1,
                        t: this._responseTime,
                        sh: this._isShared,
                        ch: this._cacheHeuristic,
                        imm: this._immutableMinTtl,
                        st: this._status,
                        resh: this._resHeaders,
                        rescc: this._rescc,
                        m: this._method,
                        u: this._url,
                        h: this._host,
                        a: this._noAuthorization,
                        reqh: this._reqHeaders,
                        reqcc: this._reqcc
                    }
                }

                /**
                 * Headers for sending to the origin server to revalidate stale response.
                 * Allows server to return 304 to allow reuse of the previous response.
                 *
                 * Hop by hop headers are always stripped.
                 * Revalidation headers may be added or removed, depending on request.
                 */
                revalidationHeaders(incomingReq) {
                    this._assertRequestHasHeaders(incomingReq)
                    const headers = this._copyWithoutHopByHopHeaders(
                        incomingReq.headers
                    )

                    // This implementation does not understand range requests
                    delete headers['if-range']

                    if (
                        !this._requestMatches(incomingReq, true) ||
                        !this.storable()
                    ) {
                        // revalidation allowed via HEAD
                        // not for the same resource, or wasn't allowed to be cached anyway
                        delete headers['if-none-match']
                        delete headers['if-modified-since']
                        return headers
                    }

                    /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */
                    if (this._resHeaders.etag) {
                        headers['if-none-match'] = headers['if-none-match']
                            ? `${headers['if-none-match']}, ${this._resHeaders.etag}`
                            : this._resHeaders.etag
                    }

                    // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.
                    const forbidsWeakValidators =
                        headers['accept-ranges'] ||
                        headers['if-match'] ||
                        headers['if-unmodified-since'] ||
                        (this._method && this._method != 'GET')

                    /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
        Note: This implementation does not understand partial responses (206) */
                    if (forbidsWeakValidators) {
                        delete headers['if-modified-since']

                        if (headers['if-none-match']) {
                            const etags = headers['if-none-match']
                                .split(/,/)
                                .filter(etag => {
                                    return !/^\s*W\//.test(etag)
                                })
                            if (!etags.length) {
                                delete headers['if-none-match']
                            } else {
                                headers['if-none-match'] = etags
                                    .join(',')
                                    .trim()
                            }
                        }
                    } else if (
                        this._resHeaders['last-modified'] &&
                        !headers['if-modified-since']
                    ) {
                        headers['if-modified-since'] = this._resHeaders[
                            'last-modified'
                        ]
                    }

                    return headers
                }

                /**
                 * Creates new CachePolicy with information combined from the previews response,
                 * and the new revalidation response.
                 *
                 * Returns {policy, modified} where modified is a boolean indicating
                 * whether the response body has been modified, and old cached body can't be used.
                 *
                 * @return {Object} {policy: CachePolicy, modified: Boolean}
                 */
                revalidatedPolicy(request, response) {
                    this._assertRequestHasHeaders(request)
                    if (!response || !response.headers) {
                        throw Error('Response headers missing')
                    }

                    // These aren't going to be supported exactly, since one CachePolicy object
                    // doesn't know about all the other cached objects.
                    let matches = false
                    if (
                        response.status !== undefined &&
                        response.status != 304
                    ) {
                        matches = false
                    } else if (
                        response.headers.etag &&
                        !/^\s*W\//.test(response.headers.etag)
                    ) {
                        // "All of the stored responses with the same strong validator are selected.
                        // If none of the stored responses contain the same strong validator,
                        // then the cache MUST NOT use the new response to update any stored responses."
                        matches =
                            this._resHeaders.etag &&
                            this._resHeaders.etag.replace(/^\s*W\//, '') ===
                                response.headers.etag
                    } else if (this._resHeaders.etag && response.headers.etag) {
                        // "If the new response contains a weak validator and that validator corresponds
                        // to one of the cache's stored responses,
                        // then the most recent of those matching stored responses is selected for update."
                        matches =
                            this._resHeaders.etag.replace(/^\s*W\//, '') ===
                            response.headers.etag.replace(/^\s*W\//, '')
                    } else if (this._resHeaders['last-modified']) {
                        matches =
                            this._resHeaders['last-modified'] ===
                            response.headers['last-modified']
                    } else {
                        // If the new response does not include any form of validator (such as in the case where
                        // a client generates an If-Modified-Since request from a source other than the Last-Modified
                        // response header field), and there is only one stored response, and that stored response also
                        // lacks a validator, then that stored response is selected for update.
                        if (
                            !this._resHeaders.etag &&
                            !this._resHeaders['last-modified'] &&
                            !response.headers.etag &&
                            !response.headers['last-modified']
                        ) {
                            matches = true
                        }
                    }

                    if (!matches) {
                        return {
                            policy: new this.constructor(request, response),
                            // Client receiving 304 without body, even if it's invalid/mismatched has no option
                            // but to reuse a cached body. We don't have a good way to tell clients to do
                            // error recovery in such case.
                            modified: response.status != 304,
                            matches: false
                        }
                    }

                    // use other header fields provided in the 304 (Not Modified) response to replace all instances
                    // of the corresponding header fields in the stored response.
                    const headers = {}
                    for (const k in this._resHeaders) {
                        headers[k] =
                            k in response.headers &&
                            !excludedFromRevalidationUpdate[k]
                                ? response.headers[k]
                                : this._resHeaders[k]
                    }

                    const newResponse = Object.assign({}, response, {
                        status: this._status,
                        method: this._method,
                        headers
                    })
                    return {
                        policy: new this.constructor(request, newResponse, {
                            shared: this._isShared,
                            cacheHeuristic: this._cacheHeuristic,
                            immutableMinTimeToLive: this._immutableMinTtl,
                            trustServerDate: this._trustServerDate
                        }),
                        modified: false,
                        matches: true
                    }
                }
            }

            /***/
        },

        /***/ lN8I: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const pSome = __webpack_require__('htIY')
            const PCancelable = __webpack_require__('ijcl')

            const pAny = (iterable, options) => {
                const anyCancelable = pSome(iterable, { ...options, count: 1 })

                return PCancelable.fn(async onCancel => {
                    onCancel(() => {
                        anyCancelable.cancel()
                    })

                    const [value] = await anyCancelable
                    return value
                })()
            }

            module.exports = pAny
            // TODO: Remove this for the next major release
            module.exports.default = pAny

            module.exports.AggregateError = pSome.AggregateError

            /***/
        },

        /***/ lSCD: /***/ function(module, exports, __webpack_require__) {
            var baseGetTag = __webpack_require__('NykK'),
                isObject = __webpack_require__('GoyQ')

            /** `Object#toString` result references. */
            var asyncTag = '[object AsyncFunction]',
                funcTag = '[object Function]',
                genTag = '[object GeneratorFunction]',
                proxyTag = '[object Proxy]'

            /**
             * Checks if `value` is classified as a `Function` object.
             *
             * @static
             * @memberOf _
             * @since 0.1.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a function, else `false`.
             * @example
             *
             * _.isFunction(_);
             * // => true
             *
             * _.isFunction(/abc/);
             * // => false
             */
            function isFunction(value) {
                if (!isObject(value)) {
                    return false
                }
                // The use of `Object#toString` avoids issues with the `typeof` operator
                // in Safari 9 which returns 'object' for typed arrays and other constructors.
                var tag = baseGetTag(value)
                return (
                    tag == funcTag ||
                    tag == genTag ||
                    tag == asyncTag ||
                    tag == proxyTag
                )
            }

            module.exports = isFunction

            /***/
        },

        /***/ la6v: /***/ function(module, exports, __webpack_require__) {
            var baseRest = __webpack_require__('EA7m'),
                eq = __webpack_require__('ljhN'),
                isIterateeCall = __webpack_require__('mv/X'),
                keysIn = __webpack_require__('mTTR')

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Assigns own and inherited enumerable string keyed properties of source
             * objects to the destination object for all destination properties that
             * resolve to `undefined`. Source objects are applied from left to right.
             * Once a property is set, additional values of the same property are ignored.
             *
             * **Note:** This method mutates `object`.
             *
             * @static
             * @since 0.1.0
             * @memberOf _
             * @category Object
             * @param {Object} object The destination object.
             * @param {...Object} [sources] The source objects.
             * @returns {Object} Returns `object`.
             * @see _.defaultsDeep
             * @example
             *
             * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
             * // => { 'a': 1, 'b': 2 }
             */
            var defaults = baseRest(function(object, sources) {
                object = Object(object)

                var index = -1
                var length = sources.length
                var guard = length > 2 ? sources[2] : undefined

                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    length = 1
                }

                while (++index < length) {
                    var source = sources[index]
                    var props = keysIn(source)
                    var propsIndex = -1
                    var propsLength = props.length

                    while (++propsIndex < propsLength) {
                        var key = props[propsIndex]
                        var value = object[key]

                        if (
                            value === undefined ||
                            (eq(value, objectProto[key]) &&
                                !hasOwnProperty.call(object, key))
                        ) {
                            object[key] = source[key]
                        }
                    }
                }

                return object
            })

            module.exports = defaults

            /***/
        },

        /***/ ljhN: /***/ function(module, exports) {
            /**
             * Performs a
             * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
             * comparison between two values to determine if they are equivalent.
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to compare.
             * @param {*} other The other value to compare.
             * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
             * @example
             *
             * var object = { 'a': 1 };
             * var other = { 'a': 1 };
             *
             * _.eq(object, object);
             * // => true
             *
             * _.eq(object, other);
             * // => false
             *
             * _.eq('a', 'a');
             * // => true
             *
             * _.eq('a', Object('a'));
             * // => false
             *
             * _.eq(NaN, NaN);
             * // => true
             */
            function eq(value, other) {
                return value === other || (value !== value && other !== other)
            }

            module.exports = eq

            /***/
        },

        /***/ 'lm/5': /***/ function(module, exports, __webpack_require__) {
            var Stack = __webpack_require__('fmRc'),
                baseIsEqual = __webpack_require__('wF/u')

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1,
                COMPARE_UNORDERED_FLAG = 2

            /**
             * The base implementation of `_.isMatch` without support for iteratee shorthands.
             *
             * @private
             * @param {Object} object The object to inspect.
             * @param {Object} source The object of property values to match.
             * @param {Array} matchData The property names, values, and compare flags to match.
             * @param {Function} [customizer] The function to customize comparisons.
             * @returns {boolean} Returns `true` if `object` is a match, else `false`.
             */
            function baseIsMatch(object, source, matchData, customizer) {
                var index = matchData.length,
                    length = index,
                    noCustomizer = !customizer

                if (object == null) {
                    return !length
                }
                object = Object(object)
                while (index--) {
                    var data = matchData[index]
                    if (
                        noCustomizer && data[2]
                            ? data[1] !== object[data[0]]
                            : !(data[0] in object)
                    ) {
                        return false
                    }
                }
                while (++index < length) {
                    data = matchData[index]
                    var key = data[0],
                        objValue = object[key],
                        srcValue = data[1]

                    if (noCustomizer && data[2]) {
                        if (objValue === undefined && !(key in object)) {
                            return false
                        }
                    } else {
                        var stack = new Stack()
                        if (customizer) {
                            var result = customizer(
                                objValue,
                                srcValue,
                                key,
                                object,
                                source,
                                stack
                            )
                        }
                        if (
                            !(result === undefined
                                ? baseIsEqual(
                                      srcValue,
                                      objValue,
                                      COMPARE_PARTIAL_FLAG |
                                          COMPARE_UNORDERED_FLAG,
                                      customizer,
                                      stack
                                  )
                                : result)
                        ) {
                            return false
                        }
                    }
                }
                return true
            }

            module.exports = baseIsMatch

            /***/
        },

        /***/ lwAK: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$defineProperty = __webpack_require__('hfKm')

            var __importStar =
                (this && this.__importStar) ||
                function(mod) {
                    if (mod && mod.__esModule) return mod
                    var result = {}
                    if (mod != null)
                        for (var k in mod)
                            if (Object.hasOwnProperty.call(mod, k))
                                result[k] = mod[k]
                    result['default'] = mod
                    return result
                }

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            const React = __importStar(__webpack_require__('q1tI'))

            exports.AmpStateContext = React.createContext({})

            /***/
        },

        /***/ m2VO: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const cookies_1 = __webpack_require__('gKi1')
            function createLogoutUrl(settings) {
                return (
                    `https://${settings.domain}/v2/logout?` +
                    `client_id=${settings.clientId}` +
                    `&returnTo=${encodeURIComponent(
                        settings.postLogoutRedirectUri
                    )}`
                )
            }
            function logoutHandler(settings, sessionSettings) {
                return (req, res) =>
                    tslib_1.__awaiter(this, void 0, void 0, function*() {
                        if (!res) {
                            throw new Error('Response is not available')
                        }
                        // Remove the cookies
                        cookies_1.setCookies(req, res, [
                            {
                                name: 'a0:state',
                                value: '',
                                maxAge: -1
                            },
                            {
                                name: sessionSettings.cookieName,
                                value: '',
                                maxAge: -1,
                                path: sessionSettings.cookiePath
                            }
                        ])
                        // Redirect to the logout endpoint.
                        res.writeHead(302, {
                            Location: createLogoutUrl(settings)
                        })
                        res.end()
                    })
            }
            exports.default = logoutHandler
            //# sourceMappingURL=logout.js.map

            /***/
        },

        /***/ m5qO: /***/ function(module, exports, __webpack_require__) {
            __webpack_require__('wgeU')
            __webpack_require__('bBy9')
            __webpack_require__('Oc8Q')
            __webpack_require__('BURE')
            __webpack_require__('+jru')
            module.exports = __webpack_require__('WEpk').WeakMap

            /***/
        },

        /***/ mRrf: /***/ function(module, exports) {
            const isNotString = val =>
                typeof val !== 'string' || val.length === 0

            module.exports.isNotString = isNotString
            module.exports.isString = function isString(
                Err,
                value,
                label,
                claim,
                required = false
            ) {
                if (required && value === undefined) {
                    throw new Err(`${label} is missing`, claim, 'missing')
                }

                if (value !== undefined && isNotString(value)) {
                    throw new Err(`${label} must be a string`, claim, 'invalid')
                }
            }

            /***/
        },

        /***/ mTTR: /***/ function(module, exports, __webpack_require__) {
            var arrayLikeKeys = __webpack_require__('b80T'),
                baseKeysIn = __webpack_require__('QcOe'),
                isArrayLike = __webpack_require__('MMmD')

            /**
             * Creates an array of the own and inherited enumerable property names of `object`.
             *
             * **Note:** Non-object values are coerced to objects.
             *
             * @static
             * @memberOf _
             * @since 3.0.0
             * @category Object
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names.
             * @example
             *
             * function Foo() {
             *   this.a = 1;
             *   this.b = 2;
             * }
             *
             * Foo.prototype.c = 3;
             *
             * _.keysIn(new Foo);
             * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
             */
            function keysIn(object) {
                return isArrayLike(object)
                    ? arrayLikeKeys(object, true)
                    : baseKeysIn(object)
            }

            module.exports = keysIn

            /***/
        },

        /***/ maZv: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')
            var settle = __webpack_require__('Rn+g')
            var buildFullPath = __webpack_require__('g7np')
            var buildURL = __webpack_require__('MLWZ')
            var http = __webpack_require__('KEll')
            var https = __webpack_require__('7WL4')
            var httpFollow = __webpack_require__('05og').http
            var httpsFollow = __webpack_require__('05og').https
            var url = __webpack_require__('bzos')
            var zlib = __webpack_require__('FMKJ')
            var pkg = __webpack_require__('SgzI')
            var createError = __webpack_require__('LYNF')
            var enhanceError = __webpack_require__('OH9c')

            var isHttps = /https:?/

            /*eslint consistent-return:0*/
            module.exports = function httpAdapter(config) {
                return new Promise(function dispatchHttpRequest(
                    resolvePromise,
                    rejectPromise
                ) {
                    var resolve = function resolve(value) {
                        resolvePromise(value)
                    }
                    var reject = function reject(value) {
                        rejectPromise(value)
                    }
                    var data = config.data
                    var headers = config.headers

                    // Set User-Agent (required by some servers)
                    // Only set header if it hasn't been set in config
                    // See https://github.com/axios/axios/issues/69
                    if (!headers['User-Agent'] && !headers['user-agent']) {
                        headers['User-Agent'] = 'axios/' + pkg.version
                    }

                    if (data && !utils.isStream(data)) {
                        if (Buffer.isBuffer(data)) {
                            // Nothing to do...
                        } else if (utils.isArrayBuffer(data)) {
                            data = Buffer.from(new Uint8Array(data))
                        } else if (utils.isString(data)) {
                            data = Buffer.from(data, 'utf-8')
                        } else {
                            return reject(
                                createError(
                                    'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
                                    config
                                )
                            )
                        }

                        // Add Content-Length header if data exists
                        headers['Content-Length'] = data.length
                    }

                    // HTTP basic authentication
                    var auth = undefined
                    if (config.auth) {
                        var username = config.auth.username || ''
                        var password = config.auth.password || ''
                        auth = username + ':' + password
                    }

                    // Parse url
                    var fullPath = buildFullPath(config.baseURL, config.url)
                    var parsed = url.parse(fullPath)
                    var protocol = parsed.protocol || 'http:'

                    if (!auth && parsed.auth) {
                        var urlAuth = parsed.auth.split(':')
                        var urlUsername = urlAuth[0] || ''
                        var urlPassword = urlAuth[1] || ''
                        auth = urlUsername + ':' + urlPassword
                    }

                    if (auth) {
                        delete headers.Authorization
                    }

                    var isHttpsRequest = isHttps.test(protocol)
                    var agent = isHttpsRequest
                        ? config.httpsAgent
                        : config.httpAgent

                    var options = {
                        path: buildURL(
                            parsed.path,
                            config.params,
                            config.paramsSerializer
                        ).replace(/^\?/, ''),
                        method: config.method.toUpperCase(),
                        headers: headers,
                        agent: agent,
                        agents: {
                            http: config.httpAgent,
                            https: config.httpsAgent
                        },
                        auth: auth
                    }

                    if (config.socketPath) {
                        options.socketPath = config.socketPath
                    } else {
                        options.hostname = parsed.hostname
                        options.port = parsed.port
                    }

                    var proxy = config.proxy
                    if (!proxy && proxy !== false) {
                        var proxyEnv = protocol.slice(0, -1) + '_proxy'
                        var proxyUrl =
                            process.env[proxyEnv] ||
                            process.env[proxyEnv.toUpperCase()]
                        if (proxyUrl) {
                            var parsedProxyUrl = url.parse(proxyUrl)
                            var noProxyEnv =
                                process.env.no_proxy || process.env.NO_PROXY
                            var shouldProxy = true

                            if (noProxyEnv) {
                                var noProxy = noProxyEnv
                                    .split(',')
                                    .map(function trim(s) {
                                        return s.trim()
                                    })

                                shouldProxy = !noProxy.some(function proxyMatch(
                                    proxyElement
                                ) {
                                    if (!proxyElement) {
                                        return false
                                    }
                                    if (proxyElement === '*') {
                                        return true
                                    }
                                    if (
                                        proxyElement[0] === '.' &&
                                        parsed.hostname.substr(
                                            parsed.hostname.length -
                                                proxyElement.length
                                        ) === proxyElement
                                    ) {
                                        return true
                                    }

                                    return parsed.hostname === proxyElement
                                })
                            }

                            if (shouldProxy) {
                                proxy = {
                                    host: parsedProxyUrl.hostname,
                                    port: parsedProxyUrl.port
                                }

                                if (parsedProxyUrl.auth) {
                                    var proxyUrlAuth = parsedProxyUrl.auth.split(
                                        ':'
                                    )
                                    proxy.auth = {
                                        username: proxyUrlAuth[0],
                                        password: proxyUrlAuth[1]
                                    }
                                }
                            }
                        }
                    }

                    if (proxy) {
                        options.hostname = proxy.host
                        options.host = proxy.host
                        options.headers.host =
                            parsed.hostname +
                            (parsed.port ? ':' + parsed.port : '')
                        options.port = proxy.port
                        options.path =
                            protocol +
                            '//' +
                            parsed.hostname +
                            (parsed.port ? ':' + parsed.port : '') +
                            options.path

                        // Basic proxy authorization
                        if (proxy.auth) {
                            var base64 = Buffer.from(
                                proxy.auth.username + ':' + proxy.auth.password,
                                'utf8'
                            ).toString('base64')
                            options.headers['Proxy-Authorization'] =
                                'Basic ' + base64
                        }
                    }

                    var transport
                    var isHttpsProxy =
                        isHttpsRequest &&
                        (proxy ? isHttps.test(proxy.protocol) : true)
                    if (config.transport) {
                        transport = config.transport
                    } else if (config.maxRedirects === 0) {
                        transport = isHttpsProxy ? https : http
                    } else {
                        if (config.maxRedirects) {
                            options.maxRedirects = config.maxRedirects
                        }
                        transport = isHttpsProxy ? httpsFollow : httpFollow
                    }

                    if (
                        config.maxContentLength &&
                        config.maxContentLength > -1
                    ) {
                        options.maxBodyLength = config.maxContentLength
                    }

                    // Create the request
                    var req = transport.request(
                        options,
                        function handleResponse(res) {
                            if (req.aborted) return

                            // uncompress the response body transparently if required
                            var stream = res
                            switch (res.headers['content-encoding']) {
                                /*eslint default-case:0*/
                                case 'gzip':
                                case 'compress':
                                case 'deflate':
                                    // add the unzipper to the body stream processing pipeline
                                    stream =
                                        res.statusCode === 204
                                            ? stream
                                            : stream.pipe(zlib.createUnzip())

                                    // remove the content-encoding in order to not confuse downstream operations
                                    delete res.headers['content-encoding']
                                    break
                            }

                            // return the last request in case of redirects
                            var lastRequest = res.req || req

                            var response = {
                                status: res.statusCode,
                                statusText: res.statusMessage,
                                headers: res.headers,
                                config: config,
                                request: lastRequest
                            }

                            if (config.responseType === 'stream') {
                                response.data = stream
                                settle(resolve, reject, response)
                            } else {
                                var responseBuffer = []
                                stream.on('data', function handleStreamData(
                                    chunk
                                ) {
                                    responseBuffer.push(chunk)

                                    // make sure the content length is not over the maxContentLength if specified
                                    if (
                                        config.maxContentLength > -1 &&
                                        Buffer.concat(responseBuffer).length >
                                            config.maxContentLength
                                    ) {
                                        stream.destroy()
                                        reject(
                                            createError(
                                                'maxContentLength size of ' +
                                                    config.maxContentLength +
                                                    ' exceeded',
                                                config,
                                                null,
                                                lastRequest
                                            )
                                        )
                                    }
                                })

                                stream.on('error', function handleStreamError(
                                    err
                                ) {
                                    if (req.aborted) return
                                    reject(
                                        enhanceError(
                                            err,
                                            config,
                                            null,
                                            lastRequest
                                        )
                                    )
                                })

                                stream.on('end', function handleStreamEnd() {
                                    var responseData = Buffer.concat(
                                        responseBuffer
                                    )
                                    if (config.responseType !== 'arraybuffer') {
                                        responseData = responseData.toString(
                                            config.responseEncoding
                                        )
                                    }

                                    response.data = responseData
                                    settle(resolve, reject, response)
                                })
                            }
                        }
                    )

                    // Handle errors
                    req.on('error', function handleRequestError(err) {
                        if (req.aborted) return
                        reject(enhanceError(err, config, null, req))
                    })

                    // Handle request timeout
                    if (config.timeout) {
                        // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
                        // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
                        // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
                        // And then these socket which be hang up will devoring CPU little by little.
                        // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
                        req.setTimeout(
                            config.timeout,
                            function handleRequestTimeout() {
                                req.abort()
                                reject(
                                    createError(
                                        'timeout of ' +
                                            config.timeout +
                                            'ms exceeded',
                                        config,
                                        'ECONNABORTED',
                                        req
                                    )
                                )
                            }
                        )
                    }

                    if (config.cancelToken) {
                        // Handle cancellation
                        config.cancelToken.promise.then(function onCanceled(
                            cancel
                        ) {
                            if (req.aborted) return

                            req.abort()
                            reject(cancel)
                        })
                    }

                    // Send the request
                    if (utils.isStream(data)) {
                        data.on('error', function handleStreamError(err) {
                            reject(enhanceError(err, config, null, req))
                        }).pipe(req)
                    } else {
                        req.end(data)
                    }
                })
            }

            /***/
        },

        /***/ mc0g: /***/ function(module, exports) {
            /**
             * Creates a base function for methods like `_.forIn` and `_.forOwn`.
             *
             * @private
             * @param {boolean} [fromRight] Specify iterating from right to left.
             * @returns {Function} Returns the new base function.
             */
            function createBaseFor(fromRight) {
                return function(object, iteratee, keysFunc) {
                    var index = -1,
                        iterable = Object(object),
                        props = keysFunc(object),
                        length = props.length

                    while (length--) {
                        var key = props[fromRight ? length : ++index]
                        if (iteratee(iterable[key], key, iterable) === false) {
                            break
                        }
                    }
                    return object
                }
            }

            module.exports = createBaseFor

            /***/
        },

        /***/ mdPL: /***/ function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */ ;(function(module) {
                var freeGlobal = __webpack_require__('WFqU')

                /** Detect free variable `exports`. */
                var freeExports =
                    true && exports && !exports.nodeType && exports

                /** Detect free variable `module`. */
                var freeModule =
                    freeExports &&
                    typeof module == 'object' &&
                    module &&
                    !module.nodeType &&
                    module

                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports =
                    freeModule && freeModule.exports === freeExports

                /** Detect free variable `process` from Node.js. */
                var freeProcess = moduleExports && freeGlobal.process

                /** Used to access faster Node.js helpers. */
                var nodeUtil = (function() {
                    try {
                        // Use `util.types` for Node.js 10+.
                        var types =
                            freeModule &&
                            freeModule.require &&
                            freeModule.require('util').types

                        if (types) {
                            return types
                        }

                        // Legacy `process.binding('util')` for Node.js < 10.
                        return (
                            freeProcess &&
                            freeProcess.binding &&
                            freeProcess.binding('util')
                        )
                    } catch (e) {}
                })()

                module.exports = nodeUtil

                /* WEBPACK VAR INJECTION */
            }.call(this, __webpack_require__('YuTi')(module)))

            /***/
        },

        /***/ mmuM: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Assert = __webpack_require__('GlC0')

            const internals = {}

            module.exports = function(obj, chain, options) {
                if (chain === false || chain === null || chain === undefined) {
                    return obj
                }

                options = options || {}
                if (typeof options === 'string') {
                    options = { separator: options }
                }

                const isChainArray = Array.isArray(chain)

                Assert(
                    !isChainArray || !options.separator,
                    'Separator option no valid for array-based chain'
                )

                const path = isChainArray
                    ? chain
                    : chain.split(options.separator || '.')
                let ref = obj
                for (let i = 0; i < path.length; ++i) {
                    let key = path[i]
                    const type = options.iterables && internals.iterables(ref)

                    if (Array.isArray(ref) || type === 'set') {
                        const number = Number(key)
                        if (Number.isInteger(number)) {
                            key = number < 0 ? ref.length + number : number
                        }
                    }

                    if (
                        !ref ||
                        (typeof ref === 'function' &&
                            options.functions === false) || // Defaults to true
                        (!type && ref[key] === undefined)
                    ) {
                        Assert(
                            !options.strict || i + 1 === path.length,
                            'Missing segment',
                            key,
                            'in reach path ',
                            chain
                        )
                        Assert(
                            typeof ref === 'object' ||
                                options.functions === true ||
                                typeof ref !== 'function',
                            'Invalid segment',
                            key,
                            'in reach path ',
                            chain
                        )
                        ref = options.default
                        break
                    }

                    if (!type) {
                        ref = ref[key]
                    } else if (type === 'set') {
                        ref = [...ref][key]
                    } else {
                        // type === 'map'
                        ref = ref.get(key)
                    }
                }

                return ref
            }

            internals.iterables = function(ref) {
                if (ref instanceof Set) {
                    return 'set'
                }

                if (ref instanceof Map) {
                    return 'map'
                }
            }

            /***/
        },

        /***/ mqlF: /***/ function(module, exports) {
            exports.f = Object.getOwnPropertySymbols

            /***/
        },

        /***/ msIP: /***/ function(module, exports) {
            module.exports = require('stream')

            /***/
        },

        /***/ 'mv/X': /***/ function(module, exports, __webpack_require__) {
            var eq = __webpack_require__('ljhN'),
                isArrayLike = __webpack_require__('MMmD'),
                isIndex = __webpack_require__('wJg7'),
                isObject = __webpack_require__('GoyQ')

            /**
             * Checks if the given arguments are from an iteratee call.
             *
             * @private
             * @param {*} value The potential iteratee value argument.
             * @param {*} index The potential iteratee index or key argument.
             * @param {*} object The potential iteratee object argument.
             * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
             *  else `false`.
             */
            function isIterateeCall(value, index, object) {
                if (!isObject(object)) {
                    return false
                }
                var type = typeof index
                if (
                    type == 'number'
                        ? isArrayLike(object) && isIndex(index, object.length)
                        : type == 'string' && index in object
                ) {
                    return eq(object[index], value)
                }
                return false
            }

            module.exports = isIterateeCall

            /***/
        },

        /***/ 'mw/K': /***/ function(module, exports) {
            module.exports = require('fs')

            /***/
        },

        /***/ mwIZ: /***/ function(module, exports, __webpack_require__) {
            var baseGet = __webpack_require__('ZWtO')

            /**
             * Gets the value at `path` of `object`. If the resolved value is
             * `undefined`, the `defaultValue` is returned in its place.
             *
             * @static
             * @memberOf _
             * @since 3.7.0
             * @category Object
             * @param {Object} object The object to query.
             * @param {Array|string} path The path of the property to get.
             * @param {*} [defaultValue] The value returned for `undefined` resolved values.
             * @returns {*} Returns the resolved value.
             * @example
             *
             * var object = { 'a': [{ 'b': { 'c': 3 } }] };
             *
             * _.get(object, 'a[0].b.c');
             * // => 3
             *
             * _.get(object, ['a', '0', 'b', 'c']);
             * // => 3
             *
             * _.get(object, 'a.b.c', 'default');
             * // => 'default'
             */
            function get(object, path, defaultValue) {
                var result = object == null ? undefined : baseGet(object, path)
                return result === undefined ? defaultValue : result
            }

            module.exports = get

            /***/
        },

        /***/ mxNO: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const EventEmitter = __webpack_require__('/0p4')
            const JSONB = __webpack_require__('F/5w')

            const loadStore = opts => {
                const adapters = {
                    redis: '@keyv/redis',
                    mongodb: '@keyv/mongo',
                    mongo: '@keyv/mongo',
                    sqlite: '@keyv/sqlite',
                    postgresql: '@keyv/postgres',
                    postgres: '@keyv/postgres',
                    mysql: '@keyv/mysql'
                }
                if (opts.adapter || opts.uri) {
                    const adapter = opts.adapter || /^[^:]*/.exec(opts.uri)[0]
                    return new (__webpack_require__('qIYm')(adapters[adapter]))(
                        opts
                    )
                }
                return new Map()
            }

            class Keyv extends EventEmitter {
                constructor(uri, opts) {
                    super()
                    this.opts = Object.assign(
                        {
                            namespace: 'keyv',
                            serialize: JSONB.stringify,
                            deserialize: JSONB.parse
                        },
                        typeof uri === 'string' ? { uri } : uri,
                        opts
                    )

                    if (!this.opts.store) {
                        const adapterOpts = Object.assign({}, this.opts)
                        this.opts.store = loadStore(adapterOpts)
                    }

                    if (typeof this.opts.store.on === 'function') {
                        this.opts.store.on('error', err =>
                            this.emit('error', err)
                        )
                    }

                    this.opts.store.namespace = this.opts.namespace
                }

                _getKeyPrefix(key) {
                    return `${this.opts.namespace}:${key}`
                }

                get(key) {
                    key = this._getKeyPrefix(key)
                    const store = this.opts.store
                    return Promise.resolve()
                        .then(() => store.get(key))
                        .then(data => {
                            data =
                                typeof data === 'string'
                                    ? this.opts.deserialize(data)
                                    : data
                            if (data === undefined) {
                                return undefined
                            }
                            if (
                                typeof data.expires === 'number' &&
                                Date.now() > data.expires
                            ) {
                                this.delete(key)
                                return undefined
                            }
                            return data.value
                        })
                }

                set(key, value, ttl) {
                    key = this._getKeyPrefix(key)
                    if (typeof ttl === 'undefined') {
                        ttl = this.opts.ttl
                    }
                    if (ttl === 0) {
                        ttl = undefined
                    }
                    const store = this.opts.store

                    return Promise.resolve()
                        .then(() => {
                            const expires =
                                typeof ttl === 'number'
                                    ? Date.now() + ttl
                                    : null
                            value = { value, expires }
                            return store.set(
                                key,
                                this.opts.serialize(value),
                                ttl
                            )
                        })
                        .then(() => true)
                }

                delete(key) {
                    key = this._getKeyPrefix(key)
                    const store = this.opts.store
                    return Promise.resolve().then(() => store.delete(key))
                }

                clear() {
                    const store = this.opts.store
                    return Promise.resolve().then(() => store.clear())
                }
            }

            module.exports = Keyv

            /***/
        },

        /***/ n3ko: /***/ function(module, exports, __webpack_require__) {
            var isObject = __webpack_require__('93I4')
            module.exports = function(it, TYPE) {
                if (!isObject(it) || it._t !== TYPE)
                    throw TypeError(
                        'Incompatible receiver, ' + TYPE + ' required!'
                    )
                return it
            }

            /***/
        },

        /***/ n8pu: /***/ function(module, exports, __webpack_require__) {
            const { improvedDH } = __webpack_require__('pDDt')
            const { KEYOBJECT } = __webpack_require__('ehsS')
            const { generateSync } = __webpack_require__('LDEB')
            const { name: secp256k1 } = __webpack_require__('F/JS')
            const { ECDH_DERIVE_LENGTHS } = __webpack_require__('N+nT')

            const derive = __webpack_require__('kZLX')

            const wrapKey = (wrap, derive, key, payload) => {
                const epk = generateSync(key.kty, key.crv)

                const derivedKey = derive(epk, key, payload)

                const result = wrap({ [KEYOBJECT]: derivedKey }, payload)
                result.header = result.header || {}
                Object.assign(result.header, {
                    epk: { kty: key.kty, crv: key.crv, x: epk.x, y: epk.y }
                })

                return result
            }

            const unwrapKey = (unwrap, derive, key, payload, header) => {
                const { epk } = header
                const derivedKey = derive(key, epk, header)

                return unwrap({ [KEYOBJECT]: derivedKey }, payload, header)
            }

            module.exports = (JWA, JWK) => {
                ;['ECDH-ES+A128KW', 'ECDH-ES+A192KW', 'ECDH-ES+A256KW'].forEach(
                    jwaAlg => {
                        const kw = jwaAlg.substr(-6)
                        const kwWrap = JWA.keyManagementEncrypt.get(kw)
                        const kwUnwrap = JWA.keyManagementDecrypt.get(kw)
                        const keylen = parseInt(jwaAlg.substr(9, 3), 10)
                        ECDH_DERIVE_LENGTHS.set(jwaAlg, keylen)

                        if (kwWrap && kwUnwrap) {
                            JWA.keyManagementEncrypt.set(
                                jwaAlg,
                                wrapKey.bind(
                                    undefined,
                                    kwWrap,
                                    derive.bind(undefined, jwaAlg, keylen)
                                )
                            )
                            JWA.keyManagementDecrypt.set(
                                jwaAlg,
                                unwrapKey.bind(
                                    undefined,
                                    kwUnwrap,
                                    derive.bind(undefined, jwaAlg, keylen)
                                )
                            )
                            JWK.EC.deriveKey[jwaAlg] = key =>
                                (key.use === 'enc' || key.use === undefined) &&
                                key.crv !== secp256k1

                            if (improvedDH) {
                                JWK.OKP.deriveKey[jwaAlg] = key =>
                                    (key.use === 'enc' ||
                                        key.use === undefined) &&
                                    key.keyObject.asymmetricKeyType.startsWith(
                                        'x'
                                    )
                            }
                        }
                    }
                )
            }
            module.exports.wrapKey = wrapKey
            module.exports.unwrapKey = unwrapKey

            /***/
        },

        /***/ nK8a: /***/ function(module) {
            module.exports = JSON.parse(
                '{"name":"openid-client","version":"3.13.0","description":"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs","keywords":["auth","authentication","basic","certified","client","connect","dynamic","electron","hybrid","identity","implicit","oauth","oauth2","oidc","openid","passport","relying party","strategy"],"homepage":"https://github.com/panva/node-openid-client","repository":"panva/node-openid-client","license":"MIT","author":"Filip Skokan <panva.ip@gmail.com>","files":["lib","types/index.d.ts"],"funding":"https://github.com/sponsors/panva","main":"lib/index.js","types":"types/index.d.ts","scripts":{"coverage":"nyc mocha test/**/*.test.js","lint":"eslint lib test && dtslint types","lint-fix":"eslint lib test --fix","test":"mocha test/**/*.test.js"},"dependencies":{"@types/got":"^9.6.9","base64url":"^3.0.1","got":"^9.6.0","jose":"^1.23.0","lodash":"^4.17.15","lru-cache":"^5.1.1","make-error":"^1.3.5","object-hash":"^2.0.1","oidc-token-hash":"^5.0.0","p-any":"^2.1.0"},"devDependencies":{"@commitlint/cli":"^8.3.4","@commitlint/config-conventional":"^8.3.4","@types/passport":"^1.0.2","chai":"^4.2.0","dtslint":"^2.0.5","eslint":"^6.8.0","eslint-config-airbnb-base":"^14.0.0","eslint-plugin-import":"^2.19.1","husky":"^4.0.0","mocha":"^7.0.0","nock":"^11.7.1","nyc":"^15.0.0","readable-mock-req":"^0.2.2","sinon":"^8.0.4","timekeeper":"^2.2.0"},"engines":{"node":"^10.13.0 || >=12.0.0"},"commitlint":{"extends":["@commitlint/config-conventional"]},"husky":{"hooks":{"commit-msg":"commitlint -E HUSKY_GIT_PARAMS"}},"nyc":{"reporter":["lcov","text-summary"]}}'
            )

            /***/
        },

        /***/ nOHt: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _interopRequireWildcard = __webpack_require__('5Uuq')

            var _interopRequireDefault = __webpack_require__('KI45')

            exports.__esModule = true
            exports.useRouter = useRouter
            exports.makePublicRouterInstance = makePublicRouterInstance
            exports.createRouter = exports.withRouter = exports.default = void 0

            var _extends2 = _interopRequireDefault(__webpack_require__('htGi'))

            var _defineProperty = _interopRequireDefault(
                __webpack_require__('hfKm')
            )

            var _react = _interopRequireDefault(__webpack_require__('q1tI'))

            var _router2 = _interopRequireWildcard(__webpack_require__('elyg'))

            exports.Router = _router2.default
            exports.NextRouter = _router2.NextRouter

            var _routerContext = __webpack_require__('qOIg')

            var _withRouter = _interopRequireDefault(
                __webpack_require__('0Bsm')
            )

            exports.withRouter = _withRouter.default
            /* global window */

            var singletonRouter = {
                router: null,
                // holds the actual router instance
                readyCallbacks: [],

                ready(cb) {
                    if (this.router) return cb()

                    if (false) {
                    }
                }
            } // Create public properties and methods of the router in the singletonRouter

            var urlPropertyFields = [
                'pathname',
                'route',
                'query',
                'asPath',
                'components'
            ]
            var routerEvents = [
                'routeChangeStart',
                'beforeHistoryChange',
                'routeChangeComplete',
                'routeChangeError',
                'hashChangeStart',
                'hashChangeComplete'
            ]
            var coreMethodFields = [
                'push',
                'replace',
                'reload',
                'back',
                'prefetch',
                'beforePopState'
            ] // Events is a static property on the router, the router doesn't have to be initialized to use it

            ;(0, _defineProperty.default)(singletonRouter, 'events', {
                get() {
                    return _router2.default.events
                }
            })
            urlPropertyFields.forEach(field => {
                // Here we need to use Object.defineProperty because, we need to return
                // the property assigned to the actual router
                // The value might get changed as we change routes and this is the
                // proper way to access it
                ;(0, _defineProperty.default)(singletonRouter, field, {
                    get() {
                        var router = getRouter()
                        return router[field]
                    }
                })
            })
            coreMethodFields.forEach(field => {
                // We don't really know the types here, so we add them later instead
                singletonRouter[field] = function() {
                    var router = getRouter()
                    return router[field](...arguments)
                }
            })
            routerEvents.forEach(event => {
                singletonRouter.ready(() => {
                    _router2.default.events.on(event, function() {
                        var eventField =
                            'on' +
                            event.charAt(0).toUpperCase() +
                            event.substring(1)
                        var _singletonRouter = singletonRouter

                        if (_singletonRouter[eventField]) {
                            try {
                                _singletonRouter[eventField](...arguments)
                            } catch (err) {
                                // tslint:disable-next-line:no-console
                                console.error(
                                    'Error when running the Router event: ' +
                                        eventField
                                ) // tslint:disable-next-line:no-console

                                console.error(err.message + '\n' + err.stack)
                            }
                        }
                    })
                })
            })

            function getRouter() {
                if (!singletonRouter.router) {
                    var message =
                        'No router instance found.\n' +
                        'You should only use "next/router" inside the client side of your app.\n'
                    throw new Error(message)
                }

                return singletonRouter.router
            } // Export the singletonRouter and this is the public API.

            var _default = singletonRouter // Reexport the withRoute HOC

            exports.default = _default

            function useRouter() {
                return _react.default.useContext(_routerContext.RouterContext)
            } // INTERNAL APIS
            // -------------
            // (do not use following exports inside the app)
            // Create a router and assign it as the singleton instance.
            // This is used in client side when we are initilizing the app.
            // This should **not** use inside the server.

            var createRouter = function createRouter() {
                for (
                    var _len = arguments.length,
                        args = new Array(_len),
                        _key = 0;
                    _key < _len;
                    _key++
                ) {
                    args[_key] = arguments[_key]
                }

                singletonRouter.router = new _router2.default(...args)
                singletonRouter.readyCallbacks.forEach(cb => cb())
                singletonRouter.readyCallbacks = []
                return singletonRouter.router
            } // This function is used to create the `withRouter` router instance

            exports.createRouter = createRouter

            function makePublicRouterInstance(router) {
                var _router = router
                var instance = {}

                for (var property of urlPropertyFields) {
                    if (typeof _router[property] === 'object') {
                        instance[property] = (0, _extends2.default)(
                            {},
                            _router[property]
                        ) // makes sure query is not stateful

                        continue
                    }

                    instance[property] = _router[property]
                } // Events is a static property on the router, the router doesn't have to be initialized to use it

                instance.events = _router2.default.events
                coreMethodFields.forEach(field => {
                    instance[field] = function() {
                        return _router[field](...arguments)
                    }
                })
                return instance
            }

            /***/
        },

        /***/ nRxi: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$defineProperty = __webpack_require__('hfKm')

            var __importStar =
                (this && this.__importStar) ||
                function(mod) {
                    if (mod && mod.__esModule) return mod
                    var result = {}
                    if (mod != null)
                        for (var k in mod)
                            if (Object.hasOwnProperty.call(mod, k))
                                result[k] = mod[k]
                    result['default'] = mod
                    return result
                }

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            const React = __importStar(__webpack_require__('q1tI'))

            exports.DocumentContext = React.createContext(null)

            /***/
        },

        /***/ nWF0: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            exports.__esModule = true
            exports['default'] = flushToReact
            exports.flushToHTML = flushToHTML

            var _react = _interopRequireDefault(__webpack_require__('q1tI'))

            var _style = __webpack_require__('3niX')

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj }
            }

            function flushToReact(options) {
                if (options === void 0) {
                    options = {}
                }

                return (0, _style.flush)().map(function(args) {
                    var id = args[0]
                    var css = args[1]
                    return _react['default'].createElement('style', {
                        id: '__' + id,
                        // Avoid warnings upon render with a key
                        key: '__' + id,
                        nonce: options.nonce ? options.nonce : undefined,
                        dangerouslySetInnerHTML: {
                            __html: css
                        }
                    })
                })
            }

            function flushToHTML(options) {
                if (options === void 0) {
                    options = {}
                }

                return (0, _style.flush)().reduce(function(html, args) {
                    var id = args[0]
                    var css = args[1]
                    html +=
                        '<style id="__' +
                        id +
                        '"' +
                        (options.nonce
                            ? ' nonce="' + options.nonce + '"'
                            : '') +
                        '>' +
                        css +
                        '</style>'
                    return html
                }, '')
            }

            /***/
        },

        /***/ nZgG: /***/ function(module, exports, __webpack_require__) {
            var $export = __webpack_require__('Y7ZC')
            // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
            $export(
                $export.S + $export.F * !__webpack_require__('jmDH'),
                'Object',
                { defineProperties: __webpack_require__('fpC5') }
            )

            /***/
        },

        /***/ nmnc: /***/ function(module, exports, __webpack_require__) {
            var root = __webpack_require__('Kz5y')

            /** Built-in value references. */
            var Symbol = root.Symbol

            module.exports = Symbol

            /***/
        },

        /***/ 'o/Eg': /***/ function(module, exports) {
            module.exports = (AlgorithmIdentifier, PrivateKey) =>
                function() {
                    this.seq().obj(
                        this.key('version').int(),
                        this.key('algorithm').use(AlgorithmIdentifier),
                        this.key('privateKey').use(PrivateKey)
                    )
                }

            /***/
        },

        /***/ o156: /***/ function(module, exports) {
            const minute = 60
            const hour = minute * 60
            const day = hour * 24
            const week = day * 7
            const year = day * 365.25

            const REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i

            module.exports = str => {
                const matched = REGEX.exec(str)

                if (!matched) {
                    throw new TypeError(`invalid time period format ("${str}")`)
                }

                const value = parseFloat(matched[1])
                const unit = matched[2].toLowerCase()

                switch (unit) {
                    case 'sec':
                    case 'secs':
                    case 'second':
                    case 'seconds':
                    case 's':
                        return Math.round(value)
                    case 'minute':
                    case 'minutes':
                    case 'min':
                    case 'mins':
                    case 'm':
                        return Math.round(value * minute)
                    case 'hour':
                    case 'hours':
                    case 'hr':
                    case 'hrs':
                    case 'h':
                        return Math.round(value * hour)
                    case 'day':
                    case 'days':
                    case 'd':
                        return Math.round(value * day)
                    case 'week':
                    case 'weeks':
                    case 'w':
                        return Math.round(value * week)
                    case 'year':
                    case 'years':
                    case 'yr':
                    case 'yrs':
                    case 'y':
                        return Math.round(value * year)
                }
            }

            /***/
        },

        /***/ o8NH: /***/ function(module, exports, __webpack_require__) {
            // 19.1.3.1 Object.assign(target, source)
            var $export = __webpack_require__('Y7ZC')

            $export($export.S + $export.F, 'Object', {
                assign: __webpack_require__('kwZ1')
            })

            /***/
        },

        /***/ 'oCl/': /***/ function(module, exports, __webpack_require__) {
            var arrayPush = __webpack_require__('CH3K'),
                getPrototype = __webpack_require__('LcsW'),
                getSymbols = __webpack_require__('MvSz'),
                stubArray = __webpack_require__('0ycA')

            /* Built-in method references for those with the same name as other `lodash` methods. */
            var nativeGetSymbols = Object.getOwnPropertySymbols

            /**
             * Creates an array of the own and inherited enumerable symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of symbols.
             */
            var getSymbolsIn = !nativeGetSymbols
                ? stubArray
                : function(object) {
                      var result = []
                      while (object) {
                          arrayPush(result, getSymbols(object))
                          object = getPrototype(object)
                      }
                      return result
                  }

            module.exports = getSymbolsIn

            /***/
        },

        /***/ oGTz: /***/ function(module, exports, __webpack_require__) {
            const errors = __webpack_require__('yt7c')
            const Key = __webpack_require__('//Cd')
            const importKey = __webpack_require__('GhER')
            const { KeyStore } = __webpack_require__('aIoy')

            module.exports = (input, keyStoreAllowed = false) => {
                if (input instanceof Key) {
                    return input
                }

                if (input instanceof KeyStore) {
                    if (!keyStoreAllowed) {
                        throw new TypeError(
                            'key argument for this operation must not be a JWKS.KeyStore instance'
                        )
                    }

                    return input
                }

                try {
                    return importKey(input)
                } catch (err) {
                    if (
                        err instanceof errors.JOSEError &&
                        !(err instanceof errors.JWKImportFailed)
                    ) {
                        throw err
                    }

                    let msg
                    if (keyStoreAllowed) {
                        msg =
                            'key must be an instance of a key instantiated by JWK.asKey, a valid JWK.asKey input, or a JWKS.KeyStore instance'
                    } else {
                        msg =
                            'key must be an instance of a key instantiated by JWK.asKey, or a valid JWK.asKey input'
                    }

                    throw new TypeError(msg)
                }
            }

            /***/
        },

        /***/ oKwy: /***/ function(module, exports) {
            /** Error message constants. */
            var FUNC_ERROR_TEXT = 'Expected a function'

            /**
             * Creates a function that negates the result of the predicate `func`. The
             * `func` predicate is invoked with the `this` binding and arguments of the
             * created function.
             *
             * @static
             * @memberOf _
             * @since 3.0.0
             * @category Function
             * @param {Function} predicate The predicate to negate.
             * @returns {Function} Returns the new negated function.
             * @example
             *
             * function isEven(n) {
             *   return n % 2 == 0;
             * }
             *
             * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
             * // => [1, 3, 5]
             */
            function negate(predicate) {
                if (typeof predicate != 'function') {
                    throw new TypeError(FUNC_ERROR_TEXT)
                }
                return function() {
                    var args = arguments
                    switch (args.length) {
                        case 0:
                            return !predicate.call(this)
                        case 1:
                            return !predicate.call(this, args[0])
                        case 2:
                            return !predicate.call(this, args[0], args[1])
                        case 3:
                            return !predicate.call(
                                this,
                                args[0],
                                args[1],
                                args[2]
                            )
                    }
                    return !predicate.apply(this, args)
                }
            }

            module.exports = negate

            /***/
        },

        /***/ oVml: /***/ function(module, exports, __webpack_require__) {
            // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
            var anObject = __webpack_require__('5K7Z')
            var dPs = __webpack_require__('fpC5')
            var enumBugKeys = __webpack_require__('FpHa')
            var IE_PROTO = __webpack_require__('VVlx')('IE_PROTO')
            var Empty = function() {
                /* empty */
            }
            var PROTOTYPE = 'prototype'

            // Create object with fake `null` prototype: use iframe Object with cleared prototype
            var createDict = function() {
                // Thrash, waste and sodomy: IE GC bug
                var iframe = __webpack_require__('Hsns')('iframe')
                var i = enumBugKeys.length
                var lt = '<'
                var gt = '>'
                var iframeDocument
                iframe.style.display = 'none'
                __webpack_require__('MvwC').appendChild(iframe)
                iframe.src = 'javascript:' // eslint-disable-line no-script-url
                // createDict = iframe.contentWindow.Object;
                // html.removeChild(iframe);
                iframeDocument = iframe.contentWindow.document
                iframeDocument.open()
                iframeDocument.write(
                    lt +
                        'script' +
                        gt +
                        'document.F=Object' +
                        lt +
                        '/script' +
                        gt
                )
                iframeDocument.close()
                createDict = iframeDocument.F
                while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]]
                return createDict()
            }

            module.exports =
                Object.create ||
                function create(O, Properties) {
                    var result
                    if (O !== null) {
                        Empty[PROTOTYPE] = anObject(O)
                        result = new Empty()
                        Empty[PROTOTYPE] = null
                        // add "__proto__" for Object.getPrototypeOf polyfill
                        result[IE_PROTO] = O
                    } else result = createDict()
                    return Properties === undefined
                        ? result
                        : dPs(result, Properties)
                }

            /***/
        },

        /***/ 'oh+g': /***/ function(module, exports, __webpack_require__) {
            var core = __webpack_require__('WEpk')
            var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify })
            module.exports = function stringify(it) {
                // eslint-disable-line no-unused-vars
                return $JSON.stringify.apply($JSON, arguments)
            }

            /***/
        },

        /***/ oioR: /***/ function(module, exports, __webpack_require__) {
            var ctx = __webpack_require__('2GTP')
            var call = __webpack_require__('sNwI')
            var isArrayIter = __webpack_require__('NwJ3')
            var anObject = __webpack_require__('5K7Z')
            var toLength = __webpack_require__('tEej')
            var getIterFn = __webpack_require__('fNZA')
            var BREAK = {}
            var RETURN = {}
            var exports = (module.exports = function(
                iterable,
                entries,
                fn,
                that,
                ITERATOR
            ) {
                var iterFn = ITERATOR
                    ? function() {
                          return iterable
                      }
                    : getIterFn(iterable)
                var f = ctx(fn, that, entries ? 2 : 1)
                var index = 0
                var length, step, iterator, result
                if (typeof iterFn != 'function')
                    throw TypeError(iterable + ' is not iterable!')
                // fast case for arrays with default iterator
                if (isArrayIter(iterFn))
                    for (
                        length = toLength(iterable.length);
                        length > index;
                        index++
                    ) {
                        result = entries
                            ? f(anObject((step = iterable[index]))[0], step[1])
                            : f(iterable[index])
                        if (result === BREAK || result === RETURN) return result
                    }
                else
                    for (
                        iterator = iterFn.call(iterable);
                        !(step = iterator.next()).done;

                    ) {
                        result = call(iterator, f, step.value, entries)
                        if (result === BREAK || result === RETURN) return result
                    }
            })
            exports.BREAK = BREAK
            exports.RETURN = RETURN

            /***/
        },

        /***/ or5M: /***/ function(module, exports, __webpack_require__) {
            var SetCache = __webpack_require__('1hJj'),
                arraySome = __webpack_require__('QoRX'),
                cacheHas = __webpack_require__('xYSL')

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1,
                COMPARE_UNORDERED_FLAG = 2

            /**
             * A specialized version of `baseIsEqualDeep` for arrays with support for
             * partial deep comparisons.
             *
             * @private
             * @param {Array} array The array to compare.
             * @param {Array} other The other array to compare.
             * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
             * @param {Function} customizer The function to customize comparisons.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Object} stack Tracks traversed `array` and `other` objects.
             * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
             */
            function equalArrays(
                array,
                other,
                bitmask,
                customizer,
                equalFunc,
                stack
            ) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                    arrLength = array.length,
                    othLength = other.length

                if (
                    arrLength != othLength &&
                    !(isPartial && othLength > arrLength)
                ) {
                    return false
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(array)
                if (stacked && stack.get(other)) {
                    return stacked == other
                }
                var index = -1,
                    result = true,
                    seen =
                        bitmask & COMPARE_UNORDERED_FLAG
                            ? new SetCache()
                            : undefined

                stack.set(array, other)
                stack.set(other, array)

                // Ignore non-index properties.
                while (++index < arrLength) {
                    var arrValue = array[index],
                        othValue = other[index]

                    if (customizer) {
                        var compared = isPartial
                            ? customizer(
                                  othValue,
                                  arrValue,
                                  index,
                                  other,
                                  array,
                                  stack
                              )
                            : customizer(
                                  arrValue,
                                  othValue,
                                  index,
                                  array,
                                  other,
                                  stack
                              )
                    }
                    if (compared !== undefined) {
                        if (compared) {
                            continue
                        }
                        result = false
                        break
                    }
                    // Recursively compare arrays (susceptible to call stack limits).
                    if (seen) {
                        if (
                            !arraySome(other, function(othValue, othIndex) {
                                if (
                                    !cacheHas(seen, othIndex) &&
                                    (arrValue === othValue ||
                                        equalFunc(
                                            arrValue,
                                            othValue,
                                            bitmask,
                                            customizer,
                                            stack
                                        ))
                                ) {
                                    return seen.push(othIndex)
                                }
                            })
                        ) {
                            result = false
                            break
                        }
                    } else if (
                        !(
                            arrValue === othValue ||
                            equalFunc(
                                arrValue,
                                othValue,
                                bitmask,
                                customizer,
                                stack
                            )
                        )
                    ) {
                        result = false
                        break
                    }
                }
                stack['delete'](array)
                stack['delete'](other)
                return result
            }

            module.exports = equalArrays

            /***/
        },

        /***/ 'otv/': /***/ function(module, exports, __webpack_require__) {
            var Symbol = __webpack_require__('nmnc')

            /** Used to convert symbols to primitives and strings. */
            var symbolProto = Symbol ? Symbol.prototype : undefined,
                symbolValueOf = symbolProto ? symbolProto.valueOf : undefined

            /**
             * Creates a clone of the `symbol` object.
             *
             * @private
             * @param {Object} symbol The symbol object to clone.
             * @returns {Object} Returns the cloned symbol object.
             */
            function cloneSymbol(symbol) {
                return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
            }

            module.exports = cloneSymbol

            /***/
        },

        /***/ oyvS: /***/ function(module, exports) {
            module.exports = require('path')

            /***/
        },

        /***/ p0XB: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('9BDd')

            /***/
        },

        /***/ pBmY: /***/ function(module, exports) {
            module.exports = AlgorithmIdentifier =>
                function() {
                    this.seq().obj(
                        this.key('algorithm').use(AlgorithmIdentifier),
                        this.key('publicKey').bitstr()
                    )
                }

            /***/
        },

        /***/ pDDt: /***/ function(module, exports, __webpack_require__) {
            const {
                diffieHellman,
                KeyObject,
                sign,
                verify
            } = __webpack_require__('PJMN')

            const [major, minor] = process.version
                .substr(1)
                .split('.')
                .map(x => parseInt(x, 10))

            module.exports = {
                oaepHashSupported: major > 12 || (major === 12 && minor >= 9),
                keyObjectSupported: !!KeyObject && major >= 12,
                edDSASupported: !!sign && !!verify,
                dsaEncodingSupported:
                    major > 13 ||
                    (major === 13 && minor >= 2) ||
                    (major === 12 && minor >= 16),
                improvedDH: !!diffieHellman
            }

            /***/
        },

        /***/ pFRH: /***/ function(module, exports, __webpack_require__) {
            var constant = __webpack_require__('cvCv'),
                defineProperty = __webpack_require__('O0oS'),
                identity = __webpack_require__('zZ0H')

            /**
             * The base implementation of `setToString` without support for hot loop shorting.
             *
             * @private
             * @param {Function} func The function to modify.
             * @param {Function} string The `toString` result.
             * @returns {Function} Returns `func`.
             */
            var baseSetToString = !defineProperty
                ? identity
                : function(func, string) {
                      return defineProperty(func, 'toString', {
                          configurable: true,
                          enumerable: false,
                          value: constant(string),
                          writable: true
                      })
                  }

            module.exports = baseSetToString

            /***/
        },

        /***/ pLtp: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('iq4v')

            /***/
        },

        /***/ pSRY: /***/ function(module, exports, __webpack_require__) {
            var getMapData = __webpack_require__('QkVE')

            /**
             * Checks if a map value for `key` exists.
             *
             * @private
             * @name has
             * @memberOf MapCache
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function mapCacheHas(key) {
                return getMapData(this, key).has(key)
            }

            module.exports = mapCacheHas

            /***/
        },

        /***/ pV7Z: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            if (true) {
                module.exports = __webpack_require__('FDah')
            } else {
            }

            /***/
        },

        /***/ q1Jy: /***/ function(module, exports, __webpack_require__) {
            var once = __webpack_require__('VmuJ')

            var noop = function() {}

            var isRequest = function(stream) {
                return stream.setHeader && typeof stream.abort === 'function'
            }

            var isChildProcess = function(stream) {
                return (
                    stream.stdio &&
                    Array.isArray(stream.stdio) &&
                    stream.stdio.length === 3
                )
            }

            var eos = function(stream, opts, callback) {
                if (typeof opts === 'function') return eos(stream, null, opts)
                if (!opts) opts = {}

                callback = once(callback || noop)

                var ws = stream._writableState
                var rs = stream._readableState
                var readable =
                    opts.readable ||
                    (opts.readable !== false && stream.readable)
                var writable =
                    opts.writable ||
                    (opts.writable !== false && stream.writable)
                var cancelled = false

                var onlegacyfinish = function() {
                    if (!stream.writable) onfinish()
                }

                var onfinish = function() {
                    writable = false
                    if (!readable) callback.call(stream)
                }

                var onend = function() {
                    readable = false
                    if (!writable) callback.call(stream)
                }

                var onexit = function(exitCode) {
                    callback.call(
                        stream,
                        exitCode
                            ? new Error('exited with error code: ' + exitCode)
                            : null
                    )
                }

                var onerror = function(err) {
                    callback.call(stream, err)
                }

                var onclose = function() {
                    process.nextTick(onclosenexttick)
                }

                var onclosenexttick = function() {
                    if (cancelled) return
                    if (readable && !(rs && rs.ended && !rs.destroyed))
                        return callback.call(
                            stream,
                            new Error('premature close')
                        )
                    if (writable && !(ws && ws.ended && !ws.destroyed))
                        return callback.call(
                            stream,
                            new Error('premature close')
                        )
                }

                var onrequest = function() {
                    stream.req.on('finish', onfinish)
                }

                if (isRequest(stream)) {
                    stream.on('complete', onfinish)
                    stream.on('abort', onclose)
                    if (stream.req) onrequest()
                    else stream.on('request', onrequest)
                } else if (writable && !ws) {
                    // legacy streams
                    stream.on('end', onlegacyfinish)
                    stream.on('close', onlegacyfinish)
                }

                if (isChildProcess(stream)) stream.on('exit', onexit)

                stream.on('end', onend)
                stream.on('finish', onfinish)
                if (opts.error !== false) stream.on('error', onerror)
                stream.on('close', onclose)

                return function() {
                    cancelled = true
                    stream.removeListener('complete', onfinish)
                    stream.removeListener('abort', onclose)
                    stream.removeListener('request', onrequest)
                    if (stream.req)
                        stream.req.removeListener('finish', onfinish)
                    stream.removeListener('end', onlegacyfinish)
                    stream.removeListener('close', onlegacyfinish)
                    stream.removeListener('finish', onfinish)
                    stream.removeListener('exit', onexit)
                    stream.removeListener('end', onend)
                    stream.removeListener('error', onerror)
                    stream.removeListener('close', onclose)
                }
            }

            module.exports = eos

            /***/
        },

        /***/ q1tI: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            if (true) {
                module.exports = __webpack_require__('viRO')
            } else {
            }

            /***/
        },

        /***/ q2Us: /***/ function(module, exports, __webpack_require__) {
            const { pbkdf2Sync: pbkdf2, randomBytes } = __webpack_require__(
                'PJMN'
            )

            const { KEYOBJECT } = __webpack_require__('ehsS')
            const base64url = __webpack_require__('Xab3')

            const SALT_LENGTH = 16
            const NULL_BUFFER = Buffer.alloc(1, 0)

            const concatSalt = (alg, p2s) => {
                return Buffer.concat([
                    Buffer.from(alg, 'utf8'),
                    NULL_BUFFER,
                    p2s
                ])
            }

            const wrapKey = (
                keylen,
                sha,
                concat,
                wrap,
                { [KEYOBJECT]: keyObject },
                payload
            ) => {
                // Note that if password-based encryption is used for multiple
                // recipients, it is expected that each recipient use different values
                // for the PBES2 parameters "p2s" and "p2c".
                // here we generate p2c between 2048 and 4096 and random p2s
                const p2c = Math.floor(Math.random() * 2049 + 2048)
                const p2s = randomBytes(SALT_LENGTH)
                const salt = concat(p2s)

                const derivedKey = pbkdf2(
                    keyObject.export(),
                    salt,
                    p2c,
                    keylen,
                    sha
                )

                const result = wrap({ [KEYOBJECT]: derivedKey }, payload)
                result.header = result.header || {}
                Object.assign(result.header, {
                    p2c,
                    p2s: base64url.encodeBuffer(p2s)
                })

                return result
            }

            const unwrapKey = (
                keylen,
                sha,
                concat,
                unwrap,
                { [KEYOBJECT]: keyObject },
                payload,
                header
            ) => {
                const { p2s, p2c } = header
                const salt = concat(p2s)
                const derivedKey = pbkdf2(
                    keyObject.export(),
                    salt,
                    p2c,
                    keylen,
                    sha
                )
                return unwrap({ [KEYOBJECT]: derivedKey }, payload, header)
            }

            module.exports = (JWA, JWK) => {
                ;[
                    'PBES2-HS256+A128KW',
                    'PBES2-HS384+A192KW',
                    'PBES2-HS512+A256KW'
                ].forEach(jwaAlg => {
                    const kw = jwaAlg.substr(-6)
                    const kwWrap = JWA.keyManagementEncrypt.get(kw)
                    const kwUnwrap = JWA.keyManagementDecrypt.get(kw)
                    const keylen = parseInt(jwaAlg.substr(13, 3), 10) / 8
                    const sha = `sha${jwaAlg.substr(8, 3)}`

                    if (kwWrap && kwUnwrap) {
                        JWA.keyManagementEncrypt.set(
                            jwaAlg,
                            wrapKey.bind(
                                undefined,
                                keylen,
                                sha,
                                concatSalt.bind(undefined, jwaAlg),
                                kwWrap
                            )
                        )
                        JWA.keyManagementDecrypt.set(
                            jwaAlg,
                            unwrapKey.bind(
                                undefined,
                                keylen,
                                sha,
                                concatSalt.bind(undefined, jwaAlg),
                                kwUnwrap
                            )
                        )
                        JWK.oct.deriveKey[jwaAlg] = key =>
                            key.use === 'enc' || key.use === undefined
                    }
                })
            }

            /***/
        },

        /***/ q6LJ: /***/ function(module, exports, __webpack_require__) {
            var global = __webpack_require__('5T2Y')
            var macrotask = __webpack_require__('QXhf').set
            var Observer =
                global.MutationObserver || global.WebKitMutationObserver
            var process = global.process
            var Promise = global.Promise
            var isNode = __webpack_require__('a0xu')(process) == 'process'

            module.exports = function() {
                var head, last, notify

                var flush = function() {
                    var parent, fn
                    if (isNode && (parent = process.domain)) parent.exit()
                    while (head) {
                        fn = head.fn
                        head = head.next
                        try {
                            fn()
                        } catch (e) {
                            if (head) notify()
                            else last = undefined
                            throw e
                        }
                    }
                    last = undefined
                    if (parent) parent.enter()
                }

                // Node.js
                if (isNode) {
                    notify = function() {
                        process.nextTick(flush)
                    }
                    // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
                } else if (
                    Observer &&
                    !(global.navigator && global.navigator.standalone)
                ) {
                    var toggle = true
                    var node = document.createTextNode('')
                    new Observer(flush).observe(node, { characterData: true }) // eslint-disable-line no-new
                    notify = function() {
                        node.data = toggle = !toggle
                    }
                    // environments with maybe non-completely correct, but existent Promise
                } else if (Promise && Promise.resolve) {
                    // Promise.resolve without an argument throws an error in LG WebOS 2
                    var promise = Promise.resolve(undefined)
                    notify = function() {
                        promise.then(flush)
                    }
                    // for other environments - macrotask based on:
                    // - setImmediate
                    // - MessageChannel
                    // - window.postMessag
                    // - onreadystatechange
                    // - setTimeout
                } else {
                    notify = function() {
                        // strange IE + webpack dev server bug - use .call(global)
                        macrotask.call(global, flush)
                    }
                }

                return function(fn) {
                    var task = { fn: fn, next: undefined }
                    if (last) last.next = task
                    if (!head) {
                        head = task
                        notify()
                    }
                    last = task
                }
            }

            /***/
        },

        /***/ q9pr: /***/ function(
            module,
            __webpack_exports__,
            __webpack_require__
        ) {
            'use strict'
            __webpack_require__.r(__webpack_exports__)
            var app_namespaceObject = {}
            __webpack_require__.r(app_namespaceObject)
            __webpack_require__.d(app_namespaceObject, 'default', function() {
                return app
            })

            // EXTERNAL MODULE: external "url"
            var external_url_ = __webpack_require__('bzos')

            // EXTERNAL MODULE: external "querystring"
            var external_querystring_ = __webpack_require__('8xkj')

            // EXTERNAL MODULE: ./node_modules/next/dist/next-server/server/render.js
            var render = __webpack_require__('/bjS')

            // EXTERNAL MODULE: ./node_modules/next/dist/next-server/server/send-html.js
            var send_html = __webpack_require__('LuNM')

            // EXTERNAL MODULE: ./node_modules/next/dist/build/webpack/loaders/next-plugin-loader.js?middleware=on-init-server
            var next_plugin_loadermiddleware_on_init_server = __webpack_require__(
                'GX0O'
            )

            // EXTERNAL MODULE: ./node_modules/next/dist/build/webpack/loaders/next-plugin-loader.js?middleware=on-error-server
            var next_plugin_loadermiddleware_on_error_server = __webpack_require__(
                'KqAr'
            )

            // EXTERNAL MODULE: ./.next/build-manifest.json
            var build_manifest = __webpack_require__('LZ9C')

            // EXTERNAL MODULE: ./.next/react-loadable-manifest.json
            var react_loadable_manifest = __webpack_require__('67Bq')

            // EXTERNAL MODULE: ./node_modules/next/dist/pages/_document.js
            var _document = __webpack_require__('VDXt')
            var _document_default = /*#__PURE__*/ __webpack_require__.n(
                _document
            )

            // EXTERNAL MODULE: ./node_modules/next/dist/pages/_error.js
            var _error = __webpack_require__('/a9y')
            var _error_default = /*#__PURE__*/ __webpack_require__.n(_error)

            // EXTERNAL MODULE: ./node_modules/next/dist/pages/_app.js
            var _app = __webpack_require__('B5Ud')
            var _app_default = /*#__PURE__*/ __webpack_require__.n(_app)

            // EXTERNAL MODULE: ./node_modules/styled-jsx/style.js
            var style = __webpack_require__('MX0m')
            var style_default = /*#__PURE__*/ __webpack_require__.n(style)

            // EXTERNAL MODULE: ./node_modules/react/index.js
            var react = __webpack_require__('q1tI')
            var react_default = /*#__PURE__*/ __webpack_require__.n(react)

            // EXTERNAL MODULE: ./lib/auth0.js
            var auth0 = __webpack_require__('2NqA')

            // EXTERNAL MODULE: ./src/components/index.tsx + 5 modules
            var components = __webpack_require__('7cJT')

            // EXTERNAL MODULE: ./src/context/index.tsx + 2 modules
            var context = __webpack_require__('2ZRA')

            // CONCATENATED MODULE: ./src/pages/app.tsx

            var __jsx = react_default.a.createElement

            const App = () =>
                __jsx(
                    context['b' /* ShoppingItemProvider */],
                    null,
                    __jsx(
                        components['c' /* Layout */],
                        null,
                        __jsx(
                            'div',
                            {
                                className: 'jsx-4115270823' + ' ' + 'hero'
                            },
                            __jsx(
                                'h1',
                                {
                                    className: 'jsx-4115270823' + ' ' + 'title'
                                },
                                'Shopping List'
                            ),
                            __jsx(
                                'section',
                                {
                                    role: 'section',
                                    className:
                                        'jsx-4115270823' + ' ' + 'container'
                                },
                                __jsx(components['a' /* ItemForm */], null),
                                __jsx(components['b' /* ItemList */], null)
                            )
                        ),
                        __jsx(
                            style_default.a,
                            {
                                id: '4115270823'
                            },
                            [
                                '.container.jsx-4115270823{-webkit-box-shadow:3px 2px 11px -8px rgba(20,20,20,1);-moz-box-shadow:3px 2px 11px -8px rgba(20,20,20,1);box-shadow:3px 2px 11px -8px rgba(20,20,20,1);border-radius:10px;margin:0 auto;max-width:325px;padding:30px;}',
                                '.hero.jsx-4115270823{width:100%;color:#333;}',
                                '.title.jsx-4115270823{font-size:48px;line-height:1.15;margin:0;padding:20px 0;width:100%;}',
                                '.title.jsx-4115270823,.description.jsx-4115270823{text-align:center;}'
                            ]
                        )
                    )
                )

            App.getInitialProps = async ({ req, res }) => {
                return auth0['a' /* default */].getSession(req).then(data => {
                    if (data === null) {
                        res.writeHead(302, {
                            Location: '/api/auth/login'
                        })
                        res.end()
                        return
                    }

                    return data
                })
            }

            /* harmony default export */ var app = App
            // CONCATENATED MODULE: ./node_modules/next/dist/build/webpack/loaders/next-serverless-loader.js?page=%2Fapp&absolutePagePath=private-next-pages%2Fapp.tsx&absoluteAppPath=next%2Fdist%2Fpages%2F_app&absoluteDocumentPath=next%2Fdist%2Fpages%2F_document&absoluteErrorPath=next%2Fdist%2Fpages%2F_error&distDir=private-dot-next&buildId=me-5Y03jN4uNGCmg33LkP&assetPrefix=&generateEtags=true&ampBindInitData=false&canonicalBase=
            /* harmony export (binding) */ __webpack_require__.d(
                __webpack_exports__,
                'unstable_getStaticProps',
                function() {
                    return unstable_getStaticProps
                }
            )
            /* harmony export (binding) */ __webpack_require__.d(
                __webpack_exports__,
                'config',
                function() {
                    return config
                }
            )
            /* harmony export (binding) */ __webpack_require__.d(
                __webpack_exports__,
                '_app',
                function() {
                    return next_serverless_loaderpage_2Fapp_absolutePagePath_private_next_pages_2Fapp_tsx_absoluteAppPath_next_2Fdist_2Fpages_2F_app_absoluteDocumentPath_next_2Fdist_2Fpages_2F_document_absoluteErrorPath_next_2Fdist_2Fpages_2F_error_distDir_private_dot_next_buildId_me_5Y03jN4uNGCmg33LkP_assetPrefix_generateEtags_true_ampBindInitData_false_canonicalBase_app
                }
            )
            /* harmony export (binding) */ __webpack_require__.d(
                __webpack_exports__,
                'renderReqToHTML',
                function() {
                    return renderReqToHTML
                }
            )
            /* harmony export (binding) */ __webpack_require__.d(
                __webpack_exports__,
                'render',
                function() {
                    return next_serverless_loaderpage_2Fapp_absolutePagePath_private_next_pages_2Fapp_tsx_absoluteAppPath_next_2Fdist_2Fpages_2F_app_absoluteDocumentPath_next_2Fdist_2Fpages_2F_document_absoluteErrorPath_next_2Fdist_2Fpages_2F_error_distDir_private_dot_next_buildId_me_5Y03jN4uNGCmg33LkP_assetPrefix_generateEtags_true_ampBindInitData_false_canonicalBase_render
                }
            )

            const Component = app
            /* harmony default export */ var next_serverless_loaderpage_2Fapp_absolutePagePath_private_next_pages_2Fapp_tsx_absoluteAppPath_next_2Fdist_2Fpages_2F_app_absoluteDocumentPath_next_2Fdist_2Fpages_2F_document_absoluteErrorPath_next_2Fdist_2Fpages_2F_error_distDir_private_dot_next_buildId_me_5Y03jN4uNGCmg33LkP_assetPrefix_generateEtags_true_ampBindInitData_false_canonicalBase_ = (__webpack_exports__[
                'default'
            ] = Component)
            const unstable_getStaticProps =
                app_namespaceObject['unstable_getStaticProp' + 's']

            const config = app_namespaceObject['confi' + 'g'] || {}
            const next_serverless_loaderpage_2Fapp_absolutePagePath_private_next_pages_2Fapp_tsx_absoluteAppPath_next_2Fdist_2Fpages_2F_app_absoluteDocumentPath_next_2Fdist_2Fpages_2F_document_absoluteErrorPath_next_2Fdist_2Fpages_2F_error_distDir_private_dot_next_buildId_me_5Y03jN4uNGCmg33LkP_assetPrefix_generateEtags_true_ampBindInitData_false_canonicalBase_app =
                _app_default.a
            async function renderReqToHTML(req, res, fromExport) {
                const options = {
                    App: _app_default.a,
                    Document: _document_default.a,
                    buildManifest: build_manifest,
                    unstable_getStaticProps,
                    reactLoadableManifest: react_loadable_manifest,
                    canonicalBase: '',
                    buildId: 'me-5Y03jN4uNGCmg33LkP',
                    assetPrefix: '',
                    ampBindInitData: false
                }
                let sprData = false

                if (req.url.match(/_next\/data/)) {
                    sprData = true
                    req.url = req.url
                        .replace(
                            new RegExp('/_next/data/me-5Y03jN4uNGCmg33LkP/'),
                            '/'
                        )
                        .replace(/\.json$/, '')
                }
                const parsedUrl = Object(external_url_['parse'])(req.url, true)
                const renderOpts = Object.assign(
                    {
                        Component,
                        pageConfig: config,
                        dataOnly:
                            req.headers &&
                            (req.headers.accept || '').indexOf(
                                'application/amp.bind+json'
                            ) !== -1,
                        nextExport: fromExport
                    },
                    options
                )
                try {
                    const params = {}
                    const nowParams = null
                    let result = await Object(render['renderToHTML'])(
                        req,
                        res,
                        '/app',
                        Object.assign(
                            {},
                            unstable_getStaticProps ? {} : parsedUrl.query,
                            nowParams ? nowParams : params,
                            sprData ? { _nextSprData: '1' } : {}
                        ),
                        renderOpts
                    )

                    if (sprData && !fromExport) {
                        const payload = JSON.stringify(renderOpts.sprData)
                        res.setHeader('Content-Type', 'application/json')
                        res.setHeader(
                            'Content-Length',
                            Buffer.byteLength(payload)
                        )
                        res.setHeader(
                            'Cache-Control',
                            `s-maxage=${renderOpts.revalidate}, stale-while-revalidate`
                        )
                        res.end(payload)
                        return null
                    }

                    if (fromExport) return { html: result, renderOpts }
                    return result
                } catch (err) {
                    if (err.code === 'ENOENT') {
                        res.statusCode = 404
                        const result = await Object(render['renderToHTML'])(
                            req,
                            res,
                            '/_error',
                            parsedUrl.query,
                            Object.assign({}, options, {
                                Component: _error_default.a
                            })
                        )
                        return result
                    } else {
                        console.error(err)
                        res.statusCode = 500
                        const result = await Object(render['renderToHTML'])(
                            req,
                            res,
                            '/_error',
                            parsedUrl.query,
                            Object.assign({}, options, {
                                Component: _error_default.a,
                                err
                            })
                        )
                        return result
                    }
                }
            }
            async function next_serverless_loaderpage_2Fapp_absolutePagePath_private_next_pages_2Fapp_tsx_absoluteAppPath_next_2Fdist_2Fpages_2F_app_absoluteDocumentPath_next_2Fdist_2Fpages_2F_document_absoluteErrorPath_next_2Fdist_2Fpages_2F_error_distDir_private_dot_next_buildId_me_5Y03jN4uNGCmg33LkP_assetPrefix_generateEtags_true_ampBindInitData_false_canonicalBase_render(
                req,
                res
            ) {
                try {
                    await Object(
                        next_plugin_loadermiddleware_on_init_server['default']
                    )()
                    const html = await renderReqToHTML(req, res)
                    if (html) {
                        Object(send_html['sendHTML'])(req, res, html, {
                            generateEtags: true
                        })
                    }
                } catch (err) {
                    await Object(
                        next_plugin_loadermiddleware_on_error_server['default']
                    )(err)
                    console.error(err)
                    res.statusCode = 500
                    res.end('Internal Server Error')
                }
            }

            /***/
        },

        /***/ qArv: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$defineProperty = __webpack_require__('hfKm')

            var __importStar =
                (this && this.__importStar) ||
                function(mod) {
                    if (mod && mod.__esModule) return mod
                    var result = {}
                    if (mod != null)
                        for (var k in mod)
                            if (Object.hasOwnProperty.call(mod, k))
                                result[k] = mod[k]
                    result['default'] = mod
                    return result
                }

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            const React = __importStar(__webpack_require__('q1tI'))

            exports.DataManagerContext = React.createContext(null)

            /***/
        },

        /***/ qIYm: /***/ function(module, exports) {
            function webpackEmptyContext(req) {
                var e = new Error("Cannot find module '" + req + "'")
                e.code = 'MODULE_NOT_FOUND'
                throw e
            }
            webpackEmptyContext.keys = function() {
                return []
            }
            webpackEmptyContext.resolve = webpackEmptyContext
            module.exports = webpackEmptyContext
            webpackEmptyContext.id = 'qIYm'

            /***/
        },

        /***/ qOIg: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$defineProperty = __webpack_require__('hfKm')

            var __importStar =
                (this && this.__importStar) ||
                function(mod) {
                    if (mod && mod.__esModule) return mod
                    var result = {}
                    if (mod != null)
                        for (var k in mod)
                            if (Object.hasOwnProperty.call(mod, k))
                                result[k] = mod[k]
                    result['default'] = mod
                    return result
                }

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            const React = __importStar(__webpack_require__('q1tI'))

            exports.RouterContext = React.createContext(null)

            /***/
        },

        /***/ qQzh: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tslib_1 = __webpack_require__('zOht')
            const iron_1 = tslib_1.__importDefault(__webpack_require__('ClL1'))
            const session_1 = tslib_1.__importDefault(
                __webpack_require__('gt9x')
            )
            const cookies_1 = __webpack_require__('gKi1')
            class CookieSessionStore {
                constructor(settings) {
                    this.settings = settings
                }
                /**
                 * Read the session from the cookie.
                 * @param req HTTP request
                 */
                read(req) {
                    return tslib_1.__awaiter(this, void 0, void 0, function*() {
                        const { cookieSecret, cookieName } = this.settings
                        const cookies = cookies_1.parseCookies(req)
                        const cookie = cookies[cookieName]
                        if (!cookie || cookie.length === 0) {
                            return null
                        }
                        const unsealed = yield iron_1.default.unseal(
                            cookies[cookieName],
                            cookieSecret,
                            iron_1.default.defaults
                        )
                        if (!unsealed) {
                            return null
                        }
                        return unsealed
                    })
                }
                /**
                 * Write the session to the cookie.
                 * @param req HTTP request
                 */
                save(req, res, session) {
                    return tslib_1.__awaiter(this, void 0, void 0, function*() {
                        const {
                            cookieSecret,
                            cookieName,
                            cookiePath,
                            cookieLifetime
                        } = this.settings
                        const {
                            idToken,
                            accessToken,
                            refreshToken,
                            user,
                            createdAt
                        } = session
                        const persistedSession = new session_1.default(
                            user,
                            createdAt
                        )
                        if (this.settings.storeIdToken && idToken) {
                            persistedSession.idToken = idToken
                        }
                        if (this.settings.storeAccessToken && accessToken) {
                            persistedSession.accessToken = accessToken
                        }
                        if (this.settings.storeRefreshToken && refreshToken) {
                            persistedSession.refreshToken = refreshToken
                        }
                        const encryptedSession = yield iron_1.default.seal(
                            persistedSession,
                            cookieSecret,
                            iron_1.default.defaults
                        )
                        cookies_1.setCookie(req, res, {
                            name: cookieName,
                            value: encryptedSession,
                            path: cookiePath,
                            maxAge: cookieLifetime
                        })
                    })
                }
            }
            exports.default = CookieSessionStore
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ qSBP: /***/ function(module, exports, __webpack_require__) {
            const { inspect } = __webpack_require__('jK02')

            const Key = __webpack_require__('//Cd')

            class NoneKey extends Key {
                constructor() {
                    super({ type: 'unsecured' }, { alg: 'none' })
                    Object.defineProperties(this, {
                        kid: { value: undefined },
                        thumbprint: { value: undefined },
                        toJWK: { value: undefined },
                        toPEM: { value: undefined }
                    })
                }

                /* c8 ignore next 3 */
                [inspect.custom]() {
                    return 'None {}'
                }

                algorithms(operation) {
                    switch (operation) {
                        case 'sign':
                        case 'verify':
                        case undefined:
                            return new Set(['none'])
                        default:
                            return new Set()
                    }
                }
            }

            module.exports = new NoneKey({ type: 'unsecured' }, { alg: 'none' })

            /***/
        },

        /***/ qXE0: /***/ function(module, exports, __webpack_require__) {
            const verify = __webpack_require__('BOd6')

            module.exports = {
                IdToken: {
                    verify: (token, key, options) =>
                        verify(token, key, { ...options, profile: 'id_token' })
                },
                LogoutToken: {
                    verify: (token, key, options) =>
                        verify(token, key, {
                            ...options,
                            profile: 'logout_token'
                        })
                },
                AccessToken: {
                    verify: (token, key, options) =>
                        verify(token, key, { ...options, profile: 'at+JWT' })
                }
            }

            /***/
        },

        /***/ qZTm: /***/ function(module, exports, __webpack_require__) {
            var baseGetAllKeys = __webpack_require__('fR/l'),
                getSymbols = __webpack_require__('MvSz'),
                keys = __webpack_require__('7GkX')

            /**
             * Creates an array of own enumerable property names and symbols of `object`.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Array} Returns the array of property names and symbols.
             */
            function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols)
            }

            module.exports = getAllKeys

            /***/
        },

        /***/ qnp3: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const Types = __webpack_require__('gdNv')
            const Utils = __webpack_require__('O0PD')

            const internals = {
                needsProtoHack: new Set([
                    Types.set,
                    Types.map,
                    Types.weakSet,
                    Types.weakMap
                ])
            }

            module.exports = internals.clone = function(
                obj,
                options = {},
                _seen = null
            ) {
                if (typeof obj !== 'object' || obj === null) {
                    return obj
                }

                let clone = internals.clone
                let seen = _seen

                if (options.shallow) {
                    if (options.shallow !== true) {
                        return internals.cloneWithShallow(obj, options)
                    }

                    clone = value => value
                } else {
                    seen = seen || new Map()

                    const lookup = seen.get(obj)
                    if (lookup) {
                        return lookup
                    }
                }

                // Built-in object types

                const baseProto = Types.getInternalProto(obj)
                if (baseProto === Types.buffer) {
                    return Buffer && Buffer.from(obj) // $lab:coverage:ignore$
                }

                if (baseProto === Types.date) {
                    return new Date(obj.getTime())
                }

                if (baseProto === Types.regex) {
                    return new RegExp(obj)
                }

                // Generic objects

                const newObj = internals.base(obj, baseProto, options)
                if (newObj === obj) {
                    return obj
                }

                if (seen) {
                    seen.set(obj, newObj) // Set seen, since obj could recurse
                }

                if (baseProto === Types.set) {
                    for (const value of obj) {
                        newObj.add(clone(value, options, seen))
                    }
                } else if (baseProto === Types.map) {
                    for (const [key, value] of obj) {
                        newObj.set(key, clone(value, options, seen))
                    }
                }

                const keys = Utils.keys(obj, options)
                for (const key of keys) {
                    if (key === '__proto__') {
                        continue
                    }

                    if (baseProto === Types.array && key === 'length') {
                        newObj.length = obj.length
                        continue
                    }

                    const descriptor = Object.getOwnPropertyDescriptor(obj, key)
                    if (descriptor) {
                        if (descriptor.get || descriptor.set) {
                            Object.defineProperty(newObj, key, descriptor)
                        } else if (descriptor.enumerable) {
                            newObj[key] = clone(obj[key], options, seen)
                        } else {
                            Object.defineProperty(newObj, key, {
                                enumerable: false,
                                writable: true,
                                configurable: true,
                                value: clone(obj[key], options, seen)
                            })
                        }
                    } else {
                        Object.defineProperty(newObj, key, {
                            enumerable: true,
                            writable: true,
                            configurable: true,
                            value: clone(obj[key], options, seen)
                        })
                    }
                }

                return newObj
            }

            internals.cloneWithShallow = function(source, options) {
                const keys = options.shallow
                options = Object.assign({}, options)
                options.shallow = false

                const storage = Utils.store(source, keys) // Move shallow copy items to storage
                const copy = internals.clone(source, options) // Deep copy the rest
                Utils.restore(copy, source, storage) // Shallow copy the stored items and restore
                return copy
            }

            internals.base = function(obj, baseProto, options) {
                if (baseProto === Types.array) {
                    return []
                }

                if (options.prototype === false) {
                    // Defaults to true
                    if (internals.needsProtoHack.has(baseProto)) {
                        return new baseProto.constructor()
                    }

                    return {}
                }

                const proto = Object.getPrototypeOf(obj)
                if (proto && proto.isImmutable) {
                    return obj
                }

                if (internals.needsProtoHack.has(baseProto)) {
                    const newObj = new proto.constructor()
                    if (proto !== baseProto) {
                        Object.setPrototypeOf(newObj, proto)
                    }

                    return newObj
                }

                return Object.create(proto)
            }

            /***/
        },

        /***/ qsvm: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            // We define these manually to ensure they're always copied
            // even if they would move up the prototype chain
            // https://nodejs.org/api/http.html#http_class_http_incomingmessage
            const knownProps = [
                'destroy',
                'setTimeout',
                'socket',
                'headers',
                'trailers',
                'rawHeaders',
                'statusCode',
                'httpVersion',
                'httpVersionMinor',
                'httpVersionMajor',
                'rawTrailers',
                'statusMessage'
            ]

            module.exports = (fromStream, toStream) => {
                const fromProps = new Set(
                    Object.keys(fromStream).concat(knownProps)
                )

                for (const prop of fromProps) {
                    // Don't overwrite existing properties
                    if (prop in toStream) {
                        continue
                    }

                    toStream[prop] =
                        typeof fromStream[prop] === 'function'
                            ? fromStream[prop].bind(fromStream)
                            : fromStream[prop]
                }
            }

            /***/
        },

        /***/ qwdb: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            function initAuth0(settings) {
                const isBrowser = typeof window !== 'undefined' || false
                if (isBrowser) {
                    return __webpack_require__('6gLP').default(settings)
                }
                return __webpack_require__('+du+').default(settings)
            }
            exports.initAuth0 = initAuth0
            /**
             * @deprecated useAuth0 has been deprecated in favor of initAuth0
             */
            exports.useAuth0 = initAuth0
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ rEGp: /***/ function(module, exports) {
            /**
             * Converts `set` to an array of its values.
             *
             * @private
             * @param {Object} set The set to convert.
             * @returns {Array} Returns the values.
             */
            function setToArray(set) {
                var index = -1,
                    result = Array(set.size)

                set.forEach(function(value) {
                    result[++index] = value
                })
                return result
            }

            module.exports = setToArray

            /***/
        },

        /***/ rMgD: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = internals.Bench = class {
                constructor() {
                    this.ts = 0
                    this.reset()
                }

                reset() {
                    this.ts = internals.Bench.now()
                }

                elapsed() {
                    return internals.Bench.now() - this.ts
                }

                static now() {
                    const ts = process.hrtime()
                    return ts[0] * 1e3 + ts[1] / 1e6
                }
            }

            /***/
        },

        /***/ raTm: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var global = __webpack_require__('5T2Y')
            var $export = __webpack_require__('Y7ZC')
            var meta = __webpack_require__('6/1s')
            var fails = __webpack_require__('KUxP')
            var hide = __webpack_require__('NegM')
            var redefineAll = __webpack_require__('XJU/')
            var forOf = __webpack_require__('oioR')
            var anInstance = __webpack_require__('EXMj')
            var isObject = __webpack_require__('93I4')
            var setToStringTag = __webpack_require__('RfKB')
            var dP = __webpack_require__('2faE').f
            var each = __webpack_require__('V7Et')(0)
            var DESCRIPTORS = __webpack_require__('jmDH')

            module.exports = function(
                NAME,
                wrapper,
                methods,
                common,
                IS_MAP,
                IS_WEAK
            ) {
                var Base = global[NAME]
                var C = Base
                var ADDER = IS_MAP ? 'set' : 'add'
                var proto = C && C.prototype
                var O = {}
                if (
                    !DESCRIPTORS ||
                    typeof C != 'function' ||
                    !(
                        IS_WEAK ||
                        (proto.forEach &&
                            !fails(function() {
                                new C().entries().next()
                            }))
                    )
                ) {
                    // create collection constructor
                    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER)
                    redefineAll(C.prototype, methods)
                    meta.NEED = true
                } else {
                    C = wrapper(function(target, iterable) {
                        anInstance(target, C, NAME, '_c')
                        target._c = new Base()
                        if (iterable != undefined)
                            forOf(iterable, IS_MAP, target[ADDER], target)
                    })
                    each(
                        'add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(
                            ','
                        ),
                        function(KEY) {
                            var IS_ADDER = KEY == 'add' || KEY == 'set'
                            if (KEY in proto && !(IS_WEAK && KEY == 'clear'))
                                hide(C.prototype, KEY, function(a, b) {
                                    anInstance(this, C, KEY)
                                    if (!IS_ADDER && IS_WEAK && !isObject(a))
                                        return KEY == 'get' ? undefined : false
                                    var result = this._c[KEY](
                                        a === 0 ? 0 : a,
                                        b
                                    )
                                    return IS_ADDER ? this : result
                                })
                        }
                    )
                    IS_WEAK ||
                        dP(C.prototype, 'size', {
                            get: function() {
                                return this._c.size
                            }
                        })
                }

                setToStringTag(C, NAME)

                O[NAME] = C
                $export($export.G + $export.W + $export.F, O)

                if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP)

                return C
            }

            /***/
        },

        /***/ rr1i: /***/ function(module, exports) {
            module.exports = function(bitmap, value) {
                return {
                    enumerable: !(bitmap & 1),
                    configurable: !(bitmap & 2),
                    writable: !(bitmap & 4),
                    value: value
                }
            }

            /***/
        },

        /***/ s8OG: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = internals.flatten = function(array, target) {
                const result = target || []

                for (let i = 0; i < array.length; ++i) {
                    if (Array.isArray(array[i])) {
                        internals.flatten(array[i], result)
                    } else {
                        result.push(array[i])
                    }
                }

                return result
            }

            /***/
        },

        /***/ sEf8: /***/ function(module, exports) {
            /**
             * The base implementation of `_.unary` without support for storing metadata.
             *
             * @private
             * @param {Function} func The function to cap arguments for.
             * @returns {Function} Returns the new capped function.
             */
            function baseUnary(func) {
                return function(value) {
                    return func(value)
                }
            }

            module.exports = baseUnary

            /***/
        },

        /***/ sNwI: /***/ function(module, exports, __webpack_require__) {
            // call something on iterator step with safe closing on error
            var anObject = __webpack_require__('5K7Z')
            module.exports = function(iterator, fn, value, entries) {
                try {
                    return entries
                        ? fn(anObject(value)[0], value[1])
                        : fn(value)
                    // 7.4.6 IteratorClose(iterator, completion)
                } catch (e) {
                    var ret = iterator['return']
                    if (ret !== undefined) anObject(ret.call(iterator))
                    throw e
                }
            }

            /***/
        },

        /***/ 'sR+5': /***/ function(module, exports, __webpack_require__) {
            const Sign = __webpack_require__('l3Iq')
            const { verify } = __webpack_require__('ZXG7')

            const single = (
                serialization,
                payload,
                key,
                protectedHeader,
                unprotectedHeader
            ) => {
                return new Sign(payload)
                    .recipient(key, protectedHeader, unprotectedHeader)
                    .sign(serialization)
            }

            module.exports.Sign = Sign
            module.exports.sign = single.bind(undefined, 'compact')
            module.exports.sign.flattened = single.bind(undefined, 'flattened')
            module.exports.sign.general = single.bind(undefined, 'general')

            module.exports.verify = verify

            /***/
        },

        /***/ seXi: /***/ function(module, exports, __webpack_require__) {
            var getAllKeys = __webpack_require__('qZTm')

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * A specialized version of `baseIsEqualDeep` for objects with support for
             * partial deep comparisons.
             *
             * @private
             * @param {Object} object The object to compare.
             * @param {Object} other The other object to compare.
             * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
             * @param {Function} customizer The function to customize comparisons.
             * @param {Function} equalFunc The function to determine equivalents of values.
             * @param {Object} stack Tracks traversed `object` and `other` objects.
             * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
             */
            function equalObjects(
                object,
                other,
                bitmask,
                customizer,
                equalFunc,
                stack
            ) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                    objProps = getAllKeys(object),
                    objLength = objProps.length,
                    othProps = getAllKeys(other),
                    othLength = othProps.length

                if (objLength != othLength && !isPartial) {
                    return false
                }
                var index = objLength
                while (index--) {
                    var key = objProps[index]
                    if (
                        !(isPartial
                            ? key in other
                            : hasOwnProperty.call(other, key))
                    ) {
                        return false
                    }
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object)
                if (stacked && stack.get(other)) {
                    return stacked == other
                }
                var result = true
                stack.set(object, other)
                stack.set(other, object)

                var skipCtor = isPartial
                while (++index < objLength) {
                    key = objProps[index]
                    var objValue = object[key],
                        othValue = other[key]

                    if (customizer) {
                        var compared = isPartial
                            ? customizer(
                                  othValue,
                                  objValue,
                                  key,
                                  other,
                                  object,
                                  stack
                              )
                            : customizer(
                                  objValue,
                                  othValue,
                                  key,
                                  object,
                                  other,
                                  stack
                              )
                    }
                    // Recursively compare objects (susceptible to call stack limits).
                    if (
                        !(compared === undefined
                            ? objValue === othValue ||
                              equalFunc(
                                  objValue,
                                  othValue,
                                  bitmask,
                                  customizer,
                                  stack
                              )
                            : compared)
                    ) {
                        result = false
                        break
                    }
                    skipCtor || (skipCtor = key == 'constructor')
                }
                if (result && !skipCtor) {
                    var objCtor = object.constructor,
                        othCtor = other.constructor

                    // Non `Object` object instances with different constructors are not equal.
                    if (
                        objCtor != othCtor &&
                        'constructor' in object && 'constructor' in other &&
                        !(
                            typeof objCtor == 'function' &&
                            objCtor instanceof objCtor &&
                            typeof othCtor == 'function' &&
                            othCtor instanceof othCtor
                        )
                    ) {
                        result = false
                    }
                }
                stack['delete'](object)
                stack['delete'](other)
                return result
            }

            module.exports = equalObjects

            /***/
        },

        /***/ shjB: /***/ function(module, exports) {
            /** Used as references for various `Number` constants. */
            var MAX_SAFE_INTEGER = 9007199254740991

            /**
             * Checks if `value` is a valid array-like length.
             *
             * **Note:** This method is loosely based on
             * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
             *
             * @static
             * @memberOf _
             * @since 4.0.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
             * @example
             *
             * _.isLength(3);
             * // => true
             *
             * _.isLength(Number.MIN_VALUE);
             * // => false
             *
             * _.isLength(Infinity);
             * // => false
             *
             * _.isLength('3');
             * // => false
             */
            function isLength(value) {
                return (
                    typeof value == 'number' &&
                    value > -1 &&
                    value % 1 == 0 &&
                    value <= MAX_SAFE_INTEGER
                )
            }

            module.exports = isLength

            /***/
        },

        /***/ t2Dn: /***/ function(module, exports, __webpack_require__) {
            var baseAssignValue = __webpack_require__('hypo'),
                eq = __webpack_require__('ljhN')

            /**
             * This function is like `assignValue` except that it doesn't assign
             * `undefined` values.
             *
             * @private
             * @param {Object} object The object to modify.
             * @param {string} key The key of the property to assign.
             * @param {*} value The value to assign.
             */
            function assignMergeValue(object, key, value) {
                if (
                    (value !== undefined && !eq(object[key], value)) ||
                    (value === undefined && !(key in object))
                ) {
                    baseAssignValue(object, key, value)
                }
            }

            module.exports = assignMergeValue

            /***/
        },

        /***/ tCGZ: /***/ function(module) {
            module.exports = JSON.parse(
                '{"name":"got","version":"9.6.0","description":"Simplified HTTP requests","license":"MIT","repository":"sindresorhus/got","main":"source","engines":{"node":">=8.6"},"scripts":{"test":"xo && nyc ava","release":"np"},"files":["source"],"keywords":["http","https","get","got","url","uri","request","util","utility","simple","curl","wget","fetch","net","network","electron"],"dependencies":{"@sindresorhus/is":"^0.14.0","@szmarczak/http-timer":"^1.1.2","cacheable-request":"^6.0.0","decompress-response":"^3.3.0","duplexer3":"^0.1.4","get-stream":"^4.1.0","lowercase-keys":"^1.0.1","mimic-response":"^1.0.1","p-cancelable":"^1.0.0","to-readable-stream":"^1.0.0","url-parse-lax":"^3.0.0"},"devDependencies":{"ava":"^1.1.0","coveralls":"^3.0.0","delay":"^4.1.0","form-data":"^2.3.3","get-port":"^4.0.0","np":"^3.1.0","nyc":"^13.1.0","p-event":"^2.1.0","pem":"^1.13.2","proxyquire":"^2.0.1","sinon":"^7.2.2","slow-stream":"0.0.4","tempfile":"^2.0.0","tempy":"^0.2.1","tough-cookie":"^3.0.0","xo":"^0.24.0"},"ava":{"concurrency":4},"browser":{"decompress-response":false,"electron":false}}'
            )

            /***/
        },

        /***/ tEej: /***/ function(module, exports, __webpack_require__) {
            // 7.1.15 ToLength
            var toInteger = __webpack_require__('Ojgd')
            var min = Math.min
            module.exports = function(it) {
                return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0 // pow(2, 53) - 1 == 9007199254740991
            }

            /***/
        },

        /***/ tMB7: /***/ function(module, exports, __webpack_require__) {
            var assocIndexOf = __webpack_require__('y1pI')

            /**
             * Gets the list cache value for `key`.
             *
             * @private
             * @name get
             * @memberOf ListCache
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function listCacheGet(key) {
                var data = this.__data__,
                    index = assocIndexOf(data, key)

                return index < 0 ? undefined : data[index][1]
            }

            module.exports = listCacheGet

            /***/
        },

        /***/ tQ2B: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')
            var settle = __webpack_require__('Rn+g')
            var buildURL = __webpack_require__('MLWZ')
            var buildFullPath = __webpack_require__('g7np')
            var parseHeaders = __webpack_require__('w0Vi')
            var isURLSameOrigin = __webpack_require__('OTTw')
            var createError = __webpack_require__('LYNF')

            module.exports = function xhrAdapter(config) {
                return new Promise(function dispatchXhrRequest(
                    resolve,
                    reject
                ) {
                    var requestData = config.data
                    var requestHeaders = config.headers

                    if (utils.isFormData(requestData)) {
                        delete requestHeaders['Content-Type'] // Let the browser set it
                    }

                    var request = new XMLHttpRequest()

                    // HTTP basic authentication
                    if (config.auth) {
                        var username = config.auth.username || ''
                        var password = config.auth.password || ''
                        requestHeaders.Authorization =
                            'Basic ' + btoa(username + ':' + password)
                    }

                    var fullPath = buildFullPath(config.baseURL, config.url)
                    request.open(
                        config.method.toUpperCase(),
                        buildURL(
                            fullPath,
                            config.params,
                            config.paramsSerializer
                        ),
                        true
                    )

                    // Set the request timeout in MS
                    request.timeout = config.timeout

                    // Listen for ready state
                    request.onreadystatechange = function handleLoad() {
                        if (!request || request.readyState !== 4) {
                            return
                        }

                        // The request errored out and we didn't get a response, this will be
                        // handled by onerror instead
                        // With one exception: request that using file: protocol, most browsers
                        // will return status as 0 even though it's a successful request
                        if (
                            request.status === 0 &&
                            !(
                                request.responseURL &&
                                request.responseURL.indexOf('file:') === 0
                            )
                        ) {
                            return
                        }

                        // Prepare the response
                        var responseHeaders =
                            'getAllResponseHeaders' in request
                                ? parseHeaders(request.getAllResponseHeaders())
                                : null
                        var responseData =
                            !config.responseType ||
                            config.responseType === 'text'
                                ? request.responseText
                                : request.response
                        var response = {
                            data: responseData,
                            status: request.status,
                            statusText: request.statusText,
                            headers: responseHeaders,
                            config: config,
                            request: request
                        }

                        settle(resolve, reject, response)

                        // Clean up request
                        request = null
                    }

                    // Handle browser request cancellation (as opposed to a manual cancellation)
                    request.onabort = function handleAbort() {
                        if (!request) {
                            return
                        }

                        reject(
                            createError(
                                'Request aborted',
                                config,
                                'ECONNABORTED',
                                request
                            )
                        )

                        // Clean up request
                        request = null
                    }

                    // Handle low level network errors
                    request.onerror = function handleError() {
                        // Real errors are hidden from us by the browser
                        // onerror should only fire if it's a network error
                        reject(
                            createError('Network Error', config, null, request)
                        )

                        // Clean up request
                        request = null
                    }

                    // Handle timeout
                    request.ontimeout = function handleTimeout() {
                        var timeoutErrorMessage =
                            'timeout of ' + config.timeout + 'ms exceeded'
                        if (config.timeoutErrorMessage) {
                            timeoutErrorMessage = config.timeoutErrorMessage
                        }
                        reject(
                            createError(
                                timeoutErrorMessage,
                                config,
                                'ECONNABORTED',
                                request
                            )
                        )

                        // Clean up request
                        request = null
                    }

                    // Add xsrf header
                    // This is only done if running in a standard browser environment.
                    // Specifically not if we're in a web worker, or react-native.
                    if (utils.isStandardBrowserEnv()) {
                        var cookies = __webpack_require__('eqyj')

                        // Add xsrf header
                        var xsrfValue =
                            (config.withCredentials ||
                                isURLSameOrigin(fullPath)) &&
                            config.xsrfCookieName
                                ? cookies.read(config.xsrfCookieName)
                                : undefined

                        if (xsrfValue) {
                            requestHeaders[config.xsrfHeaderName] = xsrfValue
                        }
                    }

                    // Add headers to the request
                    if ('setRequestHeader' in request) {
                        utils.forEach(requestHeaders, function setRequestHeader(
                            val,
                            key
                        ) {
                            if (
                                typeof requestData === 'undefined' &&
                                key.toLowerCase() === 'content-type'
                            ) {
                                // Remove Content-Type if data is undefined
                                delete requestHeaders[key]
                            } else {
                                // Otherwise add header to the request
                                request.setRequestHeader(key, val)
                            }
                        })
                    }

                    // Add withCredentials to request if needed
                    if (!utils.isUndefined(config.withCredentials)) {
                        request.withCredentials = !!config.withCredentials
                    }

                    // Add responseType to request if needed
                    if (config.responseType) {
                        try {
                            request.responseType = config.responseType
                        } catch (e) {
                            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
                            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
                            if (config.responseType !== 'json') {
                                throw e
                            }
                        }
                    }

                    // Handle progress if needed
                    if (typeof config.onDownloadProgress === 'function') {
                        request.addEventListener(
                            'progress',
                            config.onDownloadProgress
                        )
                    }

                    // Not all browsers support upload events
                    if (
                        typeof config.onUploadProgress === 'function' &&
                        request.upload
                    ) {
                        request.upload.addEventListener(
                            'progress',
                            config.onUploadProgress
                        )
                    }

                    if (config.cancelToken) {
                        // Handle cancellation
                        config.cancelToken.promise.then(function onCanceled(
                            cancel
                        ) {
                            if (!request) {
                                return
                            }

                            request.abort()
                            reject(cancel)
                            // Clean up request
                            request = null
                        })
                    }

                    if (requestData === undefined) {
                        requestData = null
                    }

                    // Send the request
                    request.send(requestData)
                })
            }

            /***/
        },

        /***/ tadb: /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5'),
                root = __webpack_require__('Kz5y')

            /* Built-in method references that are verified to be native. */
            var DataView = getNative(root, 'DataView')

            module.exports = DataView

            /***/
        },

        /***/ teXF: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const normalize_page_path_1 = __webpack_require__('w0zM')
            function getPageFiles(buildManifest, page) {
                const normalizedPage = normalize_page_path_1.normalizePagePath(
                    page
                )
                let files = buildManifest.pages[normalizedPage]
                if (!files) {
                    files =
                        buildManifest.pages[
                            normalizedPage.replace(/\/index$/, '') || '/'
                        ]
                }
                if (!files) {
                    // tslint:disable-next-line
                    console.warn(
                        `Could not find files for ${normalizedPage} in .next/build-manifest.json`
                    )
                    return []
                }
                return files
            }
            exports.getPageFiles = getPageFiles

            /***/
        },

        /***/ ttDY: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('+iuc')

            /***/
        },

        /***/ u88T: /***/ function(module, exports, __webpack_require__) {
            const asn1 = __webpack_require__('9ny7')

            const types = new Map()

            const AlgorithmIdentifier = asn1.define(
                'AlgorithmIdentifier',
                __webpack_require__('yAVD')
            )
            types.set('AlgorithmIdentifier', AlgorithmIdentifier)

            const ECPrivateKey = asn1.define(
                'ECPrivateKey',
                __webpack_require__('HKOu')
            )
            types.set('ECPrivateKey', ECPrivateKey)

            const PrivateKeyInfo = asn1.define(
                'PrivateKeyInfo',
                __webpack_require__('wEzw')(AlgorithmIdentifier)
            )
            types.set('PrivateKeyInfo', PrivateKeyInfo)

            const PublicKeyInfo = asn1.define(
                'PublicKeyInfo',
                __webpack_require__('pBmY')(AlgorithmIdentifier)
            )
            types.set('PublicKeyInfo', PublicKeyInfo)

            const PrivateKey = asn1.define(
                'PrivateKey',
                __webpack_require__('YFSu')
            )
            types.set('PrivateKey', PrivateKey)

            const OneAsymmetricKey = asn1.define(
                'OneAsymmetricKey',
                __webpack_require__('o/Eg')(AlgorithmIdentifier, PrivateKey)
            )
            types.set('OneAsymmetricKey', OneAsymmetricKey)

            const RSAPrivateKey = asn1.define(
                'RSAPrivateKey',
                __webpack_require__('Ra3S')
            )
            types.set('RSAPrivateKey', RSAPrivateKey)

            const RSAPublicKey = asn1.define(
                'RSAPublicKey',
                __webpack_require__('k9s9')
            )
            types.set('RSAPublicKey', RSAPublicKey)

            const OID = asn1.define('OID', function() {
                return this.objid()
            })
            types.set('OID', OID)

            module.exports = types

            /***/
        },

        /***/ u8Dt: /***/ function(module, exports, __webpack_require__) {
            var nativeCreate = __webpack_require__('YESw')

            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__'

            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Gets the hash value for `key`.
             *
             * @private
             * @name get
             * @memberOf Hash
             * @param {string} key The key of the value to get.
             * @returns {*} Returns the entry value.
             */
            function hashGet(key) {
                var data = this.__data__
                if (nativeCreate) {
                    var result = data[key]
                    return result === HASH_UNDEFINED ? undefined : result
                }
                return hasOwnProperty.call(data, key) ? data[key] : undefined
            }

            module.exports = hashGet

            /***/
        },

        /***/ uGJc: /***/ function(module, exports) {
            module.exports = alg => `sha${alg.substr(2, 3)}`

            /***/
        },

        /***/ uOPS: /***/ function(module, exports) {
            module.exports = true

            /***/
        },

        /***/ uWJx: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(array1, array2, options = {}) {
                if (!array1 || !array2) {
                    return options.first ? null : []
                }

                const common = []
                const hash = Array.isArray(array1) ? new Set(array1) : array1
                const found = new Set()
                for (const value of array2) {
                    if (internals.has(hash, value) && !found.has(value)) {
                        if (options.first) {
                            return value
                        }

                        common.push(value)
                        found.add(value)
                    }
                }

                return options.first ? null : common
            }

            internals.has = function(ref, key) {
                if (typeof ref.has === 'function') {
                    return ref.has(key)
                }

                return ref[key] !== undefined
            }

            /***/
        },

        /***/ ugmf: /***/ function(module, exports) {
            module.exports = require('tls')

            /***/
        },

        /***/ uk5n: /***/ function(module, exports, __webpack_require__) {
            const { createHash } = __webpack_require__('PJMN')

            const base64url = __webpack_require__('Xab3')

            const x5t = (hash, cert) =>
                base64url.encodeBuffer(
                    createHash(hash)
                        .update(Buffer.from(cert, 'base64'))
                        .digest()
                )

            module.exports.kid = components =>
                base64url.encodeBuffer(
                    createHash('sha256')
                        .update(JSON.stringify(components))
                        .digest()
                )
            module.exports.x5t = x5t.bind(undefined, 'sha1')
            module.exports['x5t#S256'] = x5t.bind(undefined, 'sha256')

            /***/
        },

        /***/ uplh: /***/ function(module, exports, __webpack_require__) {
            // all object keys, includes non-enumerable and symbols
            var gOPN = __webpack_require__('ar/p')
            var gOPS = __webpack_require__('mqlF')
            var anObject = __webpack_require__('5K7Z')
            var Reflect = __webpack_require__('5T2Y').Reflect
            module.exports =
                (Reflect && Reflect.ownKeys) ||
                function ownKeys(it) {
                    var keys = gOPN.f(anObject(it))
                    var getSymbols = gOPS.f
                    return getSymbols ? keys.concat(getSymbols(it)) : keys
                }

            /***/
        },

        /***/ urXW: /***/ function(module, exports, __webpack_require__) {
            const { JOSECritNotUnderstood, JWSInvalid } = __webpack_require__(
                'yt7c'
            )

            const DEFINED = new Set([
                'alg',
                'jku',
                'jwk',
                'kid',
                'x5u',
                'x5c',
                'x5t',
                'x5t#S256',
                'typ',
                'cty',
                'crit',
                'enc',
                'zip',
                'epk',
                'apu',
                'apv',
                'iv',
                'tag',
                'p2s',
                'p2c'
            ])

            module.exports = function validateCrit(
                Err,
                protectedHeader,
                unprotectedHeader,
                understood
            ) {
                if (protectedHeader && 'crit' in protectedHeader) {
                    if (
                        !Array.isArray(protectedHeader.crit) ||
                        protectedHeader.crit.length === 0 ||
                        protectedHeader.crit.some(
                            s => typeof s !== 'string' || !s
                        )
                    ) {
                        throw new Err(
                            '"crit" Header Parameter MUST be an array of non-empty strings when present'
                        )
                    }
                    const whitelisted = new Set(understood)
                    const combined = {
                        ...protectedHeader,
                        ...unprotectedHeader
                    }
                    protectedHeader.crit.forEach(parameter => {
                        if (DEFINED.has(parameter)) {
                            throw new Err(
                                `The critical list contains a non-extension Header Parameter ${parameter}`
                            )
                        }
                        if (!whitelisted.has(parameter)) {
                            throw new JOSECritNotUnderstood(
                                `critical "${parameter}" is not understood`
                            )
                        }
                        if (parameter === 'b64') {
                            if (!('b64' in protectedHeader)) {
                                throw new JWSInvalid(
                                    '"b64" critical parameter must be integrity protected'
                                )
                            }
                            if (typeof protectedHeader.b64 !== 'boolean') {
                                throw new JWSInvalid(
                                    '"b64" critical parameter must be a boolean'
                                )
                            }
                        } else if (!(parameter in combined)) {
                            throw new Err(
                                `critical parameter "${parameter}" is missing`
                            )
                        }
                    })
                }
                if (unprotectedHeader && 'crit' in unprotectedHeader) {
                    throw new Err(
                        '"crit" Header Parameter MUST be integrity protected when present'
                    )
                }
            }

            /***/
        },

        /***/ 'ut/Y': /***/ function(module, exports, __webpack_require__) {
            var baseMatches = __webpack_require__('ZCpW'),
                baseMatchesProperty = __webpack_require__('GDhZ'),
                identity = __webpack_require__('zZ0H'),
                isArray = __webpack_require__('Z0cm'),
                property = __webpack_require__('+c4W')

            /**
             * The base implementation of `_.iteratee`.
             *
             * @private
             * @param {*} [value=_.identity] The value to convert to an iteratee.
             * @returns {Function} Returns the iteratee.
             */
            function baseIteratee(value) {
                // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                if (typeof value == 'function') {
                    return value
                }
                if (value == null) {
                    return identity
                }
                if (typeof value == 'object') {
                    return isArray(value)
                        ? baseMatchesProperty(value[0], value[1])
                        : baseMatches(value)
                }
                return property(value)
            }

            module.exports = baseIteratee

            /***/
        },

        /***/ v5Dd: /***/ function(module, exports, __webpack_require__) {
            // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
            var toIObject = __webpack_require__('NsO/')
            var $getOwnPropertyDescriptor = __webpack_require__('vwuL').f

            __webpack_require__('zn7N')('getOwnPropertyDescriptor', function() {
                return function getOwnPropertyDescriptor(it, key) {
                    return $getOwnPropertyDescriptor(toIObject(it), key)
                }
            })

            /***/
        },

        /***/ v6xn: /***/ function(module, exports, __webpack_require__) {
            // 9.4.2.3 ArraySpeciesCreate(originalArray, length)
            var speciesConstructor = __webpack_require__('C2SN')

            module.exports = function(original, length) {
                return new (speciesConstructor(original))(length)
            }

            /***/
        },

        /***/ vBP9: /***/ function(module, exports, __webpack_require__) {
            var global = __webpack_require__('5T2Y')
            var navigator = global.navigator

            module.exports = (navigator && navigator.userAgent) || ''

            /***/
        },

        /***/ vC2k: /***/ function(module, exports, __webpack_require__) {
            const {
                generateKeyPairSync,
                generateKeyPair: async
            } = __webpack_require__('PJMN')
            const { promisify } = __webpack_require__('jK02')

            const {
                THUMBPRINT_MATERIAL,
                JWK_MEMBERS,
                PUBLIC_MEMBERS,
                PRIVATE_MEMBERS,
                KEY_MANAGEMENT_DECRYPT,
                KEY_MANAGEMENT_ENCRYPT
            } = __webpack_require__('ehsS')
            const { OKP_CURVES } = __webpack_require__('N+nT')
            const { edDSASupported } = __webpack_require__('pDDt')
            const errors = __webpack_require__('yt7c')

            const Key = __webpack_require__('//Cd')

            const generateKeyPair = promisify(async)

            const OKP_PUBLIC = new Set(['crv', 'x'])
            Object.freeze(OKP_PUBLIC)
            const OKP_PRIVATE = new Set([...OKP_PUBLIC, 'd'])
            Object.freeze(OKP_PRIVATE)

            // Octet string key pairs Key Type
            class OKPKey extends Key {
                constructor(...args) {
                    super(...args)

                    Object.defineProperties(this, {
                        kty: {
                            value: 'OKP',
                            enumerable: true
                        }
                    })
                    this[JWK_MEMBERS]()
                }

                static get [PUBLIC_MEMBERS]() {
                    return OKP_PUBLIC
                }

                static get [PRIVATE_MEMBERS]() {
                    return OKP_PRIVATE
                }

                // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special
                // JSON.stringify handling in V8
                [THUMBPRINT_MATERIAL]() {
                    return { crv: this.crv, kty: 'OKP', x: this.x }
                }

                [KEY_MANAGEMENT_ENCRYPT]() {
                    return this.algorithms('deriveKey')
                }

                [KEY_MANAGEMENT_DECRYPT]() {
                    if (this.public) {
                        return new Set()
                    }
                    return this.algorithms('deriveKey')
                }

                static async generate(crv = 'Ed25519', privat = true) {
                    if (!edDSASupported) {
                        throw new errors.JOSENotSupported(
                            'OKP keys are not supported in your Node.js runtime version'
                        )
                    }

                    if (!OKP_CURVES.has(crv)) {
                        throw new errors.JOSENotSupported(
                            `unsupported OKP key curve: ${crv}`
                        )
                    }

                    const { privateKey, publicKey } = await generateKeyPair(
                        crv.toLowerCase()
                    )

                    return privat ? privateKey : publicKey
                }

                static generateSync(crv = 'Ed25519', privat = true) {
                    if (!edDSASupported) {
                        throw new errors.JOSENotSupported(
                            'OKP keys are not supported in your Node.js runtime version'
                        )
                    }

                    if (!OKP_CURVES.has(crv)) {
                        throw new errors.JOSENotSupported(
                            `unsupported OKP key curve: ${crv}`
                        )
                    }

                    const { privateKey, publicKey } = generateKeyPairSync(
                        crv.toLowerCase()
                    )

                    return privat ? privateKey : publicKey
                }
            }

            module.exports = OKPKey

            /***/
        },

        /***/ vDqi: /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__('zuR4')

            /***/
        },

        /***/ vUsp: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            function padString(input) {
                var segmentLength = 4
                var stringLength = input.length
                var diff = stringLength % segmentLength
                if (!diff) {
                    return input
                }
                var position = stringLength
                var padLength = segmentLength - diff
                var paddedStringLength = stringLength + padLength
                var buffer = Buffer.alloc(paddedStringLength)
                buffer.write(input)
                while (padLength--) {
                    buffer.write('=', position++)
                }
                return buffer.toString()
            }
            exports.default = padString

            /***/
        },

        /***/ viRO: /***/ function(module, exports, __webpack_require__) {
            'use strict'
            /** @license React v16.12.0
             * react.production.min.js
             *
             * Copyright (c) Facebook, Inc. and its affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */

            var h = __webpack_require__('MgzW'),
                n = 'function' === typeof Symbol && Symbol.for,
                p = n ? Symbol.for('react.element') : 60103,
                q = n ? Symbol.for('react.portal') : 60106,
                r = n ? Symbol.for('react.fragment') : 60107,
                t = n ? Symbol.for('react.strict_mode') : 60108,
                u = n ? Symbol.for('react.profiler') : 60114,
                v = n ? Symbol.for('react.provider') : 60109,
                w = n ? Symbol.for('react.context') : 60110,
                x = n ? Symbol.for('react.forward_ref') : 60112,
                y = n ? Symbol.for('react.suspense') : 60113
            n && Symbol.for('react.suspense_list')
            var z = n ? Symbol.for('react.memo') : 60115,
                aa = n ? Symbol.for('react.lazy') : 60116
            n && Symbol.for('react.fundamental')
            n && Symbol.for('react.responder')
            n && Symbol.for('react.scope')
            var A = 'function' === typeof Symbol && Symbol.iterator
            function B(a) {
                for (
                    var b =
                            'https://reactjs.org/docs/error-decoder.html?invariant=' +
                            a,
                        c = 1;
                    c < arguments.length;
                    c++
                )
                    b += '&args[]=' + encodeURIComponent(arguments[c])
                return (
                    'Minified React error #' +
                    a +
                    '; visit ' +
                    b +
                    ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
                )
            }
            var C = {
                    isMounted: function() {
                        return !1
                    },
                    enqueueForceUpdate: function() {},
                    enqueueReplaceState: function() {},
                    enqueueSetState: function() {}
                },
                D = {}
            function E(a, b, c) {
                this.props = a
                this.context = b
                this.refs = D
                this.updater = c || C
            }
            E.prototype.isReactComponent = {}
            E.prototype.setState = function(a, b) {
                if (
                    'object' !== typeof a &&
                    'function' !== typeof a &&
                    null != a
                )
                    throw Error(B(85))
                this.updater.enqueueSetState(this, a, b, 'setState')
            }
            E.prototype.forceUpdate = function(a) {
                this.updater.enqueueForceUpdate(this, a, 'forceUpdate')
            }
            function F() {}
            F.prototype = E.prototype
            function G(a, b, c) {
                this.props = a
                this.context = b
                this.refs = D
                this.updater = c || C
            }
            var H = (G.prototype = new F())
            H.constructor = G
            h(H, E.prototype)
            H.isPureReactComponent = !0
            var I = { current: null },
                J = { current: null },
                K = Object.prototype.hasOwnProperty,
                L = { key: !0, ref: !0, __self: !0, __source: !0 }
            function M(a, b, c) {
                var e,
                    d = {},
                    g = null,
                    l = null
                if (null != b)
                    for (e in (void 0 !== b.ref && (l = b.ref),
                    void 0 !== b.key && (g = '' + b.key),
                    b))
                        K.call(b, e) && !L.hasOwnProperty(e) && (d[e] = b[e])
                var f = arguments.length - 2
                if (1 === f) d.children = c
                else if (1 < f) {
                    for (var k = Array(f), m = 0; m < f; m++)
                        k[m] = arguments[m + 2]
                    d.children = k
                }
                if (a && a.defaultProps)
                    for (e in ((f = a.defaultProps), f))
                        void 0 === d[e] && (d[e] = f[e])
                return {
                    $$typeof: p,
                    type: a,
                    key: g,
                    ref: l,
                    props: d,
                    _owner: J.current
                }
            }
            function ba(a, b) {
                return {
                    $$typeof: p,
                    type: a.type,
                    key: b,
                    ref: a.ref,
                    props: a.props,
                    _owner: a._owner
                }
            }
            function N(a) {
                return 'object' === typeof a && null !== a && a.$$typeof === p
            }
            function escape(a) {
                var b = { '=': '=0', ':': '=2' }
                return (
                    '$' +
                    ('' + a).replace(/[=:]/g, function(a) {
                        return b[a]
                    })
                )
            }
            var O = /\/+/g,
                P = []
            function Q(a, b, c, e) {
                if (P.length) {
                    var d = P.pop()
                    d.result = a
                    d.keyPrefix = b
                    d.func = c
                    d.context = e
                    d.count = 0
                    return d
                }
                return {
                    result: a,
                    keyPrefix: b,
                    func: c,
                    context: e,
                    count: 0
                }
            }
            function R(a) {
                a.result = null
                a.keyPrefix = null
                a.func = null
                a.context = null
                a.count = 0
                10 > P.length && P.push(a)
            }
            function S(a, b, c, e) {
                var d = typeof a
                if ('undefined' === d || 'boolean' === d) a = null
                var g = !1
                if (null === a) g = !0
                else
                    switch (d) {
                        case 'string':
                        case 'number':
                            g = !0
                            break
                        case 'object':
                            switch (a.$$typeof) {
                                case p:
                                case q:
                                    g = !0
                            }
                    }
                if (g) return c(e, a, '' === b ? '.' + T(a, 0) : b), 1
                g = 0
                b = '' === b ? '.' : b + ':'
                if (Array.isArray(a))
                    for (var l = 0; l < a.length; l++) {
                        d = a[l]
                        var f = b + T(d, l)
                        g += S(d, f, c, e)
                    }
                else if (
                    (null === a || 'object' !== typeof a
                        ? (f = null)
                        : ((f = (A && a[A]) || a['@@iterator']),
                          (f = 'function' === typeof f ? f : null)),
                    'function' === typeof f)
                )
                    for (a = f.call(a), l = 0; !(d = a.next()).done; )
                        (d = d.value), (f = b + T(d, l++)), (g += S(d, f, c, e))
                else if ('object' === d)
                    throw ((c = '' + a),
                    Error(
                        B(
                            31,
                            '[object Object]' === c
                                ? 'object with keys {' +
                                      Object.keys(a).join(', ') +
                                      '}'
                                : c,
                            ''
                        )
                    ))
                return g
            }
            function U(a, b, c) {
                return null == a ? 0 : S(a, '', b, c)
            }
            function T(a, b) {
                return 'object' === typeof a && null !== a && null != a.key
                    ? escape(a.key)
                    : b.toString(36)
            }
            function ca(a, b) {
                a.func.call(a.context, b, a.count++)
            }
            function da(a, b, c) {
                var e = a.result,
                    d = a.keyPrefix
                a = a.func.call(a.context, b, a.count++)
                Array.isArray(a)
                    ? V(a, e, c, function(a) {
                          return a
                      })
                    : null != a &&
                      (N(a) &&
                          (a = ba(
                              a,
                              d +
                                  (!a.key || (b && b.key === a.key)
                                      ? ''
                                      : ('' + a.key).replace(O, '$&/') + '/') +
                                  c
                          )),
                      e.push(a))
            }
            function V(a, b, c, e, d) {
                var g = ''
                null != c && (g = ('' + c).replace(O, '$&/') + '/')
                b = Q(b, g, e, d)
                U(a, da, b)
                R(b)
            }
            function W() {
                var a = I.current
                if (null === a) throw Error(B(321))
                return a
            }
            var X = {
                    Children: {
                        map: function(a, b, c) {
                            if (null == a) return a
                            var e = []
                            V(a, e, null, b, c)
                            return e
                        },
                        forEach: function(a, b, c) {
                            if (null == a) return a
                            b = Q(null, null, b, c)
                            U(a, ca, b)
                            R(b)
                        },
                        count: function(a) {
                            return U(
                                a,
                                function() {
                                    return null
                                },
                                null
                            )
                        },
                        toArray: function(a) {
                            var b = []
                            V(a, b, null, function(a) {
                                return a
                            })
                            return b
                        },
                        only: function(a) {
                            if (!N(a)) throw Error(B(143))
                            return a
                        }
                    },
                    createRef: function() {
                        return { current: null }
                    },
                    Component: E,
                    PureComponent: G,
                    createContext: function(a, b) {
                        void 0 === b && (b = null)
                        a = {
                            $$typeof: w,
                            _calculateChangedBits: b,
                            _currentValue: a,
                            _currentValue2: a,
                            _threadCount: 0,
                            Provider: null,
                            Consumer: null
                        }
                        a.Provider = { $$typeof: v, _context: a }
                        return (a.Consumer = a)
                    },
                    forwardRef: function(a) {
                        return { $$typeof: x, render: a }
                    },
                    lazy: function(a) {
                        return {
                            $$typeof: aa,
                            _ctor: a,
                            _status: -1,
                            _result: null
                        }
                    },
                    memo: function(a, b) {
                        return {
                            $$typeof: z,
                            type: a,
                            compare: void 0 === b ? null : b
                        }
                    },
                    useCallback: function(a, b) {
                        return W().useCallback(a, b)
                    },
                    useContext: function(a, b) {
                        return W().useContext(a, b)
                    },
                    useEffect: function(a, b) {
                        return W().useEffect(a, b)
                    },
                    useImperativeHandle: function(a, b, c) {
                        return W().useImperativeHandle(a, b, c)
                    },
                    useDebugValue: function() {},
                    useLayoutEffect: function(a, b) {
                        return W().useLayoutEffect(a, b)
                    },
                    useMemo: function(a, b) {
                        return W().useMemo(a, b)
                    },
                    useReducer: function(a, b, c) {
                        return W().useReducer(a, b, c)
                    },
                    useRef: function(a) {
                        return W().useRef(a)
                    },
                    useState: function(a) {
                        return W().useState(a)
                    },
                    Fragment: r,
                    Profiler: u,
                    StrictMode: t,
                    Suspense: y,
                    createElement: M,
                    cloneElement: function(a, b, c) {
                        if (null === a || void 0 === a) throw Error(B(267, a))
                        var e = h({}, a.props),
                            d = a.key,
                            g = a.ref,
                            l = a._owner
                        if (null != b) {
                            void 0 !== b.ref && ((g = b.ref), (l = J.current))
                            void 0 !== b.key && (d = '' + b.key)
                            if (a.type && a.type.defaultProps)
                                var f = a.type.defaultProps
                            for (k in b)
                                K.call(b, k) &&
                                    !L.hasOwnProperty(k) &&
                                    (e[k] =
                                        void 0 === b[k] && void 0 !== f
                                            ? f[k]
                                            : b[k])
                        }
                        var k = arguments.length - 2
                        if (1 === k) e.children = c
                        else if (1 < k) {
                            f = Array(k)
                            for (var m = 0; m < k; m++) f[m] = arguments[m + 2]
                            e.children = f
                        }
                        return {
                            $$typeof: p,
                            type: a.type,
                            key: d,
                            ref: g,
                            props: e,
                            _owner: l
                        }
                    },
                    createFactory: function(a) {
                        var b = M.bind(null, a)
                        b.type = a
                        return b
                    },
                    isValidElement: N,
                    version: '16.12.0',
                    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
                        ReactCurrentDispatcher: I,
                        ReactCurrentBatchConfig: { suspense: null },
                        ReactCurrentOwner: J,
                        IsSomeRendererActing: { current: !1 },
                        assign: h
                    }
                },
                Y = { default: X },
                Z = (Y && X) || Y
            module.exports = Z.default || Z

            /***/
        },

        /***/ vwuL: /***/ function(module, exports, __webpack_require__) {
            var pIE = __webpack_require__('NV0k')
            var createDesc = __webpack_require__('rr1i')
            var toIObject = __webpack_require__('NsO/')
            var toPrimitive = __webpack_require__('G8Mo')
            var has = __webpack_require__('B+OT')
            var IE8_DOM_DEFINE = __webpack_require__('eUtF')
            var gOPD = Object.getOwnPropertyDescriptor

            exports.f = __webpack_require__('jmDH')
                ? gOPD
                : function getOwnPropertyDescriptor(O, P) {
                      O = toIObject(O)
                      P = toPrimitive(P, true)
                      if (IE8_DOM_DEFINE)
                          try {
                              return gOPD(O, P)
                          } catch (e) {
                              /* empty */
                          }
                      if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P])
                  }

            /***/
        },

        /***/ 'w/wX': /***/ function(module, exports, __webpack_require__) {
            var getTag = __webpack_require__('QqLw'),
                isObjectLike = __webpack_require__('ExA7')

            /** `Object#toString` result references. */
            var setTag = '[object Set]'

            /**
             * The base implementation of `_.isSet` without Node.js optimizations.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a set, else `false`.
             */
            function baseIsSet(value) {
                return isObjectLike(value) && getTag(value) == setTag
            }

            module.exports = baseIsSet

            /***/
        },

        /***/ w0Vi: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')

            // Headers whose duplicates are ignored by node
            // c.f. https://nodejs.org/api/http.html#http_message_headers
            var ignoreDuplicateOf = [
                'age',
                'authorization',
                'content-length',
                'content-type',
                'etag',
                'expires',
                'from',
                'host',
                'if-modified-since',
                'if-unmodified-since',
                'last-modified',
                'location',
                'max-forwards',
                'proxy-authorization',
                'referer',
                'retry-after',
                'user-agent'
            ]

            /**
             * Parse headers into an object
             *
             * ```
             * Date: Wed, 27 Aug 2014 08:58:49 GMT
             * Content-Type: application/json
             * Connection: keep-alive
             * Transfer-Encoding: chunked
             * ```
             *
             * @param {String} headers Headers needing to be parsed
             * @returns {Object} Headers parsed into an object
             */
            module.exports = function parseHeaders(headers) {
                var parsed = {}
                var key
                var val
                var i

                if (!headers) {
                    return parsed
                }

                utils.forEach(headers.split('\n'), function parser(line) {
                    i = line.indexOf(':')
                    key = utils.trim(line.substr(0, i)).toLowerCase()
                    val = utils.trim(line.substr(i + 1))

                    if (key) {
                        if (
                            parsed[key] &&
                            ignoreDuplicateOf.indexOf(key) >= 0
                        ) {
                            return
                        }
                        if (key === 'set-cookie') {
                            parsed[key] = (parsed[key]
                                ? parsed[key]
                                : []
                            ).concat([val])
                        } else {
                            parsed[key] = parsed[key]
                                ? parsed[key] + ', ' + val
                                : val
                        }
                    }
                })

                return parsed
            }

            /***/
        },

        /***/ w0zM: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const path_1 = __webpack_require__('oyvS')
            function normalizePagePath(page) {
                // If the page is `/` we need to append `/index`, otherwise the returned directory root will be bundles instead of pages
                if (page === '/') {
                    page = '/index'
                }
                // Resolve on anything that doesn't start with `/`
                if (page[0] !== '/') {
                    page = `/${page}`
                }
                // Throw when using ../ etc in the pathname
                const resolvedPage = path_1.posix.normalize(page)
                if (page !== resolvedPage) {
                    throw new Error('Requested and resolved page mismatch')
                }
                return page
            }
            exports.normalizePagePath = normalizePagePath

            /***/
        },

        /***/ 'w2d+': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var addToUnscopables = __webpack_require__('hDam')
            var step = __webpack_require__('UO39')
            var Iterators = __webpack_require__('SBuE')
            var toIObject = __webpack_require__('NsO/')

            // 22.1.3.4 Array.prototype.entries()
            // 22.1.3.13 Array.prototype.keys()
            // 22.1.3.29 Array.prototype.values()
            // 22.1.3.30 Array.prototype[@@iterator]()
            module.exports = __webpack_require__('MPFp')(
                Array,
                'Array',
                function(iterated, kind) {
                    this._t = toIObject(iterated) // target
                    this._i = 0 // next index
                    this._k = kind // kind
                    // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
                },
                function() {
                    var O = this._t
                    var kind = this._k
                    var index = this._i++
                    if (!O || index >= O.length) {
                        this._t = undefined
                        return step(1)
                    }
                    if (kind == 'keys') return step(0, index)
                    if (kind == 'values') return step(0, O[index])
                    return step(0, [index, O[index]])
                },
                'values'
            )

            // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
            Iterators.Arguments = Iterators.Array

            addToUnscopables('keys')
            addToUnscopables('values')
            addToUnscopables('entries')

            /***/
        },

        /***/ w6GO: /***/ function(module, exports, __webpack_require__) {
            // 19.1.2.14 / 15.2.3.14 Object.keys(O)
            var $keys = __webpack_require__('5vMV')
            var enumBugKeys = __webpack_require__('FpHa')

            module.exports =
                Object.keys ||
                function keys(O) {
                    return $keys(O, enumBugKeys)
                }

            /***/
        },

        /***/ w7wo: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var _Object$defineProperty = __webpack_require__('hfKm')

            _Object$defineProperty(exports, '__esModule', {
                value: true
            })

            exports.PHASE_EXPORT = 'phase-export'
            exports.PHASE_PRODUCTION_BUILD = 'phase-production-build'
            exports.PHASE_PRODUCTION_SERVER = 'phase-production-server'
            exports.PHASE_DEVELOPMENT_SERVER = 'phase-development-server'
            exports.PAGES_MANIFEST = 'pages-manifest.json'
            exports.BUILD_MANIFEST = 'build-manifest.json'
            exports.PRERENDER_MANIFEST = 'prerender-manifest.json'
            exports.ROUTES_MANIFEST = 'routes-manifest.json'
            exports.REACT_LOADABLE_MANIFEST = 'react-loadable-manifest.json'
            exports.SERVER_DIRECTORY = 'server'
            exports.SERVERLESS_DIRECTORY = 'serverless'
            exports.CONFIG_FILE = 'next.config.js'
            exports.BUILD_ID_FILE = 'BUILD_ID'
            exports.BLOCKED_PAGES = ['/_document', '/_app']
            exports.CLIENT_PUBLIC_FILES_PATH = 'public'
            exports.CLIENT_STATIC_FILES_PATH = 'static'
            exports.CLIENT_STATIC_FILES_RUNTIME = 'runtime'
            exports.CLIENT_STATIC_FILES_RUNTIME_PATH = `${exports.CLIENT_STATIC_FILES_PATH}/${exports.CLIENT_STATIC_FILES_RUNTIME}` // static/runtime/main.js

            exports.CLIENT_STATIC_FILES_RUNTIME_MAIN = `${exports.CLIENT_STATIC_FILES_RUNTIME_PATH}/main.js` // static/runtime/amp.js

            exports.CLIENT_STATIC_FILES_RUNTIME_AMP = `${exports.CLIENT_STATIC_FILES_RUNTIME_PATH}/amp.js` // static/runtime/webpack.js

            exports.CLIENT_STATIC_FILES_RUNTIME_WEBPACK = `${exports.CLIENT_STATIC_FILES_RUNTIME_PATH}/webpack.js` // static/runtime/polyfills.js

            exports.CLIENT_STATIC_FILES_RUNTIME_POLYFILLS = `${exports.CLIENT_STATIC_FILES_RUNTIME_PATH}/polyfills.js` // matches static/<buildid>/pages/<page>.js

            exports.IS_BUNDLED_PAGE_REGEX = /^static[/\\][^/\\]+[/\\]pages.*\.js$/ // matches static/<buildid>/pages/:page*.js

            exports.ROUTE_NAME_REGEX = /^static[/\\][^/\\]+[/\\]pages[/\\](.*)\.js$/
            exports.SERVERLESS_ROUTE_NAME_REGEX = /^pages[/\\](.*)\.js$/
            exports.DEFAULT_REDIRECT_STATUS = 307

            /***/
        },

        /***/ w8yO: /***/ function(module, exports) {
            const sign = () => Buffer.from('')
            const verify = (key, payload, signature) => !signature.length

            module.exports = (JWA, JWK) => {
                JWA.sign.set('none', sign)
                JWA.verify.set('none', verify)
            }

            /***/
        },

        /***/ wEzw: /***/ function(module, exports) {
            module.exports = AlgorithmIdentifier =>
                function() {
                    this.seq().obj(
                        this.key('version').int(),
                        this.key('algorithm').use(AlgorithmIdentifier),
                        this.key('privateKey').octstr()
                    )
                }

            /***/
        },

        /***/ 'wF/u': /***/ function(module, exports, __webpack_require__) {
            var baseIsEqualDeep = __webpack_require__('e5cp'),
                isObjectLike = __webpack_require__('ExA7')

            /**
             * The base implementation of `_.isEqual` which supports partial comparisons
             * and tracks traversed objects.
             *
             * @private
             * @param {*} value The value to compare.
             * @param {*} other The other value to compare.
             * @param {boolean} bitmask The bitmask flags.
             *  1 - Unordered comparison
             *  2 - Partial comparison
             * @param {Function} [customizer] The function to customize comparisons.
             * @param {Object} [stack] Tracks traversed `value` and `other` objects.
             * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
             */
            function baseIsEqual(value, other, bitmask, customizer, stack) {
                if (value === other) {
                    return true
                }
                if (
                    value == null ||
                    other == null ||
                    (!isObjectLike(value) && !isObjectLike(other))
                ) {
                    return value !== value && other !== other
                }
                return baseIsEqualDeep(
                    value,
                    other,
                    bitmask,
                    customizer,
                    baseIsEqual,
                    stack
                )
            }

            module.exports = baseIsEqual

            /***/
        },

        /***/ wJg7: /***/ function(module, exports) {
            /** Used as references for various `Number` constants. */
            var MAX_SAFE_INTEGER = 9007199254740991

            /** Used to detect unsigned integer values. */
            var reIsUint = /^(?:0|[1-9]\d*)$/

            /**
             * Checks if `value` is a valid array-like index.
             *
             * @private
             * @param {*} value The value to check.
             * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
             * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
             */
            function isIndex(value, length) {
                var type = typeof value
                length = length == null ? MAX_SAFE_INTEGER : length

                return (
                    !!length &&
                    (type == 'number' ||
                        (type != 'symbol' && reIsUint.test(value))) &&
                    value > -1 && value % 1 == 0 && value < length
                )
            }

            module.exports = isIndex

            /***/
        },

        /***/ wclG: /***/ function(module, exports, __webpack_require__) {
            var baseSetToString = __webpack_require__('pFRH'),
                shortOut = __webpack_require__('88Gu')

            /**
             * Sets the `toString` method of `func` to return `string`.
             *
             * @private
             * @param {Function} func The function to modify.
             * @param {Function} string The `toString` result.
             * @returns {Function} Returns `func`.
             */
            var setToString = shortOut(baseSetToString)

            module.exports = setToString

            /***/
        },

        /***/ wgeU: /***/ function(module, exports) {
            /***/
        },

        /***/ whhB: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { URL, URLSearchParams } = __webpack_require__('bzos') // TODO: Use the `URL` global when targeting Node.js 10
            const urlLib = __webpack_require__('bzos')
            const is = __webpack_require__('6mOv')
            const urlParseLax = __webpack_require__('9l6Z')
            const lowercaseKeys = __webpack_require__('y1+z')
            const urlToOptions = __webpack_require__('NHoT')
            const isFormData = __webpack_require__('faWz')
            const merge = __webpack_require__('AW8e')
            const knownHookEvents = __webpack_require__('JlL/')

            const retryAfterStatusCodes = new Set([413, 429, 503])

            // `preNormalize` handles static options (e.g. headers).
            // For example, when you create a custom instance and make a request
            // with no static changes, they won't be normalized again.
            //
            // `normalize` operates on dynamic options - they cannot be saved.
            // For example, `body` is everytime different per request.
            // When it's done normalizing the new options, it performs merge()
            // on the prenormalized options and the normalized ones.

            const preNormalize = (options, defaults) => {
                if (is.nullOrUndefined(options.headers)) {
                    options.headers = {}
                } else {
                    options.headers = lowercaseKeys(options.headers)
                }

                if (
                    options.baseUrl &&
                    !options.baseUrl.toString().endsWith('/')
                ) {
                    options.baseUrl += '/'
                }

                if (options.stream) {
                    options.json = false
                }

                if (is.nullOrUndefined(options.hooks)) {
                    options.hooks = {}
                } else if (!is.object(options.hooks)) {
                    throw new TypeError(
                        `Parameter \`hooks\` must be an object, not ${is(
                            options.hooks
                        )}`
                    )
                }

                for (const event of knownHookEvents) {
                    if (is.nullOrUndefined(options.hooks[event])) {
                        if (defaults) {
                            options.hooks[event] = [...defaults.hooks[event]]
                        } else {
                            options.hooks[event] = []
                        }
                    }
                }

                if (is.number(options.timeout)) {
                    options.gotTimeout = { request: options.timeout }
                } else if (is.object(options.timeout)) {
                    options.gotTimeout = options.timeout
                }

                delete options.timeout

                const { retry } = options
                options.retry = {
                    retries: 0,
                    methods: [],
                    statusCodes: [],
                    errorCodes: []
                }

                if (is.nonEmptyObject(defaults) && retry !== false) {
                    options.retry = { ...defaults.retry }
                }

                if (retry !== false) {
                    if (is.number(retry)) {
                        options.retry.retries = retry
                    } else {
                        options.retry = { ...options.retry, ...retry }
                    }
                }

                if (options.gotTimeout) {
                    options.retry.maxRetryAfter = Math.min(
                        ...[
                            options.gotTimeout.request,
                            options.gotTimeout.connection
                        ].filter(n => !is.nullOrUndefined(n))
                    )
                }

                if (is.array(options.retry.methods)) {
                    options.retry.methods = new Set(
                        options.retry.methods.map(method =>
                            method.toUpperCase()
                        )
                    )
                }

                if (is.array(options.retry.statusCodes)) {
                    options.retry.statusCodes = new Set(
                        options.retry.statusCodes
                    )
                }

                if (is.array(options.retry.errorCodes)) {
                    options.retry.errorCodes = new Set(options.retry.errorCodes)
                }

                return options
            }

            const normalize = (url, options, defaults) => {
                if (is.plainObject(url)) {
                    options = { ...url, ...options }
                    url = options.url || {}
                    delete options.url
                }

                if (defaults) {
                    options = merge(
                        {},
                        defaults.options,
                        options ? preNormalize(options, defaults.options) : {}
                    )
                } else {
                    options = merge({}, preNormalize(options))
                }

                if (!is.string(url) && !is.object(url)) {
                    throw new TypeError(
                        `Parameter \`url\` must be a string or object, not ${is(
                            url
                        )}`
                    )
                }

                if (is.string(url)) {
                    if (options.baseUrl) {
                        if (url.toString().startsWith('/')) {
                            url = url.toString().slice(1)
                        }

                        url = urlToOptions(new URL(url, options.baseUrl))
                    } else {
                        url = url.replace(/^unix:/, 'http://$&')
                        url = urlParseLax(url)
                    }
                } else if (is(url) === 'URL') {
                    url = urlToOptions(url)
                }

                // Override both null/undefined with default protocol
                options = merge(
                    { path: '' },
                    url,
                    { protocol: url.protocol || 'https:' },
                    options
                )

                for (const hook of options.hooks.init) {
                    const called = hook(options)

                    if (is.promise(called)) {
                        throw new TypeError(
                            'The `init` hook must be a synchronous function'
                        )
                    }
                }

                const { baseUrl } = options
                Object.defineProperty(options, 'baseUrl', {
                    set: () => {
                        throw new Error(
                            'Failed to set baseUrl. Options are normalized already.'
                        )
                    },
                    get: () => baseUrl
                })

                const { query } = options
                if (
                    is.nonEmptyString(query) ||
                    is.nonEmptyObject(query) ||
                    query instanceof URLSearchParams
                ) {
                    if (!is.string(query)) {
                        options.query = new URLSearchParams(query).toString()
                    }

                    options.path = `${options.path.split('?')[0]}?${
                        options.query
                    }`
                    delete options.query
                }

                if (options.hostname === 'unix') {
                    const matches = /(.+?):(.+)/.exec(options.path)

                    if (matches) {
                        const [, socketPath, path] = matches
                        options = {
                            ...options,
                            socketPath,
                            path,
                            host: null
                        }
                    }
                }

                const { headers } = options
                for (const [key, value] of Object.entries(headers)) {
                    if (is.nullOrUndefined(value)) {
                        delete headers[key]
                    }
                }

                if (options.json && is.undefined(headers.accept)) {
                    headers.accept = 'application/json'
                }

                if (
                    options.decompress &&
                    is.undefined(headers['accept-encoding'])
                ) {
                    headers['accept-encoding'] = 'gzip, deflate'
                }

                const { body } = options
                if (is.nullOrUndefined(body)) {
                    options.method = options.method
                        ? options.method.toUpperCase()
                        : 'GET'
                } else {
                    const isObject =
                        is.object(body) &&
                        !is.buffer(body) &&
                        !is.nodeStream(body)
                    if (
                        !is.nodeStream(body) &&
                        !is.string(body) &&
                        !is.buffer(body) &&
                        !(options.form || options.json)
                    ) {
                        throw new TypeError(
                            'The `body` option must be a stream.Readable, string or Buffer'
                        )
                    }

                    if (options.json && !(isObject || is.array(body))) {
                        throw new TypeError(
                            'The `body` option must be an Object or Array when the `json` option is used'
                        )
                    }

                    if (options.form && !isObject) {
                        throw new TypeError(
                            'The `body` option must be an Object when the `form` option is used'
                        )
                    }

                    if (isFormData(body)) {
                        // Special case for https://github.com/form-data/form-data
                        headers['content-type'] =
                            headers['content-type'] ||
                            `multipart/form-data; boundary=${body.getBoundary()}`
                    } else if (options.form) {
                        headers['content-type'] =
                            headers['content-type'] ||
                            'application/x-www-form-urlencoded'
                        options.body = new URLSearchParams(body).toString()
                    } else if (options.json) {
                        headers['content-type'] =
                            headers['content-type'] || 'application/json'
                        options.body = JSON.stringify(body)
                    }

                    options.method = options.method
                        ? options.method.toUpperCase()
                        : 'POST'
                }

                if (!is.function(options.retry.retries)) {
                    const { retries } = options.retry

                    options.retry.retries = (iteration, error) => {
                        if (iteration > retries) {
                            return 0
                        }

                        if (
                            (!error ||
                                !options.retry.errorCodes.has(error.code)) &&
                            (!options.retry.methods.has(error.method) ||
                                !options.retry.statusCodes.has(
                                    error.statusCode
                                ))
                        ) {
                            return 0
                        }

                        if (
                            Reflect.has(error, 'headers') &&
                            Reflect.has(error.headers, 'retry-after') &&
                            retryAfterStatusCodes.has(error.statusCode)
                        ) {
                            let after = Number(error.headers['retry-after'])
                            if (is.nan(after)) {
                                after =
                                    Date.parse(error.headers['retry-after']) -
                                    Date.now()
                            } else {
                                after *= 1000
                            }

                            if (after > options.retry.maxRetryAfter) {
                                return 0
                            }

                            return after
                        }

                        if (error.statusCode === 413) {
                            return 0
                        }

                        const noise = Math.random() * 100
                        return 2 ** (iteration - 1) * 1000 + noise
                    }
                }

                return options
            }

            const reNormalize = options =>
                normalize(urlLib.format(options), options)

            module.exports = normalize
            module.exports.preNormalize = preNormalize
            module.exports.reNormalize = reNormalize

            /***/
        },

        /***/ wrZu: /***/ function(module, exports, __webpack_require__) {
            var cloneArrayBuffer = __webpack_require__('+K+b'),
                cloneDataView = __webpack_require__('XYm9'),
                cloneRegExp = __webpack_require__('b2z7'),
                cloneSymbol = __webpack_require__('otv/'),
                cloneTypedArray = __webpack_require__('yP5f')

            /** `Object#toString` result references. */
            var boolTag = '[object Boolean]',
                dateTag = '[object Date]',
                mapTag = '[object Map]',
                numberTag = '[object Number]',
                regexpTag = '[object RegExp]',
                setTag = '[object Set]',
                stringTag = '[object String]',
                symbolTag = '[object Symbol]'

            var arrayBufferTag = '[object ArrayBuffer]',
                dataViewTag = '[object DataView]',
                float32Tag = '[object Float32Array]',
                float64Tag = '[object Float64Array]',
                int8Tag = '[object Int8Array]',
                int16Tag = '[object Int16Array]',
                int32Tag = '[object Int32Array]',
                uint8Tag = '[object Uint8Array]',
                uint8ClampedTag = '[object Uint8ClampedArray]',
                uint16Tag = '[object Uint16Array]',
                uint32Tag = '[object Uint32Array]'

            /**
             * Initializes an object clone based on its `toStringTag`.
             *
             * **Note:** This function only supports cloning values with tags of
             * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
             *
             * @private
             * @param {Object} object The object to clone.
             * @param {string} tag The `toStringTag` of the object to clone.
             * @param {boolean} [isDeep] Specify a deep clone.
             * @returns {Object} Returns the initialized clone.
             */
            function initCloneByTag(object, tag, isDeep) {
                var Ctor = object.constructor
                switch (tag) {
                    case arrayBufferTag:
                        return cloneArrayBuffer(object)

                    case boolTag:
                    case dateTag:
                        return new Ctor(+object)

                    case dataViewTag:
                        return cloneDataView(object, isDeep)

                    case float32Tag:
                    case float64Tag:
                    case int8Tag:
                    case int16Tag:
                    case int32Tag:
                    case uint8Tag:
                    case uint8ClampedTag:
                    case uint16Tag:
                    case uint32Tag:
                        return cloneTypedArray(object, isDeep)

                    case mapTag:
                        return new Ctor()

                    case numberTag:
                    case stringTag:
                        return new Ctor(object)

                    case regexpTag:
                        return cloneRegExp(object)

                    case setTag:
                        return new Ctor()

                    case symbolTag:
                        return cloneSymbol(object)
                }
            }

            module.exports = initCloneByTag

            /***/
        },

        /***/ xAGQ: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')

            /**
             * Transform the data for a request or a response
             *
             * @param {Object|String} data The data to be transformed
             * @param {Array} headers The headers for the request or response
             * @param {Array|Function} fns A single function or Array of functions
             * @returns {*} The resulting transformed data
             */
            module.exports = function transformData(data, headers, fns) {
                /*eslint no-param-reassign:0*/
                utils.forEach(fns, function transform(fn) {
                    data = fn(data, headers)
                })

                return data
            }

            /***/
        },

        /***/ 'xTJ+': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var bind = __webpack_require__('HSsa')

            /*global toString:true*/

            // utils is a library of generic helper functions non-specific to axios

            var toString = Object.prototype.toString

            /**
             * Determine if a value is an Array
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is an Array, otherwise false
             */
            function isArray(val) {
                return toString.call(val) === '[object Array]'
            }

            /**
             * Determine if a value is undefined
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if the value is undefined, otherwise false
             */
            function isUndefined(val) {
                return typeof val === 'undefined'
            }

            /**
             * Determine if a value is a Buffer
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a Buffer, otherwise false
             */
            function isBuffer(val) {
                return (
                    val !== null &&
                    !isUndefined(val) &&
                    val.constructor !== null &&
                    !isUndefined(val.constructor) &&
                    typeof val.constructor.isBuffer === 'function' &&
                    val.constructor.isBuffer(val)
                )
            }

            /**
             * Determine if a value is an ArrayBuffer
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is an ArrayBuffer, otherwise false
             */
            function isArrayBuffer(val) {
                return toString.call(val) === '[object ArrayBuffer]'
            }

            /**
             * Determine if a value is a FormData
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is an FormData, otherwise false
             */
            function isFormData(val) {
                return (
                    typeof FormData !== 'undefined' && val instanceof FormData
                )
            }

            /**
             * Determine if a value is a view on an ArrayBuffer
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
             */
            function isArrayBufferView(val) {
                var result
                if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
                    result = ArrayBuffer.isView(val)
                } else {
                    result =
                        val && val.buffer && val.buffer instanceof ArrayBuffer
                }
                return result
            }

            /**
             * Determine if a value is a String
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a String, otherwise false
             */
            function isString(val) {
                return typeof val === 'string'
            }

            /**
             * Determine if a value is a Number
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a Number, otherwise false
             */
            function isNumber(val) {
                return typeof val === 'number'
            }

            /**
             * Determine if a value is an Object
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is an Object, otherwise false
             */
            function isObject(val) {
                return val !== null && typeof val === 'object'
            }

            /**
             * Determine if a value is a Date
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a Date, otherwise false
             */
            function isDate(val) {
                return toString.call(val) === '[object Date]'
            }

            /**
             * Determine if a value is a File
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a File, otherwise false
             */
            function isFile(val) {
                return toString.call(val) === '[object File]'
            }

            /**
             * Determine if a value is a Blob
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a Blob, otherwise false
             */
            function isBlob(val) {
                return toString.call(val) === '[object Blob]'
            }

            /**
             * Determine if a value is a Function
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a Function, otherwise false
             */
            function isFunction(val) {
                return toString.call(val) === '[object Function]'
            }

            /**
             * Determine if a value is a Stream
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a Stream, otherwise false
             */
            function isStream(val) {
                return isObject(val) && isFunction(val.pipe)
            }

            /**
             * Determine if a value is a URLSearchParams object
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a URLSearchParams object, otherwise false
             */
            function isURLSearchParams(val) {
                return (
                    typeof URLSearchParams !== 'undefined' &&
                    val instanceof URLSearchParams
                )
            }

            /**
             * Trim excess whitespace off the beginning and end of a string
             *
             * @param {String} str The String to trim
             * @returns {String} The String freed of excess whitespace
             */
            function trim(str) {
                return str.replace(/^\s*/, '').replace(/\s*$/, '')
            }

            /**
             * Determine if we're running in a standard browser environment
             *
             * This allows axios to run in a web worker, and react-native.
             * Both environments support XMLHttpRequest, but not fully standard globals.
             *
             * web workers:
             *  typeof window -> undefined
             *  typeof document -> undefined
             *
             * react-native:
             *  navigator.product -> 'ReactNative'
             * nativescript
             *  navigator.product -> 'NativeScript' or 'NS'
             */
            function isStandardBrowserEnv() {
                if (
                    typeof navigator !== 'undefined' &&
                    (navigator.product === 'ReactNative' ||
                        navigator.product === 'NativeScript' ||
                        navigator.product === 'NS')
                ) {
                    return false
                }
                return (
                    typeof window !== 'undefined' &&
                    typeof document !== 'undefined'
                )
            }

            /**
             * Iterate over an Array or an Object invoking a function for each item.
             *
             * If `obj` is an Array callback will be called passing
             * the value, index, and complete array for each item.
             *
             * If 'obj' is an Object callback will be called passing
             * the value, key, and complete object for each property.
             *
             * @param {Object|Array} obj The object to iterate
             * @param {Function} fn The callback to invoke for each item
             */
            function forEach(obj, fn) {
                // Don't bother if no value provided
                if (obj === null || typeof obj === 'undefined') {
                    return
                }

                // Force an array if not already something iterable
                if (typeof obj !== 'object') {
                    /*eslint no-param-reassign:0*/
                    obj = [obj]
                }

                if (isArray(obj)) {
                    // Iterate over array values
                    for (var i = 0, l = obj.length; i < l; i++) {
                        fn.call(null, obj[i], i, obj)
                    }
                } else {
                    // Iterate over object keys
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            fn.call(null, obj[key], key, obj)
                        }
                    }
                }
            }

            /**
             * Accepts varargs expecting each argument to be an object, then
             * immutably merges the properties of each object and returns result.
             *
             * When multiple objects contain the same key the later object in
             * the arguments list will take precedence.
             *
             * Example:
             *
             * ```js
             * var result = merge({foo: 123}, {foo: 456});
             * console.log(result.foo); // outputs 456
             * ```
             *
             * @param {Object} obj1 Object to merge
             * @returns {Object} Result of all merge properties
             */
            function merge(/* obj1, obj2, obj3, ... */) {
                var result = {}
                function assignValue(val, key) {
                    if (
                        typeof result[key] === 'object' &&
                        typeof val === 'object'
                    ) {
                        result[key] = merge(result[key], val)
                    } else {
                        result[key] = val
                    }
                }

                for (var i = 0, l = arguments.length; i < l; i++) {
                    forEach(arguments[i], assignValue)
                }
                return result
            }

            /**
             * Function equal to merge with the difference being that no reference
             * to original objects is kept.
             *
             * @see merge
             * @param {Object} obj1 Object to merge
             * @returns {Object} Result of all merge properties
             */
            function deepMerge(/* obj1, obj2, obj3, ... */) {
                var result = {}
                function assignValue(val, key) {
                    if (
                        typeof result[key] === 'object' &&
                        typeof val === 'object'
                    ) {
                        result[key] = deepMerge(result[key], val)
                    } else if (typeof val === 'object') {
                        result[key] = deepMerge({}, val)
                    } else {
                        result[key] = val
                    }
                }

                for (var i = 0, l = arguments.length; i < l; i++) {
                    forEach(arguments[i], assignValue)
                }
                return result
            }

            /**
             * Extends object a by mutably adding to it the properties of object b.
             *
             * @param {Object} a The object to be extended
             * @param {Object} b The object to copy properties from
             * @param {Object} thisArg The object to bind function to
             * @return {Object} The resulting value of object a
             */
            function extend(a, b, thisArg) {
                forEach(b, function assignValue(val, key) {
                    if (thisArg && typeof val === 'function') {
                        a[key] = bind(val, thisArg)
                    } else {
                        a[key] = val
                    }
                })
                return a
            }

            module.exports = {
                isArray: isArray,
                isArrayBuffer: isArrayBuffer,
                isBuffer: isBuffer,
                isFormData: isFormData,
                isArrayBufferView: isArrayBufferView,
                isString: isString,
                isNumber: isNumber,
                isObject: isObject,
                isUndefined: isUndefined,
                isDate: isDate,
                isFile: isFile,
                isBlob: isBlob,
                isFunction: isFunction,
                isStream: isStream,
                isURLSearchParams: isURLSearchParams,
                isStandardBrowserEnv: isStandardBrowserEnv,
                forEach: forEach,
                merge: merge,
                deepMerge: deepMerge,
                extend: extend,
                trim: trim
            }

            /***/
        },

        /***/ xYSL: /***/ function(module, exports) {
            /**
             * Checks if a `cache` value for `key` exists.
             *
             * @private
             * @param {Object} cache The cache to query.
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function cacheHas(cache, key) {
                return cache.has(key)
            }

            module.exports = cacheHas

            /***/
        },

        /***/ 'xZ+y': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            Object.defineProperty(exports, '__esModule', { value: true })
            const tls_1 = __webpack_require__('ugmf')
            const deferToConnect = (socket, fn) => {
                let listeners
                if (typeof fn === 'function') {
                    const connect = fn
                    listeners = { connect }
                } else {
                    listeners = fn
                }
                const hasConnectListener =
                    typeof listeners.connect === 'function'
                const hasSecureConnectListener =
                    typeof listeners.secureConnect === 'function'
                const hasCloseListener = typeof listeners.close === 'function'
                const onConnect = () => {
                    if (hasConnectListener) {
                        listeners.connect()
                    }
                    if (
                        socket instanceof tls_1.TLSSocket &&
                        hasSecureConnectListener
                    ) {
                        if (socket.authorized) {
                            listeners.secureConnect()
                        } else if (!socket.authorizationError) {
                            socket.once(
                                'secureConnect',
                                listeners.secureConnect
                            )
                        }
                    }
                    if (hasCloseListener) {
                        socket.once('close', listeners.close)
                    }
                }
                if (socket.writable && !socket.connecting) {
                    onConnect()
                } else if (socket.connecting) {
                    socket.once('connect', onConnect)
                } else if (socket.destroyed && hasCloseListener) {
                    listeners.close(socket._hadError)
                }
            }
            exports.default = deferToConnect
            // For CommonJS default export support
            module.exports = deferToConnect
            module.exports.default = deferToConnect

            /***/
        },

        /***/ xZSz: /***/ function(module, exports, __webpack_require__) {
            module.exports = {
                JWE: __webpack_require__('9AeD'),
                JWK: __webpack_require__('lA9T'),
                JWKS: __webpack_require__('WPgm'),
                JWS: __webpack_require__('sR+5'),
                JWT: __webpack_require__('zKJz'),
                errors: __webpack_require__('yt7c')
            }

            /***/
        },

        /***/ xfr8: /***/ function(module, exports, __webpack_require__) {
            const generateIV = __webpack_require__('X3uD')
            const base64url = __webpack_require__('Xab3')

            module.exports = (JWA, JWK) => {
                ;['A128GCMKW', 'A192GCMKW', 'A256GCMKW'].forEach(jwaAlg => {
                    const encAlg = jwaAlg.substr(0, 7)
                    const size = parseInt(jwaAlg.substr(1, 3), 10)
                    const encrypt = JWA.encrypt.get(encAlg)
                    const decrypt = JWA.decrypt.get(encAlg)

                    if (encrypt && decrypt) {
                        JWA.keyManagementEncrypt.set(jwaAlg, (key, payload) => {
                            const iv = generateIV(jwaAlg)
                            const { ciphertext, tag } = encrypt(key, payload, {
                                iv
                            })
                            return {
                                wrapped: ciphertext,
                                header: {
                                    tag: base64url.encodeBuffer(tag),
                                    iv: base64url.encodeBuffer(iv)
                                }
                            }
                        })
                        JWA.keyManagementDecrypt.set(jwaAlg, decrypt)
                        JWK.oct.wrapKey[jwaAlg] = JWK.oct.unwrapKey[
                            jwaAlg
                        ] = key =>
                            (key.use === 'enc' || key.use === undefined) &&
                            key.length === size
                    }
                })
            }

            /***/
        },

        /***/ xh2E: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const indentString = __webpack_require__('S6im')
            const cleanStack = __webpack_require__('9rVn')

            const cleanInternalStack = stack =>
                stack.replace(
                    /\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g,
                    ''
                )

            class AggregateError extends Error {
                constructor(errors) {
                    if (!Array.isArray(errors)) {
                        throw new TypeError(
                            `Expected input to be an Array, got ${typeof errors}`
                        )
                    }

                    errors = [...errors].map(error => {
                        if (error instanceof Error) {
                            return error
                        }

                        if (error !== null && typeof error === 'object') {
                            // Handle plain error objects with message property and/or possibly other metadata
                            return Object.assign(
                                new Error(error.message),
                                error
                            )
                        }

                        return new Error(error)
                    })

                    let message = errors
                        .map(error => {
                            // The `stack` property is not standardized, so we can't assume it exists
                            return typeof error.stack === 'string'
                                ? cleanInternalStack(cleanStack(error.stack))
                                : String(error)
                        })
                        .join('\n')
                    message = '\n' + indentString(message, 4)
                    super(message)

                    this.name = 'AggregateError'

                    Object.defineProperty(this, '_errors', { value: errors })
                }

                *[Symbol.iterator]() {
                    for (const error of this._errors) {
                        yield error
                    }
                }
            }

            module.exports = AggregateError

            /***/
        },

        /***/ xvv9: /***/ function(module, exports, __webpack_require__) {
            // https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
            __webpack_require__('cHUd')('Set')

            /***/
        },

        /***/ 'y/nk': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const { URL } = __webpack_require__('bzos') // TODO: Use the `URL` global when targeting Node.js 10
            const util = __webpack_require__('jK02')
            const EventEmitter = __webpack_require__('/0p4')
            const http = __webpack_require__('KEll')
            const https = __webpack_require__('7WL4')
            const urlLib = __webpack_require__('bzos')
            const CacheableRequest = __webpack_require__('eC53')
            const toReadableStream = __webpack_require__('MrQC')
            const is = __webpack_require__('6mOv')
            const timer = __webpack_require__('j0Yl')
            const timedOut = __webpack_require__('2IvE')
            const getBodySize = __webpack_require__('10GS')
            const getResponse = __webpack_require__('zFNg')
            const progress = __webpack_require__('K0QS')
            const {
                CacheError,
                UnsupportedProtocolError,
                MaxRedirectsError,
                RequestError,
                TimeoutError
            } = __webpack_require__('9Fi5')
            const urlToOptions = __webpack_require__('NHoT')

            const getMethodRedirectCodes = new Set([
                300,
                301,
                302,
                303,
                304,
                305,
                307,
                308
            ])
            const allMethodRedirectCodes = new Set([300, 303, 307, 308])

            module.exports = (options, input) => {
                const emitter = new EventEmitter()
                const redirects = []
                let currentRequest
                let requestUrl
                let redirectString
                let uploadBodySize
                let retryCount = 0
                let shouldAbort = false

                const setCookie = options.cookieJar
                    ? util.promisify(
                          options.cookieJar.setCookie.bind(options.cookieJar)
                      )
                    : null
                const getCookieString = options.cookieJar
                    ? util.promisify(
                          options.cookieJar.getCookieString.bind(
                              options.cookieJar
                          )
                      )
                    : null
                const agents = is.object(options.agent) ? options.agent : null

                const emitError = async error => {
                    try {
                        for (const hook of options.hooks.beforeError) {
                            // eslint-disable-next-line no-await-in-loop
                            error = await hook(error)
                        }

                        emitter.emit('error', error)
                    } catch (error2) {
                        emitter.emit('error', error2)
                    }
                }

                const get = async options => {
                    const currentUrl = redirectString || requestUrl

                    if (
                        options.protocol !== 'http:' &&
                        options.protocol !== 'https:'
                    ) {
                        throw new UnsupportedProtocolError(options)
                    }

                    decodeURI(currentUrl)

                    let fn
                    if (is.function(options.request)) {
                        fn = { request: options.request }
                    } else {
                        fn = options.protocol === 'https:' ? https : http
                    }

                    if (agents) {
                        const protocolName =
                            options.protocol === 'https:' ? 'https' : 'http'
                        options.agent = agents[protocolName] || options.agent
                    }

                    /* istanbul ignore next: electron.net is broken */
                    if (options.useElectronNet && process.versions.electron) {
                        const r = { x: __webpack_require__('/SMw') }[
                            'yx'.slice(1)
                        ] // Trick webpack
                        const electron = r('electron')
                        fn = electron.net || electron.remote.net
                    }

                    if (options.cookieJar) {
                        const cookieString = await getCookieString(
                            currentUrl,
                            {}
                        )

                        if (is.nonEmptyString(cookieString)) {
                            options.headers.cookie = cookieString
                        }
                    }

                    let timings
                    const handleResponse = async response => {
                        try {
                            /* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */
                            if (options.useElectronNet) {
                                response = new Proxy(response, {
                                    get: (target, name) => {
                                        if (
                                            name === 'trailers' ||
                                            name === 'rawTrailers'
                                        ) {
                                            return []
                                        }

                                        const value = target[name]
                                        return is.function(value)
                                            ? value.bind(target)
                                            : value
                                    }
                                })
                            }

                            const { statusCode } = response
                            response.url = currentUrl
                            response.requestUrl = requestUrl
                            response.retryCount = retryCount
                            response.timings = timings
                            response.redirectUrls = redirects
                            response.request = {
                                gotOptions: options
                            }

                            const rawCookies = response.headers['set-cookie']
                            if (options.cookieJar && rawCookies) {
                                await Promise.all(
                                    rawCookies.map(rawCookie =>
                                        setCookie(rawCookie, response.url)
                                    )
                                )
                            }

                            if (
                                options.followRedirect &&
                                'location' in response.headers
                            ) {
                                if (
                                    allMethodRedirectCodes.has(statusCode) ||
                                    (getMethodRedirectCodes.has(statusCode) &&
                                        (options.method === 'GET' ||
                                            options.method === 'HEAD'))
                                ) {
                                    response.resume() // We're being redirected, we don't care about the response.

                                    if (statusCode === 303) {
                                        // Server responded with "see other", indicating that the resource exists at another location,
                                        // and the client should request it from that location via GET or HEAD.
                                        options.method = 'GET'
                                    }

                                    if (redirects.length >= 10) {
                                        throw new MaxRedirectsError(
                                            statusCode,
                                            redirects,
                                            options
                                        )
                                    }

                                    // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604
                                    const redirectBuffer = Buffer.from(
                                        response.headers.location,
                                        'binary'
                                    ).toString()
                                    const redirectURL = new URL(
                                        redirectBuffer,
                                        currentUrl
                                    )
                                    redirectString = redirectURL.toString()

                                    redirects.push(redirectString)

                                    const redirectOptions = {
                                        ...options,
                                        ...urlToOptions(redirectURL)
                                    }

                                    for (const hook of options.hooks
                                        .beforeRedirect) {
                                        // eslint-disable-next-line no-await-in-loop
                                        await hook(redirectOptions)
                                    }

                                    emitter.emit(
                                        'redirect',
                                        response,
                                        redirectOptions
                                    )

                                    await get(redirectOptions)
                                    return
                                }
                            }

                            getResponse(response, options, emitter)
                        } catch (error) {
                            emitError(error)
                        }
                    }

                    const handleRequest = request => {
                        if (shouldAbort) {
                            request.once('error', () => {})
                            request.abort()
                            return
                        }

                        currentRequest = request

                        request.once('error', error => {
                            if (request.aborted) {
                                return
                            }

                            if (error instanceof timedOut.TimeoutError) {
                                error = new TimeoutError(error, options)
                            } else {
                                error = new RequestError(error, options)
                            }

                            if (emitter.retry(error) === false) {
                                emitError(error)
                            }
                        })

                        timings = timer(request)

                        progress.upload(request, emitter, uploadBodySize)

                        if (options.gotTimeout) {
                            timedOut(request, options.gotTimeout, options)
                        }

                        emitter.emit('request', request)

                        const uploadComplete = () => {
                            request.emit('upload-complete')
                        }

                        try {
                            if (is.nodeStream(options.body)) {
                                options.body.once('end', uploadComplete)
                                options.body.pipe(request)
                                options.body = undefined
                            } else if (options.body) {
                                request.end(options.body, uploadComplete)
                            } else if (
                                input &&
                                (options.method === 'POST' ||
                                    options.method === 'PUT' ||
                                    options.method === 'PATCH')
                            ) {
                                input.once('end', uploadComplete)
                                input.pipe(request)
                            } else {
                                request.end(uploadComplete)
                            }
                        } catch (error) {
                            emitError(new RequestError(error, options))
                        }
                    }

                    if (options.cache) {
                        const cacheableRequest = new CacheableRequest(
                            fn.request,
                            options.cache
                        )
                        const cacheRequest = cacheableRequest(
                            options,
                            handleResponse
                        )

                        cacheRequest.once('error', error => {
                            if (
                                error instanceof CacheableRequest.RequestError
                            ) {
                                emitError(new RequestError(error, options))
                            } else {
                                emitError(new CacheError(error, options))
                            }
                        })

                        cacheRequest.once('request', handleRequest)
                    } else {
                        // Catches errors thrown by calling fn.request(...)
                        try {
                            handleRequest(fn.request(options, handleResponse))
                        } catch (error) {
                            emitError(new RequestError(error, options))
                        }
                    }
                }

                emitter.retry = error => {
                    let backoff

                    try {
                        backoff = options.retry.retries(++retryCount, error)
                    } catch (error2) {
                        emitError(error2)
                        return
                    }

                    if (backoff) {
                        const retry = async options => {
                            try {
                                for (const hook of options.hooks.beforeRetry) {
                                    // eslint-disable-next-line no-await-in-loop
                                    await hook(options, error, retryCount)
                                }

                                await get(options)
                            } catch (error) {
                                emitError(error)
                            }
                        }

                        setTimeout(retry, backoff, {
                            ...options,
                            forceRefresh: true
                        })
                        return true
                    }

                    return false
                }

                emitter.abort = () => {
                    if (currentRequest) {
                        currentRequest.once('error', () => {})
                        currentRequest.abort()
                    } else {
                        shouldAbort = true
                    }
                }

                setImmediate(async () => {
                    try {
                        // Convert buffer to stream to receive upload progress events (#322)
                        const { body } = options
                        if (is.buffer(body)) {
                            options.body = toReadableStream(body)
                            uploadBodySize = body.length
                        } else {
                            uploadBodySize = await getBodySize(options)
                        }

                        if (
                            is.undefined(options.headers['content-length']) &&
                            is.undefined(options.headers['transfer-encoding'])
                        ) {
                            if (
                                (uploadBodySize > 0 ||
                                    options.method === 'PUT') &&
                                !is.null(uploadBodySize)
                            ) {
                                options.headers[
                                    'content-length'
                                ] = uploadBodySize
                            }
                        }

                        for (const hook of options.hooks.beforeRequest) {
                            // eslint-disable-next-line no-await-in-loop
                            await hook(options)
                        }

                        requestUrl =
                            options.href ||
                            new URL(
                                options.path,
                                urlLib.format(options)
                            ).toString()

                        await get(options)
                    } catch (error) {
                        emitError(error)
                    }
                })

                return emitter
            }

            /***/
        },

        /***/ 'y1+z': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            module.exports = function(obj) {
                var ret = {}
                var keys = Object.keys(Object(obj))

                for (var i = 0; i < keys.length; i++) {
                    ret[keys[i].toLowerCase()] = obj[keys[i]]
                }

                return ret
            }

            /***/
        },

        /***/ y1pI: /***/ function(module, exports, __webpack_require__) {
            var eq = __webpack_require__('ljhN')

            /**
             * Gets the index at which the `key` is found in `array` of key-value pairs.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {*} key The key to search for.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function assocIndexOf(array, key) {
                var length = array.length
                while (length--) {
                    if (eq(array[length][0], key)) {
                        return length
                    }
                }
                return -1
            }

            module.exports = assocIndexOf

            /***/
        },

        /***/ yAVD: /***/ function(module, exports) {
            module.exports = function() {
                this.seq().obj(
                    this.key('algorithm').objid(),
                    this.key('parameters')
                        .optional()
                        .any()
                )
            }

            /***/
        },

        /***/ yGk4: /***/ function(module, exports, __webpack_require__) {
            var getNative = __webpack_require__('Cwc5'),
                root = __webpack_require__('Kz5y')

            /* Built-in method references that are verified to be native. */
            var Set = getNative(root, 'Set')

            module.exports = Set

            /***/
        },

        /***/ yHx3: /***/ function(module, exports) {
            /** Used for built-in method references. */
            var objectProto = Object.prototype

            /** Used to check objects for own properties. */
            var hasOwnProperty = objectProto.hasOwnProperty

            /**
             * Initializes an array clone.
             *
             * @private
             * @param {Array} array The array to clone.
             * @returns {Array} Returns the initialized clone.
             */
            function initCloneArray(array) {
                var length = array.length,
                    result = new array.constructor(length)

                // Add properties assigned by `RegExp#exec`.
                if (
                    length &&
                    typeof array[0] == 'string' &&
                    hasOwnProperty.call(array, 'index')
                ) {
                    result.index = array.index
                    result.input = array.input
                }
                return result
            }

            module.exports = initCloneArray

            /***/
        },

        /***/ yK9s: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')

            module.exports = function normalizeHeaderName(
                headers,
                normalizedName
            ) {
                utils.forEach(headers, function processHeader(value, name) {
                    if (
                        name !== normalizedName &&
                        name.toUpperCase() === normalizedName.toUpperCase()
                    ) {
                        headers[normalizedName] = value
                        delete headers[name]
                    }
                })
            }

            /***/
        },

        /***/ yP5f: /***/ function(module, exports, __webpack_require__) {
            var cloneArrayBuffer = __webpack_require__('+K+b')

            /**
             * Creates a clone of `typedArray`.
             *
             * @private
             * @param {Object} typedArray The typed array to clone.
             * @param {boolean} [isDeep] Specify a deep clone.
             * @returns {Object} Returns the cloned typed array.
             */
            function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep
                    ? cloneArrayBuffer(typedArray.buffer)
                    : typedArray.buffer
                return new typedArray.constructor(
                    buffer,
                    typedArray.byteOffset,
                    typedArray.length
                )
            }

            module.exports = cloneTypedArray

            /***/
        },

        /***/ yt7c: /***/ function(module, exports) {
            const CODES = {
                JOSEAlgNotWhitelisted: 'ERR_JOSE_ALG_NOT_WHITELISTED',
                JOSECritNotUnderstood: 'ERR_JOSE_CRIT_NOT_UNDERSTOOD',
                JOSEInvalidEncoding: 'ERR_JOSE_INVALID_ENCODING',
                JOSEMultiError: 'ERR_JOSE_MULTIPLE_ERRORS',
                JOSENotSupported: 'ERR_JOSE_NOT_SUPPORTED',
                JWEDecryptionFailed: 'ERR_JWE_DECRYPTION_FAILED',
                JWEInvalid: 'ERR_JWE_INVALID',
                JWKImportFailed: 'ERR_JWK_IMPORT_FAILED',
                JWKInvalid: 'ERR_JWK_INVALID',
                JWKKeySupport: 'ERR_JWK_KEY_SUPPORT',
                JWKSNoMatchingKey: 'ERR_JWKS_NO_MATCHING_KEY',
                JWSInvalid: 'ERR_JWS_INVALID',
                JWSVerificationFailed: 'ERR_JWS_VERIFICATION_FAILED',
                JWTClaimInvalid: 'ERR_JWT_CLAIM_INVALID',
                JWTExpired: 'ERR_JWT_EXPIRED',
                JWTMalformed: 'ERR_JWT_MALFORMED'
            }

            const DEFAULT_MESSAGES = {
                JWEDecryptionFailed: 'decryption operation failed',
                JWEInvalid: 'JWE invalid',
                JWKSNoMatchingKey: 'no matching key found in the KeyStore',
                JWSInvalid: 'JWS invalid',
                JWSVerificationFailed: 'signature verification failed'
            }

            class JOSEError extends Error {
                constructor(message) {
                    super(message)
                    if (message === undefined) {
                        this.message = DEFAULT_MESSAGES[this.constructor.name]
                    }
                    this.name = this.constructor.name
                    this.code = CODES[this.constructor.name]
                    Error.captureStackTrace(this, this.constructor)
                }
            }

            const isMulti = e => e instanceof JOSEMultiError
            class JOSEMultiError extends JOSEError {
                constructor(errors) {
                    super()
                    let i
                    while ((i = errors.findIndex(isMulti)) && i !== -1) {
                        errors.splice(i, 1, ...errors[i])
                    }
                    Object.defineProperty(this, 'errors', { value: errors })
                }

                *[Symbol.iterator]() {
                    for (const error of this.errors) {
                        yield error
                    }
                }
            }
            module.exports.JOSEError = JOSEError

            module.exports.JOSEAlgNotWhitelisted = class JOSEAlgNotWhitelisted extends JOSEError {}
            module.exports.JOSECritNotUnderstood = class JOSECritNotUnderstood extends JOSEError {}
            module.exports.JOSEInvalidEncoding = class JOSEInvalidEncoding extends JOSEError {}
            module.exports.JOSEMultiError = JOSEMultiError
            module.exports.JOSENotSupported = class JOSENotSupported extends JOSEError {}

            module.exports.JWEDecryptionFailed = class JWEDecryptionFailed extends JOSEError {}
            module.exports.JWEInvalid = class JWEInvalid extends JOSEError {}

            module.exports.JWKImportFailed = class JWKImportFailed extends JOSEError {}
            module.exports.JWKInvalid = class JWKInvalid extends JOSEError {}
            module.exports.JWKKeySupport = class JWKKeySupport extends JOSEError {}

            module.exports.JWKSNoMatchingKey = class JWKSNoMatchingKey extends JOSEError {}

            module.exports.JWSInvalid = class JWSInvalid extends JOSEError {}
            module.exports.JWSVerificationFailed = class JWSVerificationFailed extends JOSEError {}

            class JWTClaimInvalid extends JOSEError {
                constructor(
                    message,
                    claim = 'unspecified',
                    reason = 'unspecified'
                ) {
                    super(message)
                    this.claim = claim
                    this.reason = reason
                }
            }
            module.exports.JWTClaimInvalid = JWTClaimInvalid
            module.exports.JWTExpired = class JWTExpired extends JWTClaimInvalid {}
            module.exports.JWTMalformed = class JWTMalformed extends JOSEError {}

            /***/
        },

        /***/ 'z/H/': /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const is = __webpack_require__('6mOv')

            module.exports = function deepFreeze(object) {
                for (const [key, value] of Object.entries(object)) {
                    if (is.plainObject(value) || is.array(value)) {
                        deepFreeze(object[key])
                    }
                }

                return Object.freeze(object)
            }

            /***/
        },

        /***/ zCb7: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(input) {
                if (!input) {
                    return ''
                }

                const lessThan = 0x3c
                const greaterThan = 0x3e
                const andSymbol = 0x26
                const lineSeperator = 0x2028

                // replace method
                let charCode
                return input.replace(/[<>&\u2028\u2029]/g, match => {
                    charCode = match.charCodeAt(0)

                    if (charCode === lessThan) {
                        return '\\u003c'
                    }

                    if (charCode === greaterThan) {
                        return '\\u003e'
                    }

                    if (charCode === andSymbol) {
                        return '\\u0026'
                    }

                    if (charCode === lineSeperator) {
                        return '\\u2028'
                    }

                    return '\\u2029'
                })
            }

            /***/
        },

        /***/ zEVN: /***/ function(module, exports, __webpack_require__) {
            var baseIsMap = __webpack_require__('Gi0A'),
                baseUnary = __webpack_require__('sEf8'),
                nodeUtil = __webpack_require__('mdPL')

            /* Node.js helper references. */
            var nodeIsMap = nodeUtil && nodeUtil.isMap

            /**
             * Checks if `value` is classified as a `Map` object.
             *
             * @static
             * @memberOf _
             * @since 4.3.0
             * @category Lang
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a map, else `false`.
             * @example
             *
             * _.isMap(new Map);
             * // => true
             *
             * _.isMap(new WeakMap);
             * // => false
             */
            var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap

            module.exports = isMap

            /***/
        },

        /***/ zFNg: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const decompressResponse = __webpack_require__('YNnK')
            const is = __webpack_require__('6mOv')
            const mimicResponse = __webpack_require__('qsvm')
            const progress = __webpack_require__('K0QS')

            module.exports = (response, options, emitter) => {
                const downloadBodySize =
                    Number(response.headers['content-length']) || null

                const progressStream = progress.download(
                    response,
                    emitter,
                    downloadBodySize
                )

                mimicResponse(response, progressStream)

                const newResponse =
                    options.decompress === true &&
                    is.function(decompressResponse) &&
                    options.method !== 'HEAD'
                        ? decompressResponse(progressStream)
                        : progressStream

                if (
                    !options.decompress &&
                    ['gzip', 'deflate'].includes(
                        response.headers['content-encoding']
                    )
                ) {
                    options.encoding = null
                }

                emitter.emit('response', newResponse)

                emitter.emit('downloadProgress', {
                    percent: 0,
                    transferred: 0,
                    total: downloadBodySize
                })

                response.pipe(progressStream)
            }

            /***/
        },

        /***/ zKJz: /***/ function(module, exports, __webpack_require__) {
            const decode = __webpack_require__('7o4N')
            const sign = __webpack_require__('6I+L')
            const verify = __webpack_require__('BOd6')
            const profiles = __webpack_require__('qXE0')

            module.exports = {
                decode,
                sign,
                verify,
                ...profiles
            }

            /***/
        },

        /***/ zLkG: /***/ function(module, exports, __webpack_require__) {
            exports.f = __webpack_require__('UWiX')

            /***/
        },

        /***/ zOht: /***/ function(module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_ARRAY__,
                __WEBPACK_AMD_DEFINE_RESULT__ /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
            /* global global, define, System, Reflect, Promise */
            var __extends
            var __assign
            var __rest
            var __decorate
            var __param
            var __metadata
            var __awaiter
            var __generator
            var __exportStar
            var __values
            var __read
            var __spread
            var __spreadArrays
            var __await
            var __asyncGenerator
            var __asyncDelegator
            var __asyncValues
            var __makeTemplateObject
            var __importStar
            var __importDefault
            ;(function(factory) {
                var root =
                    typeof global === 'object'
                        ? global
                        : typeof self === 'object'
                        ? self
                        : typeof this === 'object'
                        ? this
                        : {}
                if (true) {
                    !((__WEBPACK_AMD_DEFINE_ARRAY__ = [exports]),
                    (__WEBPACK_AMD_DEFINE_RESULT__ = function(exports) {
                        factory(createExporter(root, createExporter(exports)))
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                        (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
                } else {
                }
                function createExporter(exports, previous) {
                    if (exports !== root) {
                        if (typeof Object.create === 'function') {
                            Object.defineProperty(exports, '__esModule', {
                                value: true
                            })
                        } else {
                            exports.__esModule = true
                        }
                    }
                    return function(id, v) {
                        return (exports[id] = previous ? previous(id, v) : v)
                    }
                }
            })(function(exporter) {
                var extendStatics =
                    Object.setPrototypeOf ||
                    ({ __proto__: [] } instanceof Array &&
                        function(d, b) {
                            d.__proto__ = b
                        }) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                    }

                __extends = function(d, b) {
                    extendStatics(d, b)
                    function __() {
                        this.constructor = d
                    }
                    d.prototype =
                        b === null
                            ? Object.create(b)
                            : ((__.prototype = b.prototype), new __())
                }

                __assign =
                    Object.assign ||
                    function(t) {
                        for (var s, i = 1, n = arguments.length; i < n; i++) {
                            s = arguments[i]
                            for (var p in s)
                                if (Object.prototype.hasOwnProperty.call(s, p))
                                    t[p] = s[p]
                        }
                        return t
                    }

                __rest = function(s, e) {
                    var t = {}
                    for (var p in s)
                        if (
                            Object.prototype.hasOwnProperty.call(s, p) &&
                            e.indexOf(p) < 0
                        )
                            t[p] = s[p]
                    if (
                        s != null &&
                        typeof Object.getOwnPropertySymbols === 'function'
                    )
                        for (
                            var i = 0, p = Object.getOwnPropertySymbols(s);
                            i < p.length;
                            i++
                        ) {
                            if (
                                e.indexOf(p[i]) < 0 &&
                                Object.prototype.propertyIsEnumerable.call(
                                    s,
                                    p[i]
                                )
                            )
                                t[p[i]] = s[p[i]]
                        }
                    return t
                }

                __decorate = function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r =
                            c < 3
                                ? target
                                : desc === null
                                ? (desc = Object.getOwnPropertyDescriptor(
                                      target,
                                      key
                                  ))
                                : desc,
                        d
                    if (
                        typeof Reflect === 'object' &&
                        typeof Reflect.decorate === 'function'
                    )
                        r = Reflect.decorate(decorators, target, key, desc)
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i]))
                                r =
                                    (c < 3
                                        ? d(r)
                                        : c > 3
                                        ? d(target, key, r)
                                        : d(target, key)) || r
                    return (
                        c > 3 && r && Object.defineProperty(target, key, r), r
                    )
                }

                __param = function(paramIndex, decorator) {
                    return function(target, key) {
                        decorator(target, key, paramIndex)
                    }
                }

                __metadata = function(metadataKey, metadataValue) {
                    if (
                        typeof Reflect === 'object' &&
                        typeof Reflect.metadata === 'function'
                    )
                        return Reflect.metadata(metadataKey, metadataValue)
                }

                __awaiter = function(thisArg, _arguments, P, generator) {
                    return new (P || (P = Promise))(function(resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value))
                            } catch (e) {
                                reject(e)
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value))
                            } catch (e) {
                                reject(e)
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : new P(function(resolve) {
                                      resolve(result.value)
                                  }).then(fulfilled, rejected)
                        }
                        step(
                            (generator = generator.apply(
                                thisArg,
                                _arguments || []
                            )).next()
                        )
                    })
                }

                __generator = function(thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function() {
                                if (t[0] & 1) throw t[1]
                                return t[1]
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g
                    return (
                        (g = {
                            next: verb(0),
                            throw: verb(1),
                            return: verb(2)
                        }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function() {
                                return this
                            }),
                        g
                    )
                    function verb(n) {
                        return function(v) {
                            return step([n, v])
                        }
                    }
                    function step(op) {
                        if (f)
                            throw new TypeError(
                                'Generator is already executing.'
                            )
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] ||
                                                  ((t = y['return']) &&
                                                      t.call(y),
                                                  0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t
                                if (((y = 0), t)) op = [op[0] & 2, t.value]
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op
                                        break
                                    case 4:
                                        _.label++
                                        return { value: op[1], done: false }
                                    case 5:
                                        _.label++
                                        y = op[1]
                                        op = [0]
                                        continue
                                    case 7:
                                        op = _.ops.pop()
                                        _.trys.pop()
                                        continue
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t =
                                                t.length > 0 &&
                                                t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0
                                            continue
                                        }
                                        if (
                                            op[0] === 3 &&
                                            (!t ||
                                                (op[1] > t[0] && op[1] < t[3]))
                                        ) {
                                            _.label = op[1]
                                            break
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1]
                                            t = op
                                            break
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2]
                                            _.ops.push(op)
                                            break
                                        }
                                        if (t[2]) _.ops.pop()
                                        _.trys.pop()
                                        continue
                                }
                                op = body.call(thisArg, _)
                            } catch (e) {
                                op = [6, e]
                                y = 0
                            } finally {
                                f = t = 0
                            }
                        if (op[0] & 5) throw op[1]
                        return { value: op[0] ? op[1] : void 0, done: true }
                    }
                }

                __exportStar = function(m, exports) {
                    for (var p in m)
                        if (!exports.hasOwnProperty(p)) exports[p] = m[p]
                }

                __values = function(o) {
                    var m = typeof Symbol === 'function' && o[Symbol.iterator],
                        i = 0
                    if (m) return m.call(o)
                    return {
                        next: function() {
                            if (o && i >= o.length) o = void 0
                            return { value: o && o[i++], done: !o }
                        }
                    }
                }

                __read = function(o, n) {
                    var m = typeof Symbol === 'function' && o[Symbol.iterator]
                    if (!m) return o
                    var i = m.call(o),
                        r,
                        ar = [],
                        e
                    try {
                        while (
                            (n === void 0 || n-- > 0) &&
                            !(r = i.next()).done
                        )
                            ar.push(r.value)
                    } catch (error) {
                        e = { error: error }
                    } finally {
                        try {
                            if (r && !r.done && (m = i['return'])) m.call(i)
                        } finally {
                            if (e) throw e.error
                        }
                    }
                    return ar
                }

                __spread = function() {
                    for (var ar = [], i = 0; i < arguments.length; i++)
                        ar = ar.concat(__read(arguments[i]))
                    return ar
                }

                __spreadArrays = function() {
                    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
                        s += arguments[i].length
                    for (var r = Array(s), k = 0, i = 0; i < il; i++)
                        for (
                            var a = arguments[i], j = 0, jl = a.length;
                            j < jl;
                            j++, k++
                        )
                            r[k] = a[j]
                    return r
                }

                __await = function(v) {
                    return this instanceof __await
                        ? ((this.v = v), this)
                        : new __await(v)
                }

                __asyncGenerator = function(thisArg, _arguments, generator) {
                    if (!Symbol.asyncIterator)
                        throw new TypeError(
                            'Symbol.asyncIterator is not defined.'
                        )
                    var g = generator.apply(thisArg, _arguments || []),
                        i,
                        q = []
                    return (
                        (i = {}),
                        verb('next'),
                        verb('throw'),
                        verb('return'),
                        (i[Symbol.asyncIterator] = function() {
                            return this
                        }),
                        i
                    )
                    function verb(n) {
                        if (g[n])
                            i[n] = function(v) {
                                return new Promise(function(a, b) {
                                    q.push([n, v, a, b]) > 1 || resume(n, v)
                                })
                            }
                    }
                    function resume(n, v) {
                        try {
                            step(g[n](v))
                        } catch (e) {
                            settle(q[0][3], e)
                        }
                    }
                    function step(r) {
                        r.value instanceof __await
                            ? Promise.resolve(r.value.v).then(fulfill, reject)
                            : settle(q[0][2], r)
                    }
                    function fulfill(value) {
                        resume('next', value)
                    }
                    function reject(value) {
                        resume('throw', value)
                    }
                    function settle(f, v) {
                        if ((f(v), q.shift(), q.length))
                            resume(q[0][0], q[0][1])
                    }
                }

                __asyncDelegator = function(o) {
                    var i, p
                    return (
                        (i = {}),
                        verb('next'),
                        verb('throw', function(e) {
                            throw e
                        }),
                        verb('return'),
                        (i[Symbol.iterator] = function() {
                            return this
                        }),
                        i
                    )
                    function verb(n, f) {
                        i[n] = o[n]
                            ? function(v) {
                                  return (p = !p)
                                      ? {
                                            value: __await(o[n](v)),
                                            done: n === 'return'
                                        }
                                      : f
                                      ? f(v)
                                      : v
                              }
                            : f
                    }
                }

                __asyncValues = function(o) {
                    if (!Symbol.asyncIterator)
                        throw new TypeError(
                            'Symbol.asyncIterator is not defined.'
                        )
                    var m = o[Symbol.asyncIterator],
                        i
                    return m
                        ? m.call(o)
                        : ((o =
                              typeof __values === 'function'
                                  ? __values(o)
                                  : o[Symbol.iterator]()),
                          (i = {}),
                          verb('next'),
                          verb('throw'),
                          verb('return'),
                          (i[Symbol.asyncIterator] = function() {
                              return this
                          }),
                          i)
                    function verb(n) {
                        i[n] =
                            o[n] &&
                            function(v) {
                                return new Promise(function(resolve, reject) {
                                    ;(v = o[n](v)),
                                        settle(resolve, reject, v.done, v.value)
                                })
                            }
                    }
                    function settle(resolve, reject, d, v) {
                        Promise.resolve(v).then(function(v) {
                            resolve({ value: v, done: d })
                        }, reject)
                    }
                }

                __makeTemplateObject = function(cooked, raw) {
                    if (Object.defineProperty) {
                        Object.defineProperty(cooked, 'raw', { value: raw })
                    } else {
                        cooked.raw = raw
                    }
                    return cooked
                }

                __importStar = function(mod) {
                    if (mod && mod.__esModule) return mod
                    var result = {}
                    if (mod != null)
                        for (var k in mod)
                            if (Object.hasOwnProperty.call(mod, k))
                                result[k] = mod[k]
                    result['default'] = mod
                    return result
                }

                __importDefault = function(mod) {
                    return mod && mod.__esModule ? mod : { default: mod }
                }

                exporter('__extends', __extends)
                exporter('__assign', __assign)
                exporter('__rest', __rest)
                exporter('__decorate', __decorate)
                exporter('__param', __param)
                exporter('__metadata', __metadata)
                exporter('__awaiter', __awaiter)
                exporter('__generator', __generator)
                exporter('__exportStar', __exportStar)
                exporter('__values', __values)
                exporter('__read', __read)
                exporter('__spread', __spread)
                exporter('__spreadArrays', __spreadArrays)
                exporter('__await', __await)
                exporter('__asyncGenerator', __asyncGenerator)
                exporter('__asyncDelegator', __asyncDelegator)
                exporter('__asyncValues', __asyncValues)
                exporter('__makeTemplateObject', __makeTemplateObject)
                exporter('__importStar', __importStar)
                exporter('__importDefault', __importDefault)
            })

            /***/
        },

        /***/ zXhZ: /***/ function(module, exports, __webpack_require__) {
            var anObject = __webpack_require__('5K7Z')
            var isObject = __webpack_require__('93I4')
            var newPromiseCapability = __webpack_require__('ZW5q')

            module.exports = function(C, x) {
                anObject(C)
                if (isObject(x) && x.constructor === C) return x
                var promiseCapability = newPromiseCapability.f(C)
                var resolve = promiseCapability.resolve
                resolve(x)
                return promiseCapability.promise
            }

            /***/
        },

        /***/ zZ0H: /***/ function(module, exports) {
            /**
             * This method returns the first argument it receives.
             *
             * @static
             * @since 0.1.0
             * @memberOf _
             * @category Util
             * @param {*} value Any value.
             * @returns {*} Returns `value`.
             * @example
             *
             * var object = { 'a': 1 };
             *
             * console.log(_.identity(object) === object);
             * // => true
             */
            function identity(value) {
                return value
            }

            module.exports = identity

            /***/
        },

        /***/ zn7N: /***/ function(module, exports, __webpack_require__) {
            // most Object methods by ES6 should accept primitives
            var $export = __webpack_require__('Y7ZC')
            var core = __webpack_require__('WEpk')
            var fails = __webpack_require__('KUxP')
            module.exports = function(KEY, exec) {
                var fn = (core.Object || {})[KEY] || Object[KEY]
                var exp = {}
                exp[KEY] = exec(fn)
                $export(
                    $export.S +
                        $export.F *
                            fails(function() {
                                fn(1)
                            }),
                    'Object',
                    exp
                )
            }

            /***/
        },

        /***/ zoYe: /***/ function(module, exports, __webpack_require__) {
            var Symbol = __webpack_require__('nmnc'),
                arrayMap = __webpack_require__('eUgh'),
                isArray = __webpack_require__('Z0cm'),
                isSymbol = __webpack_require__('/9aa')

            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0

            /** Used to convert symbols to primitives and strings. */
            var symbolProto = Symbol ? Symbol.prototype : undefined,
                symbolToString = symbolProto ? symbolProto.toString : undefined

            /**
             * The base implementation of `_.toString` which doesn't convert nullish
             * values to empty strings.
             *
             * @private
             * @param {*} value The value to process.
             * @returns {string} Returns the string.
             */
            function baseToString(value) {
                // Exit early for strings to avoid a performance hit in some environments.
                if (typeof value == 'string') {
                    return value
                }
                if (isArray(value)) {
                    // Recursively convert values (susceptible to call stack limits).
                    return arrayMap(value, baseToString) + ''
                }
                if (isSymbol(value)) {
                    return symbolToString ? symbolToString.call(value) : ''
                }
                var result = value + ''
                return result == '0' && 1 / value == -INFINITY ? '-0' : result
            }

            module.exports = baseToString

            /***/
        },

        /***/ zosA: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            const internals = {}

            module.exports = function(string) {
                // Escape ^$.*+-?=!:|\/()[]{},

                return string.replace(
                    /[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,
                    '\\$&'
                )
            }

            /***/
        },

        /***/ zspo: /***/ function(module, exports, __webpack_require__) {
            module.exports = {
                der: __webpack_require__('R7nf'),
                pem: __webpack_require__('QQHG')
            }

            /***/
        },

        /***/ zuR4: /***/ function(module, exports, __webpack_require__) {
            'use strict'

            var utils = __webpack_require__('xTJ+')
            var bind = __webpack_require__('HSsa')
            var Axios = __webpack_require__('CgaS')
            var mergeConfig = __webpack_require__('SntB')
            var defaults = __webpack_require__('JEQr')

            /**
             * Create an instance of Axios
             *
             * @param {Object} defaultConfig The default config for the instance
             * @return {Axios} A new instance of Axios
             */
            function createInstance(defaultConfig) {
                var context = new Axios(defaultConfig)
                var instance = bind(Axios.prototype.request, context)

                // Copy axios.prototype to instance
                utils.extend(instance, Axios.prototype, context)

                // Copy context to instance
                utils.extend(instance, context)

                return instance
            }

            // Create the default instance to be exported
            var axios = createInstance(defaults)

            // Expose Axios class to allow class inheritance
            axios.Axios = Axios

            // Factory for creating new instances
            axios.create = function create(instanceConfig) {
                return createInstance(
                    mergeConfig(axios.defaults, instanceConfig)
                )
            }

            // Expose Cancel & CancelToken
            axios.Cancel = __webpack_require__('endd')
            axios.CancelToken = __webpack_require__('jfS+')
            axios.isCancel = __webpack_require__('Lmem')

            // Expose all/spread
            axios.all = function all(promises) {
                return Promise.all(promises)
            }
            axios.spread = __webpack_require__('DfZB')

            module.exports = axios

            // Allow use of default import syntax in TypeScript
            module.exports.default = axios

            /***/
        }

        /******/
    }
)
